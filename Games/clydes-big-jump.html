<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Clyde's Big Jump</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Tilt+Neon&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            font-family: 'Bebas Neue', sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            position: relative;
            border: 3px solid #0ff;
            border-radius: 12px;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            background: #0a0a0a;
            box-sizing: content-box;
            overflow: visible;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Fullscreen/iframe mode: fill entire viewport */
        .game-container.fullscreen-mode {
            width: 100% !important;
            height: 100% !important;
            border-radius: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        
        /* Fullscreen body centering - JS adds this class */
        body.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            overflow: hidden !important;
        }

        #gameCanvas {
            display: block;
            border-radius: 2px;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Overlay screens */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        /* Intro screen uses fixed positioning like Neon Defense menu */
        #introScreen {
            position: fixed;
            z-index: 2000;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title, .game-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
            margin-bottom: 10px;
            letter-spacing: 4px;
            text-align: center;
        }
        
        .subtitle, .game-subtitle {
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-bottom: 40px;
            text-align: center;
        }
        
        /* Keep title pulse animation but with cyan */
        @keyframes titlePulse {
            0%, 100% {
                text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
            }
            50% {
                text-shadow: 0 0 40px #0ff, 0 0 80px #0ff, 0 0 100px rgba(0, 255, 255, 0.5);
            }
        }

        .score-display {
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 15px #fff;
            margin-bottom: 10px;
        }

        .high-score {
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 30px;
        }

        /* Original intro button styling */
        .btn {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 20px;
            padding: 4px 28px;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 4px;
            cursor: pointer;
            letter-spacing: 3px;
            text-shadow: 0 0 8px #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.2s ease;
            animation: btnPulse 2.5s ease-in-out infinite;
            -webkit-tap-highlight-color: transparent;
        }
        
        @keyframes btnPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), 0 0 35px rgba(0, 255, 255, 0.2);
            }
        }

        .btn:hover, .btn:active {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        /* Intro button nudged down and taller */
        #introBtn {
            margin-top: 10px;
            padding-top: 10px;
            padding-bottom: 10px;
            animation: psychedelicBtn 4s ease-in-out infinite;
        }

        /* Standardized menu buttons for start/gameover screens */
        .menu-btn {
            padding: 10px 20px;
            width: 160px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            touch-action: manipulation;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .menu-btn:hover {
            background: #0ff;
            color: #000;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        .menu-btn.btn-tutorial {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 8px #f0f;
        }
        
        .menu-btn.btn-tutorial:hover {
            background: #f0f;
            color: #000;
        }
        
        .menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }
        
        .menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
        }
        
        /* Play and Restart buttons - static cyan like other games */
        #startBtn, #restartBtn {
            color: #0ff;
            border-color: #0ff;
            text-shadow: 0 0 8px #0ff;
            box-shadow: 0 0 8px #0ff;
        }
        
        #startBtn:hover, #restartBtn:hover {
            background: #0ff;
            color: #000;
        }
        
        @keyframes psychedelicBtn {
            0% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff, 0 0 15px #0ff;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            }
            25% {
                color: #f0f;
                border-color: #f0f;
                text-shadow: 0 0 8px #f0f, 0 0 15px #f0f;
                box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
            }
            50% {
                color: #ff6600;
                border-color: #ff6600;
                text-shadow: 0 0 8px #ff6600, 0 0 15px #ff6600;
                box-shadow: 0 0 15px rgba(255, 102, 0, 0.4);
            }
            75% {
                color: #00ffcc;
                border-color: #00ffcc;
                text-shadow: 0 0 8px #00ffcc, 0 0 15px #00ffcc;
                box-shadow: 0 0 15px rgba(0, 255, 204, 0.4);
            }
            100% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff, 0 0 15px #0ff;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            }
        }
        
        @keyframes psychedelicBtnFast {
            0% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 12px #0ff, 0 0 25px #0ff;
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            }
            25% {
                color: #f0f;
                border-color: #f0f;
                text-shadow: 0 0 12px #f0f, 0 0 25px #f0f;
                box-shadow: 0 0 25px rgba(255, 0, 255, 0.6);
            }
            50% {
                color: #ff6600;
                border-color: #ff6600;
                text-shadow: 0 0 12px #ff6600, 0 0 25px #ff6600;
                box-shadow: 0 0 25px rgba(255, 102, 0, 0.6);
            }
            75% {
                color: #00ffcc;
                border-color: #00ffcc;
                text-shadow: 0 0 12px #00ffcc, 0 0 25px #00ffcc;
                box-shadow: 0 0 25px rgba(0, 255, 204, 0.6);
            }
            100% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 12px #0ff, 0 0 25px #0ff;
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            }
        }
        
        .btn-secondary {
            font-size: 16px;
            padding: 8px 20px;
            width: 220px;
            text-shadow: 0 0 8px #0ff;
            box-shadow: none;
            animation: none;
        }
        
        .btn-secondary:hover, .btn-secondary:active {
            opacity: 1;
            box-shadow: none;
        }

        /* In-game HUD */
        .hud {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 36px;
            color: #fff;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 20px #ff00ff;
            z-index: 5;
            pointer-events: none;
            transition: transform 0.1s ease-out, text-shadow 0.1s ease, opacity 0.2s ease;
        }
        
        .hud.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .hud.pop {
            transform: scale(1.3);
            text-shadow: 
                0 0 15px #00ffcc,
                0 0 30px #00ffcc,
                0 0 45px #00ffcc;
        }

        .instructions {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            max-width: 200px;
            line-height: 1.4;
            margin-top: -8px;
        }
        
        /* Intro screen styles */
        .intro-cauldron {
            font-size: 56px;
            margin-bottom: 10px;
            animation: cauldronBob 2s ease-in-out infinite;
        }
        
        @keyframes cauldronBob {
            0%, 100% { transform: translateY(0) rotate(-3deg); }
            50% { transform: translateY(-8px) rotate(3deg); }
        }
        
        .intro-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 32px;
            color: #ffaa00;
            text-shadow: 
                0 0 10px #ffaa00,
                0 0 20px #ffaa00,
                0 0 40px #ff6600;
            margin-bottom: 15px;
            letter-spacing: 3px;
            padding-left: 3px;
            text-align: center;
            width: 100%;
            flex-shrink: 0;
        }
        
        /* Intro overlay needs special handling for scrollable content */
        #introScreen {
            padding: 15px 10px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            justify-content: flex-start;
            padding-top: 20px;
            padding-bottom: 20px;
        }
        
        /* Wrapper to help center content vertically when space allows */
        .intro-content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: auto;
            margin-bottom: auto;
            flex-shrink: 0;
        }
        
        .intro-story {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            font-size: 14px;
            color: #ddd;
            text-align: center;
            max-width: 95%;
            width: 100%;
            line-height: 1.5;
            margin-bottom: 20px;
            padding: 0 10px;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
            flex-shrink: 0;
        }
        
        .intro-tip {
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 0 0 10px #ffaa00;
            display: block;
            margin-top: 10px;
        }
        
        .intro-tip {
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 0 0 10px #ffaa00;
            display: block;
            margin-top: 10px;
        }
        
        /* Mobile-specific intro screen adjustments */
        @media (max-height: 550px), (max-width: 380px) {
            .intro-title {
                font-size: 24px;
                margin-bottom: 10px;
            }
            .intro-story {
                font-size: 12px;
                line-height: 1.4;
                margin-bottom: 15px;
                padding: 0 8px;
            }
            #introScreen .btn {
                font-size: 18px;
                padding: 10px 30px;
            }
        }
        
        @media (max-height: 480px) {
            .intro-title {
                font-size: 20px;
                margin-bottom: 8px;
            }
            .intro-story {
                font-size: 11px;
                line-height: 1.35;
                margin-bottom: 12px;
            }
            #introScreen .btn {
                font-size: 16px;
                padding: 8px 25px;
            }
        }
        
        /* Mobile performance optimizations */
        @media (hover: none), (max-width: 768px) {
            .title, .intro-title {
                animation: none !important;
            }
            .btn {
                animation: none !important;
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            }
            #startBtn, #restartBtn, #introBtn {
                animation: none !important;
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff;
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            }
            .btn:hover, .btn:active {
                transform: none;
            }
            .intro-cauldron {
                animation: none !important;
            }
        }
        
        /* GPU acceleration hints */
        .game-container, .overlay, canvas {
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        /* ========== LOADING SCREEN ========== */
        #loadingScreen {
            position: absolute;
            z-index: 100;
        }
        
        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .loading-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 28px;
            color: #ffaa00;
            text-shadow: 0 0 15px #ffaa00, 0 0 30px #ff6600;
            letter-spacing: 3px;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            position: relative;
        }
        
        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid transparent;
            animation: spinRing 1.2s linear infinite;
        }
        
        .spinner-ring:nth-child(1) {
            border-top-color: #0ff;
            animation-delay: 0s;
        }
        
        .spinner-ring:nth-child(2) {
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border-right-color: #f0f;
            animation-delay: -0.4s;
            animation-direction: reverse;
        }
        
        .spinner-ring:nth-child(3) {
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            border-bottom-color: #ff6600;
            animation-delay: -0.8s;
        }
        
        @keyframes spinRing {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 14px;
            color: #888;
            letter-spacing: 2px;
            animation: loadingPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes loadingPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .loading-tip {
            font-size: 12px;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            max-width: 250px;
            text-align: center;
            line-height: 1.4;
        }
        
        /* ========== SCORE MODAL ========== */
        .score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 38px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
            text-align: center;
            margin-bottom: 0;
        }
        
        .score-modal-score {
            font-size: 26px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            text-align: center;
            margin-top: -4px;
        }
        
        .score-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        
        .score-input-label {
            font-size: 14px;
            color: #fff;
            opacity: 0.9;
        }
        
        .score-input {
            width: 200px;
            padding: 10px 14px;
            font-size: 16px;
            font-family: 'Bebas Neue', sans-serif;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }
        
        .score-input:focus {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-input.error {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.15);
            animation: inputShake 0.4s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }
        
        .score-error-msg {
            font-size: 12px;
            color: #ff3366;
            text-shadow: 0 0 8px #ff3366;
            min-height: 16px;
            text-align: center;
        }
        
        .score-buttons {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }
        
        .score-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 2px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .score-btn:active {
            transform: scale(0.98);
        }
        
        .score-btn-submit {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 255, 0.2));
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .score-btn-submit:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }
        
        .score-btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .score-btn-skip {
            background: rgba(255, 255, 255, 0.05);
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #aaa;
        }
        
        /* ========== LEADERBOARD OVERLAY ========== */
        .leaderboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .leaderboard-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 28px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
        }
        
        .leaderboard-close {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .leaderboard-close:hover {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        .leaderboard-close:active {
            transform: scale(0.95);
            border-color: #0ff;
            color: #0ff;
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 10px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 4px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .leaderboard-row.top-3 {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.15), rgba(255, 102, 0, 0.1));
            border: 1px solid rgba(255, 170, 0, 0.3);
        }
        
        .leaderboard-rank {
            width: 40px;
            font-size: 16px;
            font-weight: bold;
            color: #888;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            color: #ffaa00;
            text-shadow: 0 0 8px #ffaa00;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .leaderboard-score {
            font-size: 16px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            min-width: 60px;
            text-align: right;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 16px;
        }
        
        .leaderboard-loading {
            color: #0ff;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
        
        /* Leaderboard button */
        @media (max-width: 500px) {
            .score-modal-title { font-size: 32px; }
            .score-modal-score { font-size: 22px; }
            .score-input { width: 180px; font-size: 16px; }
            .score-btn { padding: 10px 20px; font-size: 14px; }
            .leaderboard-title { font-size: 24px; }
            .leaderboard-row { padding: 8px 10px; }
            .leaderboard-name { font-size: 13px; }
            .leaderboard-score { font-size: 14px; min-width: 50px; }
        }
    </style>
</head>
<body>
    <!-- Intro Screen (visible initially) -->
    <div class="overlay" id="introScreen">
        <div class="intro-content-wrapper">
            <div class="intro-title">CLYDE'S BIG JUMP</div>
            <div class="intro-story">
                Clyde is Joe's golden retriever, and he's been waiting ALL DAY for this moment. The lake is right there, shimmering in the summer sun!<br><br>
                Though... there was something kinda funky about that cookie he snagged off the counter earlier. Everything's looking SO colorful now, and are those... giant mushrooms?! üçÑ<br><br>
                No time to think about that, time to make the biggest splash of his life! üí¶<br><br>
                <span class="intro-tip">ü¶¥ Tap to help Clyde bounce to victory! ü¶¥</span>
            </div>
            <button class="btn" id="introBtn">LET'S JUMP!</button>
        </div>
    </div>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div class="hud" id="hud">0</div>
        
        <!-- Loading Screen -->
        <div class="overlay hidden" id="loadingScreen">
            <div class="loading-content">
                <div class="loading-title">GET READY!</div>
                <div class="loading-spinner">
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                    <div class="spinner-ring"></div>
                </div>
                <div class="loading-text">LOADING...</div>
                <div class="loading-tip">üêï Tap or click to make Clyde jump!</div>
            </div>
        </div>
        
        <!-- Start Screen -->
        <div class="overlay hidden" id="startScreen">
            <div class="title">CLYDE'S BIG JUMP</div>
            <div class="subtitle">TAP TO JUMP</div>
            <div class="menu-buttons">
                <button class="menu-btn" id="startBtn">START GAME</button>
                <button class="menu-btn btn-tutorial" id="backToIntroBtn">THE STORY</button>
                <button class="menu-btn btn-leaderboard" id="leaderboardBtn">LEADER BOARD</button>
            </div>
        </div>
        
        <!-- Game Over Screen -->
        <div class="overlay hidden" id="gameOverScreen">
            <div class="title">GAME OVER</div>
            <div class="score-display" id="finalScore">SCORE: 0</div>
            <div class="high-score" id="highScore">BEST: 0</div>
            <div class="menu-buttons">
                <button class="menu-btn" id="restartBtn">PLAY AGAIN</button>
                <button class="menu-btn btn-tutorial" id="backToIntroBtn2">THE STORY</button>
                <button class="menu-btn btn-leaderboard" id="leaderboardBtn2">LEADER BOARD</button>
            </div>
        </div>
    </div>
    
    <!-- Score Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-title" id="scoreModalTitle">GOOD BOY!</div>
        <div class="score-modal-score" id="finalScoreDisplay">Score: 0</div>
        <div class="score-input-container">
            <div class="score-input-label">Enter your name for the leaderboard:</div>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME" autocomplete="off" autocorrect="off" autocapitalize="characters" spellcheck="false">
            <div class="score-error-msg" id="scoreErrorMsg"></div>
        </div>
        <div class="score-buttons">
            <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title">üèÜ TOP DOGS üèÜ</div>
                <button class="leaderboard-close" id="leaderboardClose">‚úï</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>

    <script>
        // ===== PERFORMANCE DETECTION =====
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const isLowPerf = isMobile;
        const isVeryLowPerf = isIOS && (window.screen.width < 380 || window.screen.height < 700);
        
        // Performance settings
        const PERF = {
            maxParticles: isVeryLowPerf ? 0 : (isLowPerf ? 15 : 50),
            particleMultiplier: isVeryLowPerf ? 0 : (isLowPerf ? 0.5 : 1)
        };

        // ===== DEBUG OVERLAY (hidden by default) =====
        const GameDebug = {
            el: null,
            enabled: false,
            init() {
                this.el = document.createElement('div');
                this.el.style.cssText = 'position:fixed;top:5px;left:5px;background:rgba(0,0,0,0.85);color:#0f0;font:11px monospace;padding:8px 10px;z-index:99999;border-radius:6px;pointer-events:none;line-height:1.5;display:none;';
                document.body.appendChild(this.el);
            },
            show(data) {
                if (!this.enabled) return;
                if (!this.el) this.init();
                this.el.style.display = 'block';
                this.el.innerHTML = Object.entries(data).map(([k,v]) => `<div><span style="color:#0ff">${k}:</span> ${v}</div>`).join('');
            },
            hide() {
                if (this.el) this.el.style.display = 'none';
            }
        };

        // ===== CANVAS & SCALING =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.querySelector('.game-container');

        // Base game dimensions (fixed aspect ratio)
        const baseWidth = 400;
        const baseHeight = 600;
        const ratio = baseWidth / baseHeight;

        // iOS canvas size limit (16M pixels total is safe)
        const MAX_CANVAS_PIXELS = 16 * 1024 * 1024;

        let dprScale = 1;

        // Math constants (cached)
        const PI = Math.PI;
        const PI2 = PI * 2;
        const DEG_TO_RAD = PI / 180;
        
        // Cached font strings
        const FONT_BEBAS_24 = '24px "Bebas Neue", sans-serif';
        const FONT_BEBAS_18 = '18px "Bebas Neue", sans-serif';
        const FONT_BEBAS_14 = '14px "Bebas Neue", sans-serif';

        function resizeCanvas() {
            const isInIframe = window.self !== window.top;
            const isFullscreenAPI = !!(document.fullscreenElement || document.webkitFullscreenElement);
            const isFullscreen = isInIframe || isFullscreenAPI;
            
            // Detect iPad specifically
            const isIPad = /iPad/i.test(navigator.userAgent) || 
                          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isTablet = isIPad || (window.innerWidth >= 768 && window.innerWidth <= 1366 && 'ontouchstart' in window);
            const isLaptopOrDesktop = !isMobile && !isTablet;
            
            const rawDPR = window.devicePixelRatio || 1;
            const maxNormalDPR = isLaptopOrDesktop ? 2 : 1.5;
            const maxFullscreenDPR = isLaptopOrDesktop ? Math.min(rawDPR, 2) : 2;
            
            // Get actual viewport size
            let viewW, viewH;
            if (window.visualViewport) {
                viewW = window.visualViewport.width;
                viewH = window.visualViewport.height;
            } else {
                viewW = window.innerWidth;
                viewH = window.innerHeight;
            }
            
            let displayWidth, displayHeight;

            if (isFullscreen) {
                gameContainer.classList.add('fullscreen-mode');
                document.body.classList.add('fullscreen-active');
                
                // Universal margin system
                // iPad needs extra margin for status bar, home indicator, and close buttons
                const borderWidth = 3;
                const safetyPadding = (isTablet || isIPad) ? 20 : (isInIframe ? 10 : 0);
                const totalMargin = (borderWidth + safetyPadding) * 2;
                
                const availWidth = viewW - totalMargin;
                const availHeight = viewH - totalMargin;
                
                if (availWidth / availHeight > ratio) {
                    displayHeight = Math.floor(availHeight);
                    displayWidth = Math.floor(displayHeight * ratio);
                } else {
                    displayWidth = Math.floor(availWidth);
                    displayHeight = Math.floor(displayWidth / ratio);
                }
                
                // Determine buffer scale
                let bufferScale;
                if (isTablet || isIPad) {
                    bufferScale = 2;
                } else {
                    bufferScale = Math.min(rawDPR, maxFullscreenDPR);
                }
                
                // iOS canvas memory safety check
                let bufferWidth = Math.round(baseWidth * bufferScale);
                let bufferHeight = Math.round(baseHeight * bufferScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    bufferScale *= scaleFactor;
                    bufferWidth = Math.round(baseWidth * bufferScale);
                    bufferHeight = Math.round(baseHeight * bufferScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                dprScale = bufferScale;
                
                // Debug overlay
                GameDebug.show({
                    viewport: `${viewW}√ó${viewH}`,
                    avail: `${Math.round(availWidth)}√ó${Math.round(availHeight)}`,
                    display: `${displayWidth}√ó${displayHeight}`,
                    buffer: `${bufferWidth}√ó${bufferHeight}`,
                    iframe: isInIframe ? 'YES' : 'NO',
                    device: isTablet ? 'tablet' : (isIPad ? 'iPad' : 'desktop')
                });
            } else {
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
                
                const maxWidth = Math.min(baseWidth, viewW - 20);
                const maxHeight = Math.min(baseHeight, viewH - 20);
                
                if (maxWidth / maxHeight > ratio) {
                    displayHeight = maxHeight;
                    displayWidth = maxHeight * ratio;
                } else {
                    displayWidth = maxWidth;
                    displayHeight = maxWidth / ratio;
                }
                
                if (isMobile) {
                    dprScale = Math.min(rawDPR, 1.5);
                } else if (isTablet || isLaptopOrDesktop) {
                    dprScale = Math.min(rawDPR, maxNormalDPR);
                } else {
                    dprScale = 1;
                }
                
                // iOS canvas memory safety check
                let bufferWidth = Math.round(displayWidth * dprScale);
                let bufferHeight = Math.round(displayHeight * dprScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    dprScale *= scaleFactor;
                    bufferWidth = Math.round(displayWidth * dprScale);
                    bufferHeight = Math.round(displayHeight * dprScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                
                if (canvas.parentElement) {
                    canvas.parentElement.style.width = displayWidth + 'px';
                    canvas.parentElement.style.height = displayHeight + 'px';
                }
                
                GameDebug.hide();
            }
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        
        function handleFullscreenChange() {
            resizeCanvas();
        }
        
        // Initial resize
        resizeCanvas();
        
        // Listen for resize and fullscreen changes
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Use visualViewport resize event if available (better for iframes)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
            window.visualViewport.addEventListener('scroll', resizeCanvas);
        }
        
        // Re-check size after delays for iframe loading
        setTimeout(resizeCanvas, 100);
        setTimeout(resizeCanvas, 300);

        // Game state
        let gameState = 'intro'; // 'intro', 'start', 'loading', 'countdown', 'playing', 'gameover'
        let score = 0;
        let highScore = parseInt(localStorage.getItem('clydesBigJumpHigh') || '0');
        
        // Loading screen state
        let loadingStartTime = 0;
        const MIN_LOADING_TIME = 1500; // 1.5 seconds minimum
        
        // Scale factor for responsive game (canvas pixels to game coords, includes DPR)
        const getScale = () => canvas.width / baseWidth;

        // Bird
        const bird = {
            x: 100,
            y: 290,
            width: 70,
            height: 42,
            velocity: 0,
            gravity: 0.27,
            jumpStrength: -7,
            rotation: 0,
            wingAngle: 0,
            wingDir: 1
        };

        // Pipes
        let pipes = [];
        const pipeWidth = 52;
        const pipeGap = 180;
        const pipeSpeed = 3;
        let pipeSpawnTimer = 0;
        const pipeSpawnInterval = 100;

        // ===== PARTICLE OBJECT POOL =====
        const particlePool = [];
        const MAX_POOL_SIZE = 100;
        let particles = [];
        
        function getParticle() {
            if (particlePool.length > 0) {
                return particlePool.pop();
            }
            return { x: 0, y: 0, vx: 0, vy: 0, life: 0, color: '', size: 0 };
        }
        
        function releaseParticle(p) {
            if (particlePool.length < MAX_POOL_SIZE) {
                particlePool.push(p);
            }
        }
        
        function spawnParticle(x, y, vx, vy, life, color, size) {
            if (particles.length >= PERF.maxParticles) return;
            const p = getParticle();
            p.x = x;
            p.y = y;
            p.vx = vx;
            p.vy = vy;
            p.life = life;
            p.color = color;
            p.size = size;
            particles.push(p);
        }

        // ===== MUSHROOM CANVAS POOL =====
        const capCanvasPool = [];
        const MAX_CAP_POOL_SIZE = 20;
        
        function getCapCanvas(width, height) {
            // Try to find a canvas of matching size
            for (let i = 0; i < capCanvasPool.length; i++) {
                const c = capCanvasPool[i];
                if (c.width === width && c.height === height) {
                    capCanvasPool.splice(i, 1);
                    return c;
                }
            }
            // Create new if none available
            const newCanvas = document.createElement('canvas');
            newCanvas.width = width;
            newCanvas.height = height;
            return newCanvas;
        }
        
        function releaseCapCanvas(canvas) {
            if (canvas && capCanvasPool.length < MAX_CAP_POOL_SIZE) {
                // Clear the canvas before returning to pool
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                capCanvasPool.push(canvas);
            }
        }

        // Animation timing
        let animTime = 0;
        let lastFrameTime = performance.now();
        let frameCount = 0; // For particle frame skipping
        
        // ===== CACHED BACKGROUND GRID =====
        let bgGridCanvas = null;
        function createBgGridCache() {
            // Use baseWidth x baseHeight for game coords, scale handles the rest
            // Add buffer to ensure grid covers any edge gaps
            const gridBuffer = 10;
            bgGridCanvas = document.createElement('canvas');
            bgGridCanvas.width = baseWidth + gridBuffer * 2;
            bgGridCanvas.height = baseHeight + gridBuffer;
            const bgCtx = bgGridCanvas.getContext('2d');
            
            // Draw background (extended)
            bgCtx.fillStyle = '#0a0a0a';
            bgCtx.fillRect(0, 0, bgGridCanvas.width, bgGridCanvas.height);
            
            // Skip grid on very low perf, sparse grid on low perf
            if (!isVeryLowPerf) {
                bgCtx.strokeStyle = 'rgba(0, 255, 255, 0.04)';
                bgCtx.lineWidth = 1;
                const gridSpacing = isLowPerf ? 40 : 30;  // Wider spacing on mobile
                for (let x = -gridBuffer; x < baseWidth + gridBuffer; x += gridSpacing) {
                    bgCtx.beginPath(); bgCtx.moveTo(x + gridBuffer, 0); bgCtx.lineTo(x + gridBuffer, bgGridCanvas.height); bgCtx.stroke();
                }
                for (let y = 0; y < bgGridCanvas.height; y += gridSpacing) {
                    bgCtx.beginPath(); bgCtx.moveTo(0, y); bgCtx.lineTo(bgGridCanvas.width, y); bgCtx.stroke();
                }
            }
            
            bgCtx.globalAlpha = 1;
        }
        createBgGridCache();
        
        // ===== CACHED CLYDE SPRITE =====
        const CLYDE_SIZE = 100;
        const CLYDE_CENTER = CLYDE_SIZE / 2;
        let clydeCache = null;
        
        // Spot variations for mushroom tops
        const topSpotColors = [
            { fill: 'rgba(255,255,255,0.6)', glow: 'rgba(255,255,255,0.3)' },
            { fill: 'rgba(0,255,255,0.5)', glow: 'rgba(0,255,255,0.2)' },
            { fill: 'rgba(255,0,255,0.4)', glow: 'rgba(255,0,255,0.2)' },
            { fill: 'rgba(255,170,0,0.5)', glow: 'rgba(255,170,0,0.2)' },
            { fill: 'rgba(0,255,136,0.5)', glow: 'rgba(0,255,136,0.2)' }
        ];
        
        function createClydeCache() {
            clydeCache = document.createElement('canvas');
            clydeCache.width = CLYDE_SIZE;
            clydeCache.height = CLYDE_SIZE;
            const c = clydeCache.getContext('2d');
            c.translate(CLYDE_CENTER - 5, CLYDE_CENTER);
            c.scale(1.4, 1.4);
            
            // Back legs
            c.fillStyle = '#e8b84a';
            c.save();
            c.translate(-14, 6);
            c.rotate(10 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();
            
            c.save();
            c.translate(-8, 6);
            c.rotate(15 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();

            // Body
            c.fillStyle = '#e8b84a';
            c.beginPath(); c.ellipse(0, 4, 22, 12, 0, 0, PI2); c.fill();
            
            // Front legs
            c.save();
            c.translate(8, 6);
            c.rotate(-5 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();
            
            c.save();
            c.translate(14, 6);
            c.rotate(-5 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();
            
            // Head
            c.fillStyle = '#e8b84a';
            c.beginPath(); c.ellipse(18, -6, 13, 12, 0.1, 0, PI2); c.fill();
            
            // Snout
            c.fillStyle = '#f0c860';
            c.beginPath(); c.ellipse(30, -2, 9, 6, 0, 0, PI2); c.fill();
            
            // Nose
            c.fillStyle = '#1a1a1a';
            c.beginPath(); c.ellipse(36, -3, 4, 3, 0, 0, PI2); c.fill();
            c.fillStyle = '#555';
            c.beginPath(); c.ellipse(35, -4.5, 1.5, 1, 0, 0, PI2); c.fill();
            
            // Mouth
            c.fillStyle = '#2a1a10';
            c.beginPath(); c.ellipse(32, 3, 5, 3, 0.1, 0, PI); c.fill();
            
            // Tongue drawn separately for animation
            
            // Mouth cover
            c.fillStyle = '#f0c860';
            c.beginPath(); c.ellipse(30, 1, 6, 3, 0, 0, PI); c.fill();
            
            // Eye
            c.fillStyle = '#fff';
            c.beginPath(); c.ellipse(22, -8, 4, 5, 0, 0, PI2); c.fill();
            c.fillStyle = '#3d2010';
            c.beginPath(); c.ellipse(23, -7.5, 2.5, 3, 0, 0, PI2); c.fill();
            c.fillStyle = '#1a0a00';
            c.beginPath(); c.ellipse(23.5, -7, 1.5, 2, 0, 0, PI2); c.fill();
            c.fillStyle = '#fff';
            c.beginPath(); c.arc(24.5, -9, 1.5, 0, PI2); c.fill();
            
            // Eyebrow
            c.strokeStyle = '#a86830'; c.lineWidth = 2;
            c.beginPath(); c.arc(22, -12, 5, PI * 1.2, PI * 1.7); c.stroke();
            
            // Floppy ear
            c.fillStyle = '#c9874d';
            c.save();
            c.translate(12, -10);
            c.rotate(15 * DEG_TO_RAD);
            c.beginPath();
            c.moveTo(0, 0); c.quadraticCurveTo(11, 7, 9, 16); c.quadraticCurveTo(6, 21, 1, 18); c.quadraticCurveTo(-4, 12, 0, 0);
            c.fill();
            c.fillStyle = '#a86830';
            c.beginPath();
            c.moveTo(1, 3); c.quadraticCurveTo(6, 8, 5, 13); c.quadraticCurveTo(4, 15, 2, 13); c.quadraticCurveTo(0, 9, 1, 3);
            c.fill();
            c.restore();
        }
        createClydeCache();
        
        // Score pop animation
        let scorePop = 0;
        
        // Play time tracker for instructions
        let playTime = 0;
        
        // Thought bubble system
        const thoughtMessages = [
            "I must be getting closer to the lake!",
            "Only a few more steps to the water",
            "Any minute now",
            "Whoah... pretty colors..."
        ];
        let currentThought = '';
        let thoughtTimer = 0;
        let thoughtDisplayTime = 0;
        let lastThoughtIndex = -1;
        let thoughtBubbleX = 0; // Starting X position when thought appears
        let thoughtBubbleY = 0; // Starting Y position when thought appears
        const THOUGHT_INTERVAL = 20; // seconds between thoughts
        const THOUGHT_DISPLAY_DURATION = 3.5; // total animation time
        
        // Touch throttling
        let lastTouchTime = 0;
        const TOUCH_THROTTLE = 50;

        // DOM elements
        const hud = document.getElementById('hud');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const introScreen = document.getElementById('introScreen');
        const loadingScreen = document.getElementById('loadingScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const highScoreEl = document.getElementById('highScore');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const introBtn = document.getElementById('introBtn');
        const backToIntroBtn = document.getElementById('backToIntroBtn');
        const backToIntroBtn2 = document.getElementById('backToIntroBtn2');
        
        // Hide HUD initially (intro screen is already visible in HTML)
        hud.classList.add('hidden');

        // Reset game
        function resetGame() {
            bird.y = 280;
            bird.velocity = 0;
            bird.rotation = 0;
            bird.wingAngle = 0;
            
            // Return pipe canvases to pool before clearing
            for (const pipe of pipes) {
                releaseCapCanvas(pipe.cachedCapTop);
                releaseCapCanvas(pipe.cachedCapBottom);
            }
            pipes = [];
            
            // Return particles to pool
            for (const p of particles) {
                releaseParticle(p);
            }
            particles = [];
            
            score = 0;
            scorePop = 0;
            pipeSpawnTimer = 0;
            playTime = 0;
            thoughtTimer = 0;
            thoughtDisplayTime = 0;
            currentThought = '';
            lastThoughtIndex = -1;
            capColorSequence = 0;
            lastMushroom = { capColorIndex: -1, stemColorIndex: -1, spotPattern: '', stalkType: '', stalkPattern: '' };
            hud.textContent = '0';
        }

        // Start game - now shows loading screen first
        // Countdown state
        let countdownTime = 0;
        let isCountingDown = false;
        
        function showLoadingScreen() {
            gameState = 'loading';
            loadingStartTime = performance.now();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            loadingScreen.classList.remove('hidden');
            
            // Check when to transition
            checkLoadingComplete();
        }
        
        function checkLoadingComplete() {
            const elapsed = performance.now() - loadingStartTime;
            
            if (elapsed >= MIN_LOADING_TIME) {
                // Loading complete, start game
                loadingScreen.classList.add('hidden');
                startGame();
            } else {
                // Keep checking
                requestAnimationFrame(checkLoadingComplete);
            }
        }
        
        function startGame() {
            resetGame();
            gameState = 'countdown';
            isCountingDown = true;
            countdownTime = 0;
            loadingScreen.classList.add('hidden');
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.add('hidden');
        }
        
        function beginPlaying() {
            isCountingDown = false;
            gameState = 'playing';
            hud.classList.remove('hidden');
        }

        // Game over
        function endGame() {
            gameState = 'gameover';
            hud.classList.add('hidden');
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('clydesBigJumpHigh', highScore.toString());
            }
            finalScoreEl.textContent = 'SCORE: ' + score;
            highScoreEl.textContent = 'BEST: ' + highScore;
            
            // Show score modal for leaderboard submission
            showScoreModal(score);
        }

        // Jump/flap
        function flap() {
            if (gameState === 'playing') {
                bird.velocity = bird.jumpStrength;
                bird.wingAngle = -25; // Trigger ear flap
                // Dust puff effect - skip on mobile, use pooled particles
                if (!isLowPerf) {
                    const dustColors = ['#e8e8e8', '#d0d0d0', '#f0f0f0'];
                    const dustCount = Math.floor(3 * PERF.particleMultiplier);
                    for (let i = 0; i < dustCount; i++) {
                        const angle = Math.PI + (i - 1) * 0.4;
                        spawnParticle(
                            bird.x - 5,
                            bird.y + bird.height / 2 + (i - 1) * 6,
                            Math.cos(angle) * (1 + i * 0.3),
                            Math.sin(angle) * 0.8 + (i - 1) * 0.5,
                            0.8,
                            dustColors[i % dustColors.length],
                            8 - i
                        );
                    }
                }
            }
        }

        // Spawn pipe with intelligent variety - each mushroom different from last
        function spawnPipe() {
            const minY = 100;
            const maxY = baseHeight - pipeGap - 100;
            const gapY = Math.random() * (maxY - minY) + minY;
            
            // Get values different from last mushroom
            const pattern = getDifferentFrom(spotPatternIds, lastMushroom.spotPattern);
            const stalkType = getDifferentFrom(stalkTypeIds, lastMushroom.stalkType);
            const stalkPattern = getDifferentFrom(stalkPatternIds, lastMushroom.stalkPattern);
            const capColorIndex = getNextCapColor();
            const stemColorIndex = getDifferentStemColor();
            
            // Update last mushroom tracking
            lastMushroom = {
                capColorIndex: capColorIndex,
                stemColorIndex: stemColorIndex,
                spotPattern: pattern,
                stalkType: stalkType,
                stalkPattern: stalkPattern
            };
            
            // Wider stalks get larger caps
            const widerStalks = ['stocky', 'bulge'];
            const capScale = widerStalks.includes(stalkType) ? 1.12 : 1.0;
            
            const pipeObj = {
                x: baseWidth,
                gapY: gapY,
                pattern: pattern,
                stalkType: stalkType,
                stalkPattern: stalkPattern,
                capColorIndex: capColorIndex,
                stemColorIndex: stemColorIndex,
                capScale: capScale,
                topSpots: Math.floor(Math.random() * 8) + 1,
                topSpotColor: Math.floor(Math.random() * topSpotColors.length),
                highlightCount: [1, 2, 2, 3, 3, 3, 5, 5][Math.floor(Math.random() * 8)],
                scored: false,
                cachedCapTop: null,
                cachedCapBottom: null
            };
            
            // Cache the mushroom caps to off-screen canvases (all devices now)
            pipeObj.cachedCapTop = createCachedCap(pipeObj, true);
            pipeObj.cachedCapBottom = createCachedCap(pipeObj, false);
            
            pipes.push(pipeObj);
        }
        
        // Create cached mushroom cap canvas - now uses pool
        function createCachedCap(pipe, isTop) {
            const scale = pipe.capScale || 1.0;
            const capWidth = Math.round(102 * scale);
            const capHeight = Math.round(51 * scale);
            const padding = 12;
            const canvasWidth = capWidth + padding * 2;
            const canvasHeight = capHeight + padding * 2;
            
            // Get canvas from pool
            const capCanvas = getCapCanvas(canvasWidth, canvasHeight);
            const capCtx = capCanvas.getContext('2d');
            
            const colors = getMushroomColors(pipe.capColorIndex, pipe.stemColorIndex);
            const centerX = canvasWidth / 2;
            const capY = padding;
            
            // Outline
            capCtx.strokeStyle = colors.outline;
            capCtx.lineWidth = 3;
            capCtx.beginPath();
            capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2 + 2, capHeight/2 + 2, 0, 0, PI2);
            capCtx.stroke();
            
            // Cap fill
            capCtx.fillStyle = colors.cap;
            if (isTop) {
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/2, 0, 0, PI);
                capCtx.fill();
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/3, 0, PI, PI2);
                capCtx.fill();
            } else {
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/2, 0, PI, PI2);
                capCtx.fill();
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/3, 0, 0, PI);
                capCtx.fill();
            }
            
            // Dark underside (rim where cap meets stalk)
            capCtx.fillStyle = colors.capDark;
            capCtx.beginPath();
            if (isTop) {
                // Hanging mushroom: underside rim at TOP (where stalk connects)
                capCtx.ellipse(centerX, capY + capHeight/2 - 4, capWidth/2 - 4, 10, 0, PI, PI2);
            } else {
                // Upward mushroom: underside rim at BOTTOM (where stalk connects)
                capCtx.ellipse(centerX, capY + capHeight/2 + 4, capWidth/2 - 4, 10, 0, 0, PI);
            }
            capCtx.fill();
            
            // Spots and highlights (all devices now)
            const pattern = pipe.pattern || 'classic-4';
            const highlightCount = pipe.highlightCount || 1;
            drawSpots(capCtx, pattern, centerX, capY, capWidth, capHeight, colors.spot, isTop);
            drawCapHighlights(capCtx, centerX, capY, capWidth, capHeight, highlightCount, colors.capLight, isTop);
            drawTopSpots(capCtx, pipe.topSpots, centerX, capY, capWidth, capHeight, isTop, pipe.topSpotColor);
            
            return capCanvas;
        }

        // Update game
        function update(dt = 0.016) {
            animTime += dt;
            
            // Frame-rate compensation (normalized to 60fps)
            const fps60 = dt * 60;
            
            // Animate Clyde's floppy ears
            bird.wingAngle *= 0.9;
            
            // Countdown timer
            if (gameState === 'countdown') {
                countdownTime += dt;
                bird.y = 280 + Math.sin(animTime * 1.2) * 8;
                bird.rotation = Math.sin(animTime * 0.8) * 4;
                if (countdownTime >= 2) {
                    beginPlaying();
                }
                return;
            }
            
            // Clyde bobbing on non-playing screens
            if (gameState !== 'playing') {
                bird.y = 280 + Math.sin(animTime * 1.2) * 8;
                bird.rotation = Math.sin(animTime * 0.8) * 4;
            }
            
            // Score pop decay
            if (scorePop > 0) scorePop *= 0.9;
            
            if (gameState !== 'playing') return;

            // Increment play time with actual delta
            playTime += dt;
            
            // Thought bubble timer
            thoughtTimer += dt;
            if (currentThought) {
                thoughtDisplayTime += dt;
                if (thoughtDisplayTime >= THOUGHT_DISPLAY_DURATION) {
                    currentThought = '';
                    thoughtDisplayTime = 0;
                }
            } else if (thoughtTimer >= THOUGHT_INTERVAL) {
                // Pick a random thought that's different from the last one
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * thoughtMessages.length);
                } while (newIndex === lastThoughtIndex);
                currentThought = thoughtMessages[newIndex];
                lastThoughtIndex = newIndex;
                thoughtTimer = 0;
                thoughtDisplayTime = 0;
                // Capture starting position near Clyde
                thoughtBubbleX = bird.x + bird.width + 15;
                thoughtBubbleY = bird.y - 20;
            }

            // Bird physics (frame-rate independent)
            bird.velocity += bird.gravity * fps60;
            if (bird.velocity > 8) bird.velocity = 8;
            bird.y += bird.velocity * fps60;
            
            // Smoother rotation
            const targetRotation = Math.min(Math.max(bird.velocity * 5, -20), 45);
            bird.rotation += (targetRotation - bird.rotation) * 0.08 * fps60;

            // Boundary check
            if (bird.y < 0) {
                bird.y = 0;
                bird.velocity = 0;
            }
            if (bird.y + bird.height > baseHeight) {
                endGame();
                return;
            }

            // Spawn pipes (frame-rate independent)
            pipeSpawnTimer += fps60;
            if (pipeSpawnTimer >= pipeSpawnInterval) {
                spawnPipe();
                pipeSpawnTimer = 0;
            }

            // Update pipes (frame-rate independent)
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= pipeSpeed * fps60;

                // Score
                if (!pipe.scored && pipe.x + pipeWidth < bird.x) {
                    pipe.scored = true;
                    score++;
                    hud.textContent = score;
                }

                // Remove off-screen pipes (swap-and-pop, return canvases to pool)
                if (pipe.x + pipeWidth < 0) {
                    // Return canvas references to pool
                    releaseCapCanvas(pipe.cachedCapTop);
                    releaseCapCanvas(pipe.cachedCapBottom);
                    // Swap with last element and pop (faster than splice)
                    pipes[i] = pipes[pipes.length - 1];
                    pipes.pop();
                    continue;
                }

                // Collision detection (forgiving hitbox)
                const hitboxPadding = 8;
                if (bird.x + bird.width - hitboxPadding > pipe.x && bird.x + hitboxPadding < pipe.x + pipeWidth) {
                    if (bird.y + hitboxPadding < pipe.gapY || bird.y + bird.height - hitboxPadding > pipe.gapY + pipeGap) {
                        endGame();
                        return;
                    }
                }
            }

            // Update particles - skip on mobile, use pooling
            if (!isLowPerf) {
                let i = particles.length;
                while (i--) {
                    const p = particles[i];
                    p.x += p.vx * fps60;
                    p.y += p.vy * fps60;
                    p.vy += 0.03 * fps60;
                    p.vx *= 0.96;
                    p.life -= 0.035 * fps60;
                    if (p.life <= 0) {
                        // Return to pool instead of discarding
                        releaseParticle(p);
                        particles[i] = particles[particles.length - 1];
                        particles.pop();
                    }
                }
                
                // Enforce particle limit
                if (particles.length > PERF.maxParticles) {
                    // Return excess to pool
                    while (particles.length > PERF.maxParticles) {
                        releaseParticle(particles.pop());
                    }
                }
            }
        }

        // Psychedelic mushroom color palette
        const mushroomPalette = {
            caps: ['#ff00ff', '#0ff', '#ff6600', '#00ffcc', '#ff1493', '#9b30ff', '#00ff88', '#ff3366'],
            spots: ['#fff', '#fffef0', '#f8f8ff', '#fffff0', '#fafafa'],
            stems: ['#f5e6d3', '#e8d4c0', '#d4e8d4', '#e0d0e8', '#d8e4f0']
        };
        
        // Pattern IDs
        const spotPatternIds = ['classic-4', 'many-small', 'few-large', 'scattered-mix', 'dense-dots', 'giant-spot', 'asymmetric', 'minimal'];
        const stalkTypeIds = ['straight', 'stocky', 'tapered', 'bulge', 'lean-left', 'lean-right', 'banana-left', 'banana-right', 's-curve', 'wave', 'snake'];
        const stalkPatternIds = ['plain', 'small-spots', 'large-spots', 'scattered-spots', 'dense-specks'];
        
        // Track last spawned mushroom
        let lastMushroom = {
            capColorIndex: -1,
            stemColorIndex: -1,
            spotPattern: '',
            stalkType: '',
            stalkPattern: ''
        };
        
        let capColorSequence = 0;
        
        function getDifferentFrom(arr, lastValue) {
            const available = arr.filter(item => item !== lastValue);
            return available[Math.floor(Math.random() * available.length)];
        }
        
        function getNextCapColor() {
            capColorSequence = (capColorSequence + 1) % mushroomPalette.caps.length;
            return capColorSequence;
        }
        
        function getDifferentStemColor() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * mushroomPalette.stems.length);
            } while (newIndex === lastMushroom.stemColorIndex && mushroomPalette.stems.length > 1);
            return newIndex;
        }
        
        function getMushroomColors(colorIndex, stemIndex) {
            const capColor = mushroomPalette.caps[colorIndex];
            const spotIndex = Math.floor(Math.random() * mushroomPalette.spots.length);
            return {
                cap: capColor,
                capDark: shadeColor(capColor, -35),
                capLight: shadeColor(capColor, 45),
                spot: mushroomPalette.spots[spotIndex],
                stem: mushroomPalette.stems[stemIndex],
                stemDark: shadeColor(mushroomPalette.stems[stemIndex], -20),
                outline: shadeColor(capColor, -50)
            };
        }
        
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        function drawSpots(ctx, pattern, x, y, width, height, spotColor, isTop) {
            ctx.fillStyle = spotColor;
            const flip = isTop ? 1 : -1;
            // Put spots on underside: Top mushroom = upper part (stalk side), Bottom mushroom = lower part (stalk side)
            const baseY = isTop ? y + height * 0.28 : y + height * 0.72;
            
            // All patterns reduced to ~half the spots
            switch(pattern) {
                case 'classic-4':
                    ctx.beginPath(); ctx.arc(x - width * 0.22, baseY - height * 0.02 * flip, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, baseY - height * 0.1 * flip, 7, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'many-small':
                    const smallSpots = [[-0.28, -0.04, 4], [0.02, -0.06, 4], [0.30, 0.04, 3], [0.0, 0.1, 4]];
                    smallSpots.forEach(([ox, oy, r]) => { ctx.beginPath(); ctx.arc(x + width * ox, baseY + height * oy * flip, r, 0, Math.PI * 2); ctx.fill(); });
                    break;
                case 'few-large':
                    ctx.beginPath(); ctx.arc(x - width * 0.15, baseY, 12, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, baseY - height * 0.04 * flip, 11, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'scattered-mix':
                    ctx.beginPath(); ctx.arc(x - width * 0.18, baseY - height * 0.02 * flip, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.2, baseY + height * 0.04 * flip, 8, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'dense-dots':
                    const denseSpots = [[-0.26, -0.06, 3], [0.04, -0.04, 3], [0.24, -0.06, 3], [-0.10, 0.1, 3], [0.12, 0.1, 3], [0.30, 0.08, 3]];
                    denseSpots.forEach(([ox, oy, r]) => { ctx.beginPath(); ctx.arc(x + width * ox, baseY + height * oy * flip, r, 0, Math.PI * 2); ctx.fill(); });
                    break;
                case 'giant-spot':
                    // 3 medium spores instead of 1 giant
                    ctx.beginPath(); ctx.arc(x - width * 0.18, baseY, 9, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.02, baseY - height * 0.02 * flip, 9, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, baseY + height * 0.04 * flip, 8, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'asymmetric':
                    ctx.beginPath(); ctx.arc(x - width * 0.32, baseY - height * 0.06 * flip, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.08, baseY + height * 0.02 * flip, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, baseY - height * 0.08 * flip, 5, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'minimal':
                    ctx.beginPath(); ctx.arc(x, baseY, 10, 0, Math.PI * 2); ctx.fill();
                    break;
            }
        }
        
        function drawCapHighlights(ctx, x, y, width, height, count, highlightColor, isTop) {
            ctx.fillStyle = highlightColor;
            const baseY = isTop ? y + height * 0.68 : y + height * 0.32;
            const positions = [
                [-0.25, 6], [0.15, 5], [0.35, 4], [-0.05, 6], [0.28, 5]
            ];
            for (let i = 0; i < Math.min(count, positions.length); i++) {
                const [ox, r] = positions[i];
                ctx.beginPath();
                ctx.arc(x + width * ox, baseY, r, 0, PI2);
                ctx.fill();
            }
        }
        
        function drawTopSpots(ctx, count, x, y, width, height, isTop, colorIndex) {
            const spotStyle = topSpotColors[colorIndex] || topSpotColors[0];
            const baseY = isTop ? y + height * 0.55 : y + height * 0.45;
            const spotPositions = [
                [-0.30, 0.00, 3], [0.00, -0.08, 4], [0.28, 0.02, 3],
                [-0.15, 0.06, 2], [0.12, 0.04, 3], [-0.05, 0.02, 2],
                [0.22, -0.04, 2], [-0.22, 0.08, 2]
            ];
            
            ctx.fillStyle = spotStyle.fill;
            for (let i = 0; i < Math.min(count, spotPositions.length); i++) {
                const [ox, oy, r] = spotPositions[i];
                const flip = isTop ? -1 : 1;
                ctx.beginPath();
                ctx.arc(x + width * ox, baseY + height * oy * flip, r, 0, PI2);
                ctx.fill();
            }
        }
        
        function drawStalk(ctx, centerX, topY, bottomY, stemWidth, colors, stalkType, stalkPattern) {
            const height = bottomY - topY;
            ctx.fillStyle = colors.stem;
            
            ctx.beginPath();
            switch(stalkType) {
                case 'straight':
                    ctx.rect(centerX - stemWidth/2, topY, stemWidth, height);
                    break;
                case 'stocky':
                    ctx.moveTo(centerX - stemWidth/2 - 4, bottomY);
                    ctx.lineTo(centerX - stemWidth/2, topY);
                    ctx.lineTo(centerX + stemWidth/2, topY);
                    ctx.lineTo(centerX + stemWidth/2 + 4, bottomY);
                    ctx.closePath();
                    break;
                case 'tapered':
                    ctx.moveTo(centerX - stemWidth/2 + 4, bottomY);
                    ctx.lineTo(centerX - stemWidth/2 - 3, topY);
                    ctx.lineTo(centerX + stemWidth/2 + 3, topY);
                    ctx.lineTo(centerX + stemWidth/2 - 4, bottomY);
                    ctx.closePath();
                    break;
                case 'bulge':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.quadraticCurveTo(centerX - stemWidth/2 - 8, topY + height * 0.5, centerX - stemWidth/2, topY);
                    ctx.lineTo(centerX + stemWidth/2, topY);
                    ctx.quadraticCurveTo(centerX + stemWidth/2 + 8, topY + height * 0.5, centerX + stemWidth/2, bottomY);
                    ctx.closePath();
                    break;
                case 'lean-left':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.lineTo(centerX - stemWidth/2 - 6, topY);
                    ctx.lineTo(centerX + stemWidth/2 - 6, topY);
                    ctx.lineTo(centerX + stemWidth/2, bottomY);
                    ctx.closePath();
                    break;
                case 'lean-right':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.lineTo(centerX - stemWidth/2 + 6, topY);
                    ctx.lineTo(centerX + stemWidth/2 + 6, topY);
                    ctx.lineTo(centerX + stemWidth/2, bottomY);
                    ctx.closePath();
                    break;
                case 'banana-left':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.quadraticCurveTo(centerX - stemWidth/2 - 12, topY + height * 0.4, centerX - stemWidth/2 - 4, topY);
                    ctx.lineTo(centerX + stemWidth/2 - 4, topY);
                    ctx.quadraticCurveTo(centerX + stemWidth/2 - 8, topY + height * 0.4, centerX + stemWidth/2, bottomY);
                    ctx.closePath();
                    break;
                case 'banana-right':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.quadraticCurveTo(centerX - stemWidth/2 + 8, topY + height * 0.4, centerX - stemWidth/2 + 4, topY);
                    ctx.lineTo(centerX + stemWidth/2 + 4, topY);
                    ctx.quadraticCurveTo(centerX + stemWidth/2 + 12, topY + height * 0.4, centerX + stemWidth/2, bottomY);
                    ctx.closePath();
                    break;
                case 's-curve':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.bezierCurveTo(
                        centerX - stemWidth/2 - 8, topY + height * 0.7,
                        centerX - stemWidth/2 + 8, topY + height * 0.3,
                        centerX - stemWidth/2, topY
                    );
                    ctx.lineTo(centerX + stemWidth/2, topY);
                    ctx.bezierCurveTo(
                        centerX + stemWidth/2 + 8, topY + height * 0.3,
                        centerX + stemWidth/2 - 8, topY + height * 0.7,
                        centerX + stemWidth/2, bottomY
                    );
                    ctx.closePath();
                    break;
                case 'wave':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.bezierCurveTo(
                        centerX - stemWidth/2 - 6, topY + height * 0.75,
                        centerX - stemWidth/2 + 6, topY + height * 0.5,
                        centerX - stemWidth/2 - 4, topY + height * 0.25
                    );
                    ctx.lineTo(centerX - stemWidth/2, topY);
                    ctx.lineTo(centerX + stemWidth/2, topY);
                    ctx.lineTo(centerX + stemWidth/2 + 4, topY + height * 0.25);
                    ctx.bezierCurveTo(
                        centerX + stemWidth/2 - 6, topY + height * 0.5,
                        centerX + stemWidth/2 + 6, topY + height * 0.75,
                        centerX + stemWidth/2, bottomY
                    );
                    ctx.closePath();
                    break;
                case 'snake':
                    ctx.moveTo(centerX - stemWidth/2, bottomY);
                    ctx.bezierCurveTo(
                        centerX - stemWidth/2 - 10, topY + height * 0.6,
                        centerX - stemWidth/2 + 10, topY + height * 0.3,
                        centerX - stemWidth/2 - 5, topY
                    );
                    ctx.lineTo(centerX + stemWidth/2 - 5, topY);
                    ctx.bezierCurveTo(
                        centerX + stemWidth/2 + 10, topY + height * 0.3,
                        centerX + stemWidth/2 - 10, topY + height * 0.6,
                        centerX + stemWidth/2, bottomY
                    );
                    ctx.closePath();
                    break;
                default:
                    ctx.rect(centerX - stemWidth/2, topY, stemWidth, height);
            }
            ctx.fill();
            
            // Draw stalk spots if pattern calls for it
            if (stalkPattern && stalkPattern !== 'plain') {
                const spotColor = colors.stemDark;
                ctx.fillStyle = spotColor;
                const spotCount = stalkPattern === 'dense-specks' ? 8 : (stalkPattern === 'small-spots' ? 4 : 3);
                const spotSize = stalkPattern === 'large-spots' ? 5 : (stalkPattern === 'dense-specks' ? 2 : 3);
                
                for (let i = 0; i < spotCount; i++) {
                    const spotX = centerX + (Math.random() - 0.5) * (stemWidth - 6);
                    const spotY = topY + Math.random() * height * 0.8 + height * 0.1;
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, spotSize, 0, PI2);
                    ctx.fill();
                }
            }
        }
        
        // Draw a complete mushroom pipe
        function drawMushroom(pipe, isTop) {
            const scale = pipe.capScale || 1.0;
            const capWidth = 102 * scale;
            const capHeight = 51 * scale;
            const stemWidth = 40;
            const gapY = pipe.gapY;
            const centerX = pipe.x + pipeWidth / 2;
            const colors = getMushroomColors(pipe.capColorIndex, pipe.stemColorIndex);
            
            if (isTop) {
                const capY = gapY - capHeight;
                // Draw stalk
                ctx.fillStyle = colors.stem;
                ctx.fillRect(centerX - stemWidth/2, 0, stemWidth, capY + 12);
                // Draw cached cap
                if (pipe.cachedCapTop) {
                    ctx.drawImage(pipe.cachedCapTop, centerX - capWidth/2 - 12, capY - 12);
                }
            } else {
                const capY = gapY;
                // Draw stalk
                ctx.fillStyle = colors.stem;
                ctx.fillRect(centerX - stemWidth/2, capY + capHeight - 12, stemWidth, baseHeight - capY - capHeight + 12);
                // Draw cached cap
                if (pipe.cachedCapBottom) {
                    ctx.drawImage(pipe.cachedCapBottom, centerX - capWidth/2 - 12, capY - 12);
                }
            }
        }

        // Draw game - optimized with setTransform and batching
        function draw() {
            const s = getScale();
            
            // Use setTransform instead of save/scale/restore (faster)
            ctx.setTransform(s, 0, 0, s, 0, 0);

            // Use cached background with grid and static stars (offset for buffer)
            ctx.drawImage(bgGridCanvas, -10, 0);

            // Particles - skip on mobile for performance
            if (!isLowPerf && particles.length > 0) {
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x | 0, p.y | 0, (p.size * p.life) | 0, 0, PI2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            // Draw Clyde (behind mushrooms)
            ctx.save();
            if (isLowPerf) {
                // Mobile: integer coords for faster rendering
                ctx.translate((bird.x + bird.width / 2) | 0, (bird.y + bird.height / 2) | 0);
                ctx.rotate(bird.rotation * DEG_TO_RAD);
                
                // Animated tail (drawn first, behind body)
                const wagAngle = Math.sin(animTime * 10) * 20;
                ctx.save();
                ctx.scale(1.4, 1.4);
                ctx.translate(-24, 0);
                ctx.rotate((wagAngle - 50) * DEG_TO_RAD);
                ctx.fillStyle = '#d9a840';
                ctx.beginPath();
                ctx.moveTo(0, 6); ctx.quadraticCurveTo(-5, 2, -4, -6); ctx.quadraticCurveTo(-3, -12, -1, -18); ctx.quadraticCurveTo(0, -20, 1, -18); ctx.quadraticCurveTo(3, -12, 4, -6); ctx.quadraticCurveTo(5, 2, 0, 6);
                ctx.fill();
                ctx.restore();
                
                // Cached body
                ctx.drawImage(clydeCache, -CLYDE_CENTER + 5, -CLYDE_CENTER);
                
                // Animated tongue (drawn on top)
                ctx.save();
                ctx.scale(1.4, 1.4);
                const tongueOut = (Math.sin(animTime * 2) + 1) * 0.5;
                const tongueLength = 4 + tongueOut * 5;
                ctx.translate(26, 3);
                ctx.rotate(-30 * DEG_TO_RAD);
                ctx.fillStyle = '#ff7b9a';
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.quadraticCurveTo(2, tongueLength * 0.5, 0, tongueLength); ctx.quadraticCurveTo(-3, tongueLength, -3, tongueLength * 0.5); ctx.quadraticCurveTo(-2, 0, 0, 0);
                ctx.fill();
                ctx.restore();
            } else {
                // Desktop: full animations
                ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
                ctx.rotate(bird.rotation * DEG_TO_RAD);
                ctx.scale(1.4, 1.4);

                // Animated tail
                const wagAngle = Math.sin(animTime * 10) * 20;
                ctx.save();
                ctx.translate(-24, 0);
                ctx.rotate((wagAngle - 50) * DEG_TO_RAD);
                ctx.fillStyle = '#d9a840';
                ctx.beginPath();
                ctx.moveTo(0, 6); ctx.quadraticCurveTo(-5, 2, -4, -6); ctx.quadraticCurveTo(-3, -12, -1, -18); ctx.quadraticCurveTo(0, -20, 1, -18); ctx.quadraticCurveTo(3, -12, 4, -6); ctx.quadraticCurveTo(5, 2, 0, 6);
                ctx.fill();
                ctx.restore();
                
                // Back legs
                ctx.fillStyle = '#e8b84a';
                ctx.save();
                ctx.translate(-14, 6);
                ctx.rotate(10 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.translate(-8, 6);
                ctx.rotate(15 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();

                // Body
                ctx.fillStyle = '#e8b84a';
                ctx.beginPath(); ctx.ellipse(0, 4, 22, 12, 0, 0, PI2); ctx.fill();
                
                // Front legs
                ctx.save();
                ctx.translate(8, 6);
                ctx.rotate(-5 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.translate(14, 6);
                ctx.rotate(-5 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();
                
                // Head
                ctx.fillStyle = '#e8b84a';
                ctx.beginPath(); ctx.ellipse(18, -6, 13, 12, 0.1, 0, PI2); ctx.fill();
                
                // Snout
                ctx.fillStyle = '#f0c860';
                ctx.beginPath(); ctx.ellipse(30, -2, 9, 6, 0, 0, PI2); ctx.fill();
                
                // Nose
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath(); ctx.ellipse(36, -3, 4, 3, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#555';
                ctx.beginPath(); ctx.ellipse(35, -4.5, 1.5, 1, 0, 0, PI2); ctx.fill();
                
                // Mouth
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath(); ctx.ellipse(32, 3, 5, 3, 0.1, 0, PI); ctx.fill();
                
                // Animated tongue
                const tongueOut = (Math.sin(animTime * 2) + 1) * 0.5;
                const tongueLength = 4 + tongueOut * 5;
                ctx.save();
                ctx.translate(26, 3);
                ctx.rotate(-30 * DEG_TO_RAD);
                ctx.fillStyle = '#ff7b9a';
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.quadraticCurveTo(2, tongueLength * 0.5, 0, tongueLength); ctx.quadraticCurveTo(-3, tongueLength, -3, tongueLength * 0.5); ctx.quadraticCurveTo(-2, 0, 0, 0);
                ctx.fill();
                ctx.restore();
                
                ctx.fillStyle = '#f0c860';
                ctx.beginPath(); ctx.ellipse(30, 1, 6, 3, 0, 0, PI); ctx.fill();
                
                // Eye
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.ellipse(22, -8, 4, 5, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#3d2010';
                ctx.beginPath(); ctx.ellipse(23, -7.5, 2.5, 3, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#1a0a00';
                ctx.beginPath(); ctx.ellipse(23.5, -7, 1.5, 2, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(24.5, -9, 1.5, 0, PI2); ctx.fill();
                
                // Eyebrow
                ctx.strokeStyle = '#a86830'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(22, -12, 5, PI * 1.2, PI * 1.7); ctx.stroke();
                
                // Floppy ear
                ctx.fillStyle = '#c9874d';
                ctx.save();
                ctx.translate(12, -10);
                ctx.rotate(15 * DEG_TO_RAD);
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.quadraticCurveTo(11, 7, 9, 16); ctx.quadraticCurveTo(6, 21, 1, 18); ctx.quadraticCurveTo(-4, 12, 0, 0);
                ctx.fill();
                ctx.fillStyle = '#a86830';
                ctx.beginPath();
                ctx.moveTo(1, 3); ctx.quadraticCurveTo(6, 8, 5, 13); ctx.quadraticCurveTo(4, 15, 2, 13); ctx.quadraticCurveTo(0, 9, 1, 3);
                ctx.fill();
                ctx.restore();
            }
            ctx.restore();

            // Draw mushrooms (pipes)
            for (let i = 0; i < pipes.length; i++) {
                const pipe = pipes[i];
                drawMushroom(pipe, true);  // Top mushroom
                drawMushroom(pipe, false); // Bottom mushroom
            }

            // Thought bubble
            if (currentThought && thoughtDisplayTime < THOUGHT_DISPLAY_DURATION) {
                const fadeInDuration = 0.3;
                const fadeOutStart = THOUGHT_DISPLAY_DURATION - 0.5;
                let alpha = 1;
                
                if (thoughtDisplayTime < fadeInDuration) {
                    alpha = thoughtDisplayTime / fadeInDuration;
                } else if (thoughtDisplayTime > fadeOutStart) {
                    alpha = 1 - (thoughtDisplayTime - fadeOutStart) / 0.5;
                }
                
                // Float upward from starting position
                const floatOffset = thoughtDisplayTime * 8;
                const bubbleX = Math.min(thoughtBubbleX, baseWidth - 140);
                const bubbleY = Math.max(thoughtBubbleY - floatOffset, 40);
                
                ctx.globalAlpha = alpha * 0.95;
                
                // Bubble background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.roundRect(bubbleX, bubbleY, 130, 45, 12);
                ctx.fill();
                
                // Bubble tail
                ctx.beginPath();
                ctx.moveTo(bubbleX + 10, bubbleY + 45);
                ctx.lineTo(bubbleX - 5, bubbleY + 55);
                ctx.lineTo(bubbleX + 25, bubbleY + 45);
                ctx.fill();
                
                // Thought text - using cached font
                ctx.fillStyle = '#333';
                ctx.font = FONT_BEBAS_14;
                ctx.textAlign = 'left';
                
                // Word wrap
                const words = currentThought.split(' ');
                let line = '';
                let y = bubbleY + 18;
                const maxWidth = 120;
                
                for (const word of words) {
                    const testLine = line + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && line !== '') {
                        ctx.fillText(line.trim(), bubbleX + 8, y);
                        line = word + ' ';
                        y += 14;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line.trim(), bubbleX + 8, y);
                
                ctx.globalAlpha = 1;
            }

            // Ground line (extended beyond baseWidth to fill any gaps)
            ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(-10, baseHeight); ctx.lineTo(baseWidth + 10, baseHeight); ctx.stroke();
            
            // Instructions during countdown - using cached font
            if (gameState === 'countdown') {
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#fff';
                ctx.font = FONT_BEBAS_24;
                ctx.textAlign = 'center';
                const instructionText = isMobile ? 'TAP TO JUMP' : 'CLICK OR SPACEBAR TO JUMP';
                ctx.fillText(instructionText, 200, 180);
                ctx.globalAlpha = 1;
            }
            
            // Instructions during play - using cached font
            if (gameState === 'playing' && playTime < 5) {
                const fadeOpacity = playTime < 3 ? 1 : 1 - (playTime - 3) / 2;
                ctx.globalAlpha = fadeOpacity;
                ctx.fillStyle = '#fff';
                ctx.font = FONT_BEBAS_24;
                ctx.textAlign = 'center';
                ctx.fillText('KEEP JUMPING...', bird.x + bird.width / 2, bird.y - 35);
                ctx.globalAlpha = 1;
            }

            // Reset transform for next frame
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // Game loop - native refresh rate
        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);
            
            // Skip during loading (loading screen handles its own display)
            if (gameState === 'loading') return;
            
            // Calculate delta time (capped to prevent huge jumps)
            const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1);
            lastFrameTime = currentTime;
            frameCount++;
            
            // Update game state
            update(deltaTime);
            
            // Draw
            if (gameState === 'playing' || gameState === 'countdown') {
                draw();
            } else {
                drawMenuBackground();
            }
        }
        
        // Lightweight background for menu screens
        function drawMenuBackground() {
            const s = getScale();
            ctx.setTransform(s, 0, 0, s, 0, 0);
            ctx.drawImage(bgGridCanvas, -10, 0);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // Event listeners - START GAME now shows loading screen first
        startBtn.addEventListener('click', showLoadingScreen);
        restartBtn.addEventListener('click', showLoadingScreen);
        
        introBtn.addEventListener('click', () => {
            introScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            gameState = 'start';
        });
        
        backToIntroBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            introScreen.classList.remove('hidden');
            gameState = 'intro';
        });
        
        backToIntroBtn2.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            introScreen.classList.remove('hidden');
            gameState = 'intro';
        });

        // Input handlers with throttling
        function handleInput(e) {
            e.preventDefault();
            const now = performance.now();
            if (now - lastTouchTime < TOUCH_THROTTLE) return;
            lastTouchTime = now;
            if (gameState === 'playing') flap();
        }

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', handleInput, { passive: false });
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'intro') {
                    introScreen.classList.add('hidden');
                    startScreen.classList.remove('hidden');
                    gameState = 'start';
                } else if (gameState === 'start') {
                    showLoadingScreen();
                } else if (gameState === 'playing') {
                    flap();
                } else if (gameState === 'gameover') {
                    showLoadingScreen();
                }
            }
        });

        // Start loop
        requestAnimationFrame(gameLoop);
        
        // ========== FIREBASE LEADERBOARD SYSTEM ==========
        
        // Firebase Configuration (same project, different collection)
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Collection name for THIS game
        const COLLECTION_NAME = 'clydes_jump_scores';
        const LOCAL_STORAGE_KEY = 'clydes_jump_scores';
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically - IMMEDIATELY on page load
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ===== PROFANITY FILTER =====
        const blockedPatterns = [
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i, /\bc+h+i+n+k/i,
            /\bs+p+i+c+/i, /\bk+i+k+e/i, /\bg+o+o+k/i, /\bw+e+t+b+a+c+k/i, /\btr+a+n+n+y/i,
            /\bd+y+k+e/i, /\bp+a+k+i/i, /\bt+w+a+t/i, /\bw+a+n+k/i, /\bp+r+i+c+k/i,
            /\bb+o+l+l+o+c+k/i, /\ba+r+s+e/i, /\bb+u+g+g+e+r/i, /\bc+r+a+p/i, /\bd+a+m+n/i,
            /\bp+u+t+a/i, /\bm+i+e+r+d+a/i, /\bc+a+b+r+[o√≥]+n/i, /\bp+e+n+d+e+j+o/i,
            /\bc+h+i+n+g+a/i, /\bj+o+d+e+r/i, /\bm+a+r+i+c+[o√≥]+n/i,
            /\bm+e+r+d+e/i, /\bp+u+t+a+i+n/i, /\bs+a+l+o+p/i,
            /\bs+c+h+e+i+[s√ü]+e/i, /\bf+i+c+k/i, /\bh+u+r+e/i, /\ba+r+s+c+h/i,
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i
        ];
        
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'nip', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'anus', 'homo'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            if (blockedExact.has(normalized)) return true;
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) return true;
            }
            return false;
        }
        
        function sanitizeUsername(name) {
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ===== SCORE MODAL =====
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        
        let pendingScore = 0;
        
        async function showScoreModal(finalScore) {
            pendingScore = finalScore;
            finalScoreDisplay.textContent = `Score: ${finalScore}`;
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            gameOverScreen.classList.add('hidden');
            
            const rank = await getScoreRank(finalScore);
            
            if (rank === 1) {
                scoreModalTitle.textContent = "üêï TOP DOG! üêï";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'GOOD BOY!';
            }
            
            scoreModal.classList.add('active');
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        async function getScoreRank(playerScore) {
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data().score));
                } else {
                    scores = getLocalScores().map(s => s.score);
                }
                
                let rank = 1;
                for (const existingScore of scores) {
                    if (playerScore <= existingScore) rank++;
                    else break;
                }
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999;
            }
        }
        
        scoreModal.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
            gameOverScreen.classList.remove('hidden');
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection(COLLECTION_NAME).add({
                        name: username,
                        score: pendingScore,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } else {
                    saveLocalScore(username, pendingScore);
                }
                hideScoreModal();
            } catch (e) {
                console.warn('Score submission failed:', e);
                saveLocalScore(username, pendingScore);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        // Local storage fallback
        function saveLocalScore(name, score) {
            try {
                const scores = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
                scores.push({ name, score, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Score modal event listeners
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            submitScore();
        }, { passive: false, capture: true });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideScoreModal();
        }, { passive: false, capture: true });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); submitScore(); }
            if (e.key === 'Escape') { hideScoreModal(); }
        });
        
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ===== LEADERBOARD =====
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const leaderboardBtn2 = document.getElementById('leaderboardBtn2');
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data()));
                } else {
                    scores = getLocalScores();
                }
                renderLeaderboard(scores);
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                renderLeaderboard(getLocalScores());
            }
        }
        
        function renderLeaderboard(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            scores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                    </div>
                `;
            });
            leaderboardList.innerHTML = html;
        }
        
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        // Leaderboard button listeners
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardBtn2.addEventListener('click', showLeaderboard);
        leaderboardBtn2.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) hideLeaderboard();
        });
        
        leaderboardOverlay.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        leaderboardOverlay.addEventListener('touchend', (e) => {
            if (e.target === leaderboardOverlay) {
                e.preventDefault();
                hideLeaderboard();
            }
        }, { passive: false });
    </script>
</body>
</html>
