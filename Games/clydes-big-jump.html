<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Clyde's Big Jump</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Tilt+Neon&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            font-family: 'Bebas Neue', sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            position: relative;
            border: 3px solid #0ff;
            border-radius: 12px;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            background: #0a0a0a;
            box-sizing: content-box;
            overflow: visible;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Fullscreen/iframe mode: fill entire viewport */
        .game-container.fullscreen-mode {
            width: 100% !important;
            height: 100% !important;
            border-radius: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        
        /* Native fullscreen fix for mobile - uses :fullscreen pseudo-class */
        html:fullscreen,
        html:-webkit-full-screen {
            width: 100% !important;
            height: 100% !important;
        }
        
        html:fullscreen body,
        html:-webkit-full-screen body {
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }
        
        html:fullscreen .game-container.fullscreen-mode,
        html:-webkit-full-screen .game-container.fullscreen-mode {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }

        #gameCanvas {
            display: block;
            border-radius: 2px;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Overlay screens */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        /* Intro screen uses fixed positioning like Neon Defense menu */
        #introScreen {
            position: fixed;
            z-index: 2000;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title, .game-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
            margin-bottom: 10px;
            letter-spacing: 4px;
            text-align: center;
        }
        
        .subtitle, .game-subtitle {
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-bottom: 40px;
            text-align: center;
        }
        
        /* Keep title pulse animation but with cyan */
        @keyframes titlePulse {
            0%, 100% {
                text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
            }
            50% {
                text-shadow: 0 0 40px #0ff, 0 0 80px #0ff, 0 0 100px rgba(0, 255, 255, 0.5);
            }
        }

        .score-display {
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 15px #fff;
            margin-bottom: 10px;
        }

        .high-score {
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 30px;
        }

        /* Original intro button styling */
        .btn {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 20px;
            padding: 4px 28px;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 4px;
            cursor: pointer;
            letter-spacing: 3px;
            text-shadow: 0 0 8px #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.2s ease;
            animation: btnPulse 2.5s ease-in-out infinite;
            -webkit-tap-highlight-color: transparent;
        }
        
        @keyframes btnPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), 0 0 35px rgba(0, 255, 255, 0.2);
            }
        }

        .btn:hover, .btn:active {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        /* Intro button nudged down and taller */
        #introBtn {
            margin-top: 10px;
            padding-top: 10px;
            padding-bottom: 10px;
            animation: psychedelicBtn 4s ease-in-out infinite;
        }

        /* Standardized menu buttons for start/gameover screens */
        .menu-btn {
            padding: 10px 20px;
            width: 160px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            touch-action: manipulation;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .menu-btn:hover {
            background: #0ff;
            color: #000;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        .menu-btn.btn-tutorial {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 8px #f0f;
        }
        
        .menu-btn.btn-tutorial:hover {
            background: #f0f;
            color: #000;
        }
        
        .menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }
        
        .menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
        }
        
        /* Play and Restart buttons - static cyan like other games */
        #startBtn, #restartBtn {
            color: #0ff;
            border-color: #0ff;
            text-shadow: 0 0 8px #0ff;
            box-shadow: 0 0 8px #0ff;
        }
        
        #startBtn:hover, #restartBtn:hover {
            background: #0ff;
            color: #000;
        }
        
        @keyframes psychedelicBtn {
            0% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff, 0 0 15px #0ff;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            }
            25% {
                color: #f0f;
                border-color: #f0f;
                text-shadow: 0 0 8px #f0f, 0 0 15px #f0f;
                box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
            }
            50% {
                color: #ff6600;
                border-color: #ff6600;
                text-shadow: 0 0 8px #ff6600, 0 0 15px #ff6600;
                box-shadow: 0 0 15px rgba(255, 102, 0, 0.4);
            }
            75% {
                color: #00ffcc;
                border-color: #00ffcc;
                text-shadow: 0 0 8px #00ffcc, 0 0 15px #00ffcc;
                box-shadow: 0 0 15px rgba(0, 255, 204, 0.4);
            }
            100% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff, 0 0 15px #0ff;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            }
        }
        
        @keyframes psychedelicBtnFast {
            0% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 12px #0ff, 0 0 25px #0ff;
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            }
            25% {
                color: #f0f;
                border-color: #f0f;
                text-shadow: 0 0 12px #f0f, 0 0 25px #f0f;
                box-shadow: 0 0 25px rgba(255, 0, 255, 0.6);
            }
            50% {
                color: #ff6600;
                border-color: #ff6600;
                text-shadow: 0 0 12px #ff6600, 0 0 25px #ff6600;
                box-shadow: 0 0 25px rgba(255, 102, 0, 0.6);
            }
            75% {
                color: #00ffcc;
                border-color: #00ffcc;
                text-shadow: 0 0 12px #00ffcc, 0 0 25px #00ffcc;
                box-shadow: 0 0 25px rgba(0, 255, 204, 0.6);
            }
            100% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 12px #0ff, 0 0 25px #0ff;
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            }
        }
        
        .btn-secondary {
            font-size: 16px;
            padding: 8px 20px;
            width: 220px;
            text-shadow: 0 0 8px #0ff;
            box-shadow: none;
            animation: none;
        }
        
        .btn-secondary:hover, .btn-secondary:active {
            opacity: 1;
            box-shadow: none;
        }

        /* In-game HUD */
        .hud {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 36px;
            color: #fff;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 20px #ff00ff;
            z-index: 5;
            pointer-events: none;
            transition: transform 0.1s ease-out, text-shadow 0.1s ease, opacity 0.2s ease;
        }
        
        .hud.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .hud.pop {
            transform: scale(1.3);
            text-shadow: 
                0 0 15px #00ffcc,
                0 0 30px #00ffcc,
                0 0 45px #00ffcc;
        }

        .instructions {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            max-width: 200px;
            line-height: 1.4;
            margin-top: -8px;
        }
        
        /* Intro screen styles */
        .intro-cauldron {
            font-size: 56px;
            margin-bottom: 10px;
            animation: cauldronBob 2s ease-in-out infinite;
        }
        
        @keyframes cauldronBob {
            0%, 100% { transform: translateY(0) rotate(-3deg); }
            50% { transform: translateY(-8px) rotate(3deg); }
        }
        
        .intro-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 32px;
            color: #ffaa00;
            text-shadow: 
                0 0 10px #ffaa00,
                0 0 20px #ffaa00,
                0 0 40px #ff6600;
            margin-bottom: 15px;
            letter-spacing: 3px;
            padding-left: 3px;
            text-align: center;
            width: 100%;
            flex-shrink: 0;
        }
        
        /* Intro overlay needs special handling for scrollable content */
        #introScreen {
            padding: 15px 10px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            justify-content: flex-start;
            padding-top: 20px;
            padding-bottom: 20px;
        }
        
        /* Wrapper to help center content vertically when space allows */
        .intro-content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: auto;
            margin-bottom: auto;
            flex-shrink: 0;
        }
        
        .intro-story {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            font-size: 14px;
            color: #ddd;
            text-align: center;
            max-width: 95%;
            width: 100%;
            line-height: 1.5;
            margin-bottom: 20px;
            padding: 0 10px;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
            flex-shrink: 0;
        }
        
        .intro-tip {
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 0 0 10px #ffaa00;
            display: block;
            margin-top: 10px;
        }
        
        .intro-tip {
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 0 0 10px #ffaa00;
            display: block;
            margin-top: 10px;
        }
        
        /* Mobile-specific intro screen adjustments */
        @media (max-height: 550px), (max-width: 380px) {
            .intro-title {
                font-size: 24px;
                margin-bottom: 10px;
            }
            .intro-story {
                font-size: 12px;
                line-height: 1.4;
                margin-bottom: 15px;
                padding: 0 8px;
            }
            #introScreen .btn {
                font-size: 18px;
                padding: 10px 30px;
            }
        }
        
        @media (max-height: 480px) {
            .intro-title {
                font-size: 20px;
                margin-bottom: 8px;
            }
            .intro-story {
                font-size: 11px;
                line-height: 1.35;
                margin-bottom: 12px;
            }
            #introScreen .btn {
                font-size: 16px;
                padding: 8px 25px;
            }
        }
        
        /* Mobile performance optimizations */
        @media (hover: none), (max-width: 768px) {
            .title, .intro-title {
                animation: none !important;
            }
            .btn {
                animation: none !important;
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            }
            #startBtn, #restartBtn, #introBtn {
                animation: none !important;
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff;
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            }
            .btn:hover, .btn:active {
                transform: none;
            }
            .intro-cauldron {
                animation: none !important;
            }
        }
        
        /* GPU acceleration hints */
        .game-container, .overlay, canvas {
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        /* ========== SCORE MODAL ========== */
        .score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 38px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
            text-align: center;
            margin-bottom: 0;
        }
        
        .score-modal-score {
            font-size: 26px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            text-align: center;
            margin-top: -4px;
        }
        
        .score-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        
        .score-input-label {
            font-size: 14px;
            color: #fff;
            opacity: 0.9;
        }
        
        .score-input {
            width: 200px;
            padding: 10px 14px;
            font-size: 16px;
            font-family: 'Bebas Neue', sans-serif;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }
        
        .score-input:focus {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-input.error {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.15);
            animation: inputShake 0.4s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }
        
        .score-error-msg {
            font-size: 12px;
            color: #ff3366;
            text-shadow: 0 0 8px #ff3366;
            min-height: 16px;
            text-align: center;
        }
        
        .score-buttons {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }
        
        .score-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 2px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .score-btn:active {
            transform: scale(0.98);
        }
        
        .score-btn-submit {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 255, 0.2));
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .score-btn-submit:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }
        
        .score-btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .score-btn-skip {
            background: rgba(255, 255, 255, 0.05);
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #aaa;
        }
        
        /* ========== LEADERBOARD OVERLAY ========== */
        .leaderboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .leaderboard-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 28px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
        }
        
        .leaderboard-close {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .leaderboard-close:hover {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        .leaderboard-close:active {
            transform: scale(0.95);
            border-color: #0ff;
            color: #0ff;
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 10px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 4px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .leaderboard-row.top-3 {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.15), rgba(255, 102, 0, 0.1));
            border: 1px solid rgba(255, 170, 0, 0.3);
        }
        
        .leaderboard-rank {
            width: 40px;
            font-size: 16px;
            font-weight: bold;
            color: #888;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            color: #ffaa00;
            text-shadow: 0 0 8px #ffaa00;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .leaderboard-score {
            font-size: 16px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            min-width: 60px;
            text-align: right;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 16px;
        }
        
        .leaderboard-loading {
            color: #0ff;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
        
        /* Leaderboard button */
        @media (max-width: 500px) {
            .score-modal-title { font-size: 32px; }
            .score-modal-score { font-size: 22px; }
            .score-input { width: 180px; font-size: 16px; }
            .score-btn { padding: 10px 20px; font-size: 14px; }
            .leaderboard-title { font-size: 24px; }
            .leaderboard-row { padding: 8px 10px; }
            .leaderboard-name { font-size: 13px; }
            .leaderboard-score { font-size: 14px; min-width: 50px; }
        }
    </style>
</head>
<body>
    <!-- Intro Screen (visible initially) -->
    <div class="overlay" id="introScreen">
        <div class="intro-content-wrapper">
            <div class="intro-title">CLYDE'S BIG JUMP</div>
            <div class="intro-story">
                Clyde is Joe's golden retriever, and he's been waiting ALL DAY for this moment. The lake is right there, shimmering in the summer sun!<br><br>
                Though... there was something kinda funky about that cookie he snagged off the counter earlier. Everything's looking SO colorful now, and are those... giant mushrooms?! üçÑ<br><br>
                No time to think about that, time to make the biggest splash of his life! üí¶<br><br>
                <span class="intro-tip">ü¶¥ Tap to help Clyde bounce to victory! ü¶¥</span>
            </div>
            <button class="btn" id="introBtn">LET'S JUMP!</button>
        </div>
    </div>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div class="hud" id="hud">0</div>
        
        <!-- Start Screen -->
        <div class="overlay hidden" id="startScreen">
            <div class="title">CLYDE'S BIG JUMP</div>
            <div class="subtitle">TAP TO JUMP</div>
            <div class="menu-buttons">
                <button class="menu-btn" id="startBtn">START GAME</button>
                <button class="menu-btn btn-tutorial" id="backToIntroBtn">THE STORY</button>
                <button class="menu-btn btn-leaderboard" id="leaderboardBtn">LEADER BOARD</button>
            </div>
        </div>
        
        <!-- Game Over Screen -->
        <div class="overlay hidden" id="gameOverScreen">
            <div class="title">GAME OVER</div>
            <div class="score-display" id="finalScore">SCORE: 0</div>
            <div class="high-score" id="highScore">BEST: 0</div>
            <div class="menu-buttons">
                <button class="menu-btn" id="restartBtn">PLAY AGAIN</button>
                <button class="menu-btn btn-tutorial" id="backToIntroBtn2">THE STORY</button>
                <button class="menu-btn btn-leaderboard" id="leaderboardBtn2">LEADER BOARD</button>
            </div>
        </div>
    </div>
    
    <!-- Score Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-title" id="scoreModalTitle">HIGH SCORE</div>
        <div class="score-modal-score">Jumps: <span id="finalScoreDisplay">0</span></div>
        <div class="score-input-container">
            <label class="score-input-label">Enter your name for the leaderboard:</label>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME" autocomplete="off" spellcheck="false">
            <div class="score-error-msg" id="scoreErrorMsg"></div>
        </div>
        <div class="score-buttons">
            <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title">üêï TOP 100</div>
                <button class="leaderboard-close" id="leaderboardClose">‚úï</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <div class="leaderboard-loading">Loading scores...</div>
            </div>
        </div>
    </div>

    <script>
        // ===== BROWSER COMPATIBILITY =====
        window.requestAnimationFrame = window.requestAnimationFrame 
            || window.webkitRequestAnimationFrame 
            || window.mozRequestAnimationFrame 
            || window.msRequestAnimationFrame 
            || function(callback) { return setTimeout(callback, 16); };
        
        window.cancelAnimationFrame = window.cancelAnimationFrame
            || window.webkitCancelAnimationFrame
            || window.mozCancelAnimationFrame
            || window.msCancelAnimationFrame
            || function(id) { clearTimeout(id); };
        
        if (!window.performance) window.performance = {};
        if (!window.performance.now) {
            window.performance.now = function() { return Date.now(); };
        }
        
        // ===== PERFORMANCE DETECTION (more aggressive) =====
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                      || window.matchMedia('(hover: none)').matches
                      || window.matchMedia('(pointer: coarse)').matches
                      || ('ontouchstart' in window);
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isOldDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
        const isVeryOldDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
        const hasSlowConnection = navigator.connection && (navigator.connection.saveData || navigator.connection.effectiveType === '2g' || navigator.connection.effectiveType === 'slow-2g');
        const isLowPerf = isMobile || isSafari || isIOS || isOldDevice || hasSlowConnection;
        const isVeryLowPerf = isVeryOldDevice || hasSlowConnection;
        
        const PERF = {
            particleMultiplier: 1.0,
            maxParticles: 15  // Unified for 30fps
        };

        // Pre-calculated constants
        const PI = Math.PI;
        const PI2 = PI * 2;
        const DEG_TO_RAD = PI / 180;

        // Canvas setup with Safari optimizations
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,  // Opaque canvas is faster
            desynchronized: true  // Reduce latency on supported browsers
        });
        
        // Enable image smoothing for all devices
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        // ========== COMPREHENSIVE PIXEL DENSITY SCALING ==========
        const baseWidth = 520;
        const baseHeight = 580;
        let displayWidth = baseWidth;
        let displayHeight = baseHeight;
        let dprScale = 1;
        
        // Device detection
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isTablet = isTouchDevice && Math.min(window.screen.width, window.screen.height) >= 600;
        const isLaptopOrDesktop = !isTouchDevice || window.innerWidth > 1024;
        const rawDPR = window.devicePixelRatio || 1;
        
        // Performance-based DPR limits
        const maxNormalDPR = isLowPerf ? 1.5 : 2;
        const maxFullscreenDPR = isLowPerf ? 2 : 3;
        
        // Get accurate viewport size (works better in iframes)
        function getViewportSize() {
            if (window.visualViewport) {
                return {
                    width: window.visualViewport.width,
                    height: window.visualViewport.height
                };
            }
            return {
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        
        function resizeCanvas() {
            const isNativeFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            
            // Detect if we're in an iframe
            const isInIframe = window.self !== window.top;
            
            // Detect pseudo-fullscreen: viewport is significantly larger than base canvas OR in iframe
            // This works reliably in iframes on iOS where screen.width/height can be unreliable
            const viewport = getViewportSize();
            const viewW = viewport.width;
            const viewH = viewport.height;
            const isPseudoFullscreen = !isNativeFullscreen && 
                                       (isInIframe || viewW > baseWidth * 1.15 || viewH > baseHeight * 1.15);
            
            const isFullscreen = isNativeFullscreen || isPseudoFullscreen;
            const isMobile = viewW <= 768;
            const ratio = baseWidth / baseHeight;
            const gameContainer = document.querySelector('.game-container');
            
            // Calculate display dimensions
            if (isFullscreen) {
                // Fullscreen/iframe: fill viewport accounting for border only
                gameContainer.classList.add('fullscreen-mode');
                
                const borderWidth = 3;
                const availWidth = viewW - (borderWidth * 2);
                const availHeight = viewH - (borderWidth * 2);
                
                if (availWidth / availHeight > ratio) {
                    displayHeight = availHeight;
                    displayWidth = displayHeight * ratio;
                } else {
                    displayWidth = availWidth;
                    displayHeight = displayWidth / ratio;
                }
                // Use higher DPR in fullscreen (up to 3x for 2K+ monitors)
                dprScale = Math.min(rawDPR, maxFullscreenDPR);
            } else {
                gameContainer.classList.remove('fullscreen-mode');
                
                // Available space
                const maxWidth = Math.min(baseWidth, viewW - 20);
                const maxHeight = Math.min(baseHeight, viewH - 20);
                
                // Normal mode
                if (maxWidth / maxHeight > ratio) {
                    displayHeight = maxHeight;
                    displayWidth = maxHeight * ratio;
                } else {
                    displayWidth = maxWidth;
                    displayHeight = maxWidth / ratio;
                }
                
                // Apply DPR scaling based on device type
                if (isMobile) {
                    dprScale = Math.min(rawDPR, 1.5);
                } else if (isTablet || isLaptopOrDesktop) {
                    dprScale = Math.min(rawDPR, maxNormalDPR);
                } else {
                    dprScale = 1;
                }
            }
            
            // Set canvas buffer with DPR scaling for sharp rendering
            canvas.width = Math.round(displayWidth * dprScale);
            canvas.height = Math.round(displayHeight * dprScale);
            
            // Set CSS display size
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Only set parent size in non-fullscreen mode
            if (!isFullscreen) {
                canvas.parentElement.style.width = displayWidth + 'px';
                canvas.parentElement.style.height = displayHeight + 'px';
            }
            
            // Re-apply smoothing after resize (canvas resize resets context)
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        
        function handleFullscreenChange() {
            resizeCanvas();
        }
        
        // Initial resize
        resizeCanvas();
        
        // Listen for resize and fullscreen changes
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Use visualViewport resize event if available (better for iframes)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
            window.visualViewport.addEventListener('scroll', resizeCanvas);
        }
        
        // Re-check size after delays for iframe loading
        setTimeout(resizeCanvas, 100);
        setTimeout(resizeCanvas, 300);

        // Game state
        let gameState = 'intro'; // 'intro', 'loading', 'start', 'playing', 'gameover'
        let score = 0;
        let highScore = parseInt(localStorage.getItem('clydesBigJumpHigh') || '0');
        
        // Scale factor for responsive game (canvas pixels to game coords, includes DPR)
        const getScale = () => canvas.width / baseWidth;

        // Bird
        const bird = {
            x: 100,
            y: 290,
            width: 70,
            height: 42,
            velocity: 0,
            gravity: 0.27,
            jumpStrength: -7,
            rotation: 0,
            wingAngle: 0,
            wingDir: 1
        };

        // Pipes
        let pipes = [];
        const pipeWidth = 52;
        const pipeGap = 180;
        const pipeSpeed = 3;
        let pipeSpawnTimer = 0;
        const pipeSpawnInterval = 100;

        // Particles for trail effect
        let particles = [];

        // Animation timing
        let animTime = 0;
        let lastFrameTime = performance.now();
        let frameCount = 0; // For particle frame skipping
        
        // ===== CACHED BACKGROUND GRID =====
        let bgGridCanvas = null;
        function createBgGridCache() {
            // Use baseWidth x baseHeight for game coords, scale handles the rest
            // Add buffer to ensure grid covers any edge gaps
            const gridBuffer = 10;
            bgGridCanvas = document.createElement('canvas');
            bgGridCanvas.width = baseWidth + gridBuffer * 2;
            bgGridCanvas.height = baseHeight + gridBuffer;
            const bgCtx = bgGridCanvas.getContext('2d');
            
            // Draw background (extended)
            bgCtx.fillStyle = '#0a0a0a';
            bgCtx.fillRect(0, 0, bgGridCanvas.width, bgGridCanvas.height);
            
            // Skip grid on very low perf, sparse grid on low perf
            if (!isVeryLowPerf) {
                bgCtx.strokeStyle = 'rgba(0, 255, 255, 0.04)';
                bgCtx.lineWidth = 1;
                const gridSpacing = isLowPerf ? 40 : 30;  // Wider spacing on mobile
                for (let x = -gridBuffer; x < baseWidth + gridBuffer; x += gridSpacing) {
                    bgCtx.beginPath(); bgCtx.moveTo(x + gridBuffer, 0); bgCtx.lineTo(x + gridBuffer, bgGridCanvas.height); bgCtx.stroke();
                }
                for (let y = 0; y < bgGridCanvas.height; y += gridSpacing) {
                    bgCtx.beginPath(); bgCtx.moveTo(0, y); bgCtx.lineTo(bgGridCanvas.width, y); bgCtx.stroke();
                }
            }
            
            bgCtx.globalAlpha = 1;
            
            // Skip clouds on very low perf
            // Note: positions offset by gridBuffer to account for larger canvas
            if (!isVeryLowPerf) {
                bgCtx.globalAlpha = 0.06;
                bgCtx.fillStyle = '#0ff';
                
                // Cloud 1
                bgCtx.beginPath();
                bgCtx.arc(70 + gridBuffer, 80, 25, 0, PI2);
                bgCtx.arc(95 + gridBuffer, 75, 30, 0, PI2);
                bgCtx.arc(125 + gridBuffer, 80, 22, 0, PI2);
                bgCtx.fill();
                
                // Cloud 2
                bgCtx.beginPath();
                bgCtx.arc(300 + gridBuffer, 120, 20, 0, PI2);
                bgCtx.arc(322 + gridBuffer, 115, 25, 0, PI2);
                bgCtx.arc(348 + gridBuffer, 118, 18, 0, PI2);
                bgCtx.fill();
                
                // Cloud 3
                bgCtx.beginPath();
                bgCtx.arc(200 + gridBuffer, 50, 18, 0, PI2);
                bgCtx.arc(220 + gridBuffer, 45, 22, 0, PI2);
                bgCtx.arc(242 + gridBuffer, 50, 16, 0, PI2);
                bgCtx.fill();
                
                bgCtx.globalAlpha = 1;
            }
            
            // Bake static colorful stars into background (grid-based with jitter)
            // Skip stars on very low perf
            if (!isVeryLowPerf) {
                const starColors = ['#0ff', '#ff00ff', '#ff6600', '#00ffcc', '#ff3366', '#9b30ff', '#00ff88'];
                
                // Seeded random for consistent star placement
                let seed = 12345;
                function seededRandom() {
                    seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                    return seed / 0x7fffffff;
                }
                
                // Cloud exclusion zones (x, y, width, height) - offset for gridBuffer
                const cloudZones = [
                    { x: 40 + gridBuffer, y: 45, w: 115, h: 70 },   // Cloud 1
                    { x: 275 + gridBuffer, y: 85, w: 95, h: 60 },   // Cloud 2
                    { x: 175 + gridBuffer, y: 20, w: 90, h: 55 }    // Cloud 3
                ];
                
                function inCloudZone(x, y) {
                    for (const zone of cloudZones) {
                        if (x >= zone.x && x <= zone.x + zone.w && 
                            y >= zone.y && y <= zone.y + zone.h) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Create a grid and place stars (fewer on mobile)
                const cols = isLowPerf ? 4 : 5;
                const rows = isLowPerf ? 4 : 5;
                const cellW = baseWidth / cols;
                const cellH = baseHeight / rows;
                const jitter = 0.85;
                
                bgCtx.globalAlpha = 0.6;
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (seededRandom() < 0.18) continue;
                        
                        const baseX = col * cellW + cellW / 2;
                        const baseY = row * cellH + cellH / 2;
                        const x = baseX + (seededRandom() - 0.5) * cellW * jitter;
                        const y = baseY + (seededRandom() - 0.5) * cellH * jitter;
                        
                        // Offset for cloud zone check (cloud zones are already offset)
                        if (inCloudZone(x + gridBuffer, y)) continue;
                        
                        bgCtx.fillStyle = starColors[Math.floor(seededRandom() * starColors.length)];
                        bgCtx.beginPath();
                        bgCtx.arc(x + gridBuffer, y, seededRandom() * 1.5 + 0.5, 0, PI2);
                        bgCtx.fill();
                    }
                }
                bgCtx.globalAlpha = 1;
            }
        }
        createBgGridCache();
        
        // Cache entire Clyde for mobile (no animations)
        let clydeCache;
        const CLYDE_CACHE_SIZE = 140; // Size of cached canvas
        const CLYDE_CENTER = 70; // Center point
        
        function createClydeCache() {
            clydeCache = document.createElement('canvas');
            clydeCache.width = CLYDE_CACHE_SIZE;
            clydeCache.height = CLYDE_CACHE_SIZE;
            const c = clydeCache.getContext('2d');
            
            c.translate(CLYDE_CENTER - 5, CLYDE_CENTER);
            c.scale(1.4, 1.4);
            
            // Tail drawn separately for animation
            
            // Back legs
            c.fillStyle = '#e8b84a';
            c.save();
            c.translate(-14, 6);
            c.rotate(10 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();
            
            c.save();
            c.translate(-8, 6);
            c.rotate(15 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();

            // Body
            c.fillStyle = '#e8b84a';
            c.beginPath(); c.ellipse(0, 4, 22, 12, 0, 0, PI2); c.fill();
            
            // Front legs
            c.save();
            c.translate(8, 6);
            c.rotate(-5 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();
            
            c.save();
            c.translate(14, 6);
            c.rotate(-5 * DEG_TO_RAD);
            c.beginPath(); c.roundRect(-3, 0, 7, 16, 3); c.fill();
            c.beginPath(); c.ellipse(0, 18, 5, 4, 0, 0, PI2); c.fill();
            c.restore();
            
            // Head
            c.fillStyle = '#e8b84a';
            c.beginPath(); c.ellipse(18, -6, 13, 12, 0.1, 0, PI2); c.fill();
            
            // Snout
            c.fillStyle = '#f0c860';
            c.beginPath(); c.ellipse(30, -2, 9, 6, 0, 0, PI2); c.fill();
            
            // Nose
            c.fillStyle = '#1a1a1a';
            c.beginPath(); c.ellipse(36, -3, 4, 3, 0, 0, PI2); c.fill();
            c.fillStyle = '#555';
            c.beginPath(); c.ellipse(35, -4.5, 1.5, 1, 0, 0, PI2); c.fill();
            
            // Mouth
            c.fillStyle = '#2a1a10';
            c.beginPath(); c.ellipse(32, 3, 5, 3, 0.1, 0, PI); c.fill();
            
            // Tongue drawn separately for animation
            
            // Mouth cover
            c.fillStyle = '#f0c860';
            c.beginPath(); c.ellipse(30, 1, 6, 3, 0, 0, PI); c.fill();
            
            // Eye
            c.fillStyle = '#fff';
            c.beginPath(); c.ellipse(22, -8, 4, 5, 0, 0, PI2); c.fill();
            c.fillStyle = '#3d2010';
            c.beginPath(); c.ellipse(23, -7.5, 2.5, 3, 0, 0, PI2); c.fill();
            c.fillStyle = '#1a0a00';
            c.beginPath(); c.ellipse(23.5, -7, 1.5, 2, 0, 0, PI2); c.fill();
            c.fillStyle = '#fff';
            c.beginPath(); c.arc(24.5, -9, 1.5, 0, PI2); c.fill();
            
            // Eyebrow
            c.strokeStyle = '#a86830'; c.lineWidth = 2;
            c.beginPath(); c.arc(22, -12, 5, PI * 1.2, PI * 1.7); c.stroke();
            
            // Floppy ear
            c.fillStyle = '#c9874d';
            c.save();
            c.translate(12, -10);
            c.rotate(15 * DEG_TO_RAD);
            c.beginPath();
            c.moveTo(0, 0); c.quadraticCurveTo(11, 7, 9, 16); c.quadraticCurveTo(6, 21, 1, 18); c.quadraticCurveTo(-4, 12, 0, 0);
            c.fill();
            c.fillStyle = '#a86830';
            c.beginPath();
            c.moveTo(1, 3); c.quadraticCurveTo(6, 8, 5, 13); c.quadraticCurveTo(4, 15, 2, 13); c.quadraticCurveTo(0, 9, 1, 3);
            c.fill();
            c.restore();
        }
        createClydeCache();
        
        // Score pop animation
        let scorePop = 0;
        
        // Play time tracker for instructions
        let playTime = 0;
        
        // Thought bubble system
        const thoughtMessages = [
            "I must be getting closer to the lake!",
            "Only a few more steps to the water",
            "Any minute now",
            "Whoah... pretty colors..."
        ];
        let currentThought = '';
        let thoughtTimer = 0;
        let thoughtDisplayTime = 0;
        let lastThoughtIndex = -1;
        let thoughtBubbleX = 0; // Starting X position when thought appears
        let thoughtBubbleY = 0; // Starting Y position when thought appears
        const THOUGHT_INTERVAL = 20; // seconds between thoughts
        const THOUGHT_DISPLAY_DURATION = 3.5; // total animation time
        
        // Touch throttling
        let lastTouchTime = 0;
        const TOUCH_THROTTLE = 50;

        // DOM elements
        const hud = document.getElementById('hud');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const introScreen = document.getElementById('introScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const highScoreEl = document.getElementById('highScore');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const introBtn = document.getElementById('introBtn');
        const backToIntroBtn = document.getElementById('backToIntroBtn');
        const backToIntroBtn2 = document.getElementById('backToIntroBtn2');
        
        // Hide HUD initially (intro screen is already visible in HTML)
        hud.classList.add('hidden');

        // Reset game
        function resetGame() {
            bird.y = 280;
            bird.velocity = 0;
            bird.rotation = 0;
            bird.wingAngle = 0;
            pipes = [];
            particles = [];
            score = 0;
            scorePop = 0;
            pipeSpawnTimer = 0;
            playTime = 0;
            thoughtTimer = 0;
            thoughtDisplayTime = 0;
            currentThought = '';
            lastThoughtIndex = -1;
            capColorSequence = 0;
            lastMushroom = { capColorIndex: -1, stemColorIndex: -1, spotPattern: '', stalkType: '', stalkPattern: '' };
            hud.textContent = '0';
        }

        // Start game
        // Countdown state
        let countdownTime = 0;
        let isCountingDown = false;
        
        function startGame() {
            resetGame();
            gameState = 'countdown';
            isCountingDown = true;
            countdownTime = 0;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.add('hidden');
        }
        
        function beginPlaying() {
            isCountingDown = false;
            gameState = 'playing';
            hud.classList.remove('hidden');
        }

        // Game over
        function endGame() {
            gameState = 'gameover';
            hud.classList.add('hidden');
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('clydesBigJumpHigh', highScore.toString());
            }
            finalScoreEl.textContent = 'SCORE: ' + score;
            highScoreEl.textContent = 'BEST: ' + highScore;
            
            // Show score modal for leaderboard submission
            showScoreModal(score);
        }

        // Jump/flap
        function flap() {
            if (gameState === 'playing') {
                bird.velocity = bird.jumpStrength;
                bird.wingAngle = -25; // Trigger ear flap
                // Dust puff effect - skip on mobile
                if (!isLowPerf) {
                    const dustColors = ['#e8e8e8', '#d0d0d0', '#f0f0f0'];
                    const dustCount = Math.floor(3 * PERF.particleMultiplier);
                    for (let i = 0; i < dustCount; i++) {
                        if (particles.length >= PERF.maxParticles) break;
                        const angle = Math.PI + (i - 1) * 0.4;
                        particles.push({
                            x: bird.x - 5,
                            y: bird.y + bird.height / 2 + (i - 1) * 6,
                            vx: Math.cos(angle) * (1 + i * 0.3),
                            vy: Math.sin(angle) * 0.8 + (i - 1) * 0.5,
                            life: 0.8,
                            color: dustColors[i % dustColors.length],
                            size: 8 - i
                        });
                    }
                }
            }
        }

        // Spawn pipe with intelligent variety - each mushroom different from last
        function spawnPipe() {
            const minY = 100;
            const maxY = baseHeight - pipeGap - 100;
            const gapY = Math.random() * (maxY - minY) + minY;
            
            // Get values different from last mushroom
            const pattern = getDifferentFrom(spotPatternIds, lastMushroom.spotPattern);
            const stalkType = getDifferentFrom(stalkTypeIds, lastMushroom.stalkType);
            const stalkPattern = getDifferentFrom(stalkPatternIds, lastMushroom.stalkPattern);
            const capColorIndex = getNextCapColor();
            const stemColorIndex = getDifferentStemColor();
            
            // Update last mushroom tracking
            lastMushroom = {
                capColorIndex: capColorIndex,
                stemColorIndex: stemColorIndex,
                spotPattern: pattern,
                stalkType: stalkType,
                stalkPattern: stalkPattern
            };
            
            // Wider stalks get larger caps
            const widerStalks = ['stocky', 'bulge'];
            const capScale = widerStalks.includes(stalkType) ? 1.12 : 1.0;
            
            const pipeObj = {
                x: baseWidth,
                gapY: gapY,
                pattern: pattern,
                stalkType: stalkType,
                stalkPattern: stalkPattern,
                capColorIndex: capColorIndex,
                stemColorIndex: stemColorIndex,
                capScale: capScale,
                topSpots: Math.floor(Math.random() * 8) + 1,
                topSpotColor: Math.floor(Math.random() * topSpotColors.length),
                highlightCount: [1, 2, 2, 3, 3, 3, 5, 5][Math.floor(Math.random() * 8)],
                scored: false,
                cachedCapTop: null,
                cachedCapBottom: null
            };
            
            // Cache the mushroom caps to off-screen canvases (all devices now)
            pipeObj.cachedCapTop = createCachedCap(pipeObj, true);
            pipeObj.cachedCapBottom = createCachedCap(pipeObj, false);
            
            pipes.push(pipeObj);
        }
        
        // Create cached mushroom cap canvas
        function createCachedCap(pipe, isTop) {
            const scale = pipe.capScale || 1.0;
            const capWidth = Math.round(102 * scale);
            const capHeight = Math.round(51 * scale);
            const padding = 12;
            const canvasWidth = capWidth + padding * 2;
            const canvasHeight = capHeight + padding * 2;
            
            const capCanvas = document.createElement('canvas');
            capCanvas.width = canvasWidth;
            capCanvas.height = canvasHeight;
            const capCtx = capCanvas.getContext('2d');
            
            const colors = getMushroomColors(pipe.capColorIndex, pipe.stemColorIndex);
            const centerX = canvasWidth / 2;
            const capY = padding;
            
            // Outline
            capCtx.strokeStyle = colors.outline;
            capCtx.lineWidth = 3;
            capCtx.beginPath();
            capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2 + 2, capHeight/2 + 2, 0, 0, PI2);
            capCtx.stroke();
            
            // Cap fill
            capCtx.fillStyle = colors.cap;
            if (isTop) {
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/2, 0, 0, PI);
                capCtx.fill();
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/3, 0, PI, PI2);
                capCtx.fill();
            } else {
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/2, 0, PI, PI2);
                capCtx.fill();
                capCtx.beginPath();
                capCtx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/3, 0, 0, PI);
                capCtx.fill();
            }
            
            // Dark underside (rim where cap meets stalk)
            capCtx.fillStyle = colors.capDark;
            capCtx.beginPath();
            if (isTop) {
                // Hanging mushroom: underside rim at TOP (where stalk connects)
                capCtx.ellipse(centerX, capY + capHeight/2 - 4, capWidth/2 - 4, 10, 0, PI, PI2);
            } else {
                // Upward mushroom: underside rim at BOTTOM (where stalk connects)
                capCtx.ellipse(centerX, capY + capHeight/2 + 4, capWidth/2 - 4, 10, 0, 0, PI);
            }
            capCtx.fill();
            
            // Spots and highlights (all devices now)
            const pattern = pipe.pattern || 'classic-4';
            const highlightCount = pipe.highlightCount || 1;
            drawSpots(capCtx, pattern, centerX, capY, capWidth, capHeight, colors.spot, isTop);
            drawCapHighlights(capCtx, centerX, capY, capWidth, capHeight, highlightCount, colors.capLight, isTop);
            drawTopSpots(capCtx, pipe.topSpots, centerX, capY, capWidth, capHeight, isTop, pipe.topSpotColor);
            
            return capCanvas;
        }

        // Update game
        function update(dt = 0.016) {
            animTime += dt;
            
            // Frame-rate compensation (normalized to 60fps)
            const fps60 = dt * 60;
            
            // Animate Clyde's floppy ears
            bird.wingAngle *= 0.9;
            
            // Countdown timer
            if (gameState === 'countdown') {
                countdownTime += dt;
                bird.y = 280 + Math.sin(animTime * 1.2) * 8;
                bird.rotation = Math.sin(animTime * 0.8) * 4;
                if (countdownTime >= 2) {
                    beginPlaying();
                }
                return;
            }
            
            // Clyde bobbing on non-playing screens
            if (gameState !== 'playing') {
                bird.y = 280 + Math.sin(animTime * 1.2) * 8;
                bird.rotation = Math.sin(animTime * 0.8) * 4;
            }
            
            // Score pop decay
            if (scorePop > 0) scorePop *= 0.9;
            
            if (gameState !== 'playing') return;

            // Increment play time with actual delta
            playTime += dt;
            
            // Thought bubble timer
            thoughtTimer += dt;
            if (currentThought) {
                thoughtDisplayTime += dt;
                if (thoughtDisplayTime >= THOUGHT_DISPLAY_DURATION) {
                    currentThought = '';
                    thoughtDisplayTime = 0;
                }
            } else if (thoughtTimer >= THOUGHT_INTERVAL) {
                // Pick a random thought that's different from the last one
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * thoughtMessages.length);
                } while (newIndex === lastThoughtIndex);
                currentThought = thoughtMessages[newIndex];
                lastThoughtIndex = newIndex;
                thoughtTimer = 0;
                thoughtDisplayTime = 0;
                // Capture starting position near Clyde
                thoughtBubbleX = bird.x + bird.width + 15;
                thoughtBubbleY = bird.y - 20;
            }

            // Bird physics (frame-rate independent)
            bird.velocity += bird.gravity * fps60;
            if (bird.velocity > 8) bird.velocity = 8;
            bird.y += bird.velocity * fps60;
            
            // Smoother rotation
            const targetRotation = Math.min(Math.max(bird.velocity * 5, -20), 45);
            bird.rotation += (targetRotation - bird.rotation) * 0.08 * fps60;

            // Boundary check
            if (bird.y < 0) {
                bird.y = 0;
                bird.velocity = 0;
            }
            if (bird.y + bird.height > baseHeight) {
                endGame();
                return;
            }

            // Spawn pipes (frame-rate independent)
            pipeSpawnTimer += fps60;
            if (pipeSpawnTimer >= pipeSpawnInterval) {
                spawnPipe();
                pipeSpawnTimer = 0;
            }

            // Update pipes (frame-rate independent)
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= pipeSpeed * fps60;

                // Score
                if (!pipe.scored && pipe.x + pipeWidth < bird.x) {
                    pipe.scored = true;
                    score++;
                    hud.textContent = score;
                }

                // Remove off-screen pipes (swap-and-pop, clean up canvases)
                if (pipe.x + pipeWidth < 0) {
                    // Clean up canvas references to help garbage collection
                    pipe.cachedCapTop = null;
                    pipe.cachedCapBottom = null;
                    // Swap with last element and pop (faster than splice)
                    pipes[i] = pipes[pipes.length - 1];
                    pipes.pop();
                    continue;
                }

                // Collision detection (forgiving hitbox)
                const hitboxPadding = 8;
                if (bird.x + bird.width - hitboxPadding > pipe.x && bird.x + hitboxPadding < pipe.x + pipeWidth) {
                    if (bird.y + hitboxPadding < pipe.gapY || bird.y + bird.height - hitboxPadding > pipe.gapY + pipeGap) {
                        endGame();
                        return;
                    }
                }
            }

            // Update particles - skip on mobile
            if (!isLowPerf) {
                // Update particles (swap-and-pop for efficient removal)
                let i = particles.length;
                while (i--) {
                    const p = particles[i];
                    p.x += p.vx * fps60;
                    p.y += p.vy * fps60;
                    p.vy += 0.03 * fps60;
                    p.vx *= 0.96;
                    p.life -= 0.035 * fps60;
                    if (p.life <= 0) {
                        particles[i] = particles[particles.length - 1];
                        particles.pop();
                    }
                }
                
                // Enforce particle limit
                if (particles.length > PERF.maxParticles) {
                    particles.length = PERF.maxParticles;
                }
            }
        }

        // Psychedelic mushroom color palette
        const mushroomPalette = {
            caps: ['#ff00ff', '#0ff', '#ff6600', '#00ffcc', '#ff1493', '#9b30ff', '#00ff88', '#ff3366'],
            spots: ['#fff', '#fffef0', '#f8f8ff', '#fffff0', '#fafafa'],
            stems: ['#f5e6d3', '#e8d4c0', '#d4e8d4', '#e0d0e8', '#d8e4f0']
        };
        
        // Pattern IDs
        const spotPatternIds = ['classic-4', 'many-small', 'few-large', 'scattered-mix', 'dense-dots', 'giant-spot', 'asymmetric', 'minimal'];
        const stalkTypeIds = ['straight', 'stocky', 'tapered', 'bulge', 'lean-left', 'lean-right', 'banana-left', 'banana-right', 's-curve', 'wave', 'snake'];
        const stalkPatternIds = ['plain', 'small-spots', 'large-spots', 'scattered-spots', 'dense-specks'];
        
        // Track last spawned mushroom
        let lastMushroom = {
            capColorIndex: -1,
            stemColorIndex: -1,
            spotPattern: '',
            stalkType: '',
            stalkPattern: ''
        };
        
        let capColorSequence = 0;
        
        function getDifferentFrom(arr, lastValue) {
            const available = arr.filter(item => item !== lastValue);
            return available[Math.floor(Math.random() * available.length)];
        }
        
        function getNextCapColor() {
            capColorSequence = (capColorSequence + 1) % mushroomPalette.caps.length;
            return capColorSequence;
        }
        
        function getDifferentStemColor() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * mushroomPalette.stems.length);
            } while (newIndex === lastMushroom.stemColorIndex && mushroomPalette.stems.length > 1);
            return newIndex;
        }
        
        function getMushroomColors(colorIndex, stemIndex) {
            const capColor = mushroomPalette.caps[colorIndex];
            const spotIndex = Math.floor(Math.random() * mushroomPalette.spots.length);
            return {
                cap: capColor,
                capDark: shadeColor(capColor, -35),
                capLight: shadeColor(capColor, 45),
                spot: mushroomPalette.spots[spotIndex],
                stem: mushroomPalette.stems[stemIndex],
                stemDark: shadeColor(mushroomPalette.stems[stemIndex], -20),
                outline: shadeColor(capColor, -50)
            };
        }
        
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        function drawSpots(ctx, pattern, x, y, width, height, spotColor, isTop) {
            ctx.fillStyle = spotColor;
            const flip = isTop ? 1 : -1;
            // Put spots on underside: Top mushroom = upper part (stalk side), Bottom mushroom = lower part (stalk side)
            const baseY = isTop ? y + height * 0.28 : y + height * 0.72;
            
            // All patterns reduced to ~half the spots
            switch(pattern) {
                case 'classic-4':
                    ctx.beginPath(); ctx.arc(x - width * 0.22, baseY - height * 0.02 * flip, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, baseY - height * 0.1 * flip, 7, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'many-small':
                    const smallSpots = [[-0.28, -0.04, 4], [0.02, -0.06, 4], [0.30, 0.04, 3], [0.0, 0.1, 4]];
                    smallSpots.forEach(([ox, oy, r]) => { ctx.beginPath(); ctx.arc(x + width * ox, baseY + height * oy * flip, r, 0, Math.PI * 2); ctx.fill(); });
                    break;
                case 'few-large':
                    ctx.beginPath(); ctx.arc(x - width * 0.15, baseY, 12, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, baseY - height * 0.04 * flip, 11, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'scattered-mix':
                    ctx.beginPath(); ctx.arc(x - width * 0.18, baseY - height * 0.02 * flip, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.2, baseY + height * 0.04 * flip, 8, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'dense-dots':
                    const denseSpots = [[-0.26, -0.06, 3], [0.04, -0.04, 3], [0.24, -0.06, 3], [-0.10, 0.1, 3], [0.12, 0.1, 3], [0.30, 0.08, 3]];
                    denseSpots.forEach(([ox, oy, r]) => { ctx.beginPath(); ctx.arc(x + width * ox, baseY + height * oy * flip, r, 0, Math.PI * 2); ctx.fill(); });
                    break;
                case 'giant-spot':
                    // 3 medium spores instead of 1 giant
                    ctx.beginPath(); ctx.arc(x - width * 0.18, baseY, 9, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.02, baseY - height * 0.02 * flip, 9, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, baseY + height * 0.02 * flip, 9, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'asymmetric':
                    ctx.beginPath(); ctx.ellipse(x - width * 0.2, baseY - height * 0.04 * flip, 10, 7, 0.3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(x + width * 0.15, baseY + height * 0.02 * flip, 7, 9, -0.2, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'minimal':
                    ctx.beginPath(); ctx.arc(x, baseY, 6, 0, Math.PI * 2); ctx.fill();
                    break;
            }
        }

        // Top spot colors
        const topSpotColors = ['#fff', '#9b30ff', '#ff3366', '#fff', '#ff00ff', '#fff'];
        
        // Draw cap highlights (shiny spots)
        function drawCapHighlights(ctx, centerX, capY, capWidth, capHeight, highlightCount, color, isTop) {
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5;
            
            // Put highlights on visible dome side
            const yOffset = isTop ? capHeight * 0.72 : capHeight * 0.28;
            
            switch(highlightCount) {
                case 1:
                    // Single highlight (original)
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.15, capY + yOffset, capWidth * 0.18, capHeight * 0.12, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 2:
                    // Two highlights
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.22, capY + yOffset, capWidth * 0.12, capHeight * 0.09, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.08, capY + yOffset - 2, capWidth * 0.1, capHeight * 0.08, 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 3:
                    // Three highlights
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.25, capY + yOffset, capWidth * 0.1, capHeight * 0.08, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.05, capY + yOffset - 3, capWidth * 0.12, capHeight * 0.09, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.18, capY + yOffset + 2, capWidth * 0.08, capHeight * 0.06, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 5:
                    // Five highlights scattered
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.28, capY + yOffset + 2, capWidth * 0.08, capHeight * 0.06, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.12, capY + yOffset - 2, capWidth * 0.1, capHeight * 0.08, -0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.02, capY + yOffset, capWidth * 0.07, capHeight * 0.05, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.15, capY + yOffset - 1, capWidth * 0.09, capHeight * 0.07, 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.28, capY + yOffset + 3, capWidth * 0.06, capHeight * 0.05, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                default:
                    // Fallback single
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.15, capY + yOffset, capWidth * 0.18, capHeight * 0.12, -0.3, 0, Math.PI * 2);
                    ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }
        
        function drawTopSpots(ctx, variant, x, capY, width, height, isTop, colorIndex) {
            if (variant === 0) return;
            ctx.fillStyle = topSpotColors[colorIndex] || '#fff';
            // Put spots on underside (stalk side): Top mushroom = near top edge, Bottom mushroom = near bottom edge
            const spotY = isTop ? capY + 8 : capY + height - 8;
            switch(variant) {
                case 1: // 2 spots
                    ctx.beginPath(); ctx.arc(x - width * 0.1, spotY, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.15, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 2: // 3 spots
                    ctx.beginPath(); ctx.arc(x - width * 0.18, spotY + 4, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.05, spotY, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, spotY + 5, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 3: // 1 big + 1 small
                    ctx.beginPath(); ctx.arc(x - width * 0.05, spotY + 2, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, spotY + 5, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 4: // 4 spots
                    ctx.beginPath(); ctx.arc(x - width * 0.2, spotY + 5, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.05, spotY, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.1, spotY + 6, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 5: // 5 spots scattered
                    ctx.beginPath(); ctx.arc(x - width * 0.25, spotY + 2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.1, spotY + 5, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.02, spotY + 1, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.15, spotY + 6, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 6: // 6 spots dense
                    ctx.beginPath(); ctx.arc(x - width * 0.22, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.08, spotY, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.06, spotY + 5, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, spotY + 2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.15, spotY + 7, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, spotY + 6, 2, 0, Math.PI * 2); ctx.fill();
                    break;
                case 7: // many tiny spots
                    for (let i = 0; i < 8; i++) {
                        const ox = (i - 3.5) * width * 0.08;
                        const oy = (i % 2) * 4 + 2;
                        ctx.beginPath(); ctx.arc(x + ox, spotY + oy, 2, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                case 8: // 3 big spots
                    ctx.beginPath(); ctx.arc(x - width * 0.15, spotY + 3, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.05, spotY + 1, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, spotY + 5, 4, 0, Math.PI * 2); ctx.fill();
                    break;
            }
        }

        function drawStalk(ctx, centerX, startY, endY, baseWidth, colors, stalkType, stalkPattern, isTop) {
            const w = baseWidth;
            const h = Math.abs(endY - startY);
            ctx.fillStyle = colors.stem;
            
            // Simple rectangle stalk on all devices for performance
            ctx.fillRect(centerX - w/2, Math.min(startY, endY), w, h);
        }
        function drawPixelMushroom(ctx, x, gapY, pipe, isTop) {
            const scale = pipe.capScale || 1.0;
            const capWidth = Math.round(102 * scale);
            const capHeight = Math.round(51 * scale);
            const stemWidth = Math.round(28 * scale);
            const colors = getMushroomColors(pipe.capColorIndex, pipe.stemColorIndex);
            const centerX = x + pipeWidth / 2;
            
            if (isTop) {
                const capY = gapY - capHeight;
                // Draw stalk
                ctx.fillStyle = colors.stem;
                ctx.fillRect(centerX - stemWidth/2, 0, stemWidth, capY + 12);
                // Draw cached cap
                if (pipe.cachedCapTop) {
                    ctx.drawImage(pipe.cachedCapTop, centerX - capWidth/2 - 12, capY - 12);
                }
            } else {
                const capY = gapY;
                // Draw stalk
                ctx.fillStyle = colors.stem;
                ctx.fillRect(centerX - stemWidth/2, capY + capHeight - 12, stemWidth, baseHeight - capY - capHeight + 12);
                // Draw cached cap
                if (pipe.cachedCapBottom) {
                    ctx.drawImage(pipe.cachedCapBottom, centerX - capWidth/2 - 12, capY - 12);
                }
            }
        }

        // Draw game - optimized with setTransform and batching
        function draw() {
            const s = getScale();
            
            // Use setTransform instead of save/scale/restore (faster)
            ctx.setTransform(s, 0, 0, s, 0, 0);

            // Use cached background with grid and static stars (offset for buffer)
            ctx.drawImage(bgGridCanvas, -10, 0);

            // Particles - skip on mobile for performance
            if (!isLowPerf && particles.length > 0) {
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x | 0, p.y | 0, (p.size * p.life) | 0, 0, PI2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            // Draw Clyde (behind mushrooms)
            ctx.save();
            if (isLowPerf) {
                // Mobile: integer coords for faster rendering
                ctx.translate((bird.x + bird.width / 2) | 0, (bird.y + bird.height / 2) | 0);
                ctx.rotate(bird.rotation * DEG_TO_RAD);
                
                // Animated tail (drawn first, behind body)
                const wagAngle = Math.sin(animTime * 10) * 20;
                ctx.save();
                ctx.scale(1.4, 1.4);
                ctx.translate(-24, 0);
                ctx.rotate((wagAngle - 50) * DEG_TO_RAD);
                ctx.fillStyle = '#d9a840';
                ctx.beginPath();
                ctx.moveTo(0, 6); ctx.quadraticCurveTo(-5, 2, -4, -6); ctx.quadraticCurveTo(-3, -12, -1, -18); ctx.quadraticCurveTo(0, -20, 1, -18); ctx.quadraticCurveTo(3, -12, 4, -6); ctx.quadraticCurveTo(5, 2, 0, 6);
                ctx.fill();
                ctx.restore();
                
                // Cached body
                ctx.drawImage(clydeCache, -CLYDE_CENTER + 5, -CLYDE_CENTER);
                
                // Animated tongue (drawn on top)
                ctx.save();
                ctx.scale(1.4, 1.4);
                const tongueOut = (Math.sin(animTime * 2) + 1) * 0.5;
                const tongueLength = 4 + tongueOut * 5;
                ctx.translate(26, 3);
                ctx.rotate(-30 * DEG_TO_RAD);
                ctx.fillStyle = '#ff7b9a';
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.quadraticCurveTo(2, tongueLength * 0.5, 0, tongueLength); ctx.quadraticCurveTo(-3, tongueLength, -3, tongueLength * 0.5); ctx.quadraticCurveTo(-2, 0, 0, 0);
                ctx.fill();
                ctx.restore();
            } else {
                // Desktop: full animations
                ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
                ctx.rotate(bird.rotation * DEG_TO_RAD);
                ctx.scale(1.4, 1.4);

                // Animated tail
                const wagAngle = Math.sin(animTime * 10) * 20;
                ctx.save();
                ctx.translate(-24, 0);
                ctx.rotate((wagAngle - 50) * DEG_TO_RAD);
                ctx.fillStyle = '#d9a840';
                ctx.beginPath();
                ctx.moveTo(0, 6); ctx.quadraticCurveTo(-5, 2, -4, -6); ctx.quadraticCurveTo(-3, -12, -1, -18); ctx.quadraticCurveTo(0, -20, 1, -18); ctx.quadraticCurveTo(3, -12, 4, -6); ctx.quadraticCurveTo(5, 2, 0, 6);
                ctx.fill();
                ctx.restore();
                
                // Back legs
                ctx.fillStyle = '#e8b84a';
                ctx.save();
                ctx.translate(-14, 6);
                ctx.rotate(10 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.translate(-8, 6);
                ctx.rotate(15 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();

                // Body
                ctx.fillStyle = '#e8b84a';
                ctx.beginPath(); ctx.ellipse(0, 4, 22, 12, 0, 0, PI2); ctx.fill();
                
                // Front legs
                ctx.save();
                ctx.translate(8, 6);
                ctx.rotate(-5 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.translate(14, 6);
                ctx.rotate(-5 * DEG_TO_RAD);
                ctx.beginPath(); ctx.roundRect(-3, 0, 7, 16, 3); ctx.fill();
                ctx.beginPath(); ctx.ellipse(0, 18, 5, 4, 0, 0, PI2); ctx.fill();
                ctx.restore();
                
                // Head
                ctx.fillStyle = '#e8b84a';
                ctx.beginPath(); ctx.ellipse(18, -6, 13, 12, 0.1, 0, PI2); ctx.fill();
                
                // Snout
                ctx.fillStyle = '#f0c860';
                ctx.beginPath(); ctx.ellipse(30, -2, 9, 6, 0, 0, PI2); ctx.fill();
                
                // Nose
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath(); ctx.ellipse(36, -3, 4, 3, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#555';
                ctx.beginPath(); ctx.ellipse(35, -4.5, 1.5, 1, 0, 0, PI2); ctx.fill();
                
                // Mouth
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath(); ctx.ellipse(32, 3, 5, 3, 0.1, 0, PI); ctx.fill();
                
                // Animated tongue
                const tongueOut = (Math.sin(animTime * 2) + 1) * 0.5;
                const tongueLength = 4 + tongueOut * 5;
                ctx.save();
                ctx.translate(26, 3);
                ctx.rotate(-30 * DEG_TO_RAD);
                ctx.fillStyle = '#ff7b9a';
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.quadraticCurveTo(2, tongueLength * 0.5, 0, tongueLength); ctx.quadraticCurveTo(-3, tongueLength, -3, tongueLength * 0.5); ctx.quadraticCurveTo(-2, 0, 0, 0);
                ctx.fill();
                ctx.restore();
                
                ctx.fillStyle = '#f0c860';
                ctx.beginPath(); ctx.ellipse(30, 1, 6, 3, 0, 0, PI); ctx.fill();
                
                // Eye
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.ellipse(22, -8, 4, 5, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#3d2010';
                ctx.beginPath(); ctx.ellipse(23, -7.5, 2.5, 3, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#1a0a00';
                ctx.beginPath(); ctx.ellipse(23.5, -7, 1.5, 2, 0, 0, PI2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(24.5, -9, 1.5, 0, PI2); ctx.fill();
                
                // Eyebrow
                ctx.strokeStyle = '#a86830'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(22, -12, 5, PI * 1.2, PI * 1.7); ctx.stroke();
                
                // Floppy ear
                ctx.fillStyle = '#c9874d';
                ctx.save();
                ctx.translate(12, -10);
                ctx.rotate(15 * DEG_TO_RAD);
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.quadraticCurveTo(11, 7, 9, 16); ctx.quadraticCurveTo(6, 21, 1, 18); ctx.quadraticCurveTo(-4, 12, 0, 0);
                ctx.fill();
                ctx.fillStyle = '#a86830';
                ctx.beginPath();
                ctx.moveTo(1, 3); ctx.quadraticCurveTo(6, 8, 5, 13); ctx.quadraticCurveTo(4, 15, 2, 13); ctx.quadraticCurveTo(0, 9, 1, 3);
                ctx.fill();
                ctx.restore();
            }

            ctx.restore();

            // Mushrooms (batched: all stalks first, then all caps)
            // Pass 1: Draw all stalks (fillRects batched by similar operations)
            for (let i = 0; i < pipes.length; i++) {
                const pipe = pipes[i];
                const pScale = pipe.capScale || 1.0;
                const capHeight = Math.round(51 * pScale);
                const stemWidth = Math.round(28 * pScale);
                const colors = getMushroomColors(pipe.capColorIndex, pipe.stemColorIndex);
                const centerX = pipe.x + pipeWidth / 2;
                
                ctx.fillStyle = colors.stem;
                // Top stalk (use integers for faster rendering)
                const topCapY = (pipe.gapY - capHeight) | 0;
                const stalkX = (centerX - stemWidth/2) | 0;
                ctx.fillRect(stalkX, 0, stemWidth, topCapY + 12);
                // Bottom stalk
                const bottomCapY = (pipe.gapY + pipeGap) | 0;
                ctx.fillRect(stalkX, bottomCapY + capHeight - 12, stemWidth, baseHeight - bottomCapY - capHeight + 12);
            }
            
            // Pass 2: Draw all caps (drawImage calls)
            for (let i = 0; i < pipes.length; i++) {
                const pipe = pipes[i];
                const pScale = pipe.capScale || 1.0;
                const capWidth = Math.round(102 * pScale);
                const capHeight = Math.round(51 * pScale);
                const centerX = (pipe.x + pipeWidth / 2) | 0;
                
                // Top cap (integer coords)
                if (pipe.cachedCapTop) {
                    const topCapY = (pipe.gapY - capHeight) | 0;
                    ctx.drawImage(pipe.cachedCapTop, (centerX - capWidth/2 - 12) | 0, topCapY - 12);
                }
                // Bottom cap
                if (pipe.cachedCapBottom) {
                    const bottomCapY = (pipe.gapY + pipeGap) | 0;
                    ctx.drawImage(pipe.cachedCapBottom, (centerX - capWidth/2 - 12) | 0, bottomCapY - 12);
                }
            }

            // Thought bubble (skip on very low perf)
            if (currentThought && gameState === 'playing' && !isVeryLowPerf) {
                // Fade in/out within 3.5 second total
                let bubbleAlpha = 1;
                if (thoughtDisplayTime < 0.4) {
                    bubbleAlpha = thoughtDisplayTime / 0.4; // fade in
                } else if (thoughtDisplayTime > THOUGHT_DISPLAY_DURATION - 0.6) {
                    bubbleAlpha = (THOUGHT_DISPLAY_DURATION - thoughtDisplayTime) / 0.6; // fade out
                }
                
                // Float slowly upward and slightly right from initial position
                const floatX = thoughtBubbleX + thoughtDisplayTime * 8;
                const floatY = thoughtBubbleY - thoughtDisplayTime * 15;
                
                // Clamp to stay on screen (use integers on mobile)
                ctx.font = '24px "Bebas Neue", sans-serif';
                const textWidth = ctx.measureText(currentThought).width;
                const clampedX = Math.min(Math.max(floatX, textWidth / 2 + 8), baseWidth - textWidth / 2 - 8) | 0;
                const clampedY = Math.max(floatY, 20) | 0;
                
                // Draw text (same style as KEEP JUMPING)
                ctx.globalAlpha = bubbleAlpha;
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(currentThought, clampedX, clampedY);
                ctx.globalAlpha = 1;
            }

            // Ground line (extended beyond baseWidth to fill any gaps)
            ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(-10, baseHeight); ctx.lineTo(baseWidth + 10, baseHeight); ctx.stroke();
            
            // Instructions during countdown
            if (gameState === 'countdown') {
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#fff';
                ctx.font = '24px "Bebas Neue", sans-serif';
                ctx.textAlign = 'center';
                const instructionText = isMobile ? 'TAP TO JUMP' : 'CLICK OR SPACEBAR TO JUMP';
                ctx.fillText(instructionText, 200, 180);
                ctx.globalAlpha = 1;
            }
            
            // Instructions during play
            if (gameState === 'playing' && playTime < 5) {
                const fadeOpacity = playTime < 3 ? 1 : 1 - (playTime - 3) / 2;
                ctx.globalAlpha = fadeOpacity;
                ctx.fillStyle = '#fff';
                ctx.font = '24px "Bebas Neue", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('KEEP JUMPING...', bird.x + bird.width / 2, bird.y - 35);
                ctx.globalAlpha = 1;
            }

            // Reset transform for next frame
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // Game loop - native refresh rate
        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);
            
            // Skip during loading
            if (gameState === 'loading') return;
            
            // Calculate delta time (capped to prevent huge jumps)
            const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1);
            lastFrameTime = currentTime;
            frameCount++;
            
            // Update game state
            update(deltaTime);
            
            // Draw
            if (gameState === 'playing' || gameState === 'countdown') {
                draw();
            } else {
                drawMenuBackground();
            }
        }
        
        // Lightweight background for menu screens
        function drawMenuBackground() {
            const s = getScale();
            ctx.setTransform(s, 0, 0, s, 0, 0);
            ctx.drawImage(bgGridCanvas, -10, 0);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // Event listeners
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        
        introBtn.addEventListener('click', () => {
            introScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            gameState = 'start';
        });
        
        backToIntroBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            introScreen.classList.remove('hidden');
            gameState = 'intro';
        });
        
        backToIntroBtn2.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            introScreen.classList.remove('hidden');
            gameState = 'intro';
        });

        // Input handlers with throttling
        function handleInput(e) {
            e.preventDefault();
            const now = performance.now();
            if (now - lastTouchTime < TOUCH_THROTTLE) return;
            lastTouchTime = now;
            if (gameState === 'playing') flap();
        }

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', handleInput, { passive: false });
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'intro') {
                    introScreen.classList.add('hidden');
                    startScreen.classList.remove('hidden');
                    gameState = 'start';
                } else if (gameState === 'start') {
                    startGame();
                } else if (gameState === 'playing') {
                    flap();
                } else if (gameState === 'gameover') {
                    startGame();
                }
            }
        });

        // Start loop
        requestAnimationFrame(gameLoop);
        
        // ========== FIREBASE LEADERBOARD SYSTEM ==========
        
        // Firebase Configuration (same project, different collection)
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Collection name for THIS game
        const COLLECTION_NAME = 'clydes_jump_scores';
        const LOCAL_STORAGE_KEY = 'clydes_jump_scores';
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ===== PROFANITY FILTER =====
        const blockedPatterns = [
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i, /\bc+h+i+n+k/i,
            /\bs+p+i+c+/i, /\bk+i+k+e/i, /\bg+o+o+k/i, /\bw+e+t+b+a+c+k/i, /\btr+a+n+n+y/i,
            /\bd+y+k+e/i, /\bp+a+k+i/i, /\bt+w+a+t/i, /\bw+a+n+k/i, /\bp+r+i+c+k/i,
            /\bb+o+l+l+o+c+k/i, /\ba+r+s+e/i, /\bb+u+g+g+e+r/i, /\bc+r+a+p/i, /\bd+a+m+n/i,
            /\bp+u+t+a/i, /\bm+i+e+r+d+a/i, /\bc+a+b+r+[o√≥]+n/i, /\bp+e+n+d+e+j+o/i,
            /\bc+h+i+n+g+a/i, /\bj+o+d+e+r/i, /\bm+a+r+i+c+[o√≥]+n/i,
            /\bm+e+r+d+e/i, /\bp+u+t+a+i+n/i, /\bs+a+l+o+p/i,
            /\bs+c+h+e+i+[s√ü]+e/i, /\bf+i+c+k/i, /\bh+u+r+e/i, /\ba+r+s+c+h/i,
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i
        ];
        
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'nip', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'anus', 'homo'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            if (blockedExact.has(normalized)) return true;
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) return true;
            }
            return false;
        }
        
        function sanitizeUsername(name) {
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ===== SCORE MODAL =====
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        
        let pendingScore = 0;
        
        async function showScoreModal(finalScore) {
            pendingScore = finalScore;
            finalScoreDisplay.textContent = finalScore;
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'Submit';
            
            // Check rank
            let rank = await getScoreRank(finalScore);
            
            if (rank === 1) {
                scoreModalTitle.textContent = "üêï TOP DOG! üêï";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'GOOD BOY!';
            }
            
            scoreModal.classList.add('active');
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        async function getScoreRank(playerScore) {
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data().score));
                } else {
                    scores = getLocalScores().map(s => s.score);
                }
                
                let rank = 1;
                for (const existingScore of scores) {
                    if (playerScore <= existingScore) rank++;
                    else break;
                }
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999;
            }
        }
        
        scoreModal.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
            gameOverScreen.classList.remove('hidden');
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection(COLLECTION_NAME).add({
                        name: username,
                        score: pendingScore,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } else {
                    saveLocalScore(username, pendingScore);
                }
                hideScoreModal();
            } catch (e) {
                console.warn('Score submission failed:', e);
                saveLocalScore(username, pendingScore);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        // Local storage fallback
        function saveLocalScore(name, score) {
            try {
                const scores = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
                scores.push({ name, score, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Score modal event listeners
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            submitScore();
        }, { passive: false, capture: true });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideScoreModal();
        }, { passive: false, capture: true });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); submitScore(); }
            if (e.key === 'Escape') { hideScoreModal(); }
        });
        
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ===== LEADERBOARD =====
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const leaderboardBtn2 = document.getElementById('leaderboardBtn2');
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data()));
                } else {
                    scores = getLocalScores();
                }
                renderLeaderboard(scores);
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                renderLeaderboard(getLocalScores());
            }
        }
        
        function renderLeaderboard(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            scores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                    </div>
                `;
            });
            leaderboardList.innerHTML = html;
        }
        
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        // Leaderboard button listeners
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardBtn2.addEventListener('click', showLeaderboard);
        leaderboardBtn2.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) hideLeaderboard();
        });
        
        leaderboardOverlay.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        leaderboardOverlay.addEventListener('touchend', (e) => {
            if (e.target === leaderboardOverlay) {
                e.preventDefault();
                hideLeaderboard();
            }
        }, { passive: false });
    </script>
</body>
</html>
