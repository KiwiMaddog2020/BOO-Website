<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=overlays-content">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>BOO Brickbreaker</title>
    <script>
        // Immediate iframe detection - runs before CSS layout
        if (window.self !== window.top) {
            document.documentElement.classList.add('in-iframe');
        }
        window.onerror=function(){return true};window.onunhandledrejection=function(e){if(e&&e.preventDefault)e.preventDefault();return true};
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            height: 100dvh; /* Dynamic viewport height for mobile */
            margin: 0;
            padding: 0;
            overscroll-behavior: none; /* Prevent overscroll/bounce */
            -webkit-overflow-scrolling: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center; /* Center vertically for better iframe fit */
            min-height: 100%;
            min-height: 100dvh;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none; /* Prevent overscroll/bounce */
            padding: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 6px;
            /* Size to fit content with max constraints for iframe */
            width: fit-content;
            height: fit-content;
            max-width: calc(100vw - 12px);
            max-height: calc(100vh - 12px);
            max-height: calc(100dvh - 12px);
            transform: translateZ(0);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
            overflow: visible;
            border: 3px solid #0ff;
            border-radius: 12px;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            background: #0a0a0a;
        }

        /* Fullscreen/iframe mode: fill entire viewport */
        .game-container.fullscreen-mode {
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            padding: 0;
            gap: 0;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }
        
        /* Fullscreen body centering - JS adds this class */
        body.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            overflow: hidden !important;
        }
        
        /* Force fullscreen layout when in iframe (CSS kicks in immediately) */
        html.in-iframe,
        html.in-iframe body {
            width: 100% !important;
            height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
        }
        
        html.in-iframe body {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }
        
        html.in-iframe .game-container {
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            padding: 4px !important;
            gap: 2px !important;
        }
        
        /* In iframe: compact HUD */
        html.in-iframe .hud {
            padding: 2px 0;
            flex-shrink: 0;
            font-size: 15px;
            gap: 22px;
        }
        
        /* In iframe: compact trackpad zone to fit 640/690 aspect ratio */
        html.in-iframe .trackpad-zone {
            flex: 1;
            min-height: 100px;
            max-height: none;
            padding: 6px 10px 7px;
        }
        
        html.in-iframe .power-up-timers {
            height: 52px;
            min-height: 52px;
            max-height: 52px;
        }
        
        html.in-iframe .power-up-timers span {
            height: 13px;
            min-height: 13px;
            max-height: 13px;
            line-height: 13px;
            font-size: 11px;
        }
        
        html.in-iframe .trackpad-spacer {
            flex: 1;
            min-height: 4px;
        }
        
        html.in-iframe .trackpad-instructions {
            height: 16px;
            min-height: 16px;
            font-size: 8px;
            margin: 2px 0;
        }
        
        html.in-iframe .permanent-upgrades {
            margin-top: 4px;
            padding-top: 4px;
            margin-bottom: 12px;
            gap: 8px;
        }
        
        html.in-iframe .perm-upgrade {
            width: 26px;
            height: 26px;
        }
        
        html.in-iframe .perm-icon {
            font-size: 16px;
        }

        /* Main Menu Overlay */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            touch-action: manipulation;
        }

        .menu-overlay.hidden {
            display: none;
            pointer-events: none;
        }

        .game-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 2px #0ff, 0 0 5px #0ff, 0 0 20px #0077ff, 0 0 40px #0077ff, 0 0 80px #0077ff;
            margin-bottom: 10px;
            letter-spacing: 4px;
            text-align: center;
        }
        
        @media (max-width: 500px) {
            .game-title {
                font-size: 32px;
                letter-spacing: 2px;
            }
        }

        .game-subtitle {
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-bottom: 40px;
            text-align: center;
        }
        
        @media (max-width: 500px) {
            .game-subtitle {
                font-size: 14px;
                margin-bottom: 30px;
            }
        }

        .menu-btn {
            padding: 10px 20px;
            width: 160px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            touch-action: manipulation;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .menu-btn:hover {
            background: #0ff;
            color: #000;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        .menu-btn.btn-tutorial {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 8px #f0f;
        }
        
        .menu-btn.btn-tutorial:hover {
            background: #f0f;
            color: #000;
        }
        
        .menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }
        
        .menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
        }

        #gameCanvas {
            border-radius: 3px;
            max-width: 100%;
            height: auto;
            touch-action: none;
            /* GPU acceleration for smooth rendering */
            transform: translateZ(0);
            will-change: contents;
            /* Use auto for smoother anti-aliased ball movement */
            image-rendering: auto;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* Mobile optimizations */
        @media (max-width: 800px), (hover: none) {
            #gameCanvas {
                /* Keep canvas clean on mobile */
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                transition-duration: 0.01ms !important;
            }
        }

        /* ========== UNIFIED TRACKPAD ZONE ========== */
        /* Order: power-up timers ‚Üí spacer ‚Üí instructions ‚Üí permanent upgrades */
        .trackpad-zone {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            height: 180px;
            min-height: 180px;
            padding: 10px 16px 12px;
            box-sizing: border-box;
            flex-shrink: 0;
            /* Touch control */
            touch-action: none;
            pointer-events: auto;
            /* Visual styling */
            border-top: 1px solid rgba(0, 255, 255, 0.15);
            background: linear-gradient(to bottom, rgba(0, 255, 255, 0.06), transparent);
            border-radius: 0 0 2px 2px;
        }
        
        /* Permanent upgrades display - anchored just below divider line */
        .permanent-upgrades {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            gap: 10px;
            width: 100%;
            pointer-events: none;
            /* Horizontal divider line above */
            border-top: 1px solid rgba(0, 255, 255, 0.4);
            padding-top: 2px;
            margin-top: 8px; /* Fixed spacing - ensures visibility in compact modes */
        }
        
        .perm-upgrade {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 32px;
            height: 32px;
        }
        
        .perm-icon {
            font-size: 20px;
            filter: drop-shadow(0 0 3px currentColor);
        }
        
        .perm-stack {
            position: absolute;
            bottom: -2px;
            right: -4px;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 3px #000, 0 0 3px #000;
        }
        
        /* Power-up timers container - fixed 4 rows */
        .power-up-timers {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            /* Fixed height for exactly 4 rows: 4 x 17px = 68px */
            height: 68px;
            min-height: 68px;
            max-height: 68px;
            width: 100%;
            overflow: hidden;
            pointer-events: none;
            flex-shrink: 0;
            margin-top: 2px; /* Nudge down relative to cyan bar */
        }
        
        .power-up-timers span {
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            /* Each row exactly 17px */
            height: 17px;
            min-height: 17px;
            max-height: 17px;
            line-height: 17px;
            font-size: 13px;
            padding: 0 8px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            box-sizing: border-box;
            pointer-events: none;
            flex-shrink: 0;
            /* Color set by inline styles to match brick colors */
        }
        
        /* Spacer - grows to fill remaining space for touch control */
        .trackpad-spacer {
            flex: 1;
            min-height: 20px;
            width: 100%;
            pointer-events: none;
        }
        
        /* Instructions - simple centered text above permanent upgrades */
        .trackpad-instructions {
            display: flex !important;
            visibility: visible !important;
            opacity: 0;
            align-items: center;
            justify-content: center;
            height: 24px;
            min-height: 24px;
            width: auto;
            max-width: 90%;
            font-size: 10px;
            font-family: Arial, sans-serif;
            font-weight: normal;
            color: rgba(0, 255, 255, 0.5) !important;
            letter-spacing: 1.5px;
            text-shadow: 0 0 6px rgba(0, 255, 255, 0.3);
            background: transparent;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            pointer-events: none;
            flex-shrink: 0;
            margin: 4px 0;
            position: relative;
            z-index: 10;
            transition: opacity 0.5s ease-in;
        }
        
        .trackpad-instructions.visible {
            opacity: 1;
        }
        
        .hud {
            display: flex;
            gap: 25px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px #0ff;
        }

        .hud span {
            color: #0ff;
        }

        .message {
            color: #fff;
            font-size: 11px;
            text-shadow: 0 0 5px #0ff;
            opacity: 0.7;
            text-align: center;
            padding: 2px 10px;
            margin: 0;
            position: relative;
            z-index: 100; /* Above touch zone */
            pointer-events: none; /* Allow touches through */
        }
        
        /* Mobile layout adjustments - only essential overrides */
        @media (max-width: 800px), (hover: none), (pointer: coarse) {
            .hud {
                gap: 20px;
                font-size: 14px;
            }
            .game-container {
                padding: 4px;
                gap: 3px;
                box-shadow: 0 0 10px #0ff;
            }
        }
        
        /* JS-based mobile detection - only essential overrides */
        body.is-mobile .hud {
            gap: 20px;
            font-size: 14px;
        }
        
        /* Mobile: make game nearly fill screen width */
        body.is-mobile .game-container {
            width: 96vw;
            max-width: 96vw;
            padding: 4px;
        }
        body.is-mobile #gameCanvas {
            width: 100%;
            max-width: 100%;
        }
        
        /* Mobile: compact trackpad zone */
        body.is-mobile .trackpad-zone {
            height: 130px;
            min-height: 130px;
            padding: 6px 10px 8px;
        }
        body.is-mobile .trackpad-spacer {
            min-height: 10px;
        }
        body.is-mobile .trackpad-instructions {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: 18px;
            min-height: 18px;
            font-size: 7px;
            letter-spacing: 0.5px;
            color: rgba(0, 255, 255, 0.6) !important;
            position: relative;
            z-index: 10;
        }
        body.is-mobile .permanent-upgrades {
            gap: 8px;
            padding-top: 6px;
        }
        
        /* Mobile: 3 powerup timer rows, smaller text */
        body.is-mobile .power-up-timers {
            /* 3 rows x 15px = 45px */
            height: 45px;
            min-height: 45px;
            max-height: 45px;
        }
        body.is-mobile .power-up-timers span {
            font-size: 12px;
            height: 15px;
            min-height: 15px;
            max-height: 15px;
            line-height: 15px;
            padding: 0 6px;
            color: #ffffff;
        }
        
        /* Desktop: larger HUD and powerup text */
        body.is-desktop .hud {
            font-size: 20px;
            gap: 30px;
        }
        body.is-desktop .power-up-timers span {
            font-size: 17px;
            height: 21px;
            min-height: 21px;
            max-height: 21px;
            line-height: 21px;
        }
        body.is-desktop .power-up-timers {
            /* 4 rows x 21px = 84px */
            height: 84px;
            min-height: 84px;
            max-height: 84px;
        }
        
        /* ========== UPGRADE SELECTOR OVERLAY ========== */
        .upgrade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500; /* Above all other elements */
            font-family: Arial, sans-serif;
            /* Allow touch interactions */
            touch-action: manipulation;
            pointer-events: none; /* Don't block touches when hidden */
        }
        
        .upgrade-overlay.active {
            display: flex;
            pointer-events: auto; /* Enable touches when visible */
        }
        
        .upgrade-title {
            font-size: 26px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
            margin-bottom: 6px;
            animation: titlePulse 1.5s ease-in-out infinite;
        }
        
        .upgrade-subtitle {
            font-size: 13px;
            color: #888;
            margin-bottom: 15px;
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff; }
            50% { text-shadow: 0 0 30px #0ff, 0 0 60px #0ff, 0 0 80px #f0f; }
        }
        
        .upgrade-slots {
            display: flex;
            gap: 12px;
            /* Removed perspective - causes mobile GPU issues */
        }
        
        .upgrade-slot {
            width: 120px;
            height: 155px;
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 2px solid #333;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.3);
            /* Mobile touch improvements */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .upgrade-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.05), transparent);
            animation: slotShine 4s ease-in-out infinite;
            animation-play-state: paused; /* Paused by default */
        }
        
        /* Only animate when overlay is active */
        .upgrade-overlay.active .upgrade-slot::before {
            animation-play-state: running;
        }
        
        @keyframes slotShine {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(300%); }
        }
        
        .upgrade-slot.rolling {
            pointer-events: none;
        }
        
        /* Simple opacity pulse instead of heavy transform animation */
        .upgrade-slot.rolling .upgrade-content {
            animation: slotRoll 0.3s ease-in-out infinite;
        }
        
        @keyframes slotRoll {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .upgrade-slot.revealed {
            border-color: #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            cursor: pointer;
        }
        
        .upgrade-slot.revealed:hover {
            transform: translateY(-8px) scale(1.05);
            border-color: #f0f;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.6), 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        
        /* Touch/active state for mobile */
        .upgrade-slot.revealed:active {
            transform: scale(0.95);
            border-color: #0f0;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
        }
        
        .upgrade-slot.selected {
            border-color: #0f0;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.8);
            transform: scale(1.08);
        }
        
        .upgrade-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 10px;
            z-index: 1;
        }
        
        .upgrade-icon {
            font-size: 34px;
            margin-bottom: 8px;
            filter: drop-shadow(0 0 8px currentColor);
        }
        
        .upgrade-name {
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 6px;
            line-height: 1.2;
        }
        
        .upgrade-desc {
            font-size: 11px;
            color: #0ff;
            opacity: 0.9;
        }
        
        .upgrade-slot[data-type="paddle"] .upgrade-icon { color: #0ff; }
        .upgrade-slot[data-type="speed"] .upgrade-icon { color: #00ff88; }
        .upgrade-slot[data-type="crusher"] .upgrade-icon { color: #ff6600; }
        .upgrade-slot[data-type="bigpaddle"] .upgrade-icon { color: #f0f; }
        .upgrade-slot[data-type="powerup"] .upgrade-icon { color: #ffcc00; }
        
        /* Legendary upgrade colors */
        .upgrade-slot[data-type="extralives"] .upgrade-icon { color: #ff3366; }
        .upgrade-slot[data-type="bossdamage"] .upgrade-icon { color: #ff4400; }
        .upgrade-slot[data-type="dualball"] .upgrade-icon { color: #ffcc00; }
        .upgrade-slot[data-type="magnetpaddle"] .upgrade-icon { color: #00ffcc; }
        
        /* Legendary title - hidden by default */
        .legendary-title {
            display: none;
            font-size: 16px;
            font-weight: bold;
            color: #ffcc00;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 4px;
            text-shadow: 0 0 15px #ffcc00, 0 0 30px #ffcc00;
            animation: legendaryPulse 1.2s ease-in-out infinite;
        }
        
        @keyframes legendaryPulse {
            0%, 100% { text-shadow: 0 0 15px #ffcc00, 0 0 30px #ffcc00; opacity: 1; }
            50% { text-shadow: 0 0 25px #ffcc00, 0 0 50px #ffcc00, 0 0 70px #ff8800; opacity: 0.9; }
        }
        
        /* Legendary overlay styling */
        .upgrade-overlay.legendary {
            background: radial-gradient(ellipse at center, rgba(255, 204, 0, 0.15) 0%, rgba(0, 0, 0, 0.95) 70%);
        }
        
        .upgrade-overlay.legendary .legendary-title {
            display: block;
        }
        
        .upgrade-overlay.legendary .upgrade-title {
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00, 0 0 40px #ff8800;
        }
        
        .upgrade-overlay.legendary .upgrade-subtitle {
            color: #cc9900;
        }
        
        /* Legendary slot styling */
        .upgrade-slot.legendary {
            border-color: #ffcc00;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.5), inset 0 0 15px rgba(255, 204, 0, 0.1);
        }
        
        .upgrade-slot.legendary.revealed {
            border-color: #ffcc00;
            box-shadow: 0 0 35px rgba(255, 204, 0, 0.6), inset 0 0 20px rgba(255, 204, 0, 0.15);
        }
        
        .upgrade-slot.legendary.revealed:hover {
            border-color: #fff;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.7), 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        
        .upgrade-slot.legendary.selected {
            border-color: #00ff88;
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.9);
        }
        
        @media (max-width: 500px) {
            .upgrade-slots { gap: 8px; }
            .upgrade-slot { width: 90px; height: 125px; border-width: 2px; }
            .upgrade-content { padding: 8px; }
            .upgrade-icon { font-size: 25px; margin-bottom: 6px; }
            .upgrade-name { font-size: 10px; margin-bottom: 4px; }
            .upgrade-desc { font-size: 9px; }
            .upgrade-title { font-size: 19px; margin-bottom: 4px; }
            .upgrade-subtitle { font-size: 10px; margin-bottom: 10px; }
            .legendary-title { font-size: 12px; letter-spacing: 2px; margin-bottom: 2px; }
            
            /* Mobile: disable shine animation entirely */
            .upgrade-slot::before {
                display: none;
            }
            
            /* Mobile: static opacity instead of animation */
            .upgrade-slot.rolling .upgrade-content {
                animation: none;
                opacity: 0.85;
            }
        }
        
        /* ========== SCORE SUBMISSION MODAL ========== */
        .score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-title {
            font-size: 38px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00, 0 0 40px #ff6600;
            text-align: center;
            margin-bottom: 0;
        }
        
        .score-modal-score {
            font-size: 26px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            text-align: center;
            margin-top: -4px;
        }
        
        .score-modal-level {
            font-size: 16px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-top: -8px;
        }
        
        .score-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        
        .score-input-label {
            font-size: 14px;
            color: #fff;
            opacity: 0.9;
        }
        
        .score-input {
            width: 200px;
            padding: 10px 14px;
            font-size: 16px;
            font-family: inherit;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            /* Allow text selection and input on mobile */
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }
        
        .score-input:focus {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-input.error {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.15);
            animation: inputShake 0.4s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }
        
        .score-error-msg {
            font-size: 12px;
            color: #ff3366;
            text-shadow: 0 0 8px #ff3366;
            min-height: 16px;
            text-align: center;
        }
        
        .score-buttons {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }
        
        .score-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .score-btn:active {
            transform: scale(0.98);
        }
        
        .score-btn-submit {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 255, 0.2));
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .score-btn-submit:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }
        
        .score-btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .score-btn-skip {
            background: rgba(255, 255, 255, 0.05);
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #aaa;
        }
        
        /* ========== LEADERBOARD OVERLAY ========== */
        .leaderboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            /* Allow touch interactions */
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .leaderboard-title {
            font-size: 32px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00, 0 0 40px #ff6600;
        }
        
        .leaderboard-close {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Mobile touch improvements */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            z-index: 10;
        }
        
        .leaderboard-close:hover {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        .leaderboard-close:active {
            transform: scale(0.95);
            border-color: #0ff;
            color: #0ff;
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            touch-action: pan-y; /* Allow vertical scroll only */
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 10px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 4px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .leaderboard-row.top-3 {
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.15), rgba(255, 102, 0, 0.1));
            border: 1px solid rgba(255, 204, 0, 0.3);
        }
        
        .leaderboard-row.highlight {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.15));
            border: 1px solid rgba(0, 255, 255, 0.5);
        }
        
        .leaderboard-rank {
            width: 40px;
            font-size: 16px;
            font-weight: bold;
            color: #888;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            color: #ffcc00;
            text-shadow: 0 0 8px #ffcc00;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .leaderboard-score {
            font-size: 16px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            min-width: 70px;
            text-align: right;
        }
        
        .leaderboard-level {
            font-size: 12px;
            color: #00ff88;
            min-width: 50px;
            text-align: right;
            opacity: 0.8;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 16px;
        }
        
        .leaderboard-loading {
            color: #0ff;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
        
        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2100;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .tutorial-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 255, 0.4);
            opacity: 0;
            pointer-events: none;
        }
        
        .tutorial-overlay.active::before {
            animation: flashFadeOut 0.5s ease-out forwards;
        }
        
        @keyframes flashFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .tutorial-overlay.active {
            display: flex;
        }
        
        .tutorial-container {
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(10, 10, 30, 0.98));
            border: 2px solid #0ff;
            border-radius: 15px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            opacity: 0;
            transform: translateY(30px) scale(0.95);
        }
        
        .tutorial-overlay.active .tutorial-container {
            animation: tutorialContainerEnter 0.5s ease-out 0.1s forwards;
        }
        
        @keyframes tutorialContainerEnter {
            0% { opacity: 0; transform: translateY(30px) scale(0.95); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-title {
            font-size: 24px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            letter-spacing: 2px;
        }
        
        .tutorial-close {
            background: transparent;
            border: 2px solid #ff6666;
            color: #ff6666;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s, color 0.2s;
        }
        
        .tutorial-close:hover {
            background: #ff6666;
            color: #fff;
        }
        
        .tutorial-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .tutorial-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .tutorial-content::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 3px;
        }
        
        .tutorial-step {
            display: none;
            animation: tutorialFadeIn 0.3s ease-out;
        }
        
        .tutorial-step.active {
            display: block;
        }
        
        @keyframes tutorialFadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .tutorial-step-title {
            font-size: 20px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .tutorial-step-content {
            color: #ddd;
            font-size: 14px;
            line-height: 1.7;
        }
        
        .tutorial-step-content p {
            margin-bottom: 12px;
        }
        
        .tutorial-step-content ul {
            margin: 10px 0 15px 20px;
            list-style: none;
        }
        
        .tutorial-step-content ul li {
            margin-bottom: 8px;
            position: relative;
            padding-left: 5px;
        }
        
        .tutorial-step-content ul li::before {
            content: '‚ñ∏';
            color: #0ff;
            position: absolute;
            left: -15px;
        }
        
        .tutorial-step-content .key {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            color: #0ff;
        }
        
        .tutorial-step-content .highlight {
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .tutorial-step-content .highlight.powerup { background: rgba(255, 0, 255, 0.2); color: #f0f; }
        .tutorial-step-content .highlight.debuff { background: rgba(255, 68, 68, 0.2); color: #ff4444; }
        .tutorial-step-content .highlight.upgrade { background: rgba(255, 204, 0, 0.2); color: #ffcc00; }
        .tutorial-step-content .highlight.boss { background: rgba(255, 100, 100, 0.2); color: #ff6464; }
        .tutorial-step-content .highlight.paddle { background: rgba(0, 255, 255, 0.2); color: #0ff; }
        
        .tutorial-step-content .tip {
            background: rgba(255, 255, 0, 0.1);
            border-left: 3px solid #ffff00;
            padding: 8px 12px;
            margin-top: 15px;
            font-style: italic;
            color: #ffff99;
        }
        
        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-nav-btn {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tutorial-nav-btn:hover {
            background: rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tutorial-dots {
            display: flex;
            gap: 8px;
        }
        
        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 1px solid #0ff;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-dot.active {
            background: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        
        .tutorial-dot:hover {
            background: rgba(0, 255, 255, 0.6);
        }
        
        /* Mobile tutorial sizing */
        @media (max-width: 500px) {
            .tutorial-container {
                padding: 15px;
                max-height: 90vh;
            }
            .tutorial-title {
                font-size: 18px;
            }
            .tutorial-step-title {
                font-size: 16px;
            }
            .tutorial-step-content {
                font-size: 13px;
                line-height: 1.6;
            }
            .tutorial-step-content ul {
                margin-left: 15px;
            }
            .tutorial-nav-btn {
                padding: 8px 14px;
                font-size: 12px;
            }
            .tutorial-close {
                width: 30px;
                height: 30px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 500px) {
            .score-modal-title { font-size: 32px; }
            .score-modal-score { font-size: 22px; }
            .score-input { width: 180px; font-size: 16px; }
            .score-btn { padding: 10px 20px; font-size: 14px; }
            .leaderboard-title { font-size: 26px; }
            .leaderboard-row { padding: 8px 10px; }
            .leaderboard-name { font-size: 13px; }
            .leaderboard-score { font-size: 14px; min-width: 60px; }
            .leaderboard-level { font-size: 11px; min-width: 40px; }
        }
    </style>
</head>
<body>
    <!-- Main Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay">
        <div class="game-title">BOO BRICKBREAKER</div>
        <div class="game-subtitle">Arcade Roguelite</div>
        <div class="menu-buttons">
            <button class="menu-btn" id="menuStartBtn">START GAME</button>
            <button class="menu-btn btn-tutorial" id="menuTutorialBtn">HOW TO PLAY</button>
            <button class="menu-btn btn-leaderboard" id="menuLeaderboardBtn">LEADER BOARD</button>
        </div>
    </div>

    <div class="game-container">
        <div class="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
        </div>
        <canvas id="gameCanvas" width="653" height="515"></canvas>
        
        <!-- Unified trackpad zone: power-up timers at top, instructions + permanent upgrades at bottom -->
        <div class="trackpad-zone" id="trackpadZone">
            <div class="power-up-timers" id="powerUpBar"></div>
            <div class="trackpad-spacer"></div>
            <div class="trackpad-instructions" id="trackpadInstructions">
                ‚Üê ARROW KEYS, MOUSE OR TOUCH TO MOVE ‚Üí
            </div>
            <div class="permanent-upgrades" id="permanentUpgradesBar"></div>
        </div>
        
        <!-- Upgrade Selector Overlay -->
        <div class="upgrade-overlay" id="upgradeOverlay">
            <div class="legendary-title">‚ú¶ LEGENDARY UPGRADE ‚ú¶</div>
            <div class="upgrade-title">LEVEL UP!</div>
            <div class="upgrade-subtitle">Choose an upgrade</div>
            <div class="upgrade-slots" id="upgradeSlots">
                <div class="upgrade-slot" id="slot1">
                    <div class="upgrade-content">
                        <div class="upgrade-icon">?</div>
                        <div class="upgrade-name">???</div>
                        <div class="upgrade-desc">???</div>
                    </div>
                </div>
                <div class="upgrade-slot" id="slot2">
                    <div class="upgrade-content">
                        <div class="upgrade-icon">?</div>
                        <div class="upgrade-name">???</div>
                        <div class="upgrade-desc">???</div>
                    </div>
                </div>
                <div class="upgrade-slot" id="slot3">
                    <div class="upgrade-content">
                        <div class="upgrade-icon">?</div>
                        <div class="upgrade-name">???</div>
                        <div class="upgrade-desc">???</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Score Submission Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-title" id="scoreModalTitle">HIGH SCORE</div>
        <div class="score-modal-score">Score: <span id="finalScoreDisplay">0</span></div>
        <div class="score-modal-level">Level <span id="finalLevelDisplay">1</span></div>
        <div class="score-input-container">
            <label class="score-input-label">Enter your name for the leaderboard:</label>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME" autocomplete="off" spellcheck="false">
            <div class="score-error-msg" id="scoreErrorMsg"></div>
        </div>
        <div class="score-buttons">
            <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
        </div>
    </div>
    
    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-container">
            <div class="tutorial-header">
                <div class="tutorial-title">üìñ HOW TO PLAY</div>
                <button class="tutorial-close" id="tutorialClose">‚úï</button>
            </div>
            <div class="tutorial-content" id="tutorialContent">
                <!-- Step 1: Controls -->
                <div class="tutorial-step" data-step="1">
                    <div class="tutorial-step-title">üéÆ CONTROLS</div>
                    <div class="tutorial-step-content">
                        <p><strong>Mobile:</strong> Tap and drag anywhere in the control zone below the game to move the paddle.</p>
                        <p><strong>Desktop:</strong> Use <span class="key">‚Üê ‚Üí</span> arrow keys or move your mouse to control the paddle.</p>
                        <p>Keep the ball in play by bouncing it off your <span class="highlight paddle">paddle</span>!</p>
                    </div>
                </div>
                
                <!-- Step 2: Power-Ups -->
                <div class="tutorial-step" data-step="2">
                    <div class="tutorial-step-title">‚ö° POWER-UPS</div>
                    <div class="tutorial-step-content">
                        <p>Break bricks to reveal <span class="highlight powerup">power-ups</span>! Catch them with your paddle:</p>
                        <ul>
                            <li>‚ö° <strong>Crusher</strong> - Ball smashes through bricks without bouncing</li>
                            <li>‚ú¶ <strong>Multi Ball</strong> - Splits into multiple balls</li>
                            <li>‚Üî <strong>Big Paddle</strong> - Wider paddle for easier catches</li>
                        </ul>
                        <p class="tip">üí° Power-ups stack! Grab multiple for stronger effects.</p>
                    </div>
                </div>
                
                <!-- Step 3: Debuffs -->
                <div class="tutorial-step" data-step="3">
                    <div class="tutorial-step-title">‚ö†Ô∏è DEBUFFS</div>
                    <div class="tutorial-step-content">
                        <p>Watch out for <span class="highlight debuff">debuffs</span> that make the game harder:</p>
                        <ul>
                            <li>‚ò† <strong>Small Paddle</strong> - Shrinks your paddle, making catches harder</li>
                        </ul>
                        <p>Debuff bricks have a <span class="highlight debuff">red border</span> - avoid them if you can, or survive until they wear off!</p>
                    </div>
                </div>
                
                <!-- Step 4: Upgrades -->
                <div class="tutorial-step" data-step="4">
                    <div class="tutorial-step-title">‚¨ÜÔ∏è UPGRADES</div>
                    <div class="tutorial-step-content">
                        <p>Clearing levels earns you <span class="highlight upgrade">permanent upgrades</span>!</p>
                        <p>Choose from 3 random options when you level up:</p>
                        <ul>
                            <li>Larger Paddle - Permanent size bonus</li>
                            <li>Slower Ball - Permanent speed reduction</li>
                            <li>Power-up duration boosts</li>
                            <li>Lucky Drops - More power-up spawns</li>
                            <li>Multi-Ball+ - Extra balls per split</li>
                        </ul>
                        <p class="tip">üí° Every 5 levels, earn an extra life and a <span class="highlight upgrade">legendary upgrade</span>!</p>
                    </div>
                </div>
                
                <!-- Step 5: Bosses -->
                <div class="tutorial-step" data-step="5">
                    <div class="tutorial-step-title">üëπ BOSSES</div>
                    <div class="tutorial-step-content">
                        <p>Every few levels, <span class="highlight boss">bosses</span> appear!</p>
                        <p>Bosses are large targets that:</p>
                        <ul>
                            <li>Move side to side</li>
                            <li>Fire lasers at your paddle</li>
                            <li>Take multiple hits to defeat</li>
                        </ul>
                        <p>Defeat them to earn bonus points and a <strong>legendary upgrade</strong>!</p>
                        <p class="tip">üí° Look for the ‚≠ê immunity star during boss fights!</p>
                    </div>
                </div>
            </div>
            <div class="tutorial-nav">
                <button class="tutorial-nav-btn" id="tutorialPrev">‚Üê PREV</button>
                <div class="tutorial-dots" id="tutorialDots"></div>
                <button class="tutorial-nav-btn" id="tutorialNext">NEXT ‚Üí</button>
            </div>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title">üèÜ TOP 100</div>
                <button class="leaderboard-close" id="leaderboardClose">‚úï</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <div class="leaderboard-loading">Loading scores...</div>
            </div>
        </div>
    </div>

    <script>
        // RELIABLE DEVICE DETECTION - Uses multiple signals for accuracy
        // Works correctly even inside iframes
        const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
        const hasHover = window.matchMedia('(hover: hover)').matches;
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isSmallScreen = screen.width < 800;
        const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Desktop: has hover capability AND no coarse pointer, OR large screen without mobile UA
        const isTrueDesktop = (hasHover && !hasCoarsePointer) || (!isSmallScreen && !isMobileUA && !hasTouchScreen);
        const isTrueMobile = !isTrueDesktop;
        
        (function() {
            if (isTrueDesktop) {
                document.body.classList.add('is-desktop');
            } else {
                document.body.classList.add('is-mobile');
            }
        })();
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true }); // Optimization: disable alpha, enable desync for lower latency
        
        // Enable anti-aliasing for smoother ball rendering
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        const startBtn = document.getElementById('menuStartBtn');
        const leaderboardBtn = document.getElementById('menuLeaderboardBtn');
        const tutorialBtn = document.getElementById('menuTutorialBtn');
        const menuOverlay = document.getElementById('menuOverlay');
        const trackpadZone = document.getElementById('trackpadZone');
        const trackpadInstructionsEl = document.getElementById('trackpadInstructions');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const powerUpBarEl = document.getElementById('powerUpBar'); // Cached DOM reference
        const permanentUpgradesBarEl = document.getElementById('permanentUpgradesBar'); // Cached DOM reference

        // Base canvas dimensions (game logic coordinates)
        const BASE_WIDTH = 653;
        const BASE_HEIGHT = 515;
        
        // ========== DEBUG UTILITY ==========
        const GameDebug = {
            enabled: false, // Toggle for debugging
            el: null,
            show(data) {
                if (!this.enabled) return this.hide();
                if (!this.el) {
                    this.el = document.createElement('div');
                    this.el.id = 'game-debug';
                    this.el.style.cssText = `
                        position: fixed; top: 60px; left: 10px;
                        background: rgba(255,0,0,0.9); color: #fff;
                        padding: 8px; font: 12px monospace;
                        z-index: 99999; border-radius: 4px;
                        max-width: 300px; pointer-events: none;
                    `;
                    document.body.appendChild(this.el);
                }
                this.el.innerHTML = Object.entries(data)
                    .map(([k, v]) => `${k}: ${v}`)
                    .join('<br>');
            },
            hide() {
                if (this.el) {
                    this.el.remove();
                    this.el = null;
                }
            }
        };
        
        // ========== iOS GESTURE PREVENTION ==========
        // Prevent iOS "swipe down to exit fullscreen" gesture
        (function() {
            if (!('ontouchstart' in window)) return;
            
            let touchStartY = 0;
            const EDGE_THRESHOLD = 50; // Pixels from top edge
            
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                // If touch started near top edge and is moving down, block it
                if (touchStartY < EDGE_THRESHOLD) {
                    const currentY = e.touches[0].clientY;
                    if (currentY > touchStartY + 10) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });
        })();
        
        // ========== COMPREHENSIVE PIXEL DENSITY SCALING ==========
        // Strategy: Use ctx.scale() for sharp rendering, game logic uses gameWidth/gameHeight
        
        // Device detection - improved for iPadOS 13+ which reports as Macintosh
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isIPad = /iPad/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
                      (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
        const isTablet = isTouchDevice && (isIPad || Math.min(window.screen.width, window.screen.height) >= 600);
        const isLaptopOrDesktop = !isTouchDevice || window.innerWidth > 1024;
        const rawDPR = window.devicePixelRatio || 1;
        
        // iOS canvas memory limit: 16,777,216 pixels max (approx 4096x4096)
        const MAX_CANVAS_PIXELS = 16777216;
        
        // Performance-based DPR limits
        const isLowPerfDevice = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : isTouchDevice;
        const maxNormalDPR = isLowPerfDevice ? 1.5 : 2;
        const maxFullscreenDPR = isLowPerfDevice ? 2 : 3;
        
        // Scaling state - game logic ALWAYS uses gameWidth/gameHeight
        let dprScale = 1;
        let gameWidth = BASE_WIDTH;   // Logical game coordinates
        let gameHeight = BASE_HEIGHT;
        let cssWidth = BASE_WIDTH;    // CSS display size
        let cssHeight = BASE_HEIGHT;
        
        // Get accurate viewport size (works better in iframes)
        function getViewportSize() {
            if (window.visualViewport) {
                return {
                    width: window.visualViewport.width,
                    height: window.visualViewport.height
                };
            }
            return {
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        
        function calculateScale() {
            const isNativeFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            const isInIframe = window.self !== window.top;
            
            const viewport = getViewportSize();
            const viewW = viewport.width;
            const viewH = viewport.height;
            
            const isPseudoFullscreen = !isNativeFullscreen && 
                                       (isInIframe || viewW > BASE_WIDTH * 1.15 || viewH > BASE_HEIGHT * 1.15);
            
            const isFullscreen = isNativeFullscreen || isPseudoFullscreen;
            const gameContainer = document.querySelector('.game-container');
            
            // Game logic always uses base coordinates
            gameWidth = BASE_WIDTH;
            gameHeight = BASE_HEIGHT;
            
            const gameAspect = BASE_WIDTH / BASE_HEIGHT;
            
            if (isFullscreen) {
                gameContainer.classList.add('fullscreen-mode');
                document.body.classList.add('fullscreen-active');
                
                // Universal margin system: border + safety padding
                // iPad needs extra margin for status bar, home indicator, and close buttons
                const borderWidth = isInIframe ? 0 : 3;
                const safetyPadding = (isTablet || isIPad) ? 20 : (isInIframe ? 5 : 0);
                const totalMargin = (borderWidth + safetyPadding) * 2;
                
                const availWidth = viewW - totalMargin;
                const availHeight = viewH - totalMargin;
                const screenAspect = availWidth / availHeight;
                
                // Fit game to available space, preserving aspect ratio
                if (screenAspect > gameAspect) {
                    // Screen wider than game: height-constrained
                    cssHeight = Math.floor(availHeight);
                    cssWidth = Math.floor(cssHeight * gameAspect);
                } else {
                    // Screen taller than game: width-constrained  
                    cssWidth = Math.floor(availWidth);
                    cssHeight = Math.floor(cssWidth / gameAspect);
                }
                
                // Determine optimal buffer scale based on device
                let bufferScale;
                if (isTablet || isIPad) {
                    bufferScale = 2; // Fixed 2x for tablets
                } else {
                    // Desktop: scale based on CSS size vs base size, capped by DPR
                    const displayScale = cssWidth / BASE_WIDTH;
                    bufferScale = Math.min(displayScale * rawDPR, maxFullscreenDPR);
                }
                
                // iOS canvas memory safety check
                let bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                let bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    bufferScale *= scaleFactor;
                    bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                    bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = cssWidth + 'px';
                canvas.style.height = cssHeight + 'px';
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(bufferScale, bufferScale);
                dprScale = bufferScale;
                
                // Debug overlay (toggle with GameDebug.enabled)
                GameDebug.show({
                    viewport: `${viewW}√ó${viewH}`,
                    avail: `${Math.round(availWidth)}√ó${Math.round(availHeight)}`,
                    css: `${cssWidth}√ó${cssHeight}`,
                    buffer: `${bufferWidth}√ó${bufferHeight}`,
                    iframe: isInIframe ? 'YES' : 'NO',
                    device: isTablet ? 'tablet' : (isIPad ? 'iPad' : 'desktop')
                });
            } else {
                // Normal non-fullscreen mode
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
                cssWidth = BASE_WIDTH;
                cssHeight = BASE_HEIGHT;
                
                const isMobile = viewW <= 768;
                if (isMobile) {
                    dprScale = Math.min(rawDPR, 1.5);
                } else if (isTablet || isLaptopOrDesktop) {
                    dprScale = Math.min(rawDPR, maxNormalDPR);
                } else {
                    dprScale = 1;
                }
                
                let bufferWidth = Math.round(gameWidth * dprScale);
                let bufferHeight = Math.round(gameHeight * dprScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    dprScale *= scaleFactor;
                    bufferWidth = Math.round(gameWidth * dprScale);
                    bufferHeight = Math.round(gameHeight * dprScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = cssWidth + 'px';
                canvas.style.height = cssHeight + 'px';
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dprScale, dprScale);
                
                // Hide debug in non-fullscreen
                GameDebug.hide();
            }
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        
        function handleFullscreenChange() {
            calculateScale();
        }
        
        function handleResize() {
            calculateScale();
        }
        
        // Listen for fullscreen changes (all browser variants)
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Listen for resize/orientation changes
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => setTimeout(handleResize, 100));
        
        // Use visualViewport resize event if available (better for iframes)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', handleResize);
            window.visualViewport.addEventListener('scroll', handleResize);
        }
        
        // Re-check size after delays for iframe loading
        setTimeout(handleResize, 100);
        setTimeout(handleResize, 300);
        
        // Initial scale calculation
        calculateScale();

        // Performance detection
        const isMobile = isTrueMobile; // Use unified detection
        const isLowPower = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : isMobile;
        const isVeryLowPower = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 2 : false;
        
        // Shadow blur values (tiered based on device capability)
        const shadowSettings = isVeryLowPower ? {
            // Very low power: no shadows at all
            paddle: 0,
            ball: 0,
            brick: 0,
            brickPowerUp: 0,
            brickPowerUpMax: 0,
            boss: 0
        } : isMobile ? {
            // Mobile: minimal shadows
            paddle: 0,
            ball: 0,
            brick: 0,
            brickPowerUp: 3,
            brickPowerUpMax: 6,
            boss: 10
        } : {
            // Desktop: reduced shadows
            paddle: 12,
            ball: 10,
            brick: 5,
            brickPowerUp: 8,
            brickPowerUpMax: 15,
            boss: 20
        };

        // Game state
        let gameRunning = false;
        let gameHasStarted = false; // Tracks if game has ever been started (hides paddle/ball until first start)
        let score = 0;
        let lives = 3;
        let level = 1;
        
        // Life loss pause state
        let lifeLostPause = false;
        let lifeLostPauseEnd = 0;
        
        // Boss phase transition pause states
        let bossSpawnPause = false;
        let bossSpawnPauseEnd = 0;
        let levelTransitionPause = false;
        let levelTransitionPauseEnd = 0;
        let extraLifePause = false;
        let extraLifePauseEnd = 0;
        
        // Stage clear pending - freezes ball immediately when bricks/bosses cleared
        let stageClearPending = false;
        
        // Upgrade selection state
        let upgradeSelectionActive = false;
        let currentUpgradeChoices = [];
        let preBossUpgrade = false; // True when showing upgrade after bricks cleared (before boss)
        
        // Permanent upgrades (persist across levels, reset on new game)
        let permanentUpgrades = {
            paddleSizeBonus: 0,      // Percentage bonus to paddle size
            speedReduction: 0,       // Percentage reduction to ball speed
            crusherDurationBonus: 0, // Extra seconds for crusher
            bigPaddleDurationBonus: 0, // Extra seconds for big paddle
            powerupSpawnBonus: 0,    // Bonus to powerup spawn chance (increases max powerups)
            multiBallBounceBonus: 0, // Extra bounces for multiball
            // Legendary upgrades
            bossDamageBonus: 0,      // Extra damage per hit to bosses
            dualBallStart: 0,        // Start each round with extra balls (staggered)
            magnetPaddle: false      // Ball catches on paddle, release with tap/click
        };
        
        // Upgrade definitions
        const upgradeDefinitions = [
            {
                id: 'paddle',
                name: 'Larger Paddle',
                desc: '+10% Permanent Paddle Size Bonus',
                icon: 'üèì',
                apply: () => { permanentUpgrades.paddleSizeBonus += 10; }
            },
            {
                id: 'speed',
                name: 'Slower Ball',
                desc: '-8% Permanent Ball Speed Reduction',
                icon: 'üê¢',
                apply: () => { permanentUpgrades.speedReduction += 8; }
            },
            {
                id: 'crusher',
                name: 'Crusher+',
                desc: '+3s Crusher Powerup Duration',
                icon: 'üí•',
                apply: () => { permanentUpgrades.crusherDurationBonus += 3; }
            },
            {
                id: 'bigpaddle',
                name: 'Huge Paddle+',
                desc: 'Huge Paddle duration+',
                icon: 'üìè',
                apply: () => { permanentUpgrades.bigPaddleDurationBonus += 8; }
            },
            {
                id: 'powerup',
                name: 'Lucky Drops',
                desc: '+50% Extra Powerup Spawn Chance',
                icon: 'üçÄ',
                apply: () => { permanentUpgrades.powerupSpawnBonus += 50; }
            },
            {
                id: 'multiball',
                name: 'Multi-Ball+',
                desc: '+1 Extra Multi-Ball',
                icon: 'üé±',
                apply: () => { permanentUpgrades.multiBallBounceBonus += 1; }
            }
        ];
        
        // Smart RNG tracking for upgrade selection
        // Tracks how many rounds since each upgrade was last offered (higher = more likely to appear)
        let upgradeOfferHistory = {};
        // Initialize history for all upgrades
        upgradeDefinitions.forEach(u => { upgradeOfferHistory[u.id] = 3; }); // Start with equal weight
        
        // Mapping upgrade IDs to their icons for permanent display
        const upgradeIcons = {
            paddle: { icon: 'üèì', color: '#0ff' },
            speed: { icon: 'üê¢', color: '#00ff88' },
            crusher: { icon: 'üí•', color: '#ff6600' },
            bigpaddle: { icon: 'üìè', color: '#f0f' },
            powerup: { icon: 'üçÄ', color: '#ffcc00' },
            multiball: { icon: 'üé±', color: '#ff66ff' },
            // Legendary upgrades
            extralives: { icon: '‚ù§Ô∏è', color: '#ff3366' },
            bossdamage: { icon: '‚öîÔ∏è', color: '#ff4400' },
            dualball: { icon: 'üåü', color: '#ffcc00' },
            magnetpaddle: { icon: 'üß≤', color: '#00ffcc' }
        };
        
        // Legendary upgrade definitions (shown at levels 5, 10, 15, etc.)
        const legendaryUpgradeDefinitions = [
            {
                id: 'extralives',
                name: 'Extra Lives',
                desc: '+2 Lives',
                icon: '‚ù§Ô∏è',
                apply: () => { 
                    lives += 2; 
                    livesEl.textContent = lives;
                }
            },
            {
                id: 'bossdamage',
                name: 'Boss Slayer',
                desc: '+1 Damage Per Hit to Bosses',
                icon: '‚öîÔ∏è',
                apply: () => { permanentUpgrades.bossDamageBonus += 1; }
            },
            {
                id: 'dualball',
                name: 'Multi-Launch',
                desc: '+1 Extra ball to launch',
                icon: 'üåü',
                apply: () => { permanentUpgrades.dualBallStart += 1; }
            },
            {
                id: 'magnetpaddle',
                name: 'Magnet Paddle',
                desc: isTrueMobile ? 'Catch every other bounce, tap to release' : 'Catch every other bounce, click to release',
                icon: 'üß≤',
                oneTimeOnly: true,
                apply: () => { permanentUpgrades.magnetPaddle = true; }
            }
        ];
        
        // Update permanent upgrades display
        function updatePermanentUpgradesDisplay() {
            const upgrades = [];
            
            // Check each upgrade type for stacks
            const paddleStacks = Math.floor(permanentUpgrades.paddleSizeBonus / 10);
            const speedStacks = Math.floor(permanentUpgrades.speedReduction / 8);
            const crusherStacks = Math.floor(permanentUpgrades.crusherDurationBonus / 3);
            const bigPaddleStacks = Math.floor(permanentUpgrades.bigPaddleDurationBonus / 8);
            const powerupStacks = Math.floor(permanentUpgrades.powerupSpawnBonus / 50);
            const multiballStacks = Math.floor(permanentUpgrades.multiBallBounceBonus / 1);
            
            // Legendary upgrades
            const bossDamageStacks = permanentUpgrades.bossDamageBonus;
            const dualBallStacks = permanentUpgrades.dualBallStart;
            const hasMagnetPaddle = permanentUpgrades.magnetPaddle;
            
            if (paddleStacks > 0) upgrades.push({ id: 'paddle', stacks: paddleStacks });
            if (speedStacks > 0) upgrades.push({ id: 'speed', stacks: speedStacks });
            if (crusherStacks > 0) upgrades.push({ id: 'crusher', stacks: crusherStacks });
            if (bigPaddleStacks > 0) upgrades.push({ id: 'bigpaddle', stacks: bigPaddleStacks });
            if (powerupStacks > 0) upgrades.push({ id: 'powerup', stacks: powerupStacks });
            if (multiballStacks > 0) upgrades.push({ id: 'multiball', stacks: multiballStacks });
            
            // Legendary upgrades (show with special styling)
            if (bossDamageStacks > 0) upgrades.push({ id: 'bossdamage', stacks: bossDamageStacks, legendary: true });
            if (dualBallStacks > 0) upgrades.push({ id: 'dualball', stacks: dualBallStacks, legendary: true });
            if (hasMagnetPaddle) upgrades.push({ id: 'magnetpaddle', stacks: 1, legendary: true });
            
            // Build HTML with squircle backgrounds
            const html = upgrades.map(u => {
                const info = upgradeIcons[u.id];
                const stackText = u.stacks > 1 ? `<span class="perm-stack">x${u.stacks}</span>` : '';
                return `<span class="perm-upgrade" style="color: ${info.color}"><span class="perm-icon">${info.icon}</span>${stackText}</span>`;
            }).join('');
            
            permanentUpgradesBarEl.innerHTML = html;
        }
        
        // Boss state
        let bossPhase = false; // True when fighting bosses
        let bosses = []; // Array of boss objects
        let bossesDropping = false; // True during drop animation
        let bossDropProgress = 0; // 0 to 1 for smooth drop
        let bossHitCooldownEnd = 0; // Global cooldown timer for boss damage
        let bossDeathParticles = []; // Particles for boss death explosions
        let bossDeathAnimationEnd = 0; // Time when last boss death animation ends
        let waitingForBossDeathAnimation = false; // True when waiting for animation before level transition
        const bossConfig = {
            width: 50,
            height: 25,
            speed: 1.3, // Boss movement speed
            speedPenaltyPerBoss: 0.20, // 20% slower per additional boss
            minSpeedMultiplier: 0.25, // Never slower than 25% speed
            dropDistance: 20,
            dropSpeed: 0.08, // How fast the drop animation plays (0-1 per frame)
            hitsRequired: 3,
            hitCooldown: 200, // Milliseconds between allowed hits
            colors: ['#ff0066', '#ff3300', '#ff00ff', '#00ffcc', '#ffcc00'], // Different colors per boss
            pointsPerHit: 30,
            pointsPerKill: 0,
            deathAnimationDuration: 800, // ms to wait for death animation
            // Laser settings
            laserCooldown: 8000, // 8 seconds per boss
            globalLaserCooldown: 8000, // 8 seconds minimum between any laser
            laserSpeed: 4, // Boss projectile speed
            laserWidth: 8,
            laserHeight: 12, // Shorter than before
            laserColor: '#ff0000'
        };
        
        // Laser state
        let bossLasers = []; // Active laser projectiles
        let lastGlobalLaserTime = 0; // Timestamp of last laser fired (any boss)
        
        // Immunity star state (boss phase pickup)
        let immunityStar = null; // { x, y, dx, dy, size } or null if not active
        let lastStarSpawnTime = 0; // Track when star was last spawned
        const starConfig = {
            spawnInterval: 5000, // 5 seconds between spawn attempts
            size: 18,
            speed: 2.5,
            color: '#ffff00' // Yellow star
        };
        let paddleImmunity = {
            active: false,
            timeLeft: 0,
            duration: 10 // 10 seconds of immunity
        };

        // Power-up state
        let activePowerUps = {
            bigPaddle: { active: false, timeLeft: 0, originalWidth: 107 },
            multiBall: { active: false, bouncesLeft: 0 },
            crusher: { active: false, timeLeft: 0 },
            smallPaddle: { active: false, timeLeft: 0, originalWidth: 107 }
        };
        let balls = []; // Array to hold multiple balls
        let magnetCaughtBall = null; // Ball caught by magnet paddle (stores ball reference and offset)
        let magnetNextCatch = true; // Toggle: true = next hit catches, false = next hit bounces
        let levelsSinceSkull = 0; // Track levels since last skull brick
        let lastLevelHadSkull = false; // Track if previous level had skull
        
        // Ball color transition state
        let ballColorTransition = {
            currentR: 255, currentG: 255, currentB: 255,
            targetR: 255, targetG: 255, targetB: 255,
            speed: 0.1 // How fast to transition (0-1)
        };
        
        // Paddle color transition state
        let paddleColorTransition = {
            currentR: 0, currentG: 255, currentB: 255, // Start cyan
            speed: 0.08 // Slightly slower than ball for smoother paddle transition
        };
        
        // Paddle border color transition (for debuff red border)
        let paddleBorderTransition = {
            currentR: 0, currentG: 255, currentB: 255, // Start cyan (no border visible)
            currentAlpha: 0, // Border starts invisible
            speed: 0.08
        };

        // Neon colors
        const neonColors = [
            '#ffaa00', // Yellow-orange (between yellow and orange)
            '#00ffff', // Cyan
            '#ff00ff', // Magenta
            '#00ffa0', // Blue-green (was pure green)
            '#bf00ff', // Neon Purple
        ];

        // Power-up types
        const powerUpTypes = [
            { type: 'bigPaddle', color: '#00cc66', symbol: '‚Üî' },
            { type: 'multiBall', color: '#ff6a00', symbol: '‚ú¶' },
            { type: 'crusher', color: '#ff0028', symbol: '‚ö°' }
        ];
        
        // Debuff types
        const debuffTypes = [
            { type: 'smallPaddle', color: '#888888', symbol: '‚ò†' }  // Grey skull brick
        ];

        // Paddle
        const paddle = {
            width: 107,
            height: 11,
            x: 267,
            y: 459,
            speed: 8,
            color: '#0ff',
            dx: 0,
            targetX: 267,
            smoothing: 0.15
        };

        // Ball template
        const ballTemplate = {
            x: 320,
            y: 447,
            radius: 7,
            speed: 5.75,
            dx: 5.75,
            dy: -5.75,
            color: '#fff'
        };

        function createBall(x, y, dx, dy, speed) {
            return {
                x: x,
                y: y,
                radius: 7,
                speed: speed || ballTemplate.speed,
                dx: dx,
                dy: dy,
                color: '#fff',
                trail: [] // Motion trail positions
            };
        }

        // Bricks - calculated for perfect centering
        // Scaled down from 780x600 to 640x492
        // 11 cols, 49px wide, 7px padding = 539 + 70 = 609, offset = (640-609)/2 ‚âà 16
        const brickConfig = {
            rows: 4,
            cols: 11,
            width: 49,
            height: 16,
            padding: 7,
            offsetTop: 41,
            offsetLeft: 16
        };

        let bricks = [];

        function createBricks() {
            bricks = [];
            const totalBricks = brickConfig.rows * brickConfig.cols;
            const cols = brickConfig.cols;
            
            // Helper to get adjacent positions (including diagonals)
            function getAdjacentPositions(pos) {
                const row = Math.floor(pos / cols);
                const col = pos % cols;
                const adjacent = [];
                
                for (let r = row - 1; r <= row + 1; r++) {
                    for (let c = col - 1; c <= col + 1; c++) {
                        if (r >= 0 && r < brickConfig.rows && c >= 0 && c < cols) {
                            adjacent.push(r * cols + c);
                        }
                    }
                }
                return adjacent;
            }
            
            // Luck protection: guarantee 2+ power-ups per level, each unique
            // Max power-ups increases by 1 every 3 levels (3 at level 1-2, 4 at level 3-5, etc.)
            const minPowerUps = 2;
            const baseMaxPowerUps = 3 + Math.floor(level / 3);
            // Base random number of powerups (within normal limits)
            let basePowerUps = Math.floor(Math.random() * (baseMaxPowerUps - minPowerUps + 1)) + minPowerUps;
            
            // Lucky Drops upgrade: BONUS powerups that ignore the stage max
            // Each stack = 50% chance for +1 extra powerup (stacks independently)
            const luckyStacks = Math.floor(permanentUpgrades.powerupSpawnBonus / 50);
            let bonusPowerUps = 0;
            for (let i = 0; i < luckyStacks; i++) {
                if (Math.random() < 0.5) {
                    bonusPowerUps++;
                }
            }
            
            const numPowerUps = basePowerUps + bonusPowerUps;
            
            // Pick power-up types - allow duplicates if bonus pushes us over available types
            const selectedPowerUps = [];
            for (let i = 0; i < numPowerUps; i++) {
                // First pass: try to use unique types
                if (i < powerUpTypes.length) {
                    // Pick from remaining unique types
                    const availableForUnique = powerUpTypes.filter(p => 
                        !selectedPowerUps.some(s => s.type === p.type)
                    );
                    if (availableForUnique.length > 0) {
                        const idx = Math.floor(Math.random() * availableForUnique.length);
                        selectedPowerUps.push(availableForUnique[idx]);
                        continue;
                    }
                }
                // Bonus powerups or exhausted unique: pick any random type (duplicates allowed)
                const idx = Math.floor(Math.random() * powerUpTypes.length);
                selectedPowerUps.push(powerUpTypes[idx]);
            }
            
            // Pick random brick positions for power-ups with at least 1 brick separation
            // Luck protection: bottom row (closest to paddle) and top row (furthest) have reduced spawn chance
            const powerUpPositions = new Map();
            const usedPositions = new Set();
            const blockedPositions = new Set(); // Positions adjacent to power-ups
            
            // Row spawn probability multipliers (1.0 = normal, lower = less likely)
            const getRowSpawnChance = (pos) => {
                const row = Math.floor(pos / cols);
                const lastRow = brickConfig.rows - 1;
                
                if (row === lastRow) {
                    // Bottom row (closest to paddle) - 30% normal chance
                    return 0.3;
                } else if (row === 0) {
                    // Top row (furthest from paddle) - 15% normal chance
                    return 0.15;
                }
                // Middle rows - normal chance
                return 1.0;
            };
            
            for (let i = 0; i < selectedPowerUps.length; i++) {
                let pos;
                let attempts = 0;
                let validPosition = false;
                
                while (!validPosition && attempts < 100) {
                    pos = Math.floor(Math.random() * totalBricks);
                    attempts++;
                    
                    // Skip if position already used or blocked
                    if (usedPositions.has(pos) || blockedPositions.has(pos)) {
                        continue;
                    }
                    
                    // Check row-based luck protection
                    const spawnChance = getRowSpawnChance(pos);
                    if (Math.random() < spawnChance) {
                        validPosition = true;
                    }
                    // If failed row check, loop will try another position
                }
                
                if (validPosition) {
                    usedPositions.add(pos);
                    powerUpPositions.set(pos, selectedPowerUps[i]);
                    
                    // Block adjacent positions
                    getAdjacentPositions(pos).forEach(adj => blockedPositions.add(adj));
                }
            }
            
            // Skull brick logic: not on consecutive levels, but must appear within 3 levels
            // Only eligible starting at level 3
            const skullPositions = new Set();
            let addSkull = false;
            
            if (level >= 3) {
                if (lastLevelHadSkull) {
                    // Can't have skull two levels in a row
                    addSkull = false;
                } else if (levelsSinceSkull >= 2) {
                    // Must have skull if it's been 2+ levels
                    addSkull = true;
                } else {
                    // Random chance (roughly every 3 levels)
                    addSkull = Math.random() < 0.4;
                }
                
                if (addSkull) {
                    let skullPos;
                    let attempts = 0;
                    do {
                        skullPos = Math.floor(Math.random() * totalBricks);
                        attempts++;
                        if (attempts > 100) break;
                    } while (usedPositions.has(skullPos) || blockedPositions.has(skullPos));
                    
                    if (attempts <= 100) {
                        skullPositions.add(skullPos);
                        usedPositions.add(skullPos);
                    }
                    lastLevelHadSkull = true;
                    levelsSinceSkull = 0;
                } else {
                    lastLevelHadSkull = false;
                    levelsSinceSkull++;
                }
            }
            
            let brickIndex = 0;
            for (let row = 0; row < brickConfig.rows; row++) {
                bricks[row] = [];
                for (let col = 0; col < brickConfig.cols; col++) {
                    let powerUp = null;
                    let debuff = null;
                    
                    if (powerUpPositions.has(brickIndex)) {
                        powerUp = powerUpPositions.get(brickIndex);
                    } else if (skullPositions.has(brickIndex)) {
                        debuff = debuffTypes[0];
                    }
                    
                    bricks[row][col] = {
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop,
                        alive: true,
                        color: powerUp ? powerUp.color : (debuff ? debuff.color : neonColors[row % neonColors.length]),
                        powerUp: powerUp,
                        debuff: debuff,
                        twinkleOffset: Math.random() * Math.PI * 2 // For twinkle animation
                    };
                    brickIndex++;
                }
            }
        }

        // ========== BOSS SYSTEM ==========
        function createBosses() {
            bosses = [];
            bossLasers = []; // Clear any existing lasers
            const numBosses = level; // Level 1 = 1 boss, Level 2 = 2 bosses, etc.
            
            // Determine base Y position based on level thresholds
            let baseY = 50;
            if (level >= 20) {
                baseY = 110; // Third row down at level 20+
            } else if (level >= 10) {
                baseY = 80; // Second row down at level 10+
            }
            
            // Stagger initial laser cooldowns so bosses don't all fire at once
            const now = performance.now();
            
            // Initialize star spawn timer so first star appears 10s after boss phase starts
            lastStarSpawnTime = now;
            immunityStar = null;
            
            // At level 10+ and 20+, spawn from center outward
            if (level >= 10) {
                // Calculate positions starting from center and filling outward
                const centerX = gameWidth / 2;
                const bossSpacing = bossConfig.width + 20; // Boss width + gap
                const rowSpacing = bossConfig.height + 15; // Vertical gap between rows
                const maxBossesPerRow = 10; // Max bosses that fit on top row
                
                // Split bosses between rows
                const topRowCount = Math.min(numBosses, maxBossesPerRow);
                const bottomRowCount = numBosses - topRowCount;
                
                // Generate positions for top row
                const topPositions = [];
                topPositions.push(centerX - bossConfig.width / 2); // Center boss
                
                let offset = 1;
                while (topPositions.length < topRowCount) {
                    // Add right position
                    if (topPositions.length < topRowCount) {
                        const rightX = centerX + (offset * bossSpacing) - bossConfig.width / 2;
                        if (rightX + bossConfig.width <= gameWidth - 10) {
                            topPositions.push(rightX);
                        }
                    }
                    // Add left position
                    if (topPositions.length < topRowCount) {
                        const leftX = centerX - (offset * bossSpacing) - bossConfig.width / 2;
                        if (leftX >= 10) {
                            topPositions.push(leftX);
                        }
                    }
                    offset++;
                    if (offset > 20) break;
                }
                
                // Sort positions left to right
                topPositions.sort((a, b) => a - b);
                
                // Create top row bosses
                for (let i = 0; i < topPositions.length; i++) {
                    const initialCooldown = 2000 + Math.random() * 4000;
                    bosses.push({
                        x: topPositions[i],
                        y: baseY,
                        width: bossConfig.width,
                        height: bossConfig.height,
                        hits: 0,
                        alive: true,
                        direction: 1, // All bosses move together
                        color: bossConfig.colors[i % bossConfig.colors.length],
                        flashUntil: 0,
                        nextLaserTime: now + initialCooldown
                    });
                }
                
                // Generate positions for bottom row (overflow bosses)
                if (bottomRowCount > 0) {
                    const bottomPositions = [];
                    bottomPositions.push(centerX - bossConfig.width / 2);
                    
                    offset = 1;
                    while (bottomPositions.length < bottomRowCount) {
                        if (bottomPositions.length < bottomRowCount) {
                            const rightX = centerX + (offset * bossSpacing) - bossConfig.width / 2;
                            if (rightX + bossConfig.width <= gameWidth - 10) {
                                bottomPositions.push(rightX);
                            }
                        }
                        if (bottomPositions.length < bottomRowCount) {
                            const leftX = centerX - (offset * bossSpacing) - bossConfig.width / 2;
                            if (leftX >= 10) {
                                bottomPositions.push(leftX);
                            }
                        }
                        offset++;
                        if (offset > 20) break;
                    }
                    
                    bottomPositions.sort((a, b) => a - b);
                    
                    // Create bottom row bosses
                    for (let i = 0; i < bottomPositions.length; i++) {
                        const initialCooldown = 2000 + Math.random() * 4000;
                        bosses.push({
                            x: bottomPositions[i],
                            y: baseY + rowSpacing,
                            width: bossConfig.width,
                            height: bossConfig.height,
                            hits: 0,
                            alive: true,
                            direction: 1, // All bosses move together
                            color: bossConfig.colors[(topRowCount + i) % bossConfig.colors.length],
                            flashUntil: 0,
                            nextLaserTime: now + initialCooldown
                        });
                    }
                }
            } else {
                // Original evenly-spaced spawning for levels 1-9
                const spacing = gameWidth / (numBosses + 1);
                
                for (let i = 0; i < numBosses; i++) {
                    const initialCooldown = 2000 + Math.random() * 4000;
                    bosses.push({
                        x: spacing * (i + 1) - bossConfig.width / 2,
                        y: baseY,
                        width: bossConfig.width,
                        height: bossConfig.height,
                        hits: 0,
                        alive: true,
                        direction: 1,
                        color: bossConfig.colors[i % bossConfig.colors.length],
                        flashUntil: 0,
                        nextLaserTime: now + initialCooldown
                    });
                }
            }
            bossPhase = true;
        }
        
        function drawBosses() {
            if (!bossPhase) return;
            
            ctx.shadowBlur = shadowSettings.boss;
            const now = frameTime;
            
            for (let i = 0; i < bosses.length; i++) {
                const boss = bosses[i];
                if (!boss.alive) continue;
                
                // Check if boss is flashing from damage
                const isFlashing = now < boss.flashUntil;
                let displayColor = boss.color;
                
                if (isFlashing) {
                    // Rapid flash between white and original color
                    const flashPhase = Math.floor((boss.flashUntil - now) / 30) % 2;
                    displayColor = flashPhase === 0 ? '#ffffff' : boss.color;
                }
                
                // Draw boss body with glow
                ctx.beginPath();
                ctx.roundRect(boss.x, boss.y, boss.width, boss.height, 8);
                ctx.fillStyle = displayColor;
                ctx.shadowColor = isFlashing ? '#ffffff' : boss.color;
                ctx.fill();
                
                // Draw hit indicator (3 teeth showing remaining health)
                // Order: left tooth removed first, then right, then center last
                const hitsRemaining = bossConfig.hitsRequired - boss.hits;
                const dotSpacing = boss.width / 4;
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                
                // Teeth removal order: left first, right second, center last
                // At 0 hits (3 remaining): show left, right, center
                // At 1 hit (2 remaining): hide left, show right and center
                // At 2 hits (1 remaining): hide left and right, show only center
                
                // Draw center tooth (position 2) - always shown unless dead
                if (hitsRemaining >= 1) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 2, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Draw right tooth (position 3) - shown if 2+ hits remaining
                if (hitsRemaining >= 2) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 3, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Draw left tooth (position 1) - only shown if all 3 hits remaining
                if (hitsRemaining >= 3) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 1, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw menacing eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(boss.x + 15, boss.y + 10, 5, 0, Math.PI * 2);
                ctx.arc(boss.x + boss.width - 15, boss.y + 10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = shadowSettings.boss;
            }
            ctx.shadowBlur = 0;
        }
        
        function moveBosses() {
            if (!bossPhase || bosses.length === 0) return;
            
            // Calculate speed multiplier based on number of active bosses
            // Each additional boss slows all bosses by 5%
            const aliveBossCount = bosses.filter(b => b.alive).length;
            const speedMultiplier = aliveBossCount > 1 ? 1 - ((aliveBossCount - 1) * bossConfig.speedPenaltyPerBoss) : 1;
            const effectiveSpeed = bossConfig.speed * Math.max(speedMultiplier, bossConfig.minSpeedMultiplier);
            
            // If currently dropping, animate the drop
            if (bossesDropping) {
                bossDropProgress += bossConfig.dropSpeed * deltaMultiplier;
                
                if (bossDropProgress >= 1) {
                    // Drop complete
                    bossDropProgress = 0;
                    bossesDropping = false;
                    
                    // Finalize positions and flip direction
                    bosses.forEach(boss => {
                        if (!boss.alive) return;
                        boss.y = boss.targetY;
                        boss.direction *= -1;
                    });
                } else {
                    // Smooth easing for drop animation
                    const easeProgress = 1 - Math.pow(1 - bossDropProgress, 2); // Ease out quad
                    bosses.forEach(boss => {
                        if (!boss.alive) return;
                        boss.y = boss.startY + (boss.targetY - boss.startY) * easeProgress;
                    });
                }
                return; // Don't move horizontally while dropping
            }
            
            // Check if any boss needs to change direction
            let needsDrop = false;
            bosses.forEach(boss => {
                if (!boss.alive) return;
                
                // Check if boss hits edge
                if (boss.direction === 1 && boss.x + boss.width >= gameWidth - 10) {
                    needsDrop = true;
                } else if (boss.direction === -1 && boss.x <= 10) {
                    needsDrop = true;
                }
            });
            
            // Start drop animation
            if (needsDrop) {
                bossesDropping = true;
                bossDropProgress = 0;
                bosses.forEach(boss => {
                    if (!boss.alive) return;
                    boss.startY = boss.y;
                    boss.targetY = boss.y + bossConfig.dropDistance;
                });
            } else {
                // Normal horizontal movement (frame-rate independent) with speed multiplier
                bosses.forEach(boss => {
                    if (!boss.alive) return;
                    boss.x += effectiveSpeed * boss.direction * deltaMultiplier;
                });
            }
            
            // Check if bosses reached the bottom (game over condition)
            bosses.forEach(boss => {
                if (boss.alive && boss.y + boss.height >= paddle.y - 20) {
                    lives--;
                    livesEl.textContent = lives;
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        // Reset bosses to top and show life lost message
                        showLifeLostMessage();
                        resetBossPositions();
                    }
                }
            });
        }
        
        function resetBossPositions() {
            const numBosses = bosses.filter(b => b.alive).length;
            const aliveBosses = bosses.filter(b => b.alive);
            const spacing = gameWidth / (numBosses + 1);
            
            // Reset drop animation state
            bossesDropping = false;
            bossDropProgress = 0;
            
            // Clear all active lasers and reset global cooldown
            bossLasers = [];
            lastGlobalLaserTime = 0;
            
            // Reset laser cooldowns with staggered timing
            const now = performance.now();
            aliveBosses.forEach((boss, i) => {
                boss.x = spacing * (i + 1) - boss.width / 2;
                boss.y = 50;
                boss.direction = 1;
                // Stagger laser cooldowns again after reset
                boss.nextLaserTime = now + 2000 + Math.random() * 4000;
            });
        }
        
        // ========== BOSS DEATH PARTICLE SYSTEM ==========
        function createBossDeathExplosion(boss) {
            const centerX = boss.x + boss.width / 2;
            const centerY = boss.y + boss.height / 2;
            const particleCount = 30;
            const now = performance.now();
            
            // Create explosion particles
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
                const speed = 2 + Math.random() * 4;
                const size = 4 + Math.random() * 8;
                
                bossDeathParticles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: size,
                    originalSize: size,
                    color: boss.color,
                    alpha: 1,
                    createdAt: now,
                    lifetime: 600 + Math.random() * 400, // 600-1000ms
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
            
            // Create smoke puff particles (gray/white)
            const smokeCount = 15;
            for (let i = 0; i < smokeCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.5 + Math.random() * 2;
                const size = 10 + Math.random() * 15;
                
                bossDeathParticles.push({
                    x: centerX + (Math.random() - 0.5) * boss.width,
                    y: centerY + (Math.random() - 0.5) * boss.height,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1, // Slight upward drift
                    size: size,
                    originalSize: size,
                    color: '#ffffff',
                    alpha: 0.7,
                    createdAt: now,
                    lifetime: 500 + Math.random() * 500,
                    rotation: 0,
                    rotationSpeed: 0,
                    isSmoke: true
                });
            }
        }
        
        function updateBossDeathParticles() {
            const now = performance.now();
            
            bossDeathParticles = bossDeathParticles.filter(p => {
                const age = now - p.createdAt;
                if (age >= p.lifetime) return false;
                
                // Update position
                p.x += p.vx * deltaMultiplier;
                p.y += p.vy * deltaMultiplier;
                
                // Apply gravity to non-smoke particles
                if (!p.isSmoke) {
                    p.vy += 0.1 * deltaMultiplier;
                }
                
                // Slow down
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                // Update rotation
                p.rotation += p.rotationSpeed * deltaMultiplier;
                
                // Fade out and shrink
                const lifeProgress = age / p.lifetime;
                p.alpha = 1 - lifeProgress;
                p.size = p.originalSize * (1 - lifeProgress * 0.5);
                
                return true;
            });
        }
        
        function drawBossDeathParticles() {
            if (bossDeathParticles.length === 0) return;
            
            // Single pass through all particles
            ctx.shadowBlur = 0;
            
            for (let i = 0; i < bossDeathParticles.length; i++) {
                const p = bossDeathParticles[i];
                
                if (p.isSmoke) {
                    // Draw smoke as simple fading circles (no gradient - faster)
                    ctx.globalAlpha = p.alpha * 0.4;
                    ctx.fillStyle = 'rgb(180, 180, 180)';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw colored explosion particles with rotation
                    ctx.globalAlpha = p.alpha;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = p.color;
                    
                    // Manual transform instead of save/restore (faster)
                    ctx.setTransform(dprScale, 0, 0, dprScale, p.x * dprScale, p.y * dprScale);
                    ctx.rotate(p.rotation);
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    ctx.setTransform(dprScale, 0, 0, dprScale, 0, 0); // Restore scale
                    ctx.shadowBlur = 0;
                }
            }
            
            ctx.globalAlpha = 1;
        }
        
        // Boss laser system
        function updateBossLasers() {
            if (!bossPhase) return;
            
            const now = performance.now();
            
            // Edge margin - bosses won't fire if too close to screen edges
            const edgeMargin = 60;
            
            // Check if any boss can fire (respects global cooldown)
            if (now >= lastGlobalLaserTime + bossConfig.globalLaserCooldown) {
                // Get all bosses that are ready to fire AND not too close to edges
                const readyBosses = bosses.filter(b => 
                    b.alive && 
                    now >= b.nextLaserTime &&
                    b.x + b.width / 2 > edgeMargin &&
                    b.x + b.width / 2 < gameWidth - edgeMargin
                );
                
                if (readyBosses.length > 0) {
                    // Pick a random ready boss to fire (keeps player guessing)
                    const shooter = readyBosses[Math.floor(Math.random() * readyBosses.length)];
                    
                    // Fire laser from center bottom of boss
                    bossLasers.push({
                        x: shooter.x + shooter.width / 2 - bossConfig.laserWidth / 2,
                        y: shooter.y + shooter.height,
                        width: bossConfig.laserWidth,
                        height: bossConfig.laserHeight,
                        color: shooter.color // Match boss color
                    });
                    
                    // Set cooldowns
                    shooter.nextLaserTime = now + bossConfig.laserCooldown;
                    lastGlobalLaserTime = now;
                }
            }
            
            // Move lasers downward
            bossLasers = bossLasers.filter(laser => {
                laser.y += bossConfig.laserSpeed * deltaMultiplier;
                
                // Check collision with paddle
                if (laser.y + laser.height >= paddle.y &&
                    laser.y <= paddle.y + paddle.height &&
                    laser.x + laser.width >= paddle.x &&
                    laser.x <= paddle.x + paddle.width) {
                    
                    // Check for immunity - just destroy laser, no damage
                    if (paddleImmunity.active) {
                        return false; // Remove laser, no damage
                    }
                    
                    // Hit paddle - lose a life
                    lives--;
                    livesEl.textContent = lives;
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        showLifeLostMessage();
                        resetBossPositions();
                    }
                    return false; // Remove laser
                }
                
                // Remove if off screen
                return laser.y < gameHeight;
            });
        }
        
        function drawBossLasers() {
            if (bossLasers.length === 0) return;
            
            const time = performance.now() / 1000;
            
            bossLasers.forEach(laser => {
                const centerX = laser.x + laser.width / 2;
                const centerY = laser.y + laser.height / 2;
                
                // Plasma blast - pulsing energy orb with electric tendrils
                const pulseScale = 1 + Math.sin(time * 15) * 0.15;
                const baseRadius = laser.width * 1.2 * pulseScale;
                
                // Outer glow layers (multiple for depth)
                for (let i = 3; i >= 0; i--) {
                    const glowRadius = baseRadius + i * 6;
                    const alpha = 0.15 - i * 0.03;
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, glowRadius);
                    gradient.addColorStop(0, `rgba(255, 100, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(100, 200, 255, ${alpha * 0.7})`);
                    gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, glowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
                
                // Electric tendrils/arcs around the plasma
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 + Math.sin(time * 20) * 0.3})`;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8;
                
                for (let i = 0; i < 6; i++) {
                    const angle = (time * 8 + i * Math.PI / 3) % (Math.PI * 2);
                    const tendrilLength = baseRadius * (0.7 + Math.sin(time * 12 + i) * 0.25);
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    
                    // Jagged lightning path
                    let px = centerX;
                    let py = centerY;
                    const segments = 4;
                    for (let j = 1; j <= segments; j++) {
                        const progress = j / segments;
                        const targetX = centerX + Math.cos(angle) * tendrilLength * progress;
                        const targetY = centerY + Math.sin(angle) * tendrilLength * progress;
                        // Add jitter for electric effect
                        const jitter = (1 - progress) * 4;
                        px = targetX + (Math.random() - 0.5) * jitter;
                        py = targetY + (Math.random() - 0.5) * jitter;
                        ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // Main plasma core - swirling gradient
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius);
                const hueShift = (time * 60) % 360;
                coreGradient.addColorStop(0, '#ffffff');
                coreGradient.addColorStop(0.2, `hsl(${280 + hueShift * 0.1}, 100%, 70%)`);
                coreGradient.addColorStop(0.5, `hsl(${200 + hueShift * 0.1}, 100%, 50%)`);
                coreGradient.addColorStop(0.8, `hsl(${180 + hueShift * 0.1}, 100%, 40%)`);
                coreGradient.addColorStop(1, 'rgba(0, 100, 150, 0)');
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
                ctx.fillStyle = coreGradient;
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.fill();
                
                // Inner bright core
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius * 0.4);
                innerGradient.addColorStop(0, '#ffffff');
                innerGradient.addColorStop(0.5, 'rgba(200, 150, 255, 0.9)');
                innerGradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, baseRadius * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = innerGradient;
                ctx.shadowBlur = 10;
                ctx.fill();
                
                // Sparkle highlights
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 5;
                for (let i = 0; i < 3; i++) {
                    const sparkAngle = time * 10 + i * 2.1;
                    const sparkDist = baseRadius * 0.3 * (0.5 + Math.sin(time * 15 + i) * 0.5);
                    const sparkX = centerX + Math.cos(sparkAngle) * sparkDist;
                    const sparkY = centerY + Math.sin(sparkAngle) * sparkDist;
                    const sparkSize = 1.5 + Math.sin(time * 20 + i * 3) * 0.5;
                    
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.shadowBlur = 0;
        }
        
        // ========== IMMUNITY STAR SYSTEM ==========
        function updateImmunityStar() {
            if (!bossPhase) return;
            
            const now = performance.now();
            
            // Update immunity timer
            if (paddleImmunity.active) {
                paddleImmunity.timeLeft -= (frameTime - lastPowerUpTime) / 1000;
                if (paddleImmunity.timeLeft <= 0) {
                    paddleImmunity.active = false;
                    paddleImmunity.timeLeft = 0;
                    // Reset spawn timer so next star appears 10s after immunity ends
                    lastStarSpawnTime = now;
                }
            }
            
            // Spawn star if none active, immunity not active, and enough time has passed
            if (!immunityStar && !paddleImmunity.active && now - lastStarSpawnTime >= starConfig.spawnInterval) {
                // Spawn at the top, random x position, moving horizontally only
                immunityStar = {
                    x: 100 + Math.random() * (gameWidth - 200),
                    y: 25, // Fixed at top of screen
                    dx: (Math.random() > 0.5 ? 1 : -1) * starConfig.speed,
                    size: starConfig.size
                };
                lastStarSpawnTime = now;
            }
            
            // Update star movement if active - horizontal only
            if (immunityStar) {
                immunityStar.x += immunityStar.dx * deltaMultiplier;
                
                // Bounce off left and right walls only
                if (immunityStar.x - immunityStar.size < 0) {
                    immunityStar.x = immunityStar.size;
                    immunityStar.dx = Math.abs(immunityStar.dx);
                }
                if (immunityStar.x + immunityStar.size > gameWidth) {
                    immunityStar.x = gameWidth - immunityStar.size;
                    immunityStar.dx = -Math.abs(immunityStar.dx);
                }
                
                // Check collision with any ball
                for (const ball of balls) {
                    const dx = ball.x - immunityStar.x;
                    const dy = ball.y - immunityStar.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < ball.radius + immunityStar.size) {
                        // Collected! Grant immunity
                        paddleImmunity.active = true;
                        paddleImmunity.timeLeft = paddleImmunity.duration;
                        immunityStar = null;
                        break;
                    }
                }
            }
        }
        
        function drawImmunityStar() {
            if (!immunityStar) return;
            
            const time = performance.now() / 1000;
            const pulseScale = 1 + Math.sin(time * 8) * 0.15;
            const rotation = time * 2;
            
            ctx.save();
            ctx.translate(immunityStar.x, immunityStar.y);
            ctx.rotate(rotation);
            ctx.scale(pulseScale, pulseScale);
            
            // Draw 5-pointed star
            ctx.beginPath();
            const spikes = 5;
            const outerRadius = immunityStar.size;
            const innerRadius = immunityStar.size * 0.5;
            
            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI / spikes) - Math.PI / 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            
            // Glowing yellow fill
            ctx.fillStyle = starConfig.color;
            ctx.shadowColor = starConfig.color;
            ctx.shadowBlur = 20;
            ctx.fill();
            
            // White inner glow
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.fill();
            
            ctx.restore();
            ctx.shadowBlur = 0;
        }
        
        function checkBossCollisions() {
            if (!bossPhase) return;
            
            // Cache time once per frame
            const now = performance.now();
            if (now < bossHitCooldownEnd) return;
            
            // Use labeled loop for early exit after hit
            ballLoop: for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                for (let j = 0; j < bosses.length; j++) {
                    const boss = bosses[j];
                    if (!boss.alive) continue;
                    
                    // Re-check cooldown (may have been set by previous ball)
                    if (bossHitCooldownEnd > now) break ballLoop;
                    
                    // Simple rectangle collision
                    if (ball.x + ball.radius > boss.x &&
                        ball.x - ball.radius < boss.x + boss.width &&
                        ball.y + ball.radius > boss.y &&
                        ball.y - ball.radius < boss.y + boss.height) {
                        
                        // Set cooldown
                        bossHitCooldownEnd = now + bossConfig.hitCooldown;
                        
                        // Damage the boss (apply boss damage bonus)
                        const damageDealt = 1 + permanentUpgrades.bossDamageBonus;
                        boss.hits += damageDealt;
                        boss.flashUntil = now + 150; // Flash for 150ms
                        score += bossConfig.pointsPerHit * damageDealt;
                        scoreEl.textContent = score;
                        
                        // Check if boss is destroyed
                        if (boss.hits >= bossConfig.hitsRequired) {
                            boss.alive = false;
                            score += bossConfig.pointsPerKill;
                            scoreEl.textContent = score;
                            
                            // Check if this was the last boss - freeze ball IMMEDIATELY
                            if (bosses.every(b => !b.alive)) {
                                waitingForBossDeathAnimation = true;
                                stageClearPending = true; // Also freeze via this flag
                                clearActivePowerUps(); // Reset powerups when boss killed
                            }
                            
                            // Create death explosion AFTER setting freeze flag
                            createBossDeathExplosion(boss);
                            bossDeathAnimationEnd = now + bossConfig.deathAnimationDuration;
                            
                            // If ball is now frozen, don't bounce - exit immediately
                            if (waitingForBossDeathAnimation) {
                                break ballLoop;
                            }
                        }
                        
                        // Bounce the ball (only if not frozen)
                        ball.dy = Math.abs(ball.dy); // Always bounce down
                        
                        // Exit after processing one hit per frame
                        break ballLoop;
                    }
                }
            }
        }

        function drawPaddle() {
            // Determine target paddle color based on active power-ups
            let targetR = 0, targetG = 255, targetB = 255; // Default cyan
            let targetBorderR = 0, targetBorderG = 255, targetBorderB = 255;
            let targetBorderAlpha = 0; // No border by default
            
            if (activePowerUps.bigPaddle.active) {
                // Green for huge paddle: #00cc66
                targetR = 0; targetG = 204; targetB = 102;
            } else if (activePowerUps.smallPaddle.active) {
                // Grey for small paddle debuff: #888888
                targetR = 136; targetG = 136; targetB = 136;
                // Red border for debuff
                targetBorderR = 255; targetBorderG = 0; targetBorderB = 40;
                targetBorderAlpha = 1;
            }
            
            // Smoothly transition paddle color
            paddleColorTransition.currentR += (targetR - paddleColorTransition.currentR) * paddleColorTransition.speed;
            paddleColorTransition.currentG += (targetG - paddleColorTransition.currentG) * paddleColorTransition.speed;
            paddleColorTransition.currentB += (targetB - paddleColorTransition.currentB) * paddleColorTransition.speed;
            
            // Smoothly transition border
            paddleBorderTransition.currentR += (targetBorderR - paddleBorderTransition.currentR) * paddleBorderTransition.speed;
            paddleBorderTransition.currentG += (targetBorderG - paddleBorderTransition.currentG) * paddleBorderTransition.speed;
            paddleBorderTransition.currentB += (targetBorderB - paddleBorderTransition.currentB) * paddleBorderTransition.speed;
            paddleBorderTransition.currentAlpha += (targetBorderAlpha - paddleBorderTransition.currentAlpha) * paddleBorderTransition.speed;
            
            const pR = Math.round(paddleColorTransition.currentR);
            const pG = Math.round(paddleColorTransition.currentG);
            const pB = Math.round(paddleColorTransition.currentB);
            const paddleColor = `rgb(${pR}, ${pG}, ${pB})`;
            
            const bR = Math.round(paddleBorderTransition.currentR);
            const bG = Math.round(paddleBorderTransition.currentG);
            const bB = Math.round(paddleBorderTransition.currentB);
            const borderAlpha = paddleBorderTransition.currentAlpha;
            const borderColor = `rgba(${bR}, ${bG}, ${bB}, ${borderAlpha})`;
            
            // Draw paddle
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 7);
            ctx.fillStyle = paddleColor;
            ctx.shadowColor = paddleColor;
            ctx.shadowBlur = shadowSettings.paddle;
            ctx.fill();
            
            // Draw red border if debuff active (with fade)
            if (borderAlpha > 0.01) {
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.shadowColor = `rgba(${bR}, ${bG}, ${bB}, ${borderAlpha * 0.8})`;
                ctx.shadowBlur = 8;
                ctx.stroke();
            }
            
            // Draw immunity effect (pulsing golden glow)
            if (paddleImmunity.active) {
                const time = performance.now() / 1000;
                const pulse = 0.5 + Math.sin(time * 10) * 0.5; // Fast pulse
                const glowIntensity = 15 + pulse * 15;
                
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.7 + pulse * 0.3})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = glowIntensity;
                ctx.stroke();
                
                // Draw inner white highlight
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 + pulse * 0.4})`;
                ctx.lineWidth = 1;
                ctx.shadowBlur = 5;
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }

        // Ball color alternation duration for multiple power-ups
        const ballColorAlternateDuration = 800; // ms per color

        function drawBall() {
            // Collect all active power-up colors (excluding big paddle which doesn't change ball color)
            const activeColors = [];
            
            if (activePowerUps.crusher.active) {
                activeColors.push({ r: 255, g: 0, b: 40 }); // #ff0028
            }
            if (activePowerUps.multiBall.active) {
                activeColors.push({ r: 255, g: 106, b: 0 }); // #ff6a00
            }
            
            // Determine target ball color
            let targetR = 255, targetG = 255, targetB = 255; // Default white
            
            if (activeColors.length === 1) {
                // Single power-up: use its color
                targetR = activeColors[0].r;
                targetG = activeColors[0].g;
                targetB = activeColors[0].b;
            } else if (activeColors.length > 1) {
                // Multiple power-ups: alternate between colors based on time
                const now = performance.now();
                const cycleLength = ballColorAlternateDuration * activeColors.length;
                const cyclePosition = (now % cycleLength) / ballColorAlternateDuration;
                const colorIndex = Math.floor(cyclePosition) % activeColors.length;
                
                targetR = activeColors[colorIndex].r;
                targetG = activeColors[colorIndex].g;
                targetB = activeColors[colorIndex].b;
            }
            
            // Smoothly transition current color toward target
            ballColorTransition.currentR += (targetR - ballColorTransition.currentR) * ballColorTransition.speed;
            ballColorTransition.currentG += (targetG - ballColorTransition.currentG) * ballColorTransition.speed;
            ballColorTransition.currentB += (targetB - ballColorTransition.currentB) * ballColorTransition.speed;
            
            const r = Math.round(ballColorTransition.currentR);
            const g = Math.round(ballColorTransition.currentG);
            const b = Math.round(ballColorTransition.currentB);
            const ballColor = `rgb(${r}, ${g}, ${b})`;
            
            balls.forEach(ball => {
                // Update trail - add current position
                ball.trail.push({ x: ball.x, y: ball.y });
                // Keep only last 4 positions for trail
                if (ball.trail.length > 4) ball.trail.shift();
                
                // Draw trail (older positions first, more transparent)
                for (let i = 0; i < ball.trail.length - 1; i++) {
                    const pos = ball.trail[i];
                    const alpha = (i + 1) / ball.trail.length * 0.25;
                    const trailRadius = ball.radius * (0.5 + (i / ball.trail.length) * 0.4);
                    
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, trailRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.fill();
                }
                
                // Draw main ball
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                
                ctx.fillStyle = ballColor;
                ctx.shadowColor = ballColor;
                ctx.shadowBlur = shadowSettings.ball;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        function drawBricks() {
            // Calculate twinkle once per frame, not per brick
            const twinkle = isMobile ? 0.5 : (Math.sin(frameTime / 250) * 0.5 + 0.5);
            const twinkleShadow = shadowSettings.brickPowerUp + twinkle * (shadowSettings.brickPowerUpMax - shadowSettings.brickPowerUp);
            const twinkleAlpha = 0.8 + twinkle * 0.2;
            
            // Pre-calculate brick dimensions
            const brickW = brickConfig.width;
            const brickH = brickConfig.height;
            
            // Draw all regular bricks first (batched by similar state)
            ctx.shadowBlur = shadowSettings.brick;
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (brick.alive && !brick.powerUp && !brick.debuff) {
                        ctx.beginPath();
                        ctx.roundRect(brick.x, brick.y, brickW, brickH, 5);
                        ctx.fillStyle = brick.color;
                        ctx.shadowColor = brick.color;
                        ctx.fill();
                    }
                }
            }
            
            // Draw power-up/debuff bricks with pulsing glow effect
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (brick.alive && (brick.powerUp || brick.debuff)) {
                        // Calculate per-brick pulse using its unique offset (2 second cycle)
                        const pulsePhase = (frameTime / 2000 + brick.twinkleOffset) * Math.PI * 2;
                        const pulse = isMobile ? 0.5 : (Math.sin(pulsePhase) * 0.5 + 0.5);
                        
                        // Pulsing glow intensity (subtle range)
                        const glowBlur = shadowSettings.brickPowerUp + pulse * (shadowSettings.brickPowerUpMax - shadowSettings.brickPowerUp);
                        const glowAlpha = 0.85 + pulse * 0.15;
                        
                        ctx.globalAlpha = glowAlpha;
                        ctx.shadowColor = brick.color;
                        ctx.shadowBlur = glowBlur;
                        
                        ctx.beginPath();
                        ctx.roundRect(brick.x, brick.y, brickW, brickH, 5);
                        ctx.fillStyle = brick.color;
                        ctx.fill();
                        
                        // Add red border to debuff (skull) bricks
                        if (brick.debuff) {
                            ctx.strokeStyle = '#ff0028';
                            ctx.lineWidth = 2;
                            ctx.shadowColor = '#ff0028';
                            ctx.shadowBlur = 6 + pulse * 4;
                            ctx.stroke();
                        }
                    }
                }
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Draw symbols on special bricks (separate pass for text rendering)
            const symbolShadow = isMobile ? 0 : 5;
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (!brick.alive) continue;
                    
                    const centerX = brick.x + brickW / 2;
                    const centerY = brick.y + brickH / 2;
                    
                    // Draw symbol on power-up bricks
                    if (brick.powerUp) {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = symbolShadow;
                        ctx.shadowColor = '#fff';
                        
                        if (brick.powerUp.type === 'crusher') {
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, 7, 0, Math.PI * 2);
                            ctx.fillStyle = '#fff';
                            ctx.shadowBlur = 0;
                            ctx.fill();
                            ctx.font = 'bold 14px Arial';
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        } else if (brick.powerUp.type === 'multiBall') {
                            ctx.fillStyle = '#fff';
                            ctx.shadowBlur = symbolShadow;
                            ctx.beginPath();
                            ctx.arc(centerX - 5, centerY, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(centerX + 5, centerY, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (brick.powerUp.type === 'bigPaddle') {
                            ctx.font = '900 18px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 1;
                            ctx.strokeText(brick.powerUp.symbol, centerX, centerY);
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        } else {
                            ctx.font = 'bold 14px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        }
                    }
                    
                    // Draw symbol on debuff bricks
                    if (brick.debuff) {
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = isMobile ? 3 : 5;
                        ctx.shadowColor = '#fff';
                        ctx.fillText(brick.debuff.symbol, centerX, centerY);
                    }
                }
            }
            ctx.shadowBlur = 0;
        }

        function movePaddle() {
            // Smooth keyboard movement (frame-rate independent)
            paddle.targetX += paddle.dx * deltaMultiplier;
            
            // Clamp target
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > gameWidth) paddle.targetX = gameWidth - paddle.width;
            
            // Smooth interpolation (adjust for frame rate)
            const smoothFactor = 1 - Math.pow(1 - paddle.smoothing, deltaMultiplier);
            paddle.x += (paddle.targetX - paddle.x) * smoothFactor;
            
            // Update magnet caught ball position to follow paddle
            if (magnetCaughtBall && magnetCaughtBall.ball) {
                magnetCaughtBall.ball.x = paddle.x + paddle.width / 2 + magnetCaughtBall.offsetX;
                magnetCaughtBall.ball.y = paddle.y - magnetCaughtBall.ball.radius;
                // Clamp ball to stay within paddle bounds
                if (magnetCaughtBall.ball.x < paddle.x + magnetCaughtBall.ball.radius) {
                    magnetCaughtBall.ball.x = paddle.x + magnetCaughtBall.ball.radius;
                }
                if (magnetCaughtBall.ball.x > paddle.x + paddle.width - magnetCaughtBall.ball.radius) {
                    magnetCaughtBall.ball.x = paddle.x + paddle.width - magnetCaughtBall.ball.radius;
                }
            }
        }

        function moveBall() {
            // Freeze ball immediately when stage is cleared (prevents unfair deaths)
            if (stageClearPending) {
                return;
            }
            
            let ballsToRemove = [];
            let levelChanged = false;
            
            // Store all ball positions before any movement (for freeze restoration on boss death)
            const savedPositions = balls.map(b => ({ x: b.x, y: b.y }));
            
            for (let ballIndex = 0; ballIndex < balls.length; ballIndex++) {
                if (levelChanged) break;
                const ball = balls[ballIndex];
                
                // Skip balls caught by magnet paddle (they're handled in movePaddle)
                if (magnetCaughtBall && magnetCaughtBall.ball === ball) {
                    continue;
                }
                
                // Apply delta time for frame-rate independent movement
                ball.x += ball.dx * deltaMultiplier;
                ball.y += ball.dy * deltaMultiplier;

                // Wall collision - FIXED: Reposition ball to prevent getting stuck
                // Left wall
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius; // Reposition inside
                    ball.dx = Math.abs(ball.dx); // Force moving right
                }
                // Right wall
                if (ball.x + ball.radius > gameWidth) {
                    ball.x = gameWidth - ball.radius; // Reposition inside
                    ball.dx = -Math.abs(ball.dx); // Force moving left
                }
                // Top wall
                if (ball.y - ball.radius < 0) {
                    ball.y = ball.radius; // Reposition inside
                    ball.dy = Math.abs(ball.dy); // Force moving down
                }

                // Bottom - remove ball
                if (ball.y + ball.radius > gameHeight) {
                    ballsToRemove.push(ballIndex);
                    continue;
                }

                // Paddle collision
                if (ball.y + ball.radius > paddle.y &&
                    ball.y - ball.radius < paddle.y + paddle.height &&
                    ball.x > paddle.x &&
                    ball.x < paddle.x + paddle.width) {
                    
                    ball.y = paddle.y - ball.radius;
                    
                    // Magnet paddle: catch the ball every other hit if enabled
                    if (permanentUpgrades.magnetPaddle && !magnetCaughtBall && magnetNextCatch) {
                        // Catch the ball - store offset from paddle center
                        magnetCaughtBall = {
                            ball: ball,
                            offsetX: ball.x - (paddle.x + paddle.width / 2)
                        };
                        ball.dx = 0;
                        ball.dy = 0;
                        magnetNextCatch = false; // Next hit will bounce
                        continue; // Skip normal bounce processing
                    }
                    
                    // Toggle for next paddle hit (if magnet enabled but didn't catch)
                    if (permanentUpgrades.magnetPaddle && !magnetCaughtBall) {
                        magnetNextCatch = true; // Next hit will catch
                    }
                    
                    // Angle based on where ball hits paddle (-0.8 to 0.8 range for max angle)
                    let hitPoint = (ball.x - paddle.x) / paddle.width;
                    let angle = (hitPoint - 0.5) * 1.6; // Max angle ~38 degrees
                    
                    // Normalize velocity to maintain consistent speed
                    ball.dx = ball.speed * Math.sin(angle * Math.PI / 2);
                    ball.dy = -ball.speed * Math.cos(angle * Math.PI / 2);
                    
                    // Ensure ball always moves upward
                    if (ball.dy > -ball.speed * 0.3) {
                        ball.dy = -ball.speed * 0.3;
                        // Renormalize dx to maintain speed
                        const dxMax = Math.sqrt(ball.speed * ball.speed - ball.dy * ball.dy);
                        ball.dx = Math.sign(ball.dx) * Math.min(Math.abs(ball.dx), dxMax);
                    }
                    
                    // Multiball: spawn new ball on paddle hit
                    if (activePowerUps.multiBall.active && activePowerUps.multiBall.bouncesLeft > 0) {
                        activePowerUps.multiBall.bouncesLeft--;
                        
                        // Spawn a new ball at random angle (normalized velocity)
                        const spawnAngle = (Math.random() - 0.5) * Math.PI * 0.6; // -54¬∞ to +54¬∞
                        const newBall = createBall(
                            ball.x,
                            ball.y - 10,
                            ball.speed * Math.sin(spawnAngle),
                            -ball.speed * Math.cos(spawnAngle),
                            ball.speed
                        );
                        balls.push(newBall);
                        
                        if (activePowerUps.multiBall.bouncesLeft <= 0) {
                            activePowerUps.multiBall.active = false;
                        }
                    }
                }

                // Brick collision - only during brick phase
                if (!bossPhase) {
                    // Early exit: skip if ball is clearly outside brick area
                    const brickAreaBottom = brickConfig.offsetTop + brickConfig.rows * (brickConfig.height + brickConfig.padding);
                    if (ball.y - ball.radius <= brickAreaBottom && ball.y + ball.radius >= brickConfig.offsetTop) {
                        for (let row = 0; row < brickConfig.rows; row++) {
                            if (levelChanged) break;
                            
                            // Skip rows that ball can't possibly touch
                            const rowY = brickConfig.offsetTop + row * (brickConfig.height + brickConfig.padding);
                            if (ball.y + ball.radius < rowY) break; // Ball above this row and all below
                            if (ball.y - ball.radius > rowY + brickConfig.height) continue; // Ball below this row
                            
                            for (let col = 0; col < brickConfig.cols; col++) {
                                if (levelChanged) break;
                                const brick = bricks[row][col];
                                if (brick.alive) {
                                    // Check collision with ball radius on all sides
                                    if (ball.x + ball.radius > brick.x &&
                                        ball.x - ball.radius < brick.x + brickConfig.width &&
                                        ball.y + ball.radius > brick.y &&
                                        ball.y - ball.radius < brick.y + brickConfig.height) {
                                        
                                        // Only bounce if crusher is not active
                                        if (!activePowerUps.crusher.active) {
                                            // Determine which side was hit for proper bounce direction
                                            const overlapLeft = (ball.x + ball.radius) - brick.x;
                                            const overlapRight = (brick.x + brickConfig.width) - (ball.x - ball.radius);
                                            const overlapTop = (ball.y + ball.radius) - brick.y;
                                            const overlapBottom = (brick.y + brickConfig.height) - (ball.y - ball.radius);
                                            
                                            const minOverlapX = Math.min(overlapLeft, overlapRight);
                                            const minOverlapY = Math.min(overlapTop, overlapBottom);
                                            
                                            if (minOverlapX < minOverlapY) {
                                                ball.dx *= -1;
                                            } else {
                                                ball.dy *= -1;
                                            }
                                        }
                                        
                                        brick.alive = false;
                                        score += 1;
                                        scoreEl.textContent = score;
                                    
                                    // Activate power-up if brick had one
                                    if (brick.powerUp) {
                                        activatePowerUp(brick.powerUp.type);
                                    }
                                    
                                    // Activate debuff if brick had one
                                    if (brick.debuff) {
                                        activatePowerUp(brick.debuff.type);
                                    }

                                    // Check win - triggers pre-boss upgrade then boss phase
                                    if (checkWin() && !bossPhase) {
                                        stageClearPending = true; // Freeze ball immediately
                                        clearActivePowerUps(); // Reset powerups when bricks cleared
                                        preBossUpgrade = true;
                                        showUpgradeSelector();
                                        levelChanged = true;
                                    }
                                }
                            }
                        }
                    }
                    } // End early exit check
                }
            }
            
            if (levelChanged) return;
            
            // Boss phase logic
            if (bossPhase) {
                moveBosses();
                updateBossLasers();
                updateImmunityStar();
                checkBossCollisions();
                
                // If boss death triggered freeze, restore all ball positions
                if (waitingForBossDeathAnimation) {
                    balls.forEach((ball, i) => {
                        if (savedPositions[i]) {
                            ball.x = savedPositions[i].x;
                            ball.y = savedPositions[i].y;
                        }
                    });
                    return; // Exit immediately, ball is frozen
                }
            }
            
            // Update boss death particles (always, even after boss phase ends)
            updateBossDeathParticles();
            
            // Remove balls that fell off screen (Set for O(1) lookup)
            if (ballsToRemove.length > 0) {
                const removeSet = new Set(ballsToRemove);
                balls = balls.filter((_, index) => !removeSet.has(index));
            }
            
            // If no balls left, lose a life
            if (balls.length === 0) {
                lives--;
                livesEl.textContent = lives;
                if (lives <= 0) {
                    gameOver();
                } else {
                    showLifeLostMessage();
                }
            }
        }

        // Show life lost message and pause briefly
        function showLifeLostMessage() {
            lifeLostPause = true;
            lifeLostPauseEnd = performance.now() + 1275; // 1.275 second pause (15% shorter)
            
            // Clear all active power-ups on life loss
            clearActivePowerUps();
        }
        
        // Clear all active power-ups (called on life loss and stage clear)
        function clearActivePowerUps() {
            // Stop any paddle animation
            paddleAnimation.active = false;
            
            // Calculate correct paddle width for current level with permanent bonuses
            const basePaddleWidth = Math.max(66, 107 - (level - 1) * 6);
            const bonusMultiplier = 1 + (permanentUpgrades.paddleSizeBonus / 100);
            const correctPaddleWidth = Math.round(basePaddleWidth * bonusMultiplier);
            
            // Reset big paddle
            if (activePowerUps.bigPaddle.active) {
                activePowerUps.bigPaddle.active = false;
                activePowerUps.bigPaddle.timeLeft = 0;
            }
            
            // Reset small paddle (debuff)
            if (activePowerUps.smallPaddle.active) {
                activePowerUps.smallPaddle.active = false;
                activePowerUps.smallPaddle.timeLeft = 0;
            }
            
            // Force paddle to correct width and update originalWidth values
            paddle.width = correctPaddleWidth;
            activePowerUps.bigPaddle.originalWidth = correctPaddleWidth;
            activePowerUps.smallPaddle.originalWidth = correctPaddleWidth;
            
            // Reset crusher
            activePowerUps.crusher.active = false;
            activePowerUps.crusher.timeLeft = 0;
            
            // Reset multi-ball bounces
            activePowerUps.multiBall.active = false;
            activePowerUps.multiBall.bouncesLeft = 0;
            
            // Clear power-up bar display
            powerUpBarEl.innerHTML = '';
            lastPowerUpBarContent = '';
        }
        
        function drawLifeLostMessage() {
            if (!lifeLostPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // Magenta text (matches game over)
            const fontSize = isTrueMobile ? 26 : 32;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 10;
            ctx.fillText(`${lives} ${lives === 1 ? 'LIFE' : 'LIVES'} REMAINING`, gameWidth / 2, gameHeight / 2);
            ctx.shadowBlur = 0;
        }

        function checkWin() {
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    if (bricks[row][col].alive) return false;
                }
            }
            return true;
        }
        
        function startBossPhase() {
            // Clear stage pending flag so ball can move again
            stageClearPending = false;
            // Pause before bosses appear
            bossSpawnPause = true;
            bossSpawnPauseEnd = performance.now() + 1200; // 1.2 second pause
        }
        
        function startLevelTransition() {
            // Clear stage pending flag 
            stageClearPending = false;
            // Check if player earns an extra life AND legendary upgrade (every 5 levels)
            if (level % 5 === 0) {
                lives++;
                livesEl.textContent = lives;
                // Show extra life message first, then legendary upgrade selector
                extraLifePause = true;
                extraLifePauseEnd = performance.now() + 1200; // 1.2 second pause
                // Flag for legendary upgrade after extra life pause
                pendingLegendaryUpgrade = true;
            } else {
                // Show regular upgrade selector directly
                showUpgradeSelector();
            }
        }
        
        // Flag for pending legendary upgrade
        let pendingLegendaryUpgrade = false;
        
        // ========== UPGRADE SELECTOR SYSTEM ==========
        const upgradeOverlay = document.getElementById('upgradeOverlay');
        const slots = [
            document.getElementById('slot1'),
            document.getElementById('slot2'),
            document.getElementById('slot3')
        ];
        
        // Event delegation for upgrade selection (robust iOS support)
        upgradeOverlay.addEventListener('click', (e) => {
            if (!upgradeSelectionActive) return;
            const slot = e.target.closest('.upgrade-slot.revealed');
            if (slot) {
                const index = slots.indexOf(slot);
                if (index !== -1) selectUpgrade(index);
            }
        });
        
        // Touch event delegation (iOS Safari needs this)
        upgradeOverlay.addEventListener('touchstart', (e) => {
            // Allow touches on slots, but stop propagation to prevent game controls
            e.stopPropagation();
        }, { passive: true });
        
        upgradeOverlay.addEventListener('touchend', (e) => {
            if (!upgradeSelectionActive) return;
            const slot = e.target.closest('.upgrade-slot.revealed');
            if (slot) {
                e.preventDefault();
                const index = slots.indexOf(slot);
                if (index !== -1) selectUpgrade(index);
            }
        }, { passive: false });
        
        function showUpgradeSelector(legendary = false) {
            upgradeSelectionActive = true;
            upgradeSelected = false; // Reset selection flag for new upgrade screen
            isLegendaryUpgrade = legendary;
            
            if (legendary) {
                // Filter legendary upgrades - remove one-time upgrades if already taken
                let availableLegendary = legendaryUpgradeDefinitions.filter(u => {
                    if (u.id === 'bossdamage' && permanentUpgrades.bossDamageBonus >= 2) {
                        return false; // Cap boss damage at 2
                    }
                    if (u.id === 'magnetpaddle' && permanentUpgrades.magnetPaddle) {
                        return false; // One-time only upgrade
                    }
                    return true;
                });
                
                // Shuffle and pick up to 3 legendary upgrades
                const shuffled = [...availableLegendary].sort(() => Math.random() - 0.5);
                currentUpgradeChoices = shuffled.slice(0, 3);
                
                // Determine how many slots to show (up to 3)
                const slotsToShow = currentUpgradeChoices.length;
                
                // Reset slots to rolling state with legendary styling
                slots.forEach((slot, i) => {
                    if (i < slotsToShow) {
                        slot.className = 'upgrade-slot rolling legendary';
                        slot.style.display = '';
                        slot.dataset.type = '';
                        slot.querySelector('.upgrade-icon').textContent = '?';
                        slot.querySelector('.upgrade-name').textContent = '???';
                        slot.querySelector('.upgrade-desc').textContent = '???';
                    } else {
                        // Hide extra slots
                        slot.style.display = 'none';
                    }
                });
                
                upgradeOverlay.classList.add('active');
                upgradeOverlay.classList.add('legendary');
            } else {
                // Smart RNG: Weight upgrades by how long since they were offered
                // Upgrades not shown recently have higher chance of appearing
                function weightedRandomSelect(available, count) {
                    const selected = [];
                    const pool = [...available];
                    
                    for (let i = 0; i < count && pool.length > 0; i++) {
                        // Calculate weights based on history (higher = shown longer ago)
                        const weights = pool.map(u => {
                            const roundsSince = upgradeOfferHistory[u.id] || 1;
                            // Weight formula: rounds since last offer squared (exponential preference for variety)
                            return roundsSince * roundsSince;
                        });
                        
                        // Calculate total weight
                        const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                        
                        // Random selection based on weights
                        let random = Math.random() * totalWeight;
                        let selectedIdx = 0;
                        
                        for (let j = 0; j < weights.length; j++) {
                            random -= weights[j];
                            if (random <= 0) {
                                selectedIdx = j;
                                break;
                            }
                        }
                        
                        selected.push(pool.splice(selectedIdx, 1)[0]);
                    }
                    
                    return selected;
                }
                
                // Pick 3 upgrades using weighted selection
                currentUpgradeChoices = weightedRandomSelect(upgradeDefinitions, 3);
                
                // Update history: reset offered upgrades to 0, increment others
                upgradeDefinitions.forEach(u => {
                    const wasOffered = currentUpgradeChoices.some(c => c.id === u.id);
                    if (wasOffered) {
                        upgradeOfferHistory[u.id] = 0; // Just offered
                    } else {
                        // Increment rounds since last offer (cap at 5 to prevent runaway weights)
                        upgradeOfferHistory[u.id] = Math.min((upgradeOfferHistory[u.id] || 0) + 1, 5);
                    }
                });
                
                // Reset slots to rolling state (ensure all 3 are visible)
                slots.forEach((slot, i) => {
                    slot.className = 'upgrade-slot rolling';
                    slot.style.display = ''; // Ensure visible
                    slot.dataset.type = '';
                    slot.querySelector('.upgrade-icon').textContent = '?';
                    slot.querySelector('.upgrade-name').textContent = '???';
                    slot.querySelector('.upgrade-desc').textContent = '???';
                });
                
                upgradeOverlay.classList.add('active');
            }
            
            // Start the slot machine roll animation
            rollSlots();
        }
        
        function rollSlots() {
            // Legendary has slightly longer/more dramatic timing
            const rollDuration = isLegendaryUpgrade ? 1800 : 1500;
            const staggerDelay = isLegendaryUpgrade ? 400 : 300;
            const rollDefinitions = isLegendaryUpgrade ? currentUpgradeChoices : upgradeDefinitions;
            
            // Only animate slots that have choices
            const slotsToAnimate = currentUpgradeChoices.length;
            
            slots.forEach((slot, index) => {
                // Skip hidden slots
                if (index >= slotsToAnimate) return;
                
                const stopTime = rollDuration + (index * staggerDelay);
                let rollInterval;
                
                // Rapidly cycle through random upgrades (100ms for performance)
                rollInterval = setInterval(() => {
                    const randomUpgrade = rollDefinitions[Math.floor(Math.random() * rollDefinitions.length)];
                    slot.querySelector('.upgrade-icon').textContent = randomUpgrade.icon;
                    slot.querySelector('.upgrade-name').textContent = randomUpgrade.name;
                    slot.querySelector('.upgrade-desc').textContent = randomUpgrade.desc;
                }, 100);
                
                // Stop on the actual choice
                setTimeout(() => {
                    clearInterval(rollInterval);
                    const choice = currentUpgradeChoices[index];
                    slot.className = isLegendaryUpgrade ? 'upgrade-slot revealed legendary' : 'upgrade-slot revealed';
                    slot.dataset.type = choice.id;
                    slot.querySelector('.upgrade-icon').textContent = choice.icon;
                    slot.querySelector('.upgrade-name').textContent = choice.name;
                    slot.querySelector('.upgrade-desc').textContent = choice.desc;
                    
                    // Add click handler for desktop
                    slot.onclick = () => selectUpgrade(index);
                    
                    // Add touch handler for mobile (iOS Safari needs this)
                    slot.ontouchend = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        selectUpgrade(index);
                    };
                }, stopTime);
            });
        }
        
        // Legendary upgrade flag (used for levels 5, 10, 15, etc.)
        let isLegendaryUpgrade = false;
        
        // Flag to prevent double-selection during timeout
        let upgradeSelected = false;
        
        function selectUpgrade(index) {
            if (!upgradeSelectionActive || upgradeSelected) return;
            
            // Prevent double-selection
            upgradeSelected = true;
            
            const choice = currentUpgradeChoices[index];
            
            // Visual feedback
            slots.forEach((slot, i) => {
                if (i === index) {
                    slot.classList.add('selected');
                } else {
                    slot.style.opacity = '0.3';
                    slot.style.pointerEvents = 'none';
                }
            });
            
            // Apply the upgrade
            choice.apply();
            
            // Immediately recalculate paddle size if paddle bonus changed
            // This ensures the bonus applies before boss phase, not just at next level
            if (choice.id === 'paddle') {
                const basePaddleWidth = Math.max(66, 107 - (level - 1) * 6);
                const bonusMultiplier = 1 + (permanentUpgrades.paddleSizeBonus / 100);
                const newWidth = Math.round(basePaddleWidth * bonusMultiplier);
                // Animate to new size
                animatePaddleSize(newWidth);
                // Update originalWidth for power-ups
                activePowerUps.bigPaddle.originalWidth = newWidth;
                activePowerUps.smallPaddle.originalWidth = newWidth;
            }
            
            // Update the permanent upgrades display
            updatePermanentUpgradesDisplay();
            
            // Brief pause then continue (keep upgradeSelectionActive true to freeze ball)
            setTimeout(() => {
                // NOW disable upgrade selection (after timeout, not before)
                upgradeSelectionActive = false;
                
                upgradeOverlay.classList.remove('active');
                upgradeOverlay.classList.remove('legendary');
                
                // Reset slot styles and clear all handlers
                slots.forEach(slot => {
                    slot.style.opacity = '';
                    slot.style.pointerEvents = '';
                    slot.classList.remove('selected');
                    slot.classList.remove('legendary');
                    slot.onclick = null;
                    slot.ontouchend = null;
                });
                
                // Reset legendary flag
                isLegendaryUpgrade = false;
                
                // Check if this was a pre-boss upgrade
                if (preBossUpgrade) {
                    preBossUpgrade = false;
                    startBossPhase();
                } else {
                    // Post-boss upgrade - show level clear message
                    levelTransitionPause = true;
                    levelTransitionPauseEnd = performance.now() + 1200;
                }
            }, 800);
        }
        
        function drawExtraLifeMessage() {
            if (!extraLifePause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // Blue text for extra life
            ctx.font = 'bold 42px Arial';
            ctx.fillStyle = '#00aaff';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#00aaff';
            ctx.shadowBlur = 25;
            ctx.fillText('+1 LIFE', gameWidth / 2, gameHeight / 2);
            ctx.shadowBlur = 0;
        }
        
        function drawBossSpawnMessage() {
            if (!bossSpawnPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // Warning text - same pink as start button
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 20;
            ctx.fillText('BOSS INCOMING!', gameWidth / 2, gameHeight / 2);
            ctx.shadowBlur = 0;
        }
        
        function drawLevelTransitionMessage() {
            if (!levelTransitionPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // Victory text - same cyan as paddle
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#0ff';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 20;
            ctx.fillText(`LEVEL ${level} CLEAR!`, gameWidth / 2, gameHeight / 2);
            ctx.shadowBlur = 0;
        }

        function activatePowerUp(type) {
            switch(type) {
                case 'bigPaddle':
                    activePowerUps.bigPaddle.active = true;
                    // Base 12s + permanent big paddle duration bonus
                    activePowerUps.bigPaddle.timeLeft = 12 + permanentUpgrades.bigPaddleDurationBonus;
                    activePowerUps.bigPaddle.originalWidth = paddle.width;
                    // Animate paddle growing ~104% bigger (20% larger than previous 70%)
                    animatePaddleSize(paddle.width * 2.04);
                    break;
                    
                case 'multiBall':
                    activePowerUps.multiBall.active = true;
                    // Base 2 bounces + permanent multiball bounce bonus
                    activePowerUps.multiBall.bouncesLeft = 2 + permanentUpgrades.multiBallBounceBonus;
                    break;
                    
                case 'crusher':
                    activePowerUps.crusher.active = true;
                    // Base 8s + permanent crusher duration bonus
                    activePowerUps.crusher.timeLeft = 8 + permanentUpgrades.crusherDurationBonus;
                    break;
                    
                case 'smallPaddle':
                    activePowerUps.smallPaddle.active = true;
                    activePowerUps.smallPaddle.timeLeft = 10;
                    activePowerUps.smallPaddle.originalWidth = paddle.width;
                    // Animate paddle shrinking 30% smaller
                    animatePaddleSize(paddle.width * 0.7);
                    break;
            }
        }

        let paddleAnimation = {
            active: false,
            startWidth: 0,
            targetWidth: 0,
            startTime: 0,
            duration: 300
        };

        function animatePaddleSize(targetWidth) {
            paddleAnimation.active = true;
            paddleAnimation.startWidth = paddle.width;
            paddleAnimation.targetWidth = targetWidth;
            paddleAnimation.startTime = frameTime; // Use frameTime
        }
        
        function updatePaddleAnimation() {
            if (!paddleAnimation.active) return;
            
            const elapsed = frameTime - paddleAnimation.startTime; // Use frameTime
            const progress = Math.min(elapsed / paddleAnimation.duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            const oldWidth = paddle.width;
            paddle.width = paddleAnimation.startWidth + (paddleAnimation.targetWidth - paddleAnimation.startWidth) * eased;
            
            // Adjust position to keep paddle centered during resize
            const widthDiff = paddle.width - oldWidth;
            paddle.x -= widthDiff / 2;
            paddle.targetX -= widthDiff / 2;
            
            // Clamp to canvas bounds
            if (paddle.x < 0) {
                paddle.x = 0;
                paddle.targetX = 0;
            }
            if (paddle.x + paddle.width > gameWidth) {
                paddle.x = gameWidth - paddle.width;
                paddle.targetX = gameWidth - paddle.width;
            }
            
            if (progress >= 1) {
                paddleAnimation.active = false;
            }
        }

        let lastPowerUpTime = 0;
        
        function updatePowerUps() {
            const delta = (frameTime - lastPowerUpTime) / 1000; // Use frameTime
            lastPowerUpTime = frameTime;
            
            // Big paddle timer
            if (activePowerUps.bigPaddle.active) {
                activePowerUps.bigPaddle.timeLeft -= delta;
                if (activePowerUps.bigPaddle.timeLeft <= 0) {
                    activePowerUps.bigPaddle.active = false;
                    // Animate paddle shrinking back
                    animatePaddleSize(activePowerUps.bigPaddle.originalWidth);
                }
            }
            
            // Crusher timer
            if (activePowerUps.crusher.active) {
                activePowerUps.crusher.timeLeft -= delta;
                if (activePowerUps.crusher.timeLeft <= 0) {
                    activePowerUps.crusher.active = false;
                }
            }
            
            // Small paddle timer (debuff)
            if (activePowerUps.smallPaddle.active) {
                activePowerUps.smallPaddle.timeLeft -= delta;
                if (activePowerUps.smallPaddle.timeLeft <= 0) {
                    activePowerUps.smallPaddle.active = false;
                    // Animate paddle growing back
                    animatePaddleSize(activePowerUps.smallPaddle.originalWidth);
                }
            }
        }

        // Track last power-up bar content to avoid unnecessary DOM updates
        let lastPowerUpBarContent = '';
        
        function drawPowerUpTimers() {
            const flashOn = Math.sin(frameTime / 1000 * 6) > 0; // Use cached frameTime
            
            // Collect all active powerups with their display info
            const activePowerups = [];
            
            // Big paddle timer - green like brick #00cc66
            if (activePowerUps.bigPaddle.active) {
                const timeLeft = activePowerUps.bigPaddle.timeLeft;
                const isWarning = timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: timeLeft,
                    html: `<span style="color: #00cc66; text-shadow: 0 0 8px #00cc66; opacity: ${opacity};">‚Üî Huge Paddle: ${Math.ceil(timeLeft)}s ‚Üî</span>`
                });
            }
            
            // Crusher timer - red like brick #ff0028
            if (activePowerUps.crusher.active) {
                const timeLeft = activePowerUps.crusher.timeLeft;
                const isWarning = timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: timeLeft,
                    html: `<span style="color: #ff0028; text-shadow: 0 0 8px #ff0028; opacity: ${opacity};">‚ö° Crusher: ${Math.ceil(timeLeft)}s ‚ö°</span>`
                });
            }
            
            // Multiball bounces - orange like brick #ff6a00
            if (activePowerUps.multiBall.active) {
                const bouncesLeft = activePowerUps.multiBall.bouncesLeft;
                const isWarning = bouncesLeft === 1;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: bouncesLeft * 2,
                    html: `<span style="color: #ff6a00; text-shadow: 0 0 8px #ff6a00; opacity: ${opacity};">‚ú¶ Multi Ball: ${bouncesLeft} Bounce${bouncesLeft !== 1 ? 's' : ''} ‚ú¶</span>`
                });
            }
            
            // Small paddle timer - grey like brick #888888 with red border
            if (activePowerUps.smallPaddle.active) {
                const timeLeft = activePowerUps.smallPaddle.timeLeft;
                const isWarning = timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: timeLeft,
                    html: `<span style="color: #888888; text-shadow: 0 0 6px #888888; border: 1px solid #ff0028; border-radius: 3px; padding: 1px 6px; box-shadow: 0 0 8px rgba(255, 0, 40, 0.6); opacity: ${opacity};">‚ò† Small Paddle: ${Math.ceil(timeLeft)}s ‚ò†</span>`
                });
            }
            
            // Paddle immunity timer - golden/yellow
            if (paddleImmunity.active) {
                const timeLeft = paddleImmunity.timeLeft;
                const isWarning = timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: timeLeft,
                    html: `<span style="color: #ffff00; text-shadow: 0 0 8px #ffff00; opacity: ${opacity};">‚òÖ Immunity: ${Math.ceil(timeLeft)}s ‚òÖ</span>`
                });
            }
            
            // Sort by time remaining (lowest first = closest to expiring on top)
            activePowerups.sort((a, b) => a.sortValue - b.sortValue);
            
            // Limit to 3 on mobile, 4 on desktop (hide extras via overflow:hidden in CSS)
            const maxTimers = isTrueMobile ? 3 : 4;
            const html = activePowerups.slice(0, maxTimers).map(p => p.html).join('');
            
            // Only update DOM if content changed (major optimization)
            if (html !== lastPowerUpBarContent) {
                powerUpBarEl.innerHTML = html;
                lastPowerUpBarContent = html;
            }
        }

        function nextLevel() {
            level++;
            levelEl.textContent = level;
            
            // Clear boss state for new level
            bossPhase = false;
            bosses = [];
            bossLasers = [];
            lastGlobalLaserTime = 0;
            bossesDropping = false;
            bossDropProgress = 0;
            bossDeathParticles = [];
            waitingForBossDeathAnimation = false;
            stageClearPending = false;
            
            // Reset immunity star for new level
            immunityStar = null;
            lastStarSpawnTime = 0;
            paddleImmunity.active = false;
            paddleImmunity.timeLeft = 0;
            
            // Progressive difficulty - slower ramp early, faster later
            if (level <= 3) {
                ballTemplate.speed += 0.4;  // Gentle increase for first 3 levels
            } else {
                ballTemplate.speed += 0.6;  // Faster increase after that
            }
            
            // Stop any paddle animation in progress to prevent override
            paddleAnimation.active = false;
            
            // Calculate correct paddle width: base size (shrinks per level) + permanent bonus
            const basePaddleWidth = Math.max(66, 107 - (level - 1) * 6);
            const bonusMultiplier = 1 + (permanentUpgrades.paddleSizeBonus / 100);
            const correctPaddleWidth = Math.round(basePaddleWidth * bonusMultiplier);
            
            // Force paddle to correct size
            paddle.width = correctPaddleWidth;
            
            // Add more brick rows at higher levels (max 7)
            brickConfig.rows = Math.min(7, 4 + Math.floor(level / 2));
            
            // Reset power-ups on level change with correct originalWidth
            activePowerUps.bigPaddle = { active: false, timeLeft: 0, originalWidth: correctPaddleWidth };
            activePowerUps.multiBall = { active: false, bouncesLeft: 0 };
            activePowerUps.crusher = { active: false, timeLeft: 0 };
            activePowerUps.smallPaddle = { active: false, timeLeft: 0, originalWidth: correctPaddleWidth };
            
            createBricks();
            resetBall();
        }

        function resetBall() {
            // Clear any magnet-caught ball and reset catch toggle
            magnetCaughtBall = null;
            magnetNextCatch = true; // First hit after reset will catch
            
            // Apply permanent speed reduction bonus
            const speedMultiplier = 1 - (permanentUpgrades.speedReduction / 100);
            const speed = ballTemplate.speed * speedMultiplier;
            // Launch at 45-degree angle with NORMALIZED velocity
            // At 45¬∞: sin(45¬∞) = cos(45¬∞) = 0.707, so dx¬≤ + dy¬≤ = speed¬≤
            const angle = 0.707; // ‚àö2/2 for 45-degree launch
            const direction = Math.random() > 0.5 ? 1 : -1;
            
            // Create primary ball
            balls = [createBall(
                paddle.x + paddle.width / 2,
                paddle.y - 8 - 5,
                speed * angle * direction,  // dx: ~70% of speed
                -speed * angle,              // dy: ~70% of speed (upward)
                speed
            )];
            
            // Spawn extra balls from dual ball start upgrade (staggered deployment)
            if (permanentUpgrades.dualBallStart > 0) {
                const extraBalls = permanentUpgrades.dualBallStart;
                for (let i = 0; i < extraBalls; i++) {
                    // Stagger each extra ball by 800ms
                    setTimeout(() => {
                        if (!gameRunning) return; // Don't spawn if game ended
                        const extraDirection = (i % 2 === 0) ? -direction : direction; // Alternate directions
                        const extraAngle = 0.6 + (Math.random() * 0.2); // Slight angle variation
                        const extraBall = createBall(
                            paddle.x + paddle.width / 2,
                            paddle.y - 8 - 5,
                            speed * extraAngle * extraDirection,
                            -speed * (1 - extraAngle * extraAngle) ** 0.5, // Normalize velocity
                            speed
                        );
                        balls.push(extraBall);
                    }, 800 * (i + 1));
                }
            }
        }

        function gameOver() {
            gameRunning = false;
            
            powerUpBarEl.innerHTML = '';
            lastPowerUpBarContent = '';
            
            // Draw game over screen (will be visible after modal closes)
            drawGameOverScreen();
            
            // Show score submission modal after 2 second pause
            setTimeout(() => {
                showScoreModal(score, level);
            }, 2000);
        }
        
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            ctx.font = 'bold 52px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = isMobile ? 15 : 25;
            ctx.fillText('GAME OVER', gameWidth / 2, gameHeight / 2 - 60);
            ctx.shadowBlur = 0;
            
            ctx.font = '24px Arial';
            ctx.fillStyle = '#0ff';
            ctx.fillText(`Final Score: ${score}`, gameWidth / 2, gameHeight / 2 - 15);
        }
        
        function showGameOverButtons() {
            startBtn.textContent = 'PLAY AGAIN';
            menuOverlay.classList.remove('hidden');
        }

        function draw() {
            // Background fill (no need for clearRect since we fill the whole canvas)
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // Draw play area boundary lines - shows where ball bounces/falls
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = isMobile ? 2 : 4;
            
            // Top line (ball bounces here)
            ctx.beginPath();
            ctx.moveTo(0, 1);
            ctx.lineTo(gameWidth, 1);
            ctx.stroke();
            
            // Left edge (ball bounces here)
            ctx.beginPath();
            ctx.moveTo(1, 0);
            ctx.lineTo(1, gameHeight);
            ctx.stroke();
            
            // Right edge (ball bounces here)
            ctx.beginPath();
            ctx.moveTo(gameWidth - 1, 0);
            ctx.lineTo(gameWidth - 1, gameHeight);
            ctx.stroke();
            
            // Bottom edge (death zone indicator)
            ctx.beginPath();
            ctx.moveTo(0, gameHeight - 1);
            ctx.lineTo(gameWidth, gameHeight - 1);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            
            // Draw bricks only if not in boss phase
            if (!bossPhase) {
                drawBricks();
            }
            
            // Draw bosses if in boss phase
            if (bossPhase) {
                drawBosses();
                drawBossLasers();
                drawImmunityStar();
            }
            
            // Draw boss death particles (always, even after boss phase ends)
            drawBossDeathParticles();
            
            drawPaddle();
            drawBall();
            
            // Draw life lost message overlay (on top of everything)
            drawLifeLostMessage();
        }

        // Delta time for consistent game speed across all frame rates
        let lastFrameTime = 0;
        const targetFrameTime = 1000 / 60; // Target 60fps as baseline for speed calculations
        
        // Single timestamp per frame (optimization)
        let frameTime = 0;
        let deltaMultiplier = 1; // Scales movement based on actual frame time

        function update(currentTime) {
            if (!gameRunning) return;
            
            // Calculate delta time for frame-rate independent movement
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            frameTime = currentTime;
            
            // Calculate speed multiplier (1.0 at 60fps, higher if slower, lower if faster)
            // Clamp to prevent huge jumps if tab was inactive
            deltaMultiplier = Math.min(deltaTime / targetFrameTime, 3);
            
            // Check if life lost pause is over
            if (lifeLostPause) {
                if (currentTime >= lifeLostPauseEnd) {
                    lifeLostPause = false;
                    resetBall();
                }
                // During pause, still draw but don't update game logic
                draw();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if boss spawn pause is over
            if (bossSpawnPause) {
                if (currentTime >= bossSpawnPauseEnd) {
                    bossSpawnPause = false;
                    createBosses();
                    resetBall();
                }
                // During pause, still draw but don't update game logic
                draw();
                drawBossSpawnMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if level transition pause is over
            if (levelTransitionPause) {
                if (currentTime >= levelTransitionPauseEnd) {
                    levelTransitionPause = false;
                    nextLevel();
                }
                // During pause, still draw but don't update game logic
                draw();
                drawLevelTransitionMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if extra life pause is over
            if (extraLifePause) {
                if (currentTime >= extraLifePauseEnd) {
                    extraLifePause = false;
                    // Show legendary or regular upgrade selector
                    if (pendingLegendaryUpgrade) {
                        pendingLegendaryUpgrade = false;
                        showUpgradeSelector(true); // Legendary upgrade
                    } else {
                        showUpgradeSelector();
                    }
                }
                // During pause, still draw but don't update game logic
                draw();
                drawExtraLifeMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if upgrade selection is active (pause game)
            if (upgradeSelectionActive) {
                draw();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if waiting for boss death animation (freeze ball but keep drawing)
            if (waitingForBossDeathAnimation) {
                // Update boss death particles for animation
                updateBossDeathParticles();
                
                // Check if animation is complete
                if (currentTime >= bossDeathAnimationEnd) {
                    waitingForBossDeathAnimation = false;
                    bossPhase = false;
                    startLevelTransition();
                }
                
                // Draw everything but don't move ball
                movePaddle();
                updatePaddleAnimation();
                updatePowerUps();
                drawPowerUpTimers();
                draw();
                requestAnimationFrame(update);
                return;
            }
            
            movePaddle();
            updatePaddleAnimation();
            moveBall();
            
            // Check if game ended during moveBall (lives ran out)
            if (!gameRunning) return;
            
            updatePowerUps();
            drawPowerUpTimers();
            draw();
            
            requestAnimationFrame(update);
        }

        function startGame() {
            // Show instructions with fade-in
            trackpadInstructionsEl.classList.add('visible');
            
            score = 0;
            lives = 3;
            level = 1;
            ballTemplate.speed = 5.75; // Initial speed (5% slower)
            
            // Reset boss phase
            bossPhase = false;
            bosses = [];
            bossLasers = [];
            lastGlobalLaserTime = 0;
            bossesDropping = false;
            bossDropProgress = 0;
            bossDeathParticles = [];
            waitingForBossDeathAnimation = false;
            stageClearPending = false;
            
            // Reset immunity star
            immunityStar = null;
            lastStarSpawnTime = 0;
            paddleImmunity.active = false;
            paddleImmunity.timeLeft = 0;
            
            // Reset all pause states
            lifeLostPause = false;
            bossSpawnPause = false;
            levelTransitionPause = false;
            extraLifePause = false;
            upgradeSelectionActive = false;
            preBossUpgrade = false;
            pendingLegendaryUpgrade = false;
            isLegendaryUpgrade = false;
            upgradeOverlay.classList.remove('active');
            upgradeOverlay.classList.remove('legendary');
            
            // Reset permanent upgrades (including legendary)
            permanentUpgrades = {
                paddleSizeBonus: 0,
                speedReduction: 0,
                crusherDurationBonus: 0,
                bigPaddleDurationBonus: 0,
                powerupSpawnBonus: 0,
                multiBallBounceBonus: 0,
                // Legendary upgrades
                bossDamageBonus: 0,
                dualBallStart: 0,
                magnetPaddle: false
            };
            
            // Reset smart RNG history for upgrades
            upgradeDefinitions.forEach(u => { upgradeOfferHistory[u.id] = 3; });
            
            // Activate mouse control when starting game
            mouseControlActive = true;
            
            // Reset difficulty
            paddle.width = 107;
            brickConfig.rows = 4;
            
            // Reset power-ups
            activePowerUps.bigPaddle = { active: false, timeLeft: 0, originalWidth: 107 };
            activePowerUps.multiBall = { active: false, bouncesLeft: 0 };
            activePowerUps.crusher = { active: false, timeLeft: 0 };
            activePowerUps.smallPaddle = { active: false, timeLeft: 0, originalWidth: 107 };
            powerUpBarEl.innerHTML = '';
            lastPowerUpBarContent = '';
            permanentUpgradesBarEl.innerHTML = '';
            
            // Reset ball color to white
            ballColorTransition.currentR = 255;
            ballColorTransition.currentG = 255;
            ballColorTransition.currentB = 255;
            ballColorTransition.targetR = 255;
            ballColorTransition.targetG = 255;
            ballColorTransition.targetB = 255;
            
            // Reset paddle color to cyan
            paddleColorTransition.currentR = 0;
            paddleColorTransition.currentG = 255;
            paddleColorTransition.currentB = 255;
            
            // Reset paddle border
            paddleBorderTransition.currentR = 0;
            paddleBorderTransition.currentG = 255;
            paddleBorderTransition.currentB = 255;
            paddleBorderTransition.currentAlpha = 0;
            
            // Reset skull tracking
            levelsSinceSkull = 0;
            lastLevelHadSkull = false;
            
            scoreEl.textContent = score;
            livesEl.textContent = lives;
            levelEl.textContent = level;
            
            paddle.x = gameWidth / 2 - paddle.width / 2;
            paddle.targetX = paddle.x;
            createBricks();
            resetBall();
            
            lastPowerUpTime = performance.now();
            lastFrameTime = performance.now();
            frameTime = performance.now();
            deltaMultiplier = 1; // Start with normal speed
            gameRunning = true;
            gameHasStarted = true;
            // Hide menu overlay during gameplay
            menuOverlay.classList.add('hidden');
            requestAnimationFrame(update);
        }

        // Controls (combined keyboard handler)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                paddle.dx = -paddle.speed;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                paddle.dx = paddle.speed;
            }
            if (e.key === 'Escape') {
                if (leaderboardOverlay.classList.contains('active')) {
                    hideLeaderboard();
                }
                if (scoreModal.classList.contains('active')) {
                    hideScoreModal();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') paddle.dx = 0;
        });

        // Track if mouse is controlling paddle (only when inside game area)
        let mouseControlActive = false;

        // Track mouse on document when control is active
        document.addEventListener('mousemove', (e) => {
            if (!mouseControlActive) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = gameWidth / rect.width;
            const mouseX = (e.clientX - rect.left) * scaleX;
            paddle.targetX = mouseX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > gameWidth) paddle.targetX = gameWidth - paddle.width;
        });
        
        // Activate mouse control when clicking on canvas or game container
        const gameContainer = document.querySelector('.game-container');
        gameContainer.addEventListener('mousedown', () => {
            mouseControlActive = true;
        });
        
        // Deactivate mouse control when clicking outside game container
        document.addEventListener('mousedown', (e) => {
            if (!gameContainer.contains(e.target)) {
                mouseControlActive = false;
            }
        });

        // Touch input for mobile - canvas area
        function handleTouch(e) {
            // Only work during active gameplay
            if (!gameRunning || upgradeSelectionActive) return;
            
            if (e.touches.length === 0) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = gameWidth / rect.width;
            const touch = e.touches[0];
            const touchX = (touch.clientX - rect.left) * scaleX;
            paddle.targetX = touchX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > gameWidth) paddle.targetX = gameWidth - paddle.width;
        }

        // Only add canvas touch listeners - they check gameRunning internally
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('touchmove', handleTouch, { passive: false });
        
        // Trackpad zone - maps touch X to paddle position during gameplay
        function handleTrackpad(e) {
            // Only work during active gameplay
            if (!gameRunning || upgradeSelectionActive) return;
            
            if (e.touches.length === 0) return;
            e.preventDefault();
            e.stopPropagation();
            
            const touch = e.touches[0];
            
            // Map touch X position to canvas coordinates
            const rect = canvas.getBoundingClientRect();
            const scaleX = gameWidth / rect.width;
            const touchX = (touch.clientX - rect.left) * scaleX;
            
            // Move paddle to touch position (centered on touch)
            paddle.targetX = touchX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > gameWidth) paddle.targetX = gameWidth - paddle.width;
        }
        
        // Trackpad zone handles touch events for paddle control
        trackpadZone.addEventListener('touchstart', handleTrackpad, { passive: false });
        trackpadZone.addEventListener('touchmove', handleTrackpad, { passive: false });
        
        // Magnet paddle release function
        function releaseMagnetBall() {
            if (magnetCaughtBall && magnetCaughtBall.ball && gameRunning) {
                const ball = magnetCaughtBall.ball;
                // Calculate release angle based on ball position on paddle
                let hitPoint = (ball.x - paddle.x) / paddle.width;
                let angle = (hitPoint - 0.5) * 1.6; // Max angle ~38 degrees
                
                // Launch ball upward with angle
                ball.dx = ball.speed * Math.sin(angle * Math.PI / 2);
                ball.dy = -ball.speed * Math.cos(angle * Math.PI / 2);
                
                // Ensure ball always moves upward
                if (ball.dy > -ball.speed * 0.3) {
                    ball.dy = -ball.speed * 0.3;
                    const dxMax = Math.sqrt(ball.speed * ball.speed - ball.dy * ball.dy);
                    ball.dx = Math.sign(ball.dx) * Math.min(Math.abs(ball.dx), dxMax);
                }
                
                magnetCaughtBall = null;
            }
        }
        
        // Desktop: Click to release magnet ball
        canvas.addEventListener('click', releaseMagnetBall);
        trackpadZone.addEventListener('click', releaseMagnetBall);
        
        // Mobile: Tap to release magnet ball (use touchend for tap detection)
        let magnetTapStart = null;
        trackpadZone.addEventListener('touchstart', (e) => {
            if (magnetCaughtBall && gameRunning) {
                magnetTapStart = { x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() };
            }
        }, { passive: true });
        
        trackpadZone.addEventListener('touchend', (e) => {
            if (magnetCaughtBall && gameRunning && magnetTapStart) {
                const elapsed = Date.now() - magnetTapStart.time;
                // Quick tap (under 300ms) releases the ball
                if (elapsed < 300) {
                    releaseMagnetBall();
                }
            }
            magnetTapStart = null;
        }, { passive: true });
        
        // AGGRESSIVE scroll prevention - use capture phase on document
        // This fires BEFORE any element handlers and prevents scroll at the root
        
        // Notify parent frame of touch events (for DuckDuckGo browser UI prevention)
        function notifyParentTouchStart() {
            if (window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'gameTouch', action: 'start' }, '*');
                } catch(e) {}
            }
        }
        
        function notifyParentTouchEnd() {
            if (window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'gameTouch', action: 'end' }, '*');
                } catch(e) {}
            }
        }
        
        document.addEventListener('touchstart', (e) => {
            // Notify parent frame immediately
            notifyParentTouchStart();
            
            if (e.target.closest('.game-container')) {
                // Allow interactive elements to receive touch events normally
                const isInteractive = e.target.closest('button') ||
                                     e.target.closest('input') ||
                                     e.target.closest('.upgrade-slot') ||
                                     e.target.closest('.leaderboard-close');
                if (!isInteractive) {
                    e.preventDefault();
                }
            }
        }, { passive: false, capture: true });
        
        document.addEventListener('touchend', (e) => {
            // Notify parent frame
            notifyParentTouchEnd();
        }, { passive: true, capture: true });
        
        document.addEventListener('touchcancel', (e) => {
            // Notify parent frame
            notifyParentTouchEnd();
        }, { passive: true, capture: true });
        
        document.addEventListener('touchmove', (e) => {
            // Prevent scroll on game container and modals
            if (e.target.closest('.game-container') ||
                e.target.closest('.score-modal') ||
                e.target.closest('.leaderboard-overlay')) {
                // Allow leaderboard list scrolling only
                if (e.target.closest('.leaderboard-list')) {
                    return;
                }
                e.preventDefault();
            }
        }, { passive: false, capture: true });

        // Start button - support both click and touch with capture phase for priority
        startBtn.addEventListener('click', startGame);
        
        // Use capture phase to ensure button gets touch events first
        startBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.stopImmediatePropagation();
        }, { passive: true, capture: true });
        
        startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            startGame();
        }, { passive: false, capture: true });

        // Create display-only bricks (no power-ups or debuffs) for pre-game view
        function createDisplayBricks() {
            bricks = [];
            for (let row = 0; row < brickConfig.rows; row++) {
                bricks[row] = [];
                for (let col = 0; col < brickConfig.cols; col++) {
                    bricks[row][col] = {
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop,
                        alive: true,
                        color: neonColors[row % neonColors.length],
                        powerUp: null,
                        debuff: null,
                        twinkleOffset: Math.random() * Math.PI * 2
                    };
                }
            }
        }

        // Initial setup - show plain bricks before game starts
        // Ball velocity normalized: 5.75 * 0.707 ‚âà 4.07 for 45-degree angle
        balls = [createBall(320, 447, 4.07, -4.07, 5.75)];
        createDisplayBricks(); // Plain bricks for display
        draw();
        
        // ========== HIGH SCORE SYSTEM ==========
        
        // ===== FIREBASE CONFIGURATION =====
        // BOO Website Game Leaderboard
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase (only if config is set)
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ===== PROFANITY FILTER =====
        // Common slurs and profanity in English, Spanish, French, German
        // This list is intentionally obfuscated and comprehensive
        const blockedPatterns = [
            // English
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i, /\bc+h+i+n+k/i,
            /\bs+p+i+c+/i, /\bk+i+k+e/i, /\bg+o+o+k/i, /\bw+e+t+b+a+c+k/i, /\btr+a+n+n+y/i,
            /\bd+y+k+e/i, /\bp+a+k+i/i, /\bt+w+a+t/i, /\bw+a+n+k/i, /\bp+r+i+c+k/i,
            /\bb+o+l+l+o+c+k/i, /\ba+r+s+e/i, /\bb+u+g+g+e+r/i, /\bc+r+a+p/i, /\bd+a+m+n/i,
            // Spanish  
            /\bp+u+t+a/i, /\bm+i+e+r+d+a/i, /\bc+a+b+r+[o√≥]+n/i, /\bp+e+n+d+e+j+o/i,
            /\bc+h+i+n+g+a/i, /\bj+o+d+e+r/i, /\bc+o+[√±n]+o/i, /\bm+a+r+i+c+[o√≥]+n/i,
            /\bn+e+g+r+o+.+m+i+e+r+d+a/i, /\bp+i+n+c+h+e/i,
            // French
            /\bm+e+r+d+e/i, /\bp+u+t+a+i+n/i, /\bs+a+l+o+p/i, /\bb+o+r+d+e+l/i,
            /\be+n+c+u+l+[e√©]/i, /\bn+[i√Æ]+q+u+e/i, /\bc+o+n+n+a+r+d/i, /\bb+i+t+e/i,
            /\bn+[√®e]+g+r+e/i,
            // German
            /\bs+c+h+e+i+[s√ü]+e/i, /\bf+i+c+k/i, /\bh+u+r+e/i, /\ba+r+s+c+h/i,
            /\bw+i+c+h+s/i, /\bs+c+h+l+a+m+p+e/i, /\bn+e+g+e+r/i, /\bk+a+n+a+k/i,
            // Hindi/Indian
            /b+h*e+n+.?c+h+o+d/i, /m+a+d+a*r+.?c+h+o+d/i, /c+h+u+t+i+y+a/i,
            /g+a+n+d+u/i, /l+u+n+d/i, /r+a+n+d+i/i, /h+a+r+a+m+i/i,
            /b+h+o+s+d+/i, /c+h+u+t+/i, /g+a+a+n+d/i, /l+o+d+e/i,
            // Numeric/Leet substitutions
            /n+[1i]+g+/i, /f+[4a]+g+/i, /a+[5s]+[5s]+/i, /[5s]+h+[1i]+t/i,
            /\b6+9+\b/, /\b4+2+0+\b/,
            // Catch common evasions
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i, /b.?h.?e.?n.?c.?h.?o.?d/i
        ];
        
        // Additional blocked exact words
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'nip', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'anus', 'homo',
            'bc', 'mc', 'lodu', 'chut', 'gand', 'lund', 'randi'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            
            // Normalize: lowercase, remove special chars except alphanumeric
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            
            // Check exact matches
            if (blockedExact.has(normalized)) return true;
            
            // Check patterns against both normalized and original
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function sanitizeUsername(name) {
            // Remove leading/trailing whitespace, limit to 12 chars, uppercase
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ===== SCORE SUBMISSION =====
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const finalLevelDisplay = document.getElementById('finalLevelDisplay');
        
        let pendingScore = 0;
        let pendingLevel = 1;
        
        async function showScoreModal(finalScore, finalLevel) {
            // Clear canvas - hide game over text behind modal
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            pendingScore = finalScore;
            pendingLevel = finalLevel;
            finalScoreDisplay.textContent = finalScore;
            finalLevelDisplay.textContent = finalLevel;
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
            submitScoreBtn.disabled = false;
            
            // Check rank against existing scores
            let rank = await getScoreRank(finalScore);
            
            // Update title based on rank
            if (rank === 1) {
                scoreModalTitle.textContent = "üëë YOU'RE #1 üëë";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'HIGH SCORE';
            }
            
            scoreModal.classList.add('active');
            
            // Focus input after brief delay (for mobile keyboards)
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        // Get the rank this score would achieve
        async function getScoreRank(playerScore) {
            try {
                let scores = [];
                
                if (firebaseReady && db) {
                    // Fetch from Firebase
                    const snapshot = await db.collection('highscores')
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => {
                        scores.push(doc.data().score);
                    });
                } else {
                    // Use local scores
                    const localScores = getLocalScores();
                    scores = localScores.map(s => s.score);
                }
                
                // Find where this score would rank
                let rank = 1;
                for (const existingScore of scores) {
                    if (playerScore <= existingScore) {
                        rank++;
                    } else {
                        break;
                    }
                }
                
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999; // Default to non-top-10 on error
            }
        }
        
        // Prevent score modal touches from propagating
        scoreModal.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true });
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
            
            // Show buttons after score modal closes (game over screen already drawn)
            if (!gameRunning) {
                showGameOverButtons();
            }
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            // Validation
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection('highscores').add({
                        name: username,
                        score: pendingScore,
                        level: pendingLevel,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    scoreErrorMsg.textContent = '';
                } else {
                    // Offline mode - save to localStorage
                    saveLocalScore(username, pendingScore, pendingLevel);
                }
                
                hideScoreModal();
                
            } catch (e) {
                console.warn('Score submission failed:', e);
                // Fallback to local storage
                saveLocalScore(username, pendingScore, pendingLevel);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        // Local storage fallback
        function saveLocalScore(name, score, level) {
            try {
                const scores = JSON.parse(localStorage.getItem('brickbreaker_scores') || '[]');
                scores.push({ name, score, level, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem('brickbreaker_scores', JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem('brickbreaker_scores') || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Event listeners for score modal
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            submitScore();
        }, { passive: false, capture: true });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideScoreModal();
        }, { passive: false, capture: true });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitScore();
            }
            if (e.key === 'Escape') {
                hideScoreModal();
            }
        });
        
        // Clear error on input
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ===== LEADERBOARD =====
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            try {
                let scores = [];
                
                if (firebaseReady && db) {
                    // Fetch from Firebase
                    const snapshot = await db.collection('highscores')
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    
                    snapshot.forEach(doc => {
                        scores.push(doc.data());
                    });
                } else {
                    // Use local scores
                    scores = getLocalScores();
                }
                
                renderLeaderboard(scores);
                
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                // Fallback to local
                renderLeaderboard(getLocalScores());
            }
        }
        
        function renderLeaderboard(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            scores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                        <div class="leaderboard-level">Lv.${entry.level}</div>
                    </div>
                `;
            });
            
            leaderboardList.innerHTML = html;
        }
        
        // Cached element for HTML escaping
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        leaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardClose.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        
        // Touch handler for close button (iOS Safari needs this)
        leaderboardClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideLeaderboard();
        }, { passive: false, capture: true });
        
        // Close leaderboard on overlay click/touch (not content)
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) {
                hideLeaderboard();
            }
        });
        
        // Prevent leaderboard touches from propagating to game
        leaderboardOverlay.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true });
        
        leaderboardOverlay.addEventListener('touchend', (e) => {
            if (e.target === leaderboardOverlay) {
                e.preventDefault();
                hideLeaderboard();
            }
        }, { passive: false });
        
        // ===== TUTORIAL SYSTEM =====
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialClose = document.getElementById('tutorialClose');
        const tutorialPrev = document.getElementById('tutorialPrev');
        const tutorialNext = document.getElementById('tutorialNext');
        const tutorialDots = document.getElementById('tutorialDots');
        const tutorialSteps = document.querySelectorAll('.tutorial-step');
        
        let currentTutorialStep = 0;
        const totalSteps = tutorialSteps.length;
        
        function initTutorialDots() {
            tutorialDots.innerHTML = '';
            for (let i = 0; i < totalSteps; i++) {
                const dot = document.createElement('div');
                dot.className = 'tutorial-dot' + (i === 0 ? ' active' : '');
                dot.addEventListener('click', () => goToTutorialStep(i));
                tutorialDots.appendChild(dot);
            }
        }
        
        function updateTutorialStep() {
            tutorialSteps.forEach((step, i) => {
                step.classList.toggle('active', i === currentTutorialStep);
            });
            
            const dots = tutorialDots.querySelectorAll('.tutorial-dot');
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === currentTutorialStep);
            });
            
            tutorialPrev.disabled = currentTutorialStep === 0;
            tutorialNext.textContent = currentTutorialStep === totalSteps - 1 ? 'DONE' : 'NEXT ‚Üí';
        }
        
        function goToTutorialStep(step) {
            currentTutorialStep = Math.max(0, Math.min(totalSteps - 1, step));
            updateTutorialStep();
        }
        
        function showTutorial() {
            currentTutorialStep = 0;
            initTutorialDots();
            updateTutorialStep();
            tutorialOverlay.classList.add('active');
        }
        
        function hideTutorial() {
            tutorialOverlay.classList.remove('active');
        }
        
        // Tutorial button listeners
        tutorialBtn.addEventListener('click', showTutorial);
        tutorialBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showTutorial();
        }, { passive: false, capture: true });
        
        tutorialClose.addEventListener('click', hideTutorial);
        tutorialClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideTutorial();
        }, { passive: false, capture: true });
        
        tutorialPrev.addEventListener('click', () => goToTutorialStep(currentTutorialStep - 1));
        tutorialPrev.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            goToTutorialStep(currentTutorialStep - 1);
        }, { passive: false, capture: true });
        
        tutorialNext.addEventListener('click', () => {
            if (currentTutorialStep === totalSteps - 1) {
                hideTutorial();
            } else {
                goToTutorialStep(currentTutorialStep + 1);
            }
        });
        tutorialNext.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (currentTutorialStep === totalSteps - 1) {
                hideTutorial();
            } else {
                goToTutorialStep(currentTutorialStep + 1);
            }
        }, { passive: false, capture: true });
        
        tutorialOverlay.addEventListener('click', (e) => {
            if (e.target === tutorialOverlay) hideTutorial();
        });
        
        tutorialOverlay.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        tutorialOverlay.addEventListener('touchend', (e) => {
            if (e.target === tutorialOverlay) {
                e.preventDefault();
                hideTutorial();
            }
        }, { passive: false });
    </script>
</body>
</html>
