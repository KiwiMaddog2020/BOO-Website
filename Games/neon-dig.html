<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Goldmine</title>
    <script>
        // Immediate iframe detection - runs before CSS layout
        if (window.self !== window.top) {
            document.documentElement.classList.add('in-iframe');
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600;700;800&family=Exo+2:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --cyan: #00f0ff;
            --cyan-dim: #00a0aa;
            --magenta: #ff00ff;
            --magenta-dim: #aa00aa;
            --orange: #ff9500;
            --green: #00ff88;
            --bg-deep: #020408;
            --bg-card: rgba(8, 12, 20, 0.85);
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --scale: 1;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            height: 100dvh;
            background: var(--bg-deep);
            font-family: 'Exo 2', sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: 
                linear-gradient(90deg, rgba(0, 240, 255, 0.02) 1px, transparent 1px),
                linear-gradient(rgba(0, 240, 255, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: -1;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: fit-content;
            height: fit-content;
            max-width: 100vw;
            max-height: 100vh;
            max-height: 100dvh;
            touch-action: none;
            position: relative;
            overflow: hidden;
            background: linear-gradient(160deg, rgba(10, 15, 25, 0.95) 0%, rgba(5, 8, 15, 0.98) 100%);
            border: 3px solid #0ff;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            border-radius: 12px;
            box-sizing: border-box;
        }

        /* Fullscreen/iframe mode: center content */
        .game-container.fullscreen-mode {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0;
        }
        
        /* Fullscreen body centering - JS adds this class */
        body.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            overflow: hidden !important;
        }
        
        /* Force fullscreen layout when in iframe (CSS kicks in immediately) */
        html.in-iframe body {
            align-items: flex-start;
        }
        
        html.in-iframe .game-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(0deg, rgba(0, 15, 25, 0.9) 0%, rgba(0, 10, 18, 0.95) 100%);
            border-top: 1px solid rgba(0, 240, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            order: 1;
        }

        .hud-item { display: flex; flex-direction: column; gap: 2px; }

        .hud-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .hud-value {
            color: var(--cyan);
            font-family: 'Oxanium', monospace;
            font-size: 20px;
            font-weight: 400;
            text-shadow: 0 0 20px var(--cyan);
            letter-spacing: -0.5px;
        }

        .hud-value.score { 
            color: var(--magenta); 
            text-shadow: 0 0 20px var(--magenta);
            font-family: 'Oxanium', monospace;
            font-size: 20px;
            font-weight: 400;
        }

        .hud-center { 
            display: flex; 
            align-items: center; 
            justify-content: center;
            gap: 36px; 
        }

        .bar-container { display: flex; flex-direction: column; gap: 4px; align-items: center; }

        .fuel-bar-wrapper { position: relative; width: 180px; height: 28px; }

        .hull-bar-wrapper { position: relative; width: 180px; height: 28px; }

        .hull-bar {
            width: 100%; height: 100%;
            background: rgba(0, 240, 255, 0.1);
            border: 2px solid rgba(0, 240, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .hull-fill {
            height: 100%;
            background: linear-gradient(90deg, #00aacc, #00f0ff, #66ffff);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
        }

        .hull-bar.critical .hull-fill {
            background: linear-gradient(90deg, #ff0033, #ff4400);
            animation: criticalPulse 0.6s ease-in-out infinite;
        }

        .hull-percent {
            position: absolute;
            left: 50%; 
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            color: rgba(0, 0, 0, 0.85);
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .fuel-bar {
            width: 100%; height: 100%;
            background: rgba(255, 150, 0, 0.1);
            border: 2px solid rgba(255, 150, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .fuel-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4400, #ff9500, #ffcc00);
            box-shadow: 0 0 15px rgba(255, 150, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
        }

        .fuel-bar.critical .fuel-fill {
            background: linear-gradient(90deg, #ff0033, #ff4400);
            animation: criticalPulse 0.6s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 15px rgba(255, 0, 50, 0.5); }
            50% { opacity: 0.7; box-shadow: 0 0 25px rgba(255, 0, 50, 0.8); }
        }

        .fuel-percent {
            position: absolute;
            left: 50%; 
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            color: rgba(0, 0, 0, 0.85);
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            touch-action: manipulation;
        }

        .menu-overlay.hidden {
            display: none;
            pointer-events: none;
        }

        .game-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 10px #ffcc00, 0 0 25px #ffcc00, 0 0 50px rgba(255, 204, 0, 0.5);
            margin-bottom: 10px;
            letter-spacing: 4px;
            text-align: center;
        }

        .game-subtitle {
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-bottom: 40px;
            text-align: center;
        }

        .menu-buttons { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            align-items: center;
            margin-top: 15px;
        }

        .menu-btn {
            padding: 10px 20px;
            width: 160px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            touch-action: manipulation;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .menu-btn:hover {
            background: #0ff;
            color: #000;
        }

        .menu-btn.btn-tutorial {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 8px #f0f;
        }

        .menu-btn.btn-tutorial:hover {
            background: #f0f;
            color: #000;
        }

        .menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }

        .menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
        }

        .game-btn {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Oxanium', monospace;
            background: transparent;
            border: 2px solid var(--cyan);
            border-radius: 6px;
            color: var(--cyan);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px var(--cyan);
            text-align: center;
            letter-spacing: 2px;
        }

        .game-btn:hover {
            background: var(--cyan);
            color: #000;
            box-shadow: 0 0 20px var(--cyan);
        }

        .control-zone {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100px;
            min-height: 100px;
            padding: 10px 16px 14px;
            touch-action: none;
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(5, 12, 20, 0.9) 0%, rgba(2, 8, 15, 0.95) 100%);
            border-top: 1px solid rgba(0, 240, 255, 0.08);
            gap: 8px;
            order: 2;
        }

        .control-instructions {
            font-size: 10px;
            color: rgba(0, 240, 255, 0.3);
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 500;
            display: none;
        }

        .control-instructions.visible {
            display: block;
        }

        .permanent-upgrades {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 5px;
            width: 100%;
            pointer-events: none;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 240, 255, 0.08);
        }

        .perm-upgrade {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 32px; height: 32px;
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.08) 0%, rgba(0, 240, 255, 0.02) 100%);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 8px;
        }

        .perm-icon { font-size: 15px; filter: drop-shadow(0 0 6px currentColor); }

        .perm-stack {
            position: absolute;
            bottom: -3px; right: -3px;
            font-size: 9px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: #fff;
            background: rgba(0, 0, 0, 0.85);
            padding: 2px 5px;
            border-radius: 6px;
            border: 1px solid currentColor;
            line-height: 1;
        }

        .upgrade-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(5, 15, 30, 0.97) 0%, rgba(2, 5, 12, 0.99) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
            touch-action: manipulation;
            pointer-events: none;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .upgrade-overlay.active { display: flex; pointer-events: auto; }

        .upgrade-header { text-align: center; margin-bottom: 24px; }

        .upgrade-title {
            font-size: 26px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: var(--cyan);
            text-shadow: 0 0 40px var(--cyan), 0 0 80px var(--cyan);
            letter-spacing: 6px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        .upgrade-subtitle {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 13px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        @keyframes titlePulse {
            0%, 100% { opacity: 1; filter: brightness(1); }
            50% { opacity: 0.9; filter: brightness(1.2); }
        }

        .upgrade-slots { display: flex; gap: 14px; }

        .upgrade-slot {
            width: 125px; height: 165px;
            background: linear-gradient(170deg, rgba(15, 20, 35, 0.95) 0%, rgba(8, 10, 20, 0.98) 100%);
            border: 1px solid rgba(60, 70, 100, 0.3);
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.03);
            -webkit-tap-highlight-color: transparent;
        }

        .upgrade-slot::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 40%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02) 0%, transparent 100%);
            pointer-events: none;
        }

        .upgrade-slot.rolling { pointer-events: none; }
        .upgrade-slot.rolling .upgrade-content { animation: slotRoll 0.12s ease-in-out infinite; }

        @keyframes slotRoll {
            0%, 100% { opacity: 0.4; transform: translateY(0) scale(0.98); }
            50% { opacity: 0.8; transform: translateY(-3px) scale(1); }
        }

        .upgrade-slot.revealed {
            border-color: rgba(0, 240, 255, 0.5);
            box-shadow: 0 0 35px rgba(0, 240, 255, 0.2), 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .upgrade-slot.revealed:hover {
            transform: translateY(-10px) scale(1.03);
            border-color: var(--cyan);
            box-shadow: 0 0 50px rgba(0, 240, 255, 0.35), 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .upgrade-slot.selected {
            border-color: var(--green);
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.5);
            transform: scale(1.05);
        }

        .upgrade-slot.legendary { border-color: rgba(255, 0, 255, 0.5); box-shadow: 0 0 40px rgba(255, 0, 255, 0.25); }
        .upgrade-slot.legendary.revealed:hover { box-shadow: 0 0 55px rgba(255, 0, 255, 0.45); }
        .upgrade-overlay.legendary .upgrade-title { color: var(--magenta); text-shadow: 0 0 40px var(--magenta), 0 0 80px var(--magenta); }
        
        /* Chest upgrade style */
        .upgrade-overlay.chest .upgrade-title { color: #ffd700; text-shadow: 0 0 40px #ffd700, 0 0 80px #ff9500; }
        .upgrade-slot.chest { border-color: rgba(255, 215, 0, 0.5); box-shadow: 0 0 40px rgba(255, 215, 0, 0.25); }
        .upgrade-slot.chest.revealed { border-color: rgba(255, 215, 0, 0.7); box-shadow: 0 0 50px rgba(255, 215, 0, 0.35); }
        .upgrade-slot.chest.revealed:hover { box-shadow: 0 0 60px rgba(255, 215, 0, 0.5); border-color: #ffd700; }

        .upgrade-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 18px 10px;
            width: 100%; height: 100%;
            position: relative;
            z-index: 1;
        }

        .upgrade-icon { font-size: 38px; margin-bottom: 12px; filter: drop-shadow(0 0 15px currentColor); }
        .upgrade-name { font-size: 12px; font-weight: 700; font-family: 'Oxanium', monospace; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255,255,255,0.4); }
        .upgrade-desc { font-size: 10px; color: rgba(255, 255, 255, 0.5); line-height: 1.4; }

        @media (max-width: 500px) {
            .upgrade-slot { width: 100px; height: 145px; }
            .upgrade-icon { font-size: 30px; }
            .upgrade-name { font-size: 10px; }
            .upgrade-desc { font-size: 9px; }
            .upgrade-title { font-size: 20px; letter-spacing: 4px; }
            .upgrade-slots { gap: 8px; }
            .hud { padding: 12px 14px; }
            .hud-value { font-size: 18px; }
            /* Mobile HUD bar scaling */
            .hud-center { gap: 12px; }
            .fuel-bar-wrapper, .hull-bar-wrapper { width: 100px; height: 24px; }
            .fuel-percent, .hull-percent { font-size: 12px; }
            .hud-label { font-size: 9px; letter-spacing: 1px; }
            .control-zone { height: 95px; min-height: 95px; }
            .menu-btn, .game-btn { padding: 8px 16px; font-size: 12px; width: 140px; }
            .game-title { font-size: 32px; letter-spacing: 2px; }
            .game-subtitle { font-size: 14px; margin-bottom: 30px; }
            .menu-subtitle { font-size: 11px; margin-bottom: 25px; }
            .leaderboard-container { padding: 15px; }
            .leaderboard-title { font-size: 20px; }
            .score-modal-content { padding: 20px; }
            .score-modal-title { font-size: 20px; }
        }

        /* Leaderboard Overlay */
        .leaderboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid var(--cyan);
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.3);
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 240, 255, 0.3);
        }
        
        .leaderboard-title {
            font-size: 24px;
            font-family: 'Oxanium', monospace;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            letter-spacing: 2px;
        }
        
        .leaderboard-close {
            width: 32px;
            height: 32px;
            background: transparent;
            border: 2px solid #ff3366;
            border-radius: 50%;
            color: #ff3366;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .leaderboard-close:hover {
            background: #ff3366;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .leaderboard-list::-webkit-scrollbar { width: 6px; }
        .leaderboard-list::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); border-radius: 3px; }
        .leaderboard-list::-webkit-scrollbar-thumb { background: var(--cyan); border-radius: 3px; }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .leaderboard-row:hover {
            background: rgba(0, 240, 255, 0.1);
        }
        
        .leaderboard-row.top-3 {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .leaderboard-rank {
            font-size: 14px;
            font-weight: bold;
            color: #888;
            min-width: 40px;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank { font-size: 16px; }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 14px;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .leaderboard-score {
            font-size: 15px;
            font-weight: bold;
            color: var(--cyan);
            min-width: 70px;
            text-align: right;
        }
        
        .leaderboard-depth {
            font-size: 12px;
            color: #888;
            min-width: 50px;
            text-align: right;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }
        
        .leaderboard-error { color: #ff3366; }

        /* Score Modal */
        .score-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-content {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid var(--magenta);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.3);
            max-width: 350px;
            width: 90%;
        }
        
        .score-modal-title {
            font-size: 24px;
            font-family: 'Oxanium', monospace;
            color: var(--magenta);
            text-shadow: 0 0 20px var(--magenta);
            margin-bottom: 15px;
            letter-spacing: 2px;
        }
        
        .score-stats {
            font-size: 16px;
            color: #fff;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .score-stats span {
            color: var(--cyan);
            font-weight: bold;
        }
        
        .score-input-label {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }
        
        .score-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--cyan);
            border-radius: 8px;
            color: #fff;
            text-transform: uppercase;
            margin-bottom: 10px;
            outline: none;
        }
        
        .score-input:focus {
            border-color: var(--magenta);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }
        
        .score-input.error {
            border-color: #ff3366;
            animation: inputShake 0.3s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .score-error {
            font-size: 12px;
            color: #ff3366;
            margin-bottom: 10px;
            min-height: 18px;
        }
        
        .score-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .score-btn {
            padding: 12px 25px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Oxanium', monospace;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 1px;
        }
        
        .score-btn.submit {
            background: linear-gradient(180deg, var(--cyan), #00a0aa);
            border-color: var(--cyan);
            color: #000;
        }
        
        .score-btn.submit:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5);
        }
        
        .score-btn.skip {
            background: transparent;
            border-color: #666;
            color: #888;
        }
        
        .score-btn.skip:hover {
            border-color: #999;
            color: #fff;
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .tutorial-overlay.active { display: flex; }
        
        .tutorial-container {
            position: relative;
            background: linear-gradient(145deg, #0a1520, #050a10);
            border: 2px solid var(--cyan);
            border-radius: 12px;
            padding: 20px 24px;
            max-width: 380px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.2);
        }
        
        .tutorial-title {
            font-size: 20px;
            font-family: 'Oxanium', monospace;
            color: var(--cyan);
            text-shadow: 0 0 20px var(--cyan);
            margin-bottom: 16px;
            letter-spacing: 3px;
        }
        
        .tutorial-step {
            display: none;
            animation: tutorialFadeIn 0.3s ease-out;
        }
        
        .tutorial-step.active { display: block; }
        
        @keyframes tutorialFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .tutorial-icon { font-size: 40px; margin-bottom: 12px; }
        
        .tutorial-heading {
            font-size: 16px;
            font-family: 'Oxanium', monospace;
            color: #fff;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .tutorial-text {
            font-size: 13px;
            font-family: 'Exo 2', sans-serif;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.5;
            margin-bottom: 16px;
        }
        
        .tutorial-highlight {
            color: var(--cyan);
            font-weight: 600;
        }
        
        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 240, 255, 0.15);
        }
        
        .tutorial-nav-btn {
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-prev {
            background: transparent;
            border-color: #555;
            color: #888;
        }
        
        .tutorial-prev:hover { border-color: #888; color: #fff; }
        .tutorial-prev:disabled { opacity: 0.3; cursor: not-allowed; }
        
        .tutorial-next {
            background: linear-gradient(180deg, var(--cyan), #00a0aa);
            border-color: var(--cyan);
            color: #000;
        }
        
        .tutorial-next:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
        }
        
        .tutorial-dots { display: flex; gap: 6px; }
        
        .tutorial-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .tutorial-dot.active {
            background: var(--cyan);
            box-shadow: 0 0 8px var(--cyan);
        }
        
        .tutorial-close {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            background: transparent;
            border: 2px solid #ff3366;
            border-radius: 50%;
            color: #ff3366;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tutorial-close:hover { background: #ff3366; color: #000; }
    </style>
</head>
<body>
    <div class="menu-overlay" id="menuOverlay">
        <div class="game-title">GOLDMINE</div>
        <div class="game-subtitle">Dig Deep ‚Ä¢ Collect Riches ‚Ä¢ Upgrade & Survive</div>
        <div class="menu-buttons">
            <button class="menu-btn" id="startBtn">START</button>
            <button class="menu-btn btn-tutorial" id="tutorialBtn">HOW TO PLAY</button>
            <button class="menu-btn btn-leaderboard" id="leaderboardBtn">LEADER BOARD</button>
        </div>
    </div>
    <div class="game-wrapper">
        <div class="game-container">
        <div class="hud">
            <div class="hud-item">
                <div class="hud-label">Depth</div>
                <div class="hud-value"><span id="depth">0</span>m</div>
            </div>
            <div class="hud-center">
                <div class="bar-container">
                    <div class="hud-label">Fuel</div>
                    <div class="fuel-bar-wrapper">
                        <div class="fuel-bar" id="fuelBarContainer">
                            <div class="fuel-fill" id="fuelBar" style="width: 100%"></div>
                        </div>
                        <span class="fuel-percent" id="fuelPercent">100</span>
                    </div>
                </div>
                <div class="bar-container">
                    <div class="hud-label">Hull</div>
                    <div class="hull-bar-wrapper">
                        <div class="hull-bar" id="hullBarContainer">
                            <div class="hull-fill" id="hullBar" style="width: 100%"></div>
                        </div>
                        <span class="hull-percent" id="hullPercent">100</span>
                    </div>
                </div>
            </div>
            <div class="hud-item" style="align-items: flex-end;">
                <div class="hud-label">Score</div>
                <div class="hud-value score" id="score">0</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="448" height="480"></canvas>

        <div class="control-zone" id="controlZone">
            <div class="control-instructions" id="controlInstructions">Arrow Keys / WASD ‚Ä¢ Swipe on mobile</div>
            <div class="permanent-upgrades" id="permUpgrades"></div>
        </div>

        <div class="upgrade-overlay" id="upgradeOverlay">
            <div class="upgrade-header">
                <div class="upgrade-title">UPGRADE</div>
                <div class="upgrade-subtitle">Choose your enhancement</div>
            </div>
            <div class="upgrade-slots">
                <div class="upgrade-slot" id="slot1"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
                <div class="upgrade-slot" id="slot2"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
                <div class="upgrade-slot" id="slot3"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
            </div>
        </div>

        <div class="leaderboard-overlay" id="leaderboardOverlay">
            <div class="leaderboard-container">
                <div class="leaderboard-header">
                    <div class="leaderboard-title">HIGH SCORES</div>
                    <button class="leaderboard-close" id="leaderboardClose">‚úï</button>
                </div>
                <div class="leaderboard-list" id="leaderboardList"></div>
            </div>
        </div>

        <div class="score-modal" id="scoreModal">
            <div class="score-modal-content">
                <div class="score-modal-title">RUN COMPLETE</div>
                <div class="score-stats" id="finalScore">0</div>
                <label class="score-input-label">Enter your name for the leaderboard</label>
                <input type="text" class="score-input" id="usernameInput" placeholder="YOUR NAME" maxlength="12">
                <div class="score-error" id="scoreError"></div>
                <div class="score-buttons">
                    <button class="score-btn submit" id="submitScoreBtn">SAVE</button>
                    <button class="score-btn skip" id="skipScoreBtn">SKIP</button>
                </div>
            </div>
        </div>

        <!-- Tutorial Overlay -->
        <div class="tutorial-overlay" id="tutorialOverlay">
            <div class="tutorial-container">
                <button class="tutorial-close" id="tutorialClose">‚úï</button>
                <div class="tutorial-title">üìñ HOW TO PLAY</div>
                
                <div class="tutorial-step active" data-step="0">
                    <div class="tutorial-icon">üéÆ</div>
                    <div class="tutorial-heading">Controls</div>
                    <div class="tutorial-text">
                        <strong>Mobile:</strong> Swipe in any direction to move and dig.<br><br>
                        <strong>Desktop:</strong> Use <span class="tutorial-highlight">Arrow Keys</span> or <span class="tutorial-highlight">WASD</span> to move.
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="1">
                    <div class="tutorial-icon">‚õèÔ∏è</div>
                    <div class="tutorial-heading">Dig & Collect</div>
                    <div class="tutorial-text">
                        Dig through colored blocks to find treasures:<br>
                        <span class="tutorial-highlight">üü§ Dirt</span> - Easy to dig<br>
                        <span class="tutorial-highlight">ÔøΩite;ü™® Rock</span> - Generates heat<br>
                        <span class="tutorial-highlight">üíé Gems</span> - Worth points!<br>
                        Deeper gems = higher value!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="2">
                    <div class="tutorial-icon">‚õΩ</div>
                    <div class="tutorial-heading">Fuel & Hull</div>
                    <div class="tutorial-text">
                        <span class="tutorial-highlight">üü° Yellow Bar</span> = Fuel (drains as you move)<br>
                        <span class="tutorial-highlight">üîµ Cyan Bar</span> = Hull HP<br><br>
                        Return to the <span class="tutorial-highlight">üè† surface station</span> to refuel and repair!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="3">
                    <div class="tutorial-icon">‚ö†Ô∏è</div>
                    <div class="tutorial-heading">Hazards</div>
                    <div class="tutorial-text">
                        <span class="tutorial-highlight">üî• Lava</span> - Burns your hull!<br>
                        <span class="tutorial-highlight">‚òÅÔ∏è Toxic Gas</span> - Damages over time<br>
                        <span class="tutorial-highlight">üå°Ô∏è Overheat</span> - Drill too much rock = cooldown<br><br>
                        Surface cools your drill faster!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="4">
                    <div class="tutorial-icon">üéÅ</div>
                    <div class="tutorial-heading">Special Blocks</div>
                    <div class="tutorial-text">
                        <span class="tutorial-highlight">üí£ Bombs</span> - Clear area, reveal hidden gems<br>
                        <span class="tutorial-highlight">üì¶ Chests</span> - Bonus rewards<br>
                        <span class="tutorial-highlight">‚ö° Upgrade Chests</span> - Free upgrades!<br>
                        <span class="tutorial-highlight">‚õΩ Fuel Cans</span> - Emergency refuel
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="5">
                    <div class="tutorial-icon">‚¨ÜÔ∏è</div>
                    <div class="tutorial-heading">Upgrades</div>
                    <div class="tutorial-text">
                        Every <span class="tutorial-highlight">50m depth</span>, choose 1 of 3 upgrades:<br><br>
                        üõ°Ô∏è Hull capacity<br>
                        ‚õΩ Fuel efficiency<br>
                        ‚ùÑÔ∏è Heat sink<br>
                        üí™ Drill power<br>
                        ...and more!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="6">
                    <div class="tutorial-icon">üêõ</div>
                    <div class="tutorial-heading">Creatures</div>
                    <div class="tutorial-text">
                        Below <span class="tutorial-highlight">50m</span>, enemies appear!<br><br>
                        <span class="tutorial-highlight">ü™± Worms</span> - Burrow toward you<br>
                        <span class="tutorial-highlight">ü™≤ Beetles</span> - Patrol tunnels<br>
                        <span class="tutorial-highlight">üî• Lava Slugs</span> - Lurk in hot zones<br><br>
                        Drill into them to defeat them!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="7">
                    <div class="tutorial-icon">üåü</div>
                    <div class="tutorial-heading">Fever Mode</div>
                    <div class="tutorial-text">
                        Build a <span class="tutorial-highlight">10x combo</span> by collecting gems quickly!<br><br>
                        ‚ú® <strong>FEVER MODE:</strong><br>
                        ‚Ä¢ 2x points<br>
                        ‚Ä¢ Half fuel cost<br>
                        ‚Ä¢ Reduced heat buildup<br>
                        Lasts 10 seconds!
                    </div>
                </div>
                
                <div class="tutorial-nav">
                    <button class="tutorial-nav-btn tutorial-prev" id="tutorialPrev">‚Üê Back</button>
                    <div class="tutorial-dots" id="tutorialDots"></div>
                    <button class="tutorial-nav-btn tutorial-next" id="tutorialNext">Next ‚Üí</button>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
    (function() {
        'use strict';
        
        // ==================== FIREBASE CONFIGURATION ====================
        const firebaseConfig = {
            apiKey: "AIzaSyCDod9eY_pubWR02GohtHK6M3O2IzLOVKs",
            authDomain: "bunch-of-others-games.firebaseapp.com",
            projectId: "bunch-of-others-games",
            storageBucket: "bunch-of-others-games.firebasestorage.app",
            messagingSenderId: "421079709042",
            appId: "1:421079709042:web:17105e8dac21669e9e4f36"
        };
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        const SCORES_COLLECTION = 'neondig_scores';
        
        // Initialize Firebase (only if config is set)
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        
        // Start loading Firebase
        loadFirebaseSDK();
        
        // ==================== CONSTANTS ====================
        const TILE_SIZE = 28;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
        const MAX_PARTICLES = 150;
        const MAX_FLOATING_TEXTS = 30;
        const WORLD_BUFFER_ROWS = 60;
        const WORLD_TRIM_THRESHOLD = 100;
        
        // Base canvas dimensions (logical size)
        const BASE_WIDTH = 448;
        const BASE_HEIGHT = 500;
        let renderScale = 1;
        
        // iOS canvas memory limit: 16,777,216 pixels max (approx 4096x4096)
        const MAX_CANVAS_PIXELS = 16777216;
        
        // Tile types
        const TILE = Object.freeze({
            AIR: 0, DIRT: 1, ROCK: 2, HARD_ROCK: 3,
            GEM_COMMON: 4, GEM_RARE: 5, GEM_EPIC: 6,
            LAVA: 7, GAS: 8, FUEL: 9,
            BOMB: 10, CHEST: 11, UNSTABLE: 12, BEDROCK: 13,
            UPGRADE_CHEST: 14
        });
        
        // Surface refuel settings
        const SURFACE_REFUEL_DEPTH = 2; // Rows from surface to trigger refuel (legacy)
        const REFUEL_LINE_Y = 84; // World Y position of refuel line (player feet must be above this)
        const REFUEL_RATE = 2.5; // Fuel per frame when at surface
        
        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const depthEl = document.getElementById('depth');
        const scoreEl = document.getElementById('score');
        const fuelBar = document.getElementById('fuelBar');
        const fuelBarContainer = document.getElementById('fuelBarContainer');
        const fuelPercent = document.getElementById('fuelPercent');
        const hullBar = document.getElementById('hullBar');
        const hullBarContainer = document.getElementById('hullBarContainer');
        const hullPercent = document.getElementById('hullPercent');
        const startBtn = document.getElementById('startBtn');
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const tutorialBtn = document.getElementById('tutorialBtn');
        const menuOverlay = document.getElementById('menuOverlay');
        const controlZone = document.getElementById('controlZone');
        const controlInstructions = document.getElementById('controlInstructions');
        const permUpgradesEl = document.getElementById('permUpgrades');
        const upgradeOverlay = document.getElementById('upgradeOverlay');
        const slots = [document.getElementById('slot1'), document.getElementById('slot2'), document.getElementById('slot3')];
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        const scoreModal = document.getElementById('scoreModal');
        const finalScoreEl = document.getElementById('finalScore');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreError = document.getElementById('scoreError');
        const gameContainer = document.querySelector('.game-container');
        
        // Tutorial elements
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialClose = document.getElementById('tutorialClose');
        const tutorialPrev = document.getElementById('tutorialPrev');
        const tutorialNext = document.getElementById('tutorialNext');
        const tutorialDots = document.getElementById('tutorialDots');
        const tutorialSteps = document.querySelectorAll('.tutorial-step');
        const totalTutorialSteps = tutorialSteps.length;
        let currentTutorialStep = 0;
        
        let WORLD_WIDTH = 16; // Will be updated on resize
        
        // ==================== GAME STATE ====================
        let gameRunning = false;
        let score = 0;
        let depth = 0;
        let maxDepthThisRun = 0; // Track deepest point reached
        let fuel = 100;
        let maxFuel = 100;
        let hull = 100;
        let maxHull = 100;
        let lastUpgradeDepth = 0;
        let upgradeSelectionActive = false;
        let upgradeSelected = false;
        let isLegendaryUpgrade = false;
        let isChestUpgrade = false;
        let lastFrameTime = 0;
        let deltaMultiplier = 1;
        let screenShake = 0;
        let depthColorShift = 0;
        let globalTime = 0;
        let worldRowOffset = 0;
        
        // ==================== COMBO & FEVER SYSTEM ====================
        let comboCount = 0;
        let comboTimer = 0;
        const COMBO_DECAY_TIME = 270; // frames (~4.5 sec at 60fps)
        let feverMode = false;
        let feverTimer = 0;
        const FEVER_DURATION = 480; // frames (~8 sec)
        const FEVER_COMBO_THRESHOLD = 8;
        
        // ==================== DRILL HEAT SYSTEM ====================
        let drillHeat = 0;
        let maxDrillHeat = 100;
        let drillOverheated = false;
        let drillCooldownTimer = 0;
        const DRILL_COOLDOWN_FRAMES = 180; // 3 seconds to recover from overheat
        const HEAT_DECAY_RATE = 1.0; // Heat lost per frame when not drilling hard materials
        
        // ==================== VISUAL EFFECTS ====================
        let screenFlash = { active: false, color: '#ffffff', alpha: 0, duration: 0 };
        let speedLines = [];
        let unstableTiles = []; // Track tiles that are about to collapse
        
        // ==================== ENEMY SYSTEM ====================
        const ENEMY_TYPE = {
            WORM: 'worm',
            BEETLE: 'beetle', 
            LAVA_SLUG: 'lava_slug'
        };
        
        const ENEMY_MIN_DEPTH = 50; // No worms/lava slugs until 50m
        let enemies = [];
        let firstEnemySpawned = false; // Track if player has encountered first enemy
        
        // Spawn rates per 100 tiles generated (very low, scales with depth)
        function getEnemySpawnChance(depth, biome) {
            // Beetles can spawn early (easiest enemy - predictable patrol)
            let beetleChance = 0;
            if (depth >= 10) {
                if (depth < ENEMY_MIN_DEPTH) {
                    // Early game: low chance, guarantees encounter within first 50m
                    beetleChance = 0.008; // ~0.8% per tile dug
                } else {
                    // Normal scaling after 50m
                    const depthFactor = Math.min(1, (depth - ENEMY_MIN_DEPTH) / 400);
                    beetleChance = 0.002 + depthFactor * 0.006;
                }
            }
            
            // Worms and lava slugs only after 50m
            if (depth < ENEMY_MIN_DEPTH) {
                return { worm: 0, beetle: beetleChance, lava_slug: 0 };
            }
            
            // Gradual scaling: starts very low, slowly increases
            const depthFactor = Math.min(1, (depth - ENEMY_MIN_DEPTH) / 400); // Max at depth 450
            
            return {
                worm: 0.003 + depthFactor * 0.008,      // 0.3% to 1.1%
                beetle: beetleChance,
                lava_slug: biome === BIOME.LAVA_ZONE ? (0.004 + depthFactor * 0.01) : 0  // Only in lava
            };
        }
        
        function spawnEnemy(type, tx, ty) {
            const enemy = {
                type: type,
                x: tx * TILE_SIZE + TILE_SIZE / 2,
                y: (ty + worldRowOffset) * TILE_SIZE + TILE_SIZE / 2,
                tx: tx,  // Tile coordinates
                ty: ty + worldRowOffset,
                width: 14,
                height: 14,
                moveTimer: 0,
                moveDelay: type === ENEMY_TYPE.WORM ? 45 : (type === ENEMY_TYPE.LAVA_SLUG ? 60 : 30),
                direction: Math.random() < 0.5 ? -1 : 1, // For beetles/slugs
                health: 1,
                damage: type === ENEMY_TYPE.LAVA_SLUG ? 15 : 8,
                inGround: type === ENEMY_TYPE.WORM, // Worms burrow through ground
                animFrame: 0
            };
            enemies.push(enemy);
            firstEnemySpawned = true;
        }
        
        // Upgrade intervals for cleanup
        let activeRollIntervals = [];
        let activeRollTimeouts = [];
        
        // ==================== UPGRADE DEFINITIONS ====================
        // BUG FIX: Cap percentages to prevent exceeding 100%
        const permanentUpgrades = {
            digSpeed: 0,
            fuelCapacity: 0,
            gemMagnet: 0,
            armor: 0,
            fuelEfficiency: 0,
            gemValue: 0,
            climbSpeed: 0,
            drillPower: 0,
            drillCooling: 0
        };
        
        // Helper to get effective values with caps
        function getEffectiveUpgrade(key, maxPercent = 90) {
            return Math.min(permanentUpgrades[key], maxPercent);
        }
        
        const upgradeDefinitions = [
            { id: 'digSpeed', name: 'Turbo Drill', icon: '‚ö°', desc: '+15% dig speed', apply: () => permanentUpgrades.digSpeed += 15 },
            { id: 'fuelCapacity', name: 'Fuel Tank', icon: '‚õΩ', desc: '+25% fuel ‚Ä¢ Dive deeper!', apply: () => { permanentUpgrades.fuelCapacity += 25; maxFuel = 100 * (1 + permanentUpgrades.fuelCapacity / 100); } },
            { id: 'gemMagnet', name: 'Gem Magnet', icon: 'üß≤', desc: '+1 attraction range', apply: () => permanentUpgrades.gemMagnet += 1 },
            { id: 'fuelEfficiency', name: 'Eco Mode', icon: 'üåø', desc: '-15% fuel usage', apply: () => permanentUpgrades.fuelEfficiency += 15 },
            { id: 'gemValue', name: 'Appraiser', icon: 'üí∞', desc: '+15% gem value', apply: () => permanentUpgrades.gemValue += 15 },
            { id: 'climbSpeed', name: 'Grapple', icon: 'ü™ù', desc: '+25% climb speed', apply: () => permanentUpgrades.climbSpeed += 25 },
            { id: 'drillPower', name: 'Diamond Tip', icon: 'üíé', desc: '+10% instant break', apply: () => permanentUpgrades.drillPower += 10 },
            { id: 'drillCooling', name: 'Heat Sink', icon: '‚ùÑÔ∏è', desc: '-20% drill heat buildup', apply: () => permanentUpgrades.drillCooling += 20 }
        ];
        
        const legendaryUpgradeDefinitions = [
            { id: 'armor', name: 'Titanium Hull', icon: 'üõ°Ô∏è', desc: '-25% hazard damage', apply: () => permanentUpgrades.armor += 25 },
            { id: 'doubleGems', name: 'Lucky Strike', icon: 'üçÄ', desc: '2x gems this run', apply: () => permanentUpgrades.gemValue += 100 },
            { id: 'megaTank', name: 'Mega Tank', icon: 'üõ¢Ô∏è', desc: '+50% fuel + full refill', apply: () => { permanentUpgrades.fuelCapacity += 50; maxFuel = 100 * (1 + permanentUpgrades.fuelCapacity / 100); fuel = maxFuel; } },
            { id: 'superCooling', name: 'Cryo Drill', icon: 'üßä', desc: 'Drill never overheats', apply: () => permanentUpgrades.drillCooling += 200 }
        ];
        
        let upgradeOfferHistory = {};
        let currentUpgradeChoices = [];
        
        // ==================== WORLD ====================
        let world = [];
        let cameraY = -30;
        
        // ==================== PLAYER ====================
        const player = {
            x: BASE_WIDTH / 2 - 12,
            y: 60,
            width: 24,
            height: 28,
            speed: 3,
            digging: false,
            digProgress: 0,
            digTarget: null,
            thrusterFlicker: 0
        };
        
        // ==================== PARTICLES (Object Pool) ====================
        let particles = [];
        let floatingTexts = [];
        let ambientParticles = [];
        let bgStars = [];
        
        const keys = { left: false, right: false, up: false, down: false };
        
        // ==================== CACHED GRADIENTS ====================
        let cachedScanlinePattern = null;
        
        function createScanlinePattern() {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 4;
            patternCanvas.height = 6;
            const pctx = patternCanvas.getContext('2d');
            pctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            pctx.fillRect(0, 0, 4, 1);
            pctx.fillRect(0, 3, 4, 1);
            cachedScanlinePattern = ctx.createPattern(patternCanvas, 'repeat');
        }
        
        // ==================== INITIALIZATION ====================
        function initBgStars() {
            bgStars = [];
            for (let i = 0; i < 40; i++) {
                bgStars.push({
                    x: Math.random() * BASE_WIDTH,
                    y: Math.random() * 2000,
                    size: 0.5 + Math.random() * 1.5,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }
        
        function initAmbientParticles() {
            ambientParticles = [];
            for (let i = 0; i < 20; i++) {
                ambientParticles.push({
                    x: Math.random() * BASE_WIDTH,
                    y: Math.random() * BASE_HEIGHT * 3,
                    size: 1 + Math.random() * 2,
                    speed: 0.15 + Math.random() * 0.4,
                    alpha: 0.1 + Math.random() * 0.2,
                    hue: Math.random() < 0.5 ? 180 : 300
                });
            }
        }
        
        // ==================== WORLD GENERATION ====================
        // Biome types for variety
        const BIOME = {
            NORMAL: 0,
            CRYSTAL_CAVE: 1,
            LAVA_ZONE: 2,
            ANCIENT_RUINS: 3,
            SOFT_EARTH: 4,
            GEM_VEIN: 5
        };
        
        let currentBiome = BIOME.NORMAL;
        let biomeStartY = 0;
        let biomeLength = 0;
        
        function generateWorld() {
            world = [];
            worldRowOffset = 0;
            currentBiome = BIOME.NORMAL;
            biomeStartY = 0;
            biomeLength = 50;
            
            for (let y = 0; y < 200; y++) {
                const row = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    row.push(generateTile(x, y));
                }
                world.push(row);
            }
            
            // Add bedrock foundation under gas station
            // Station is at BASE_WIDTH / 4 - TILE_SIZE, convert to tile coordinates
            const stationTileX = Math.floor((BASE_WIDTH / 4 - TILE_SIZE) / TILE_SIZE);
            for (let y = 3; y <= 4; y++) {
                for (let x = Math.max(0, stationTileX - 1); x <= Math.min(WORLD_WIDTH - 1, stationTileX + 2); x++) {
                    if (world[y] && world[y][x] !== undefined) {
                        world[y][x] = TILE.BEDROCK;
                    }
                }
            }
            
            // Add bedrock foundation under repair shop (mirrored on right side)
            // Shop is at 3 * BASE_WIDTH / 4 + TILE_SIZE, convert to tile coordinates
            const shopTileX = Math.floor((3 * BASE_WIDTH / 4 + TILE_SIZE) / TILE_SIZE);
            for (let y = 3; y <= 4; y++) {
                for (let x = Math.max(0, shopTileX - 3); x <= Math.min(WORLD_WIDTH - 1, shopTileX); x++) {
                    if (world[y] && world[y][x] !== undefined) {
                        world[y][x] = TILE.BEDROCK;
                    }
                }
            }
        }
        
        function selectNewBiome(y) {
            // Deeper = more interesting biomes
            const depthTier = Math.floor(y / 100);
            const rand = Math.random();
            
            if (depthTier === 0) {
                // Early game: mostly normal with occasional crystal caves
                if (rand < 0.15) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.25) return BIOME.SOFT_EARTH;
                return BIOME.NORMAL;
            } else if (depthTier === 1) {
                // Mid game: introduce lava and gems
                if (rand < 0.12) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.22) return BIOME.LAVA_ZONE;
                if (rand < 0.32) return BIOME.SOFT_EARTH;
                if (rand < 0.42) return BIOME.GEM_VEIN;
                return BIOME.NORMAL;
            } else {
                // Deep game: all biomes, more special ones
                if (rand < 0.10) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.22) return BIOME.LAVA_ZONE;
                if (rand < 0.32) return BIOME.ANCIENT_RUINS;
                if (rand < 0.44) return BIOME.SOFT_EARTH;
                if (rand < 0.56) return BIOME.GEM_VEIN;
                return BIOME.NORMAL;
            }
        }
        
        function generateTile(x, y) {
            // Row 0-2: Air (above ground)
            if (y < 3) return TILE.AIR;
            
            // Check for biome transition
            if (y >= biomeStartY + biomeLength) {
                biomeStartY = y;
                biomeLength = 15 + Math.floor(Math.random() * 25); // 15-40 rows per biome
                currentBiome = selectNewBiome(y);
            }
            
            const depthFactor = Math.min(y / 150, 1);
            const rand = Math.random();
            
            // Generate based on current biome
            switch (currentBiome) {
                case BIOME.CRYSTAL_CAVE:
                    return generateCrystalCave(x, y, rand, depthFactor);
                case BIOME.LAVA_ZONE:
                    return generateLavaZone(x, y, rand, depthFactor);
                case BIOME.ANCIENT_RUINS:
                    return generateAncientRuins(x, y, rand, depthFactor);
                case BIOME.SOFT_EARTH:
                    return generateSoftEarth(x, y, rand, depthFactor);
                case BIOME.GEM_VEIN:
                    return generateGemVein(x, y, rand, depthFactor);
                default:
                    return generateNormalTile(x, y, rand, depthFactor);
            }
        }
        
        function generateNormalTile(x, y, rand, depthFactor) {
            // Very rare upgrade chest (~0.1% chance, increases slightly with depth)
            if (rand < 0.001 + depthFactor * 0.0005) return TILE.UPGRADE_CHEST;
            
            // Rare special tiles
            if (rand < 0.008 + depthFactor * 0.004) return TILE.CHEST; // Treasure chest
            if (rand < 0.015 + depthFactor * 0.008) return TILE.BOMB;  // Bomb block
            if (rand < 0.04 + depthFactor * 0.03) return TILE.UNSTABLE; // Unstable rock
            
            // Rare fuel canisters (strategic pickups)
            if (rand < 0.048 + depthFactor * 0.01) return TILE.FUEL;
            
            // DEPTH-SCALED ROCK: More hard rock at deeper levels
            // But scale gradually to keep early game accessible
            const hardRockChance = 0.06 + depthFactor * 0.12; // 6% at surface, up to 18%+ deep
            const rockChance = 0.15 + depthFactor * 0.10;     // 15% at surface, up to 25%+ deep
            
            if (rand < hardRockChance) return TILE.HARD_ROCK;
            if (rand < hardRockChance + rockChance) return TILE.ROCK;
            
            if (rand < hardRockChance + rockChance + 0.12) {
                const gemRand = Math.random();
                if (gemRand < 0.1 + depthFactor * 0.15) return TILE.GEM_EPIC;
                if (gemRand < 0.35 + depthFactor * 0.1) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (y > 30 && rand < hardRockChance + rockChance + 0.17 + depthFactor * 0.02) {
                return Math.random() < 0.6 ? TILE.LAVA : TILE.GAS;
            }
            return TILE.DIRT;
        }
        
        function generateCrystalCave(x, y, rand, depthFactor) {
            // Very rare upgrade chest
            if (rand < 0.0015) return TILE.UPGRADE_CHEST;
            // More gems, more air pockets, less rock
            if (rand < 0.02) return TILE.CHEST; // More chests in crystal caves
            if (rand < 0.04) return TILE.BOMB;
            if (rand < 0.05) return TILE.FUEL; // Rare fuel
            if (rand < 0.18) return TILE.AIR; // Cave pockets
            if (rand < 0.52) {
                const gemRand = Math.random();
                if (gemRand < 0.15 + depthFactor * 0.2) return TILE.GEM_EPIC;
                if (gemRand < 0.45 + depthFactor * 0.15) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.60 + depthFactor * 0.08) return TILE.ROCK;
            if (rand < 0.68 + depthFactor * 0.06) return TILE.HARD_ROCK;
            return TILE.DIRT;
        }
        
        function generateLavaZone(x, y, rand, depthFactor) {
            // Very rare upgrade chest - slightly higher in danger zones
            if (rand < 0.002) return TILE.UPGRADE_CHEST;
            // Dangerous but rewarding - more lava but also epic gems
            if (rand < 0.015) return TILE.CHEST; // Rare but valuable
            if (rand < 0.04) return TILE.BOMB;   // Explosions in lava zone!
            if (rand < 0.055) return TILE.FUEL;  // Rare fuel in danger zone
            if (rand < 0.11) return TILE.UNSTABLE; // Unstable near lava
            if (rand < 0.31) return TILE.LAVA;
            if (rand < 0.37) return TILE.GAS;
            if (rand < 0.55) {
                // Higher chance of epic gems as reward for danger
                const gemRand = Math.random();
                if (gemRand < 0.35) return TILE.GEM_EPIC;
                if (gemRand < 0.65) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            // More hard rock in lava zones
            if (rand < 0.75 + depthFactor * 0.05) return TILE.HARD_ROCK;
            return TILE.ROCK;
        }
        
        function generateAncientRuins(x, y, rand, depthFactor) {
            // Structured patterns with guaranteed loot
            const patternX = x % 5;
            const patternY = (y - biomeStartY) % 5;
            
            // Create room-like structures
            if (patternX === 0 || patternX === 4) return TILE.HARD_ROCK; // Walls
            if (patternY === 0 && patternX > 0 && patternX < 4) return TILE.HARD_ROCK; // Ceiling
            if (patternY === 4 && patternX === 2) return TILE.AIR; // Doorway
            
            // Inside rooms
            if (patternX >= 1 && patternX <= 3 && patternY >= 1 && patternY <= 3) {
                if (patternX === 2 && patternY === 2) {
                    // Center treasure - higher chest chance in ruins
                    const treasureRand = Math.random();
                    if (treasureRand < 0.5) return TILE.CHEST;
                    return TILE.GEM_EPIC;
                }
                if (rand < 0.25) return TILE.AIR;
                if (rand < 0.45) {
                    return Math.random() < 0.4 ? TILE.GEM_RARE : TILE.GEM_COMMON;
                }
                if (rand < 0.5) return TILE.BOMB; // Trapped rooms
                return TILE.AIR;
            }
            
            if (rand < 0.08) return TILE.UNSTABLE; // Crumbling ruins
            return rand < 0.35 ? TILE.ROCK : TILE.DIRT;
        }
        
        function generateSoftEarth(x, y, rand, depthFactor) {
            // Easy digging zone - mostly soft dirt with gems
            if (rand < 0.015) return TILE.CHEST;
            if (rand < 0.03) return TILE.BOMB;
            if (rand < 0.04) return TILE.FUEL; // Rare fuel
            if (rand < 0.20) return TILE.AIR; // Easy to navigate
            if (rand < 0.40) {
                const gemRand = Math.random();
                if (gemRand < 0.15) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.50) return TILE.ROCK;
            return TILE.DIRT;
        }
        
        function generateGemVein(x, y, rand, depthFactor) {
            // Dense gem clusters with moderate difficulty
            if (rand < 0.025) return TILE.CHEST; // Gem veins have treasure
            if (rand < 0.05) return TILE.BOMB;
            if (rand < 0.058) return TILE.FUEL; // Rare fuel
            if (rand < 0.52) {
                const gemRand = Math.random();
                if (gemRand < 0.20 + depthFactor * 0.15) return TILE.GEM_EPIC;
                if (gemRand < 0.55 + depthFactor * 0.1) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.67) return TILE.ROCK;
            if (rand < 0.80) return TILE.HARD_ROCK;
            if (rand < 0.84) return TILE.UNSTABLE;
            return TILE.DIRT;
        }
        
        function extendWorld() {
            const neededRows = Math.floor(cameraY / TILE_SIZE) + WORLD_BUFFER_ROWS - worldRowOffset;
            while (world.length < neededRows) {
                const y = world.length + worldRowOffset;
                const row = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    row.push(generateTile(x, y));
                }
                world.push(row);
                
                // Try to spawn enemies in this new row
                const depthM = y * TILE_SIZE / 16; // Convert to meters
                const spawnChances = getEnemySpawnChance(depthM, currentBiome);
                
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    const localY = world.length - 1;
                    const tile = world[localY][x];
                    
                    // Worms spawn in dirt/rock
                    if ((tile === TILE.DIRT || tile === TILE.ROCK) && Math.random() < spawnChances.worm) {
                        spawnEnemy(ENEMY_TYPE.WORM, x, localY);
                    }
                    // Beetles spawn in air (tunnels) - but we don't have tunnels yet at generation
                    // They'll spawn when tiles are dug
                    
                    // Lava slugs spawn on lava tiles
                    if (tile === TILE.LAVA && Math.random() < spawnChances.lava_slug) {
                        spawnEnemy(ENEMY_TYPE.LAVA_SLUG, x, localY);
                    }
                }
            }
            
            // MEMORY OPTIMIZATION: Trim old rows that are far above camera
            const trimThreshold = Math.floor(cameraY / TILE_SIZE) - WORLD_TRIM_THRESHOLD;
            if (trimThreshold > worldRowOffset + 50) {
                const rowsToTrim = trimThreshold - worldRowOffset - 20;
                if (rowsToTrim > 0) {
                    world.splice(0, rowsToTrim);
                    worldRowOffset += rowsToTrim;
                    
                    // Remove enemies that are now above the world
                    enemies = enemies.filter(e => e.ty >= worldRowOffset);
                }
            }
        }
        
        function getWorldRow(absoluteY) {
            return absoluteY - worldRowOffset;
        }
        
        function getTile(worldX, worldY) {
            const tx = Math.floor(worldX / TILE_SIZE);
            const ty = getWorldRow(Math.floor(worldY / TILE_SIZE));
            if (tx < 0 || tx >= WORLD_WIDTH || ty < 0 || ty >= world.length) return TILE.ROCK;
            return world[ty][tx];
        }
        
        function setTile(tx, absoluteTy, value) {
            const ty = getWorldRow(absoluteTy);
            if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < world.length) {
                world[ty][tx] = value;
            }
        }
        
        function checkCollision(x, y, width, height) {
            const points = [
                [x + 3, y + 1],              // Top left (tighter margin)
                [x + width - 3, y + 1],      // Top right (tighter margin)
                [x + width / 2, y + 1],      // Top center (new)
                [x + 3, y + height - 3],
                [x + width - 3, y + height - 3],
                [x + width / 2, y + height - 3]
            ];
            for (const [px, py] of points) {
                if (getTile(px, py) !== TILE.AIR) return true;
            }
            return false;
        }
        
        // Check horizontal collision with multiple points
        function checkHorizontalCollision(x, y, width, height, direction) {
            const checkX = direction > 0 ? x + width - 2 : x + 2;
            const points = [
                [checkX, y + 4],           // Top
                [checkX, y + height / 2],   // Middle
                [checkX, y + height - 4]    // Bottom
            ];
            for (const [px, py] of points) {
                if (getTile(px, py) !== TILE.AIR) return true;
            }
            return false;
        }
        
        // Push player out of walls if stuck
        function unstuckPlayer() {
            const margin = 2;
            let stuck = true;
            let attempts = 0;
            
            while (stuck && attempts < 10) {
                stuck = false;
                attempts++;
                
                // Check if any corner is stuck
                const corners = [
                    { x: player.x + margin, y: player.y + margin },
                    { x: player.x + player.width - margin, y: player.y + margin },
                    { x: player.x + margin, y: player.y + player.height - margin },
                    { x: player.x + player.width - margin, y: player.y + player.height - margin }
                ];
                
                for (const corner of corners) {
                    if (getTile(corner.x, corner.y) !== TILE.AIR) {
                        stuck = true;
                        // Push up primarily (most common case is falling into ground)
                        player.y -= 1;
                        break;
                    }
                }
            }
        }
        
        // ==================== DIGGING ====================
        function dig(tx, absoluteTy) {
            const ty = getWorldRow(absoluteTy);
            if (ty < 0 || ty >= world.length || tx < 0 || tx >= WORLD_WIDTH) return;
            
            const tile = world[ty][tx];
            if (tile === TILE.AIR) return;
            if (tile === TILE.BEDROCK) return; // Can't dig bedrock
            if (drillOverheated) return; // Can't dig when overheated
            
            // Speed multipliers
            const speedMultiplier = 1 + getEffectiveUpgrade('digSpeed', 300) / 100;
            const feverBonus = feverMode ? 1.5 : 1;
            const totalSpeed = speedMultiplier * feverBonus;
            
            let digTime = 0.35 / totalSpeed; // Base dig time
            
            if (tile === TILE.ROCK) digTime = 0.55 / totalSpeed;
            if (tile === TILE.HARD_ROCK) {
                const drillChance = getEffectiveUpgrade('drillPower', 90);
                digTime = Math.random() * 100 < drillChance ? 0.1 : 0.85 / totalSpeed;
            }
            if (tile === TILE.UNSTABLE) {
                digTime = 0.6 / totalSpeed; // Takes a bit to break
                // Start collapse timer if not already started
                const existing = unstableTiles.find(u => u.tx === tx && u.absoluteTy === absoluteTy);
                if (!existing) {
                    startUnstableTimer(tx, absoluteTy);
                }
            }
            if (tile === TILE.BOMB) digTime = 0.15 / totalSpeed; // Quick to trigger
            if (tile === TILE.CHEST) digTime = 0.35 / totalSpeed; // Satisfying open time
            if (tile === TILE.UPGRADE_CHEST) digTime = 0.5 / totalSpeed; // Slightly longer for anticipation
            
            player.digging = true;
            player.digTarget = { x: tx, y: absoluteTy, time: digTime };
            player.digProgress = 0;
        }
        
        // Track last dig direction for continuous digging
        let lastDigDirection = null; // 'down', 'left', 'right'
        
        // ==================== COMBO & EFFECTS FUNCTIONS ====================
        function addCombo() {
            comboCount++;
            comboTimer = COMBO_DECAY_TIME;
            
            // Check for fever mode activation
            if (comboCount >= FEVER_COMBO_THRESHOLD && !feverMode) {
                activateFeverMode();
            }
        }
        
        function getComboMultiplier() {
            if (comboCount < 2) return 1;
            if (comboCount < 5) return 2;
            if (comboCount < 10) return 3;
            if (comboCount < 20) return 4;
            return 5;
        }
        
        function activateFeverMode() {
            feverMode = true;
            feverTimer = FEVER_DURATION;
            triggerScreenFlash('#ff00ff', 0.4, 20);
            screenShake = 10;
            createFloatingText('üî• FEVER MODE! üî•', player.x + player.width/2, player.y - 30, '#ff00ff');
        }
        
        function triggerScreenFlash(color, alpha, duration) {
            screenFlash = { active: true, color: color, alpha: alpha, duration: duration };
        }
        
        function createSpeedLine() {
            if (speedLines.length < 20) {
                speedLines.push({
                    x: Math.random() * BASE_WIDTH,
                    y: -20,
                    length: 30 + Math.random() * 50,
                    speed: 15 + Math.random() * 10,
                    alpha: 0.3 + Math.random() * 0.4
                });
            }
        }
        
        function explodeBomb(centerTX, centerAbsTY) {
            // 3x3 explosion
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const tx = centerTX + dx;
                    const absoluteTy = centerAbsTY + dy;
                    const ty = getWorldRow(absoluteTy);
                    
                    if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < world.length) {
                        const tile = world[ty][tx];
                        
                        // Don't destroy hard rock or bedrock with bombs
                        if (tile !== TILE.AIR && tile !== TILE.HARD_ROCK && tile !== TILE.BEDROCK) {
                            // Collect any gems caught in explosion
                            if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                                let value = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                                value = Math.floor(value * (1 + permanentUpgrades.gemValue / 100) * getComboMultiplier());
                                score += value;
                                addCombo();
                            }
                            if (tile === TILE.FUEL) {
                                fuel = Math.min(fuel + 20, maxFuel);
                            }
                            
                            world[ty][tx] = TILE.AIR;
                            createParticles(tx * TILE_SIZE + TILE_SIZE/2, absoluteTy * TILE_SIZE + TILE_SIZE/2, '#ff6600', 4);
                        }
                    }
                }
            }
            
            // Big explosion effects
            const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
            const cy = centerAbsTY * TILE_SIZE + TILE_SIZE/2;
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                particles.push({
                    x: cx, y: cy,
                    vx: Math.cos(angle) * (5 + Math.random() * 5),
                    vy: Math.sin(angle) * (5 + Math.random() * 5),
                    size: 4 + Math.random() * 6,
                    color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00',
                    life: 1,
                    type: 'explosion'
                });
            }
            
            triggerScreenFlash('#ff6600', 0.5, 15);
            screenShake = 12;
            scoreEl.textContent = score;
            updateFuelBar();
        }
        
        function openChest(tx, absoluteTy) {
            // Huge gem payout!
            const baseValue = 150 + Math.floor(Math.random() * 100);
            const value = Math.floor(baseValue * (1 + permanentUpgrades.gemValue / 100) * getComboMultiplier());
            score += value;
            
            // Also give some fuel
            fuel = Math.min(fuel + 50, maxFuel);
            
            const worldY = absoluteTy * TILE_SIZE;
            createFloatingText(`üíé +${value}! üíé`, tx * TILE_SIZE + TILE_SIZE/2, worldY, '#ffd700');
            
            // Shower of particles
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 5;
                particles.push({
                    x: tx * TILE_SIZE + TILE_SIZE/2,
                    y: worldY + TILE_SIZE/2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 3,
                    size: 3 + Math.random() * 5,
                    color: ['#ffd700', '#ff9500', '#00f0ff', '#ff00ff'][Math.floor(Math.random() * 4)],
                    life: 1.2,
                    type: 'gem'
                });
            }
            
            triggerScreenFlash('#ffd700', 0.4, 25);
            screenShake = 8;
            addCombo();
            scoreEl.textContent = score;
            updateFuelBar();
        }
        
        function openUpgradeChest(tx, absoluteTy) {
            const worldY = absoluteTy * TILE_SIZE;
            
            // Pick a random upgrade from all available (regular + legendary)
            const allUpgrades = [...upgradeDefinitions, ...legendaryUpgradeDefinitions];
            const upgrade = allUpgrades[Math.floor(Math.random() * allUpgrades.length)];
            
            // Rainbow particle explosion
            for (let i = 0; i < 35; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 4 + Math.random() * 6;
                const hue = (i / 35) * 360;
                particles.push({
                    x: tx * TILE_SIZE + TILE_SIZE/2,
                    y: worldY + TILE_SIZE/2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 4,
                    size: 4 + Math.random() * 4,
                    color: `hsl(${hue}, 100%, 60%)`,
                    life: 1.5,
                    type: 'gem'
                });
            }
            
            // Screen effects
            triggerScreenFlash('#ffd700', 0.5, 30);
            screenShake = 12;
            
            // Bonus score
            const bonusScore = 100;
            score += bonusScore;
            scoreEl.textContent = score;
            
            // Show upgrade overlay with single slot
            showChestUpgrade(upgrade);
        }
        
        function showChestUpgrade(upgrade) {
            upgradeSelectionActive = true;
            upgradeSelected = false;
            isChestUpgrade = true;
            isLegendaryUpgrade = false;
            
            currentUpgradeChoices = [upgrade];
            
            // Update title and subtitle
            const titleEl = upgradeOverlay.querySelector('.upgrade-title');
            const subtitleEl = upgradeOverlay.querySelector('.upgrade-subtitle');
            titleEl.textContent = 'TREASURE FOUND';
            subtitleEl.textContent = 'Claim your reward';
            
            // Set chest styling
            upgradeOverlay.classList.remove('legendary');
            upgradeOverlay.classList.add('chest');
            
            // Show only the first slot, hide others
            slots.forEach((slot, i) => {
                if (i === 0) {
                    slot.className = 'upgrade-slot rolling chest';
                    slot.style.display = '';
                    slot.querySelector('.upgrade-icon').textContent = '?';
                    slot.querySelector('.upgrade-name').textContent = '???';
                    slot.querySelector('.upgrade-desc').textContent = '???';
                } else {
                    slot.style.display = 'none';
                }
            });
            
            upgradeOverlay.classList.add('active');
            rollChestSlot(upgrade);
        }
        
        function rollChestSlot(upgrade) {
            clearRollTimers();
            
            const rollDuration = 1200;
            const allDefs = [...upgradeDefinitions, ...legendaryUpgradeDefinitions];
            const slot = slots[0];
            
            const rollInterval = setInterval(() => {
                const r = allDefs[Math.floor(Math.random() * allDefs.length)];
                slot.querySelector('.upgrade-icon').textContent = r.icon;
                slot.querySelector('.upgrade-name').textContent = r.name;
                slot.querySelector('.upgrade-desc').textContent = r.desc;
            }, 100);
            
            activeRollIntervals.push(rollInterval);
            
            const timeout = setTimeout(() => {
                clearInterval(rollInterval);
                slot.className = 'upgrade-slot revealed chest';
                slot.querySelector('.upgrade-icon').textContent = upgrade.icon;
                slot.querySelector('.upgrade-name').textContent = upgrade.name;
                slot.querySelector('.upgrade-desc').textContent = upgrade.desc;
                slot.onclick = () => selectChestUpgrade(upgrade);
                slot.ontouchend = (e) => { e.preventDefault(); e.stopPropagation(); selectChestUpgrade(upgrade); };
            }, rollDuration);
            
            activeRollTimeouts.push(timeout);
        }
        
        function selectChestUpgrade(upgrade) {
            if (!upgradeSelectionActive || upgradeSelected) return;
            upgradeSelected = true;
            
            slots[0].classList.add('selected');
            
            // Apply the upgrade
            upgrade.apply();
            updatePermanentUpgradesDisplay();
            updateFuelBar();
            updateHullBar();
            
            setTimeout(() => {
                upgradeSelectionActive = false;
                isChestUpgrade = false;
                upgradeOverlay.classList.remove('active', 'chest');
                
                // Reset title and subtitle for next time
                const titleEl = upgradeOverlay.querySelector('.upgrade-title');
                const subtitleEl = upgradeOverlay.querySelector('.upgrade-subtitle');
                titleEl.textContent = 'UPGRADE';
                subtitleEl.textContent = 'Choose your enhancement';
                
                slots.forEach(s => {
                    s.style.display = '';
                    s.style.opacity = '';
                    s.style.pointerEvents = '';
                    s.classList.remove('selected', 'chest');
                    s.onclick = null;
                    s.ontouchend = null;
                });
            }, 600);
        }
        
        function startUnstableTimer(tx, absoluteTy) {
            // Add to unstable tiles list with a timer
            unstableTiles.push({
                tx: tx,
                absoluteTy: absoluteTy,
                timer: 45, // ~0.75 seconds to break before collapse
                warned: false
            });
        }
        
        function completeDig(fromMagnet = false) {
            if (!player.digTarget) return;
            
            const { x: tx, y: absoluteTy } = player.digTarget;
            const ty = getWorldRow(absoluteTy);
            if (ty < 0 || ty >= world.length) {
                player.digging = false;
                player.digTarget = null;
                return;
            }
            
            const tile = world[ty][tx];
            const worldY = absoluteTy * TILE_SIZE;
            const tileCenterX = tx * TILE_SIZE + TILE_SIZE/2;
            const tileCenterY = worldY + TILE_SIZE/2;
            
            // Apply fever mode speed bonus
            const feverMultiplier = feverMode ? 1.5 : 1;
            
            // ===== GEMS =====
            if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                addCombo();
                const multiplier = getComboMultiplier();
                let value = Math.floor(baseValue * (1 + permanentUpgrades.gemValue / 100) * multiplier);
                
                // Fever mode bonus
                if (feverMode) value = Math.floor(value * 1.5);
                
                score += value;
                scoreEl.textContent = score;
                
                const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                const text = multiplier > 1 ? `+${value} x${multiplier}!` : `+${value}`;
                createFloatingText(text, tileCenterX, worldY - 5, color);
                createGemParticles(tileCenterX, tileCenterY, color);
                
                // Epic gem screen flash
                if (tile === TILE.GEM_EPIC) {
                    triggerScreenFlash('#ff9500', 0.3, 12);
                    screenShake = 5;
                } else {
                    screenShake = 3;
                }
            }
            
            // ===== FUEL CANISTER =====
            if (tile === TILE.FUEL) {
                const fuelGain = feverMode ? 35 : 25;
                fuel = Math.min(fuel + fuelGain, maxFuel);
                updateFuelBar();
                createFloatingText(`+${fuelGain} ‚õΩ`, tileCenterX, worldY - 5, '#ff9500');
                createParticles(tileCenterX, tileCenterY, '#ff9500', 10);
                triggerScreenFlash('#ff8800', 0.15, 8);
            }
            
            // ===== BOMB =====
            if (tile === TILE.BOMB) {
                world[ty][tx] = TILE.AIR; // Clear bomb first
                explodeBomb(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return; // Skip normal completion
            }
            
            // ===== CHEST =====
            if (tile === TILE.CHEST) {
                world[ty][tx] = TILE.AIR;
                openChest(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== UPGRADE CHEST =====
            if (tile === TILE.UPGRADE_CHEST) {
                world[ty][tx] = TILE.AIR;
                openUpgradeChest(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== UNSTABLE ROCK =====
            if (tile === TILE.UNSTABLE) {
                // Successfully mined before collapse - bonus gems!
                const value = Math.floor(20 * (1 + permanentUpgrades.gemValue / 100) * getComboMultiplier());
                score += value;
                scoreEl.textContent = score;
                createFloatingText(`+${value}`, tileCenterX, worldY - 5, '#aaaaff');
                createParticles(tileCenterX, tileCenterY, '#8888aa', 10);
                addCombo();
                
                // Remove from unstable tracking
                unstableTiles = unstableTiles.filter(u => !(u.tx === tx && u.absoluteTy === absoluteTy));
            }
            
            // ===== HAZARDS =====
            if (tile === TILE.LAVA || tile === TILE.GAS) {
                const baseDamage = tile === TILE.LAVA ? 20 : 10;
                const damage = baseDamage * (1 - getEffectiveUpgrade('armor', 90) / 100);
                hull -= damage;
                comboCount = 0; // Break combo on damage
                comboTimer = 0;
                createFloatingText(`-${Math.floor(damage)}`, player.x + 12, player.y, '#ff3355');
                createParticles(player.x + 12, player.y + 14 + cameraY, '#ff3355', 8);
                triggerScreenFlash('#ff0000', 0.25, 8);
                screenShake = 6;
                updateHullBar();
            }
            
            // Don't charge fuel for magnet-collected gems
            if (!fromMagnet) {
                let fuelCost = 0.5 * (1 - getEffectiveUpgrade('fuelEfficiency', 90) / 100);
                if (feverMode) fuelCost *= 0.5; // Half fuel cost in fever mode
                fuel -= fuelCost;
            }
            
            updateFuelBar();
            
            // Chance to spawn beetle when digging creates tunnel
            const depthM = absoluteTy * TILE_SIZE / 16;
            const spawnChances = getEnemySpawnChance(depthM, currentBiome);
            
            // Guaranteed first enemy encounter between 40-50m depth
            let shouldSpawnBeetle = false;
            if (!firstEnemySpawned && depthM >= 40 && depthM < 50) {
                // High chance that increases as we approach 50m (guaranteed by 48m)
                const urgency = (depthM - 40) / 8; // 0 at 40m, 1 at 48m
                shouldSpawnBeetle = Math.random() < (0.15 + urgency * 0.85);
            } else if (spawnChances.beetle > 0) {
                shouldSpawnBeetle = Math.random() < spawnChances.beetle * 0.3;
            }
            
            if (shouldSpawnBeetle) {
                // Spawn beetle nearby (not on player's tile)
                const offsetX = Math.random() < 0.5 ? -1 : 1;
                const spawnTx = tx + offsetX;
                if (spawnTx >= 0 && spawnTx < WORLD_WIDTH) {
                    const spawnTy = ty;
                    // Check if spawn location is valid (air tile)
                    if (world[spawnTy] && world[spawnTy][spawnTx] === TILE.AIR) {
                        spawnEnemy(ENEMY_TYPE.BEETLE, spawnTx, spawnTy);
                    }
                }
            }
            
            // Clear tile
            world[ty][tx] = TILE.AIR;
            createDigParticles(tileCenterX, absoluteTy * TILE_SIZE + TILE_SIZE/2, tile);
            
            player.digging = false;
            player.digTarget = null;
            
            // Continue digging if direction key still held
            if (!fromMagnet && lastDigDirection) {
                tryDigInDirection(lastDigDirection);
            }
        }
        
        // Attempt to dig in a specific direction
        function tryDigInDirection(direction) {
            let targetTX, targetAbsTY;
            
            if (direction === 'down') {
                targetTX = Math.floor((player.x + player.width / 2) / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height) / TILE_SIZE);
            } else if (direction === 'left') {
                targetTX = Math.floor(player.x / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
            } else if (direction === 'right') {
                targetTX = Math.floor((player.x + player.width) / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
            } else {
                return false;
            }
            
            const ty = getWorldRow(targetAbsTY);
            if (ty >= 0 && ty < world.length && targetTX >= 0 && targetTX < WORLD_WIDTH) {
                const tile = world[ty][targetTX];
                // Can't dig through bedrock
                if (tile === TILE.BEDROCK) return false;
                // Can't dig when overheated
                if (drillOverheated) {
                    if (Math.random() < 0.05) {
                        createFloatingText('‚è≥ Cooling...', player.x + player.width/2, player.y - 15, '#ff8844');
                    }
                    return false;
                }
                if (tile !== TILE.AIR) {
                    // Start unstable timer when we begin digging unstable rock
                    if (tile === TILE.UNSTABLE) {
                        const existing = unstableTiles.find(u => u.tx === targetTX && u.absoluteTy === targetAbsTY);
                        if (!existing) {
                            startUnstableTimer(targetTX, targetAbsTY);
                        }
                    }
                    dig(targetTX, targetAbsTY);
                    return true;
                }
            }
            return false;
        }
        
        // ==================== PARTICLES ====================
        function createParticles(x, y, color, count) {
            // OPTIMIZATION: Limit particle count
            const available = MAX_PARTICLES - particles.length;
            const toCreate = Math.min(count, available);
            
            for (let i = 0; i < toCreate; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5 - 2,
                    size: 2 + Math.random() * 3,
                    color: color,
                    life: 1,
                    type: 'normal'
                });
            }
        }
        
        function createGemParticles(x, y, color) {
            const available = MAX_PARTICLES - particles.length;
            const count = Math.min(10, available);
            
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (3 + Math.random() * 2),
                    vy: Math.sin(angle) * (3 + Math.random() * 2),
                    size: 3 + Math.random() * 4,
                    color: color,
                    life: 1,
                    type: 'gem'
                });
            }
        }
        
        function createDigParticles(x, y, tile) {
            const colors = {
                [TILE.DIRT]: ['#5a4535', '#3d2d20'],
                [TILE.ROCK]: ['#555', '#444'],
                [TILE.HARD_ROCK]: ['#3a3a50', '#2a2a40']
            };
            const colorSet = colors[tile] || ['#555'];
            
            const available = MAX_PARTICLES - particles.length;
            const count = Math.min(5, available);
            
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 10,
                    y: y + (Math.random() - 0.5) * 10,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 3 - 1,
                    size: 2 + Math.random() * 4,
                    color: colorSet[Math.floor(Math.random() * colorSet.length)],
                    life: 1,
                    type: 'debris',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }
        
        function createFloatingText(text, x, worldY, color) {
            // OPTIMIZATION: Limit floating texts
            if (floatingTexts.length >= MAX_FLOATING_TEXTS) {
                floatingTexts.shift();
            }
            floatingTexts.push({
                text: text,
                x: x,
                y: worldY,
                vy: -2.5,
                life: 1,
                color: color,
                scale: 1.3
            });
        }
        
        function updateParticles() {
            // OPTIMIZATION: Filter in place to reduce allocations
            let writeIndex = 0;
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                p.x += p.vx * deltaMultiplier;
                p.y += p.vy * deltaMultiplier;
                p.vy += 0.15 * deltaMultiplier;
                p.vx *= 0.98;
                p.life -= 0.025 * deltaMultiplier;
                if (p.rotation !== undefined) {
                    p.rotation += p.rotationSpeed * deltaMultiplier;
                }
                if (p.life > 0) {
                    particles[writeIndex++] = p;
                }
            }
            particles.length = writeIndex;
            
            writeIndex = 0;
            for (let i = 0; i < floatingTexts.length; i++) {
                const t = floatingTexts[i];
                t.y -= 1.5 * deltaMultiplier;
                t.vy *= 0.94;
                t.life -= 0.018 * deltaMultiplier;
                t.scale = 0.8 + t.life * 0.5;
                if (t.life > 0) {
                    floatingTexts[writeIndex++] = t;
                }
            }
            floatingTexts.length = writeIndex;
            
            // Update ambient particles
            for (let i = 0; i < ambientParticles.length; i++) {
                const p = ambientParticles[i];
                p.y -= p.speed * deltaMultiplier;
                if (p.y < cameraY - 50) {
                    p.y = cameraY + BASE_HEIGHT + 50;
                    p.x = Math.random() * BASE_WIDTH;
                }
            }
        }
        
        // ==================== ENEMY UPDATE ====================
        function updateEnemies() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Animation
                enemy.animFrame = (enemy.animFrame + 0.1 * deltaMultiplier) % (Math.PI * 2);
                
                // Movement timer
                enemy.moveTimer += deltaMultiplier;
                
                if (enemy.moveTimer >= enemy.moveDelay) {
                    enemy.moveTimer = 0;
                    
                    const localTy = enemy.ty - worldRowOffset;
                    
                    if (enemy.type === ENEMY_TYPE.WORM) {
                        // Worms burrow toward player through dirt/rock
                        const dx = playerCenterX - enemy.x;
                        const dy = playerCenterY - enemy.y;
                        
                        // Prefer moving toward player
                        let moveTx = enemy.tx;
                        let moveTy = enemy.ty;
                        
                        if (Math.abs(dx) > Math.abs(dy)) {
                            moveTx += dx > 0 ? 1 : -1;
                        } else {
                            moveTy += dy > 0 ? 1 : -1;
                        }
                        
                        // Check if can move there
                        const newLocalTy = moveTy - worldRowOffset;
                        if (moveTx >= 0 && moveTx < WORLD_WIDTH && newLocalTy >= 0 && newLocalTy < world.length) {
                            const targetTile = world[newLocalTy][moveTx];
                            // Can move through dirt, rock, or air
                            if (targetTile === TILE.DIRT || targetTile === TILE.ROCK || targetTile === TILE.AIR) {
                                enemy.tx = moveTx;
                                enemy.ty = moveTy;
                                enemy.x = moveTx * TILE_SIZE + TILE_SIZE / 2;
                                enemy.y = moveTy * TILE_SIZE + TILE_SIZE / 2;
                                enemy.inGround = targetTile !== TILE.AIR;
                            }
                        }
                    } else if (enemy.type === ENEMY_TYPE.BEETLE || enemy.type === ENEMY_TYPE.LAVA_SLUG) {
                        // Walk along floors, reverse at walls
                        const nextTx = enemy.tx + enemy.direction;
                        const belowTy = localTy + 1;
                        
                        // Check if can move forward and has ground below
                        if (nextTx >= 0 && nextTx < WORLD_WIDTH && belowTy < world.length) {
                            const nextTile = world[localTy] ? world[localTy][nextTx] : TILE.ROCK;
                            const belowTile = world[belowTy] ? world[belowTy][nextTx] : TILE.AIR;
                            
                            // For lava slugs, they can walk on lava
                            const canWalkOn = enemy.type === ENEMY_TYPE.LAVA_SLUG ? 
                                (belowTile !== TILE.AIR) : 
                                (belowTile !== TILE.AIR && belowTile !== TILE.LAVA);
                            
                            if (nextTile === TILE.AIR && canWalkOn) {
                                enemy.tx = nextTx;
                                enemy.x = nextTx * TILE_SIZE + TILE_SIZE / 2;
                            } else {
                                // Reverse direction
                                enemy.direction *= -1;
                            }
                        } else {
                            enemy.direction *= -1;
                        }
                    }
                }
                
                // Check collision with player
                const distX = Math.abs(enemy.x - playerCenterX);
                const distY = Math.abs(enemy.y - playerCenterY);
                
                if (distX < (enemy.width + player.width) / 2 && distY < (enemy.height + player.height) / 2) {
                    // Player hit by enemy!
                    // But if player is digging toward enemy, kill the enemy instead
                    if (player.digging && player.digTarget) {
                        const digTx = player.digTarget.x;
                        const digTy = player.digTarget.y;
                        if (enemy.tx === digTx && enemy.ty === digTy) {
                            // Drilling into enemy - kill it!
                            killEnemy(i);
                            continue;
                        }
                    }
                    
                    // Take damage from enemy
                    const damage = enemy.damage * (1 - getEffectiveUpgrade('armor', 90) / 100);
                    hull -= damage;
                    comboCount = 0;
                    comboTimer = 0;
                    createFloatingText(`-${Math.floor(damage)}`, player.x + player.width/2, player.y, '#ff3355');
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff3355', 8);
                    triggerScreenFlash('#ff0000', 0.3, 10);
                    screenShake = 8;
                    updateHullBar();
                    
                    // Kill enemy after contact
                    enemies.splice(i, 1);
                    continue;
                }
                
                // Check if player is drilling into enemy's tile
                if (player.digging && player.digTarget) {
                    const digTx = player.digTarget.x;
                    const digTy = player.digTarget.y;
                    if (enemy.tx === digTx && enemy.ty === digTy) {
                        // Player drilling into enemy tile - kill enemy
                        killEnemy(i);
                        continue;
                    }
                }
                
                // Remove enemies that are too far above camera
                if (enemy.y < cameraY - 200) {
                    enemies.splice(i, 1);
                }
            }
        }
        
        function killEnemy(index) {
            const enemy = enemies[index];
            
            // Reward
            const baseValue = enemy.type === ENEMY_TYPE.LAVA_SLUG ? 30 : 
                             enemy.type === ENEMY_TYPE.WORM ? 20 : 15;
            const value = Math.floor(baseValue * (1 + permanentUpgrades.gemValue / 100));
            score += value;
            scoreEl.textContent = score;
            
            // Effects
            const color = enemy.type === ENEMY_TYPE.LAVA_SLUG ? '#ff6600' : 
                         enemy.type === ENEMY_TYPE.WORM ? '#88ff88' : '#ffaa00';
            createFloatingText(`+${value} üíÄ`, enemy.x, enemy.y - 10, color);
            createParticles(enemy.x, enemy.y, color, 12);
            screenShake = 4;
            
            enemies.splice(index, 1);
        }
        
        // ==================== UPDATE ====================
        function update() {
            if (!gameRunning || upgradeSelectionActive) return;
            
            extendWorld();
            updateEnemies();
            
            // OPTIMIZATION: Wrap globalTime to prevent overflow
            globalTime = (globalTime + deltaMultiplier) % 100000;
            
            if (screenShake > 0) {
                screenShake *= 0.85;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            // ===== COMBO TIMER DECAY =====
            if (comboTimer > 0) {
                comboTimer -= deltaMultiplier;
                if (comboTimer <= 0) {
                    comboCount = 0;
                    comboTimer = 0;
                }
            }
            
            // ===== FEVER MODE UPDATE =====
            if (feverMode) {
                feverTimer -= deltaMultiplier;
                if (feverTimer <= 0) {
                    feverMode = false;
                    feverTimer = 0;
                    createFloatingText('Fever ended!', player.x + player.width/2, player.y - 20, '#888888');
                }
                // Fever mode speed lines
                if (Math.random() < 0.3) createSpeedLine();
            }
            
            // ===== SURFACE REFUELING & REPAIR =====
            const playerFeetY = player.y + player.height;
            const playerCenterY = player.y + player.height / 2;
            const isAboveRefuelLine = playerCenterY <= REFUEL_LINE_Y; // 50%+ of player above line
            
            if (isAboveRefuelLine && fuel < maxFuel) {
                const refuelAmount = REFUEL_RATE * deltaMultiplier * (1 + permanentUpgrades.fuelCapacity / 200);
                fuel = Math.min(fuel + refuelAmount, maxFuel);
                updateFuelBar();
                
                // Occasional refuel particles
                if (Math.random() < 0.1) {
                    createParticles(player.x + player.width/2, player.y, '#00ff88', 2);
                }
            }
            
            // Hull repair at surface (slower than refueling)
            if (isAboveRefuelLine && hull < maxHull) {
                const repairAmount = 0.8 * deltaMultiplier; // Slower than fuel
                hull = Math.min(hull + repairAmount, maxHull);
                updateHullBar();
                
                // Occasional repair particles (cyan sparks)
                if (Math.random() < 0.05) {
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#00ffff', 2);
                }
            }
            
            // ===== DRILL HEAT MANAGEMENT =====
            // Heat decays when not actively drilling hard materials
            if (!player.digging) {
                const coolRate = HEAT_DECAY_RATE * (1 + permanentUpgrades.drillCooling / 50);
                drillHeat = Math.max(0, drillHeat - coolRate * deltaMultiplier);
            }
            
            // Surface cools drill faster (uses same isAboveRefuelLine check)
            if (isAboveRefuelLine) {
                drillHeat = Math.max(0, drillHeat - 1.5 * deltaMultiplier);
            }
            
            // Heat visual effects - smoke/steam particles
            const heatPercent = drillHeat / maxDrillHeat;
            
            // Calculate drill position for particles (same logic as drawPlayer)
            let particleDrillX = player.x + player.width / 2;
            let particleDrillY = player.y + player.height;
            
            // Determine drill direction
            let particleDrillDirection = 'down';
            
            // Check if actively digging sideways
            if (player.digging && player.digTarget) {
                const targetWorldX = player.digTarget.x * TILE_SIZE + TILE_SIZE / 2;
                const playerCenterX = player.x + player.width / 2;
                const dx = targetWorldX - playerCenterX;
                
                if (Math.abs(dx) > TILE_SIZE / 2) {
                    particleDrillDirection = dx < 0 ? 'left' : 'right';
                }
            }
            // If not digging but holding left/right keys
            else if (keys.left && !keys.right) {
                particleDrillDirection = 'left';
            } else if (keys.right && !keys.left) {
                particleDrillDirection = 'right';
            }
            // When overheated, remember last dig direction
            else if (drillOverheated && lastDigDirection === 'left') {
                particleDrillDirection = 'left';
            } else if (drillOverheated && lastDigDirection === 'right') {
                particleDrillDirection = 'right';
            }
            
            // Apply direction offsets
            if (particleDrillDirection === 'left') {
                particleDrillX = player.x - 3;
                particleDrillY = player.y + player.height / 2 + 1;
            } else if (particleDrillDirection === 'right') {
                particleDrillX = player.x + player.width + 3;
                particleDrillY = player.y + player.height / 2 + 1;
            }
            
            if (heatPercent > 0.6 && Math.random() < (heatPercent - 0.5) * 0.15) {
                // Heat shimmer particles rising from drill
                particles.push({
                    x: particleDrillX + (Math.random() - 0.5) * 10,
                    y: particleDrillY + 5,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -1 - Math.random() * 1.5,
                    size: 3 + Math.random() * 3,
                    color: drillOverheated ? '#ff4400' : '#ff8844',
                    life: 0.6,
                    type: 'smoke'
                });
            }
            
            // Smoke puffs when overheated
            if (drillOverheated && Math.random() < 0.2) {
                particles.push({
                    x: particleDrillX + (Math.random() - 0.5) * 8,
                    y: particleDrillY,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -2 - Math.random() * 2,
                    size: 5 + Math.random() * 4,
                    color: '#444444',
                    life: 0.8,
                    type: 'smoke'
                });
            }
            
            // Overheat recovery
            if (drillOverheated) {
                drillCooldownTimer -= deltaMultiplier;
                
                // Screen edge warning effect
                if (Math.random() < 0.05) {
                    screenShake = Math.max(screenShake, 1);
                }
                
                if (drillCooldownTimer <= 0) {
                    drillOverheated = false;
                    drillHeat = 50; // Reset to half heat after cooldown
                    createFloatingText('‚úì Drill Cooled', player.x + player.width/2, player.y - 20, '#00ffaa');
                    triggerScreenFlash('#00ffaa', 0.2, 10);
                }
            }
            
            // ===== SCREEN FLASH UPDATE =====
            if (screenFlash.active) {
                screenFlash.duration -= deltaMultiplier;
                if (screenFlash.duration <= 0) {
                    screenFlash.active = false;
                }
            }
            
            // ===== SPEED LINES UPDATE =====
            speedLines = speedLines.filter(line => {
                line.y += line.speed * deltaMultiplier;
                return line.y < BASE_HEIGHT + 50;
            });
            
            // ===== UNSTABLE TILES UPDATE =====
            unstableTiles = unstableTiles.filter(unstable => {
                unstable.timer -= deltaMultiplier;
                
                // Warning shake when low
                if (unstable.timer < 20 && !unstable.warned) {
                    unstable.warned = true;
                }
                
                // Collapse!
                if (unstable.timer <= 0) {
                    const ty = getWorldRow(unstable.absoluteTy);
                    if (ty >= 0 && ty < world.length && world[ty][unstable.tx] === TILE.UNSTABLE) {
                        // Collapse damages player if nearby
                        const tileCX = unstable.tx * TILE_SIZE + TILE_SIZE/2;
                        const tileCY = unstable.absoluteTy * TILE_SIZE + TILE_SIZE/2;
                        const playerCX = player.x + player.width/2;
                        const playerCY = player.y + player.height/2;
                        const dist = Math.sqrt(Math.pow(tileCX - playerCX, 2) + Math.pow(tileCY - playerCY, 2));
                        
                        if (dist < TILE_SIZE * 2) {
                            const damage = 15 * (1 - getEffectiveUpgrade('armor', 90) / 100);
                            hull -= damage;
                            comboCount = 0;
                            comboTimer = 0;
                            createFloatingText(`-${Math.floor(damage)}`, player.x + 12, player.y, '#ff3355');
                            triggerScreenFlash('#ff0000', 0.2, 6);
                            screenShake = 8;
                            updateHullBar();
                        }
                        
                        // Turn into rubble (just air with particles)
                        world[ty][unstable.tx] = TILE.AIR;
                        createParticles(tileCX, unstable.absoluteTy * TILE_SIZE + TILE_SIZE/2, '#666688', 12);
                        
                        // Cancel dig if we were digging this tile
                        if (player.digTarget && player.digTarget.x === unstable.tx && player.digTarget.y === unstable.absoluteTy) {
                            player.digging = false;
                            player.digTarget = null;
                        }
                    }
                    return false;
                }
                return true;
            });
            
            player.thrusterFlicker = Math.sin(globalTime * 0.3) * 0.3 + 0.7;
            
            // ===== DIG CANCELLATION WHEN KEY RELEASED =====
            if (player.digging && player.digTarget) {
                // Check if the direction key for current dig is still held
                let keyStillHeld = false;
                if (lastDigDirection === 'down' && keys.down) keyStillHeld = true;
                if (lastDigDirection === 'left' && keys.left) keyStillHeld = true;
                if (lastDigDirection === 'right' && keys.right) keyStillHeld = true;
                
                if (!keyStillHeld && lastDigDirection !== null) {
                    // Key released - cancel dig
                    player.digging = false;
                    player.digTarget = null;
                } else {
                    // Get tile being dug for heat calculation
                    const digTy = getWorldRow(player.digTarget.y);
                    const digTile = (digTy >= 0 && digTy < world.length) ? world[digTy][player.digTarget.x] : TILE.AIR;
                    
                    // Heat generation based on material hardness
                    let heatGen = 0;
                    if (digTile === TILE.HARD_ROCK) {
                        heatGen = 1.2; // High heat for hard rock
                    } else if (digTile === TILE.ROCK) {
                        heatGen = 0.4; // Moderate heat for rock
                    } else if (digTile === TILE.UNSTABLE) {
                        heatGen = 0.25; // Some heat for unstable
                    }
                    
                    // Apply cooling upgrade reduction
                    const coolingReduction = 1 - Math.min(permanentUpgrades.drillCooling / 100, 0.95);
                    heatGen *= coolingReduction;
                    
                    // Fever mode reduces heat buildup
                    if (feverMode) heatGen *= 0.5;
                    
                    drillHeat = Math.min(maxDrillHeat, drillHeat + heatGen * deltaMultiplier);
                    
                    // Check for overheat
                    if (drillHeat >= maxDrillHeat && !drillOverheated) {
                        drillOverheated = true;
                        drillCooldownTimer = DRILL_COOLDOWN_FRAMES;
                        player.digging = false;
                        player.digTarget = null;
                        triggerScreenFlash('#ff4400', 0.4, 15);
                        screenShake = 8;
                        createFloatingText('üî• OVERHEATED!', player.x + player.width/2, player.y - 20, '#ff4400');
                    } else {
                        player.digProgress += (1/60) * deltaMultiplier;
                        if (player.digProgress >= player.digTarget.time) {
                            completeDig(false);
                        }
                    }
                }
            } else {
                let dx = 0, dy = 0;
                
                // Apply fever mode speed bonus
                const moveSpeed = player.speed * (feverMode ? 1.3 : 1);
                
                if (keys.left) dx = -moveSpeed;
                if (keys.right) dx = moveSpeed;
                if (keys.up) {
                    dy = -moveSpeed * 0.7 * (1 + permanentUpgrades.climbSpeed / 100);
                }
                
                if (keys.down && !player.digging) {
                    lastDigDirection = 'down';
                    const tx = Math.floor((player.x + player.width / 2) / TILE_SIZE);
                    const absoluteTy = Math.floor((player.y + player.height) / TILE_SIZE);
                    const ty = getWorldRow(absoluteTy);
                    if (ty >= 0 && ty < world.length && world[ty][tx] !== TILE.AIR) {
                        dig(tx, absoluteTy);
                    }
                }
                
                if (dx !== 0) {
                    const newX = player.x + dx * deltaMultiplier;
                    if (newX >= 0 && newX + player.width <= BASE_WIDTH) {
                        // Use multi-point horizontal collision check
                        if (!checkHorizontalCollision(newX, player.y, player.width, player.height, dx)) {
                            player.x = newX;
                            // Speed lines when moving fast in fever mode
                            if (feverMode && Math.random() < 0.2) createSpeedLine();
                        } else if (!player.digging) {
                            lastDigDirection = dx > 0 ? 'right' : 'left';
                            const checkX = dx > 0 ? newX + player.width : newX;
                            const midY = player.y + player.height / 2;
                            const tx = Math.floor(checkX / TILE_SIZE);
                            const absoluteTy = Math.floor(midY / TILE_SIZE);
                            dig(tx, absoluteTy);
                        }
                    }
                }
                
                if (dy < 0) {
                    const MIN_PLAYER_Y = 10; // Prevent flying too high
                    const targetY = Math.max(MIN_PLAYER_Y, player.y + dy * deltaMultiplier);
                    
                    // Step-by-step collision check to prevent tunneling through rocks
                    const step = 2; // Check every 2 pixels
                    let newY = player.y;
                    let blocked = false;
                    
                    while (newY > targetY && !blocked) {
                        const nextY = Math.max(targetY, newY - step);
                        if (checkCollision(player.x, nextY, player.width, player.height)) {
                            blocked = true;
                        } else {
                            newY = nextY;
                        }
                    }
                    
                    if (newY < player.y && newY >= MIN_PLAYER_Y) {
                        player.y = newY;
                        let climbCost = 0.1 * (1 - getEffectiveUpgrade('fuelEfficiency', 90) / 100);
                        if (feverMode) climbCost *= 0.5;
                        fuel -= climbCost * deltaMultiplier;
                        updateFuelBar();
                        
                        // Thruster particles
                        if (Math.random() < 0.4 && particles.length < MAX_PARTICLES) {
                            const color = feverMode ? '#ff00ff' : '#ff6600';
                            particles.push({
                                x: player.x + player.width / 2 + (Math.random() - 0.5) * 8,
                                y: player.y + player.height,
                                vx: (Math.random() - 0.5) * 2,
                                vy: 2 + Math.random() * 2,
                                size: 3 + Math.random() * 3,
                                color: color,
                                life: 0.5,
                                type: 'thruster'
                            });
                        }
                    }
                }
                
                // Gravity
                if (!keys.up) {
                    const newY = player.y + 3 * deltaMultiplier;
                    if (!checkCollision(player.x, newY, player.width, player.height)) {
                        player.y = newY;
                    }
                }
                
                // Unstuck player if somehow inside a wall
                unstuckPlayer();
            }
            
            // Clear dig direction when keys released (but keep direction during overheat for visual feedback)
            if (!drillOverheated) {
                if (!keys.down && lastDigDirection === 'down') lastDigDirection = null;
                if (!keys.left && lastDigDirection === 'left') lastDigDirection = null;
                if (!keys.right && lastDigDirection === 'right') lastDigDirection = null;
            }
            
            // Gem magnet
            if (permanentUpgrades.gemMagnet > 0) {
                const magnetRange = permanentUpgrades.gemMagnet * TILE_SIZE;
                const pcx = player.x + player.width / 2;
                const pcy = player.y + player.height / 2;
                
                const startTX = Math.max(0, Math.floor((pcx - magnetRange) / TILE_SIZE));
                const endTX = Math.min(WORLD_WIDTH - 1, Math.floor((pcx + magnetRange) / TILE_SIZE));
                const startAbsTY = Math.floor((pcy - magnetRange) / TILE_SIZE);
                const endAbsTY = Math.floor((pcy + magnetRange) / TILE_SIZE);
                
                for (let absoluteTy = startAbsTY; absoluteTy <= endAbsTY; absoluteTy++) {
                    const ty = getWorldRow(absoluteTy);
                    if (ty < 0 || ty >= world.length) continue;
                    
                    for (let tx = startTX; tx <= endTX; tx++) {
                        const tile = world[ty][tx];
                        if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                            const gemX = tx * TILE_SIZE + TILE_SIZE / 2;
                            const gemY = absoluteTy * TILE_SIZE + TILE_SIZE / 2;
                            const dist = Math.sqrt(Math.pow(gemX - pcx, 2) + Math.pow(gemY - pcy, 2));
                            
                            if (dist < magnetRange) {
                                // BUG FIX: Pass true to indicate magnet collection (no fuel cost)
                                player.digTarget = { x: tx, y: absoluteTy, time: 0 };
                                completeDig(true);
                            }
                        }
                    }
                }
            }
            
            // Camera follow - faster when player moves up, smoother when going down
            const targetCameraY = Math.max(-40, player.y - BASE_HEIGHT * 0.3);
            const cameraDiff = targetCameraY - cameraY;
            // Use faster lerp when camera needs to catch up going upward (player above camera view)
            const lerpSpeed = cameraDiff < 0 ? 0.15 : 0.08;
            cameraY += cameraDiff * lerpSpeed * deltaMultiplier;
            
            // Depth tracking
            const newDepth = Math.floor((player.y - 60) / TILE_SIZE);
            if (newDepth > depth) {
                depth = newDepth;
                if (depth > maxDepthThisRun) {
                    maxDepthThisRun = depth;
                }
                depthEl.textContent = depth;
                depthColorShift = Math.min(depth / 200, 1);
                
                const milestone = Math.floor(depth / 50) * 50;
                if (milestone > lastUpgradeDepth && milestone > 0) {
                    lastUpgradeDepth = milestone;
                    showUpgradeSelector(milestone % 250 === 0);
                }
            }
            
            updateParticles();
            
            if (fuel <= 0 || hull <= 0) {
                gameOver();
            }
        }
        
        function updateFuelBar() {
            const percent = Math.max(0, (fuel / maxFuel) * 100);
            fuelBar.style.width = percent + '%';
            fuelPercent.textContent = Math.round(percent);
            fuelBarContainer.classList.toggle('critical', percent < 25);
        }
        
        function updateHullBar() {
            const percent = Math.max(0, (hull / maxHull) * 100);
            hullBar.style.width = percent + '%';
            hullPercent.textContent = Math.round(percent);
            hullBarContainer.classList.toggle('critical', percent < 25);
        }
        
        // ==================== DRAWING ====================
        function draw() {
            ctx.save();
            
            if (screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake * 2,
                    (Math.random() - 0.5) * screenShake * 2
                );
            }
            
            // Background
            const hue1 = 220 - depthColorShift * 40;
            const hue2 = 240 - depthColorShift * 50;
            const bgGrad = ctx.createLinearGradient(0, 0, 0, BASE_HEIGHT);
            
            // Fever mode tints background magenta
            if (feverMode) {
                const feverPulse = 0.5 + Math.sin(globalTime * 0.1) * 0.2;
                bgGrad.addColorStop(0, `hsl(300, 50%, ${4 * feverPulse}%)`);
                bgGrad.addColorStop(0.5, `hsl(280, 45%, ${3 * feverPulse}%)`);
                bgGrad.addColorStop(1, `hsl(260, 55%, ${2 * feverPulse}%)`);
            } else {
                bgGrad.addColorStop(0, `hsl(${hue1}, 40%, 3%)`);
                bgGrad.addColorStop(0.5, `hsl(${hue2}, 35%, 2%)`);
                bgGrad.addColorStop(1, `hsl(${hue2 - 10}, 45%, 1%)`);
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // Background stars (simplified)
            ctx.globalAlpha = 0.35;
            const starTime = globalTime * 0.05;
            for (let i = 0; i < bgStars.length; i++) {
                const star = bgStars[i];
                const sy = star.y - cameraY * 0.3;
                const modY = ((sy % BASE_HEIGHT) + BASE_HEIGHT) % BASE_HEIGHT;
                const twinkle = 0.5 + Math.sin(starTime + star.twinkle) * 0.5;
                ctx.fillStyle = feverMode ? `rgba(255, 150, 255, ${twinkle * 0.6})` : `rgba(200, 220, 255, ${twinkle * 0.5})`;
                ctx.fillRect(star.x - star.size/2, modY - star.size/2, star.size, star.size);
            }
            ctx.globalAlpha = 1;
            
            // ===== SPEED LINES =====
            if (speedLines.length > 0) {
                ctx.strokeStyle = feverMode ? 'rgba(255, 100, 255, 0.6)' : 'rgba(100, 200, 255, 0.4)';
                ctx.lineWidth = 2;
                for (const line of speedLines) {
                    ctx.globalAlpha = line.alpha;
                    ctx.beginPath();
                    ctx.moveTo(line.x, line.y);
                    ctx.lineTo(line.x, line.y + line.length);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Ambient particles
            for (let i = 0; i < ambientParticles.length; i++) {
                const p = ambientParticles[i];
                const sy = p.y - cameraY;
                if (sy > -10 && sy < BASE_HEIGHT + 10) {
                    const hue = feverMode ? 300 : p.hue;
                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${p.alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, sy, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw surface fuel zone indicators and "FUEL HERE" text
            const surfaceScreenY = -cameraY;
            // Line position: at REFUEL_LINE_Y constant
            const refuelLineY = REFUEL_LINE_Y - cameraY;
            
            if (surfaceScreenY > -100 && surfaceScreenY < BASE_HEIGHT + 100) {
                // === "FUEL & REPAIR HERE" flashing text at top of fuel zone ===
                const flashAlpha = 0.25 + Math.sin(globalTime * 0.08) * 0.15; // Slow flash
                ctx.save();
                ctx.fillStyle = `rgba(0, 255, 136, ${flashAlpha})`;
                ctx.font = 'bold 14px Oxanium, monospace';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;
                ctx.fillText('‚õΩ FUEL & REPAIR HERE üîß', BASE_WIDTH / 2, surfaceScreenY + 12);
                ctx.restore();
                
                // Refuel zone indicator line (dashed) at bottom of refuel zone
                if (refuelLineY > -20 && refuelLineY < BASE_HEIGHT + 20) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.45)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, refuelLineY);
                    ctx.lineTo(BASE_WIDTH, refuelLineY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Pulsing refuel/repair effect when player is in zone
                const playerCenterY = player.y + player.height / 2;
                const isAboveRefuelLine = playerCenterY <= REFUEL_LINE_Y;
                const needsFuel = fuel < maxFuel;
                const needsRepair = hull < maxHull;
                
                if (isAboveRefuelLine && (needsFuel || needsRepair)) {
                    const pulse = 0.12 + Math.sin(globalTime * 0.2) * 0.06;
                    const refuelGrad = ctx.createLinearGradient(0, 0, 0, refuelLineY + 20);
                    refuelGrad.addColorStop(0, `rgba(0, 255, 136, ${pulse * 0.3})`);
                    refuelGrad.addColorStop(0.5, `rgba(0, 255, 136, ${pulse})`);
                    refuelGrad.addColorStop(1, `rgba(0, 255, 136, 0)`);
                    ctx.fillStyle = refuelGrad;
                    ctx.fillRect(0, 0, BASE_WIDTH, refuelLineY + 20);
                    
                    // Status text based on what's happening
                    let statusText = '';
                    if (needsFuel && needsRepair) statusText = 'REFUELING & REPAIRING...';
                    else if (needsFuel) statusText = 'REFUELING...';
                    else if (needsRepair) statusText = 'REPAIRING...';
                    
                    ctx.fillStyle = `rgba(0, 255, 136, ${0.5 + Math.sin(globalTime * 0.25) * 0.3})`;
                    ctx.font = 'bold 11px Oxanium, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(statusText, BASE_WIDTH / 2, surfaceScreenY + 28);
                }
            }
            
            // === GAS STATION (background layer - drawn before world tiles) ===
            // Positioned at player's starting level, centered between left edge and player
            const stationCenterX = BASE_WIDTH / 4 - TILE_SIZE; // One block left of center
            const stationScreenY = TILE_SIZE * 2 - cameraY; // Row 2 level
            
            if (stationScreenY > -80 && stationScreenY < BASE_HEIGHT + 50) {
                const pumpGlow = 0.7 + Math.sin(globalTime * 0.15) * 0.3;
                const groundY = stationScreenY + TILE_SIZE; // Bottom of station just touches ground
                
                // Station building (main structure)
                ctx.fillStyle = '#2d4a5a';
                ctx.fillRect(stationCenterX - 22, groundY - 38, 44, 38);
                
                // Roof
                ctx.fillStyle = '#1a3040';
                ctx.fillRect(stationCenterX - 25, groundY - 42, 50, 5);
                
                // Roof edge highlight
                ctx.fillStyle = '#3a5a6a';
                ctx.fillRect(stationCenterX - 25, groundY - 43, 50, 2);
                
                // Window
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(stationCenterX - 16, groundY - 32, 18, 12);
                ctx.fillStyle = `rgba(100, 200, 255, ${0.25 + pumpGlow * 0.15})`;
                ctx.fillRect(stationCenterX - 14, groundY - 30, 14, 8);
                
                // Door
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(stationCenterX + 6, groundY - 26, 10, 26);
                ctx.fillStyle = '#3a5a6a';
                ctx.fillRect(stationCenterX + 8, groundY - 24, 6, 10);
                
                // Red canopy over pump area
                ctx.fillStyle = '#cc3333';
                ctx.fillRect(stationCenterX + 20, groundY - 44, 36, 6);
                ctx.fillStyle = '#992222';
                ctx.fillRect(stationCenterX + 20, groundY - 38, 36, 3);
                
                // Canopy pole
                ctx.fillStyle = '#555555';
                ctx.fillRect(stationCenterX + 36, groundY - 35, 4, 35);
                
                // Gas pump
                ctx.fillStyle = '#dddddd';
                ctx.fillRect(stationCenterX + 24, groundY - 30, 16, 30);
                ctx.fillStyle = '#333333';
                ctx.fillRect(stationCenterX + 26, groundY - 26, 12, 10); // Screen
                ctx.fillStyle = `rgba(0, 255, 100, ${pumpGlow})`;
                ctx.fillRect(stationCenterX + 27, groundY - 25, 10, 8); // Screen glow
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(stationCenterX + 26, groundY - 14, 12, 6); // Orange stripe
                
                // Nozzle hanging
                ctx.fillStyle = '#222222';
                ctx.fillRect(stationCenterX + 41, groundY - 22, 6, 3);
                ctx.fillRect(stationCenterX + 45, groundY - 24, 3, 10);
                
                // "GAS" neon sign on building
                ctx.save();
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10 * pumpGlow;
                ctx.fillStyle = `rgba(0, 255, 136, ${0.6 + pumpGlow * 0.3})`;
                ctx.font = 'bold 11px Oxanium, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('GAS', stationCenterX, groundY - 46);
                ctx.restore();
                
                // Price sign on pole
                ctx.fillStyle = '#111111';
                ctx.fillRect(stationCenterX + 50, groundY - 32, 18, 22);
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 7px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('$1.99', stationCenterX + 59, groundY - 20);
                ctx.fillStyle = '#ffff00';
                ctx.font = '5px Arial';
                ctx.fillText('/gal', stationCenterX + 59, groundY - 14);
            }
            
            // === REPAIR SHOP (mirrored on right side) ===
            const shopCenterX = 3 * BASE_WIDTH / 4 + TILE_SIZE; // One block right of center
            const shopScreenY = TILE_SIZE * 2 - cameraY; // Same row as gas station
            
            if (shopScreenY > -80 && shopScreenY < BASE_HEIGHT + 50) {
                const shopGlow = 0.7 + Math.sin(globalTime * 0.06) * 0.3; // Slower flashing
                const groundY = shopScreenY + TILE_SIZE;
                
                // Shop building (main structure) - mirrored
                ctx.fillStyle = '#4a3a2d';
                ctx.fillRect(shopCenterX - 22, groundY - 38, 44, 38);
                
                // Roof
                ctx.fillStyle = '#302518';
                ctx.fillRect(shopCenterX - 25, groundY - 42, 50, 5);
                
                // Roof edge highlight
                ctx.fillStyle = '#5a4a3a';
                ctx.fillRect(shopCenterX - 25, groundY - 43, 50, 2);
                
                // Window (mirrored - on right side of building)
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(shopCenterX - 2, groundY - 32, 18, 12);
                ctx.fillStyle = `rgba(255, 200, 100, ${0.2 + shopGlow * 0.2})`;
                ctx.fillRect(shopCenterX, groundY - 30, 14, 8);
                
                // Door (mirrored - on left side of building)
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(shopCenterX - 16, groundY - 26, 10, 26);
                ctx.fillStyle = '#5a4a3a';
                ctx.fillRect(shopCenterX - 14, groundY - 24, 6, 10);
                
                // Blue canopy over work area (mirrored to left)
                ctx.fillStyle = '#3366cc';
                ctx.fillRect(shopCenterX - 56, groundY - 44, 36, 6);
                ctx.fillStyle = '#224488';
                ctx.fillRect(shopCenterX - 56, groundY - 38, 36, 3);
                
                // Canopy pole (mirrored)
                ctx.fillStyle = '#555555';
                ctx.fillRect(shopCenterX - 40, groundY - 35, 4, 35);
                
                // Tool cabinet / work station - improved design
                // Main cabinet body
                ctx.fillStyle = '#b83030';
                ctx.fillRect(shopCenterX - 52, groundY - 30, 16, 30);
                // Cabinet edge highlight
                ctx.fillStyle = '#d44040';
                ctx.fillRect(shopCenterX - 52, groundY - 30, 2, 30);
                // Cabinet shadow edge
                ctx.fillStyle = '#8a2020';
                ctx.fillRect(shopCenterX - 38, groundY - 30, 2, 30);
                
                // Top drawer
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(shopCenterX - 50, groundY - 27, 12, 9);
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(shopCenterX - 50, groundY - 27, 12, 2); // Drawer top edge
                
                // Bottom drawer (taller)
                ctx.fillStyle = '#252525';
                ctx.fillRect(shopCenterX - 50, groundY - 16, 12, 12);
                ctx.fillStyle = '#353535';
                ctx.fillRect(shopCenterX - 50, groundY - 16, 12, 2); // Drawer top edge
                
                // Drawer handles (chrome look)
                ctx.fillStyle = '#aaaaaa';
                ctx.fillRect(shopCenterX - 47, groundY - 23, 6, 2);
                ctx.fillStyle = '#cccccc';
                ctx.fillRect(shopCenterX - 47, groundY - 23, 6, 1);
                ctx.fillStyle = '#aaaaaa';
                ctx.fillRect(shopCenterX - 47, groundY - 10, 6, 2);
                ctx.fillStyle = '#cccccc';
                ctx.fillRect(shopCenterX - 47, groundY - 10, 6, 1);
                
                // Cabinet top surface
                ctx.fillStyle = '#444444';
                ctx.fillRect(shopCenterX - 53, groundY - 31, 18, 2);
                
                // Wrench hanging (mirrored nozzle equivalent)
                ctx.fillStyle = '#888888';
                ctx.fillRect(shopCenterX - 59, groundY - 22, 6, 3);
                ctx.fillStyle = '#666666';
                ctx.fillRect(shopCenterX - 62, groundY - 26, 4, 12);
                
                // "REPAIR" neon sign on building
                ctx.save();
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10 * shopGlow;
                ctx.fillStyle = `rgba(0, 255, 255, ${0.6 + shopGlow * 0.3})`;
                ctx.font = 'bold 9px Oxanium, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('REPAIR', shopCenterX, groundY - 46);
                ctx.restore();
                
                // Service sign on pole (mirrored)
                ctx.fillStyle = '#111111';
                ctx.fillRect(shopCenterX - 68, groundY - 32, 18, 22);
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 6px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('HULL', shopCenterX - 59, groundY - 22);
                ctx.fillStyle = '#ffff00';
                ctx.font = '5px Arial';
                ctx.fillText('FIX', shopCenterX - 59, groundY - 14);
            }
            
            // Draw world
            const startRow = Math.max(0, Math.floor(cameraY / TILE_SIZE) - worldRowOffset);
            const endRow = Math.min(world.length - 1, Math.ceil((cameraY + BASE_HEIGHT) / TILE_SIZE) - worldRowOffset);
            
            for (let y = startRow; y <= endRow; y++) {
                const absoluteY = y + worldRowOffset;
                const screenY = absoluteY * TILE_SIZE - cameraY;
                
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    const tile = world[y][x];
                    if (tile !== TILE.AIR) {
                        drawTile(tile, x * TILE_SIZE, screenY, x, absoluteY);
                    }
                }
            }
            
            drawParticles();
            drawEnemies();
            drawPlayer();
            drawFloatingTexts();
            
            // Vignette (stronger during fever mode, red during overheat)
            const vignette = ctx.createRadialGradient(
                BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.25,
                BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.85
            );
            
            const heatPercent = drillHeat / maxDrillHeat;
            
            if (drillOverheated) {
                // Pulsing red vignette when overheated
                const pulse = Math.sin(globalTime * 0.25) * 0.15 + 0.35;
                vignette.addColorStop(0, 'rgba(50, 0, 0, 0)');
                vignette.addColorStop(0.5, `rgba(100, 0, 0, ${pulse * 0.3})`);
                vignette.addColorStop(1, `rgba(150, 0, 0, ${pulse})`);
            } else if (heatPercent > 0.7) {
                // Warning orange vignette when near overheat
                const warningAlpha = (heatPercent - 0.7) / 0.3 * 0.25;
                vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignette.addColorStop(0.6, `rgba(80, 30, 0, ${warningAlpha * 0.5})`);
                vignette.addColorStop(1, `rgba(120, 40, 0, ${warningAlpha})`);
            } else if (feverMode) {
                vignette.addColorStop(0, 'rgba(50, 0, 50, 0)');
                vignette.addColorStop(0.6, 'rgba(80, 0, 80, 0.15)');
                vignette.addColorStop(1, 'rgba(100, 0, 100, 0.4)');
            } else {
                vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0.15)');
                vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            }
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // OPTIMIZATION: Use cached scanline pattern
            if (cachedScanlinePattern) {
                ctx.fillStyle = cachedScanlinePattern;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            }
            
            // ===== SCREEN FLASH =====
            if (screenFlash.active) {
                const flashAlpha = screenFlash.alpha * (screenFlash.duration / 20);
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = flashAlpha;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                ctx.globalAlpha = 1;
            }
            
            // ===== COMBO METER UI =====
            if (comboCount > 0) {
                const comboX = 10;
                const comboY = BASE_HEIGHT - 50;
                const meterWidth = 100;
                const meterHeight = 8;
                const progress = comboTimer / COMBO_DECAY_TIME;
                const multiplier = getComboMultiplier();
                
                // Meter background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(comboX, comboY + 20, meterWidth, meterHeight);
                
                // Meter fill
                const meterColor = multiplier >= 4 ? '#ff00ff' : multiplier >= 3 ? '#ff9500' : multiplier >= 2 ? '#00f0ff' : '#00ff88';
                ctx.fillStyle = meterColor;
                ctx.fillRect(comboX, comboY + 20, meterWidth * progress, meterHeight);
                
                // Meter border
                ctx.strokeStyle = meterColor;
                ctx.lineWidth = 1;
                ctx.strokeRect(comboX, comboY + 20, meterWidth, meterHeight);
                
                // Combo text
                const comboScale = 1 + (multiplier - 1) * 0.1;
                ctx.font = `bold ${Math.floor(16 * comboScale)}px Oxanium, monospace`;
                ctx.fillStyle = meterColor;
                ctx.textAlign = 'left';
                ctx.shadowColor = meterColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`${comboCount} COMBO`, comboX, comboY + 14);
                
                if (multiplier > 1) {
                    ctx.font = `bold ${Math.floor(20 * comboScale)}px Oxanium, monospace`;
                    ctx.fillText(`x${multiplier}`, comboX + meterWidth + 10, comboY + 26);
                }
                ctx.shadowBlur = 0;
            }
            
            // ===== FEVER MODE INDICATOR =====
            if (feverMode) {
                const feverProgress = feverTimer / FEVER_DURATION;
                const feverX = BASE_WIDTH - 110;
                const feverY = BASE_HEIGHT - 35;
                
                // Pulsing "FEVER" text
                const feverPulse = 1 + Math.sin(globalTime * 0.2) * 0.1;
                ctx.font = `bold ${Math.floor(18 * feverPulse)}px Oxanium, monospace`;
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'right';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 15;
                ctx.fillText('üî• FEVER!', BASE_WIDTH - 10, feverY);
                ctx.shadowBlur = 0;
                
                // Timer bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(feverX, feverY + 5, 100, 6);
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(feverX, feverY + 5, 100 * feverProgress, 6);
            }
            
            ctx.restore();
        }
        
        function drawTile(tile, x, y, tx, ty) {
            const s = TILE_SIZE;
            const time = globalTime * 0.02;
            
            switch(tile) {
                case TILE.DIRT:
                    ctx.fillStyle = '#3d2d20';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = '#4a3828';
                    ctx.fillRect(x, y, s, s * 0.4);
                    ctx.fillStyle = 'rgba(0,0,0,0.15)';
                    ctx.fillRect(x + ((tx * 7) % s), y + ((ty * 11) % s), 2, 2);
                    ctx.fillRect(x + ((tx * 7 + 13) % s), y + ((ty * 11 + 7) % s), 2, 2);
                    break;
                    
                case TILE.ROCK:
                    ctx.fillStyle = '#404040';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(x, y, s, 1);
                    ctx.fillRect(x, y, 1, s);
                    break;
                    
                case TILE.HARD_ROCK:
                    ctx.fillStyle = '#252530';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = 'rgba(80, 100, 150, 0.2)';
                    ctx.beginPath();
                    ctx.moveTo(x + 3, y + s/2);
                    ctx.lineTo(x + s/2, y + 3);
                    ctx.lineTo(x + s - 3, y + s/2);
                    ctx.lineTo(x + s/2, y + s - 3);
                    ctx.closePath();
                    ctx.fill();
                    break;
                
                case TILE.BEDROCK:
                    // Dark impenetrable stone with metallic sheen
                    ctx.fillStyle = '#151518';
                    ctx.fillRect(x, y, s, s);
                    // Cross-hatch pattern to show it's special
                    ctx.strokeStyle = 'rgba(60, 60, 80, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + s, y + s);
                    ctx.moveTo(x + s, y);
                    ctx.lineTo(x, y + s);
                    ctx.stroke();
                    // Subtle border
                    ctx.strokeStyle = 'rgba(80, 80, 100, 0.3)';
                    ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
                    break;
                    
                case TILE.GEM_COMMON:
                case TILE.GEM_RARE:
                case TILE.GEM_EPIC:
                    ctx.fillStyle = '#1a1a22';
                    ctx.fillRect(x, y, s, s);
                    
                    const gemColors = {
                        [TILE.GEM_COMMON]: ['#00f0ff', '#00b0bb'],
                        [TILE.GEM_RARE]: ['#ff00ff', '#bb00bb'],
                        [TILE.GEM_EPIC]: ['#ff9500', '#cc7700']
                    };
                    const colors = gemColors[tile];
                    const pulse = 0.85 + Math.sin(time * 3 + tx + ty) * 0.15;
                    
                    // OPTIMIZATION: Reduced shadow usage
                    ctx.fillStyle = colors[1];
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + s/2 - 7 * pulse);
                    ctx.lineTo(x + s/2 + 6 * pulse, y + s/2);
                    ctx.lineTo(x + s/2, y + s/2 + 7 * pulse);
                    ctx.lineTo(x + s/2 - 6 * pulse, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = colors[0];
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + s/2 - 3 * pulse);
                    ctx.lineTo(x + s/2 + 2 * pulse, y + s/2);
                    ctx.lineTo(x + s/2, y + s/2 + 3 * pulse);
                    ctx.lineTo(x + s/2 - 2 * pulse, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case TILE.LAVA:
                    const lavaIntensity = 0.5 + Math.sin(time * 3 + tx) * 0.3;
                    ctx.fillStyle = `rgb(${180 + lavaIntensity * 75}, ${30 + lavaIntensity * 40}, 0)`;
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + s * 0.3, y + (Math.sin(time * 2 + tx * 2) + 1) * s / 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff5500';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
                    break;
                    
                case TILE.GAS:
                    const gasAlpha = 0.35 + Math.sin(time * 2 + tx + ty) * 0.15;
                    ctx.fillStyle = '#101a10';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = `rgba(80, 220, 80, ${gasAlpha})`;
                    ctx.fillRect(x, y, s, s);
                    break;
                    
                case TILE.FUEL:
                    // Fuel canister - orange with pulsing glow
                    const fuelPulse = 0.8 + Math.sin(time * 3 + tx + ty) * 0.2;
                    ctx.fillStyle = '#1a1208';
                    ctx.fillRect(x, y, s, s);
                    
                    // Canister body
                    ctx.fillStyle = `rgba(255, 140, 0, ${fuelPulse})`;
                    ctx.beginPath();
                    ctx.roundRect(x + 6, y + 4, s - 12, s - 8, 3);
                    ctx.fill();
                    
                    // Canister highlight
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(x + 8, y + 6, s - 16, 3);
                    
                    // Cap
                    ctx.fillStyle = '#666';
                    ctx.fillRect(x + s/2 - 3, y + 2, 6, 4);
                    
                    // "F" symbol
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${Math.floor(s * 0.35)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('F', x + s/2, y + s/2 + 5);
                    break;
                    
                case TILE.BOMB:
                    // Dark background
                    ctx.fillStyle = '#1a1515';
                    ctx.fillRect(x, y, s, s);
                    
                    // Bomb body (pulsing)
                    const bombPulse = 0.9 + Math.sin(time * 5 + tx + ty) * 0.1;
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, (s/2 - 4) * bombPulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bomb highlight
                    ctx.fillStyle = '#555555';
                    ctx.beginPath();
                    ctx.arc(x + s/2 - 3, y + s/2 - 1, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fuse
                    ctx.strokeStyle = '#aa6600';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 4);
                    ctx.quadraticCurveTo(x + s/2 + 4, y + 2, x + s/2 + 6, y + 5);
                    ctx.stroke();
                    
                    // Spark
                    const sparkAlpha = 0.5 + Math.sin(time * 10) * 0.5;
                    ctx.fillStyle = `rgba(255, 200, 50, ${sparkAlpha})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 6, y + 4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case TILE.CHEST:
                    // Dark background
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x, y, s, s);
                    
                    const chestGlow = 0.85 + Math.sin(time * 2 + tx) * 0.15;
                    
                    // Chest body (wooden brown box)
                    ctx.fillStyle = `rgb(${Math.floor(110 * chestGlow)}, ${Math.floor(65 * chestGlow)}, ${Math.floor(25 * chestGlow)})`;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + s/2 - 1, s - 4, s/2 - 1, 2);
                    ctx.fill();
                    
                    // Rounded lid (dome top)
                    ctx.fillStyle = `rgb(${Math.floor(130 * chestGlow)}, ${Math.floor(80 * chestGlow)}, ${Math.floor(30 * chestGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 1, s/2 - 3, s/3 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Lid top highlight
                    ctx.fillStyle = `rgb(${Math.floor(150 * chestGlow)}, ${Math.floor(95 * chestGlow)}, ${Math.floor(40 * chestGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 3, s/2 - 6, s/5 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Gold metal bands
                    ctx.fillStyle = `rgb(${Math.floor(220 * chestGlow)}, ${Math.floor(180 * chestGlow)}, 60)`;
                    // Horizontal band across front
                    ctx.fillRect(x + 2, y + s/2 - 2, s - 4, 3);
                    // Vertical bands on sides
                    ctx.fillRect(x + 2, y + s/2 - 1, 3, s/2 - 2);
                    ctx.fillRect(x + s - 5, y + s/2 - 1, 3, s/2 - 2);
                    
                    // Gold lock plate (circular)
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Keyhole
                    ctx.fillStyle = '#1a1510';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(x + s/2 - 1, y + s/2 + 4, 2, 3);
                    
                    // Sparkles
                    ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + Math.sin(time * 4 + tx * 2) * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(x + 8, y + s/3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + s - 8, y + s/3 + 2, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case TILE.UPGRADE_CHEST:
                    // Rare upgrade chest - cartoon style with cyan/magenta
                    const upgradeGlow = 0.85 + Math.sin(time * 3 + tx) * 0.15;
                    const pulsePhase = Math.sin(time * 2) * 0.5 + 0.5;
                    
                    // Background glow
                    ctx.fillStyle = `rgba(0, 255, 200, ${0.2 + pulsePhase * 0.15})`;
                    ctx.fillRect(x - 2, y - 2, s + 4, s + 4);
                    
                    // Dark base
                    ctx.fillStyle = '#0a1520';
                    ctx.fillRect(x, y, s, s);
                    
                    // Chest body (dark teal box)
                    ctx.fillStyle = `rgb(${Math.floor(20 * upgradeGlow)}, ${Math.floor(70 * upgradeGlow)}, ${Math.floor(80 * upgradeGlow)})`;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + s/2 - 1, s - 4, s/2 - 1, 2);
                    ctx.fill();
                    
                    // Rounded lid (dome top - magenta)
                    ctx.fillStyle = `rgb(${Math.floor(100 * upgradeGlow)}, ${Math.floor(30 * upgradeGlow)}, ${Math.floor(120 * upgradeGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 1, s/2 - 3, s/3 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Lid top highlight
                    ctx.fillStyle = `rgb(${Math.floor(130 * upgradeGlow)}, ${Math.floor(50 * upgradeGlow)}, ${Math.floor(150 * upgradeGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 3, s/2 - 6, s/5 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Glowing cyan metal bands
                    ctx.fillStyle = `rgba(0, 255, 255, ${0.7 + pulsePhase * 0.3})`;
                    ctx.fillRect(x + 2, y + s/2 - 2, s - 4, 3);
                    ctx.fillRect(x + 2, y + s/2 - 1, 3, s/2 - 2);
                    ctx.fillRect(x + s - 5, y + s/2 - 1, 3, s/2 - 2);
                    
                    // Glowing lock plate
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + pulsePhase * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Lightning bolt on lock
                    ctx.fillStyle = `rgba(0, 200, 255, 1)`;
                    ctx.font = `bold 10px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ö°', x + s/2, y + s/2 + 4);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Sparkle particles
                    for (let i = 0; i < 3; i++) {
                        const sparkleX = x + 6 + (i * (s - 12) / 2);
                        const sparkleY = y + s/3 + Math.sin(time * 5 + i * 2) * 3;
                        ctx.fillStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(time * 6 + i) * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case TILE.UNSTABLE:
                    // Check if this tile is about to collapse
                    const unstableData = unstableTiles.find(u => u.tx === tx && u.absoluteTy === ty);
                    const isWarning = unstableData && unstableData.timer < 25;
                    const shakeAmount = isWarning ? Math.sin(time * 20) * 2 : 0;
                    
                    // Cracked rock appearance
                    ctx.fillStyle = isWarning ? '#4a3535' : '#3a3545';
                    ctx.fillRect(x + shakeAmount, y, s, s);
                    
                    // Crack lines
                    ctx.strokeStyle = isWarning ? '#ff6666' : '#555566';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x + s/4 + shakeAmount, y);
                    ctx.lineTo(x + s/3 + shakeAmount, y + s/2);
                    ctx.lineTo(x + s/5 + shakeAmount, y + s);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + s*0.7 + shakeAmount, y);
                    ctx.lineTo(x + s*0.6 + shakeAmount, y + s/3);
                    ctx.lineTo(x + s*0.8 + shakeAmount, y + s*0.7);
                    ctx.stroke();
                    
                    // Warning glow
                    if (isWarning) {
                        ctx.fillStyle = `rgba(255, 100, 100, ${0.2 + Math.sin(time * 15) * 0.2})`;
                        ctx.fillRect(x, y, s, s);
                    }
                    break;
            }
            
            // Grid lines (simplified)
            if (tile !== TILE.AIR && tile < TILE.LAVA) {
                ctx.strokeStyle = 'rgba(0,0,0,0.08)';
                ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
            }
        }
        
        function drawPlayer() {
            const screenY = player.y - cameraY;
            const cx = player.x + player.width / 2;
            const heatPercent = drillHeat / maxDrillHeat;
            
            // Calculate drill position early so all effects can use it
            let drillAngle = 0; // 0 = down, -90 = left, 90 = right
            let drillOffsetX = 0;
            let drillOffsetY = player.height;
            
            // Determine drill direction
            let drillDirection = 'down'; // Track current direction
            
            // Check if actively digging sideways
            if (player.digging && player.digTarget) {
                const targetWorldX = player.digTarget.x * TILE_SIZE + TILE_SIZE / 2;
                const playerCenterX = player.x + player.width / 2;
                const dx = targetWorldX - playerCenterX;
                
                if (Math.abs(dx) > TILE_SIZE / 2) {
                    // Drilling left or right
                    if (dx < 0) {
                        drillDirection = 'left';
                    } else {
                        drillDirection = 'right';
                    }
                }
            } 
            // If not digging but holding left/right keys, point drill that direction
            else if (keys.left && !keys.right) {
                drillDirection = 'left';
            } else if (keys.right && !keys.left) {
                drillDirection = 'right';
            }
            // When overheated, remember last dig direction
            else if (drillOverheated && lastDigDirection === 'left') {
                drillDirection = 'left';
            } else if (drillOverheated && lastDigDirection === 'right') {
                drillDirection = 'right';
            }
            
            // Apply direction offsets
            if (drillDirection === 'left') {
                drillAngle = Math.PI / 2;
                drillOffsetX = -player.width / 2 - 3;
                drillOffsetY = player.height / 2 + 1;
            } else if (drillDirection === 'right') {
                drillAngle = -Math.PI / 2;
                drillOffsetX = player.width / 2 + 3;
                drillOffsetY = player.height / 2 + 1;
            }
            
            // Actual drill world position for effects
            const drillWorldX = cx + drillOffsetX;
            const drillWorldY = screenY + drillOffsetY;
            
            // ===== OVERHEAT WARNING AURA =====
            if (heatPercent > 0.7 || drillOverheated) {
                const warningIntensity = drillOverheated ? 0.6 : (heatPercent - 0.7) * 2;
                const pulseSpeed = drillOverheated ? 0.4 : 0.2;
                const pulse = Math.sin(globalTime * pulseSpeed) * 0.3 + 0.7;
                const auraSize = 25 + (drillOverheated ? Math.sin(globalTime * 0.3) * 5 : 0);
                
                const heatAura = ctx.createRadialGradient(drillWorldX, drillWorldY, 5, drillWorldX, drillWorldY, auraSize);
                heatAura.addColorStop(0, `rgba(255, ${drillOverheated ? 50 : 150}, 0, ${warningIntensity * pulse})`);
                heatAura.addColorStop(0.5, `rgba(255, ${drillOverheated ? 0 : 100}, 0, ${warningIntensity * pulse * 0.5})`);
                heatAura.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = heatAura;
                ctx.beginPath();
                ctx.arc(drillWorldX, drillWorldY, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ===== FEVER MODE AURA =====
            if (feverMode) {
                const auraSize = 30 + Math.sin(globalTime * 0.15) * 8;
                const auraGrad = ctx.createRadialGradient(cx, screenY + player.height/2, 5, cx, screenY + player.height/2, auraSize);
                auraGrad.addColorStop(0, 'rgba(255, 0, 255, 0.4)');
                auraGrad.addColorStop(0.5, 'rgba(255, 0, 255, 0.15)');
                auraGrad.addColorStop(1, 'rgba(255, 0, 255, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(cx, screenY + player.height/2, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Thruster glow
            if (keys.up) {
                const thrusterColor = feverMode ? 'rgba(255, 0, 255,' : 'rgba(255, 100, 0,';
                ctx.fillStyle = `${thrusterColor} ${0.4 * player.thrusterFlicker})`;
                ctx.beginPath();
                ctx.ellipse(cx, screenY + 22, 10, 15, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Body color shifts with heat when overheated
            let bodyColor = feverMode ? '#d000d8' : '#00d0d8';
            let highlightColor = feverMode ? '#ff00ff' : '#00f0ff';
            if (drillOverheated) {
                const flashPhase = Math.sin(globalTime * 0.5) * 0.5 + 0.5;
                bodyColor = `rgb(${Math.floor(200 + flashPhase * 55)}, ${Math.floor(50 * (1 - flashPhase))}, ${Math.floor(80 * (1 - flashPhase))})`;
                highlightColor = `rgb(255, ${Math.floor(100 * (1 - flashPhase))}, ${Math.floor(50 * (1 - flashPhase))})`;
            }
            
            // Body
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.roundRect(player.x + 2, screenY + 4, player.width - 4, player.height - 10, 5);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = highlightColor;
            ctx.fillRect(player.x + 4, screenY + 5, player.width - 8, 3);
            
            // Cockpit
            ctx.fillStyle = feverMode ? '#150015' : (drillOverheated ? '#150505' : '#001015');
            ctx.beginPath();
            ctx.roundRect(player.x + 5, screenY + 7, player.width - 10, 10, 3);
            ctx.fill();
            
            ctx.fillStyle = feverMode ? 'rgba(255, 0, 255, 0.7)' : (drillOverheated ? 'rgba(255, 100, 50, 0.7)' : 'rgba(0, 240, 255, 0.7)');
            ctx.beginPath();
            ctx.roundRect(player.x + 6, screenY + 8, player.width - 12, 8, 2);
            ctx.fill();
            
            // Thrusters (draw before drill so drill appears on top)
            ctx.fillStyle = feverMode ? '#450045' : (drillOverheated ? '#452020' : '#004550');
            ctx.fillRect(player.x - 1, screenY + 12, 4, 8);
            ctx.fillRect(player.x + player.width - 3, screenY + 12, 4, 8);
            
            // Drill - color changes with heat (drawn last to appear on top)
            let drillColor = feverMode ? '#ff00ff' : '#e8e8e8';
            if (heatPercent > 0.3 && !feverMode) {
                // Transition from white to orange to red based on heat
                const heatTint = Math.min(1, (heatPercent - 0.3) / 0.7);
                const r = Math.floor(232 + (255 - 232) * heatTint);
                const g = Math.floor(232 - 180 * heatTint);
                const b = Math.floor(232 - 200 * heatTint);
                drillColor = `rgb(${r}, ${g}, ${b})`;
            }
            if (drillOverheated) {
                // Pulsing red when overheated
                const pulse = Math.sin(globalTime * 0.4) * 0.3 + 0.7;
                drillColor = `rgb(255, ${Math.floor(50 * pulse)}, ${Math.floor(30 * pulse)})`;
            }
            
            ctx.fillStyle = drillColor;
            ctx.save();
            
            ctx.translate(drillWorldX, drillWorldY);
            ctx.rotate(drillAngle);
            
            // Drill shake when overheated or near overheat
            if (drillOverheated) {
                const shake = Math.sin(globalTime * 0.8) * 2;
                ctx.translate(shake, 0);
            } else if (heatPercent > 0.8) {
                const shake = Math.sin(globalTime * 0.6) * 1;
                ctx.translate(shake, 0);
            }
            
            if (player.digging) {
                const spinSpeed = feverMode ? 0.8 : 0.5;
                ctx.rotate(Math.sin(globalTime * spinSpeed) * 0.15);
            }
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.lineTo(8, -4);
            ctx.lineTo(3, 10);
            ctx.lineTo(0, 14);
            ctx.lineTo(-3, 10);
            ctx.closePath();
            ctx.fill();
            
            // Drill glow when hot
            if (heatPercent > 0.5) {
                ctx.shadowColor = drillOverheated ? '#ff2200' : '#ff8800';
                ctx.shadowBlur = 8 + heatPercent * 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            ctx.strokeStyle = feverMode ? '#aa00aa' : (drillOverheated ? '#aa2200' : '#999999');
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-4, 0);
            ctx.lineTo(0, 10);
            ctx.moveTo(4, 0);
            ctx.lineTo(0, 10);
            ctx.stroke();
            ctx.restore();
            
            // Dig progress indicator
            if (player.digging && player.digTarget) {
                const progress = player.digProgress / player.digTarget.time;
                const barColor = feverMode ? 'rgba(255, 0, 255,' : 'rgba(0, 240, 255,';
                ctx.fillStyle = `${barColor} 0.8)`;
                ctx.fillRect(player.x, screenY - 6, player.width * progress, 3);
                ctx.strokeStyle = `${barColor} 0.4)`;
                ctx.strokeRect(player.x, screenY - 6, player.width, 3);
            }
            
            // Drill heat bar (shows when heat > 20%)
            if (drillHeat > 20 || drillOverheated) {
                const heatPercent = drillHeat / maxDrillHeat;
                const heatBarWidth = player.width + 8;
                const heatBarX = player.x - 4;
                const heatBarY = screenY - 14;
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(heatBarX, heatBarY, heatBarWidth, 5);
                
                // Heat fill - transitions from yellow to orange to red
                let heatColor;
                if (heatPercent < 0.5) {
                    heatColor = `rgb(255, ${Math.floor(255 - heatPercent * 200)}, 50)`;
                } else if (heatPercent < 0.8) {
                    heatColor = `rgb(255, ${Math.floor(155 - (heatPercent - 0.5) * 300)}, 30)`;
                } else {
                    heatColor = '#ff2200';
                }
                
                // Pulsing when near overheat
                if (heatPercent > 0.7) {
                    const pulse = Math.sin(globalTime * 0.3) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                }
                
                ctx.fillStyle = heatColor;
                ctx.fillRect(heatBarX, heatBarY, heatBarWidth * heatPercent, 5);
                ctx.globalAlpha = 1;
                
                // Border
                ctx.strokeStyle = drillOverheated ? '#ff0000' : 'rgba(255, 150, 50, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(heatBarX, heatBarY, heatBarWidth, 5);
                
                // Overheat warning icon
                if (drillOverheated) {
                    ctx.fillStyle = '#ff4400';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('üî•', player.x + player.width/2, heatBarY - 3);
                }
            }
        }
        
        function drawEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const screenX = enemy.x;
                const screenY = enemy.y - cameraY;
                
                // Skip off-screen enemies
                if (screenY < -30 || screenY > BASE_HEIGHT + 30) continue;
                
                const wobble = Math.sin(enemy.animFrame) * 2;
                const dangerPulse = 0.5 + Math.sin(enemy.animFrame * 3) * 0.3;
                
                // ===== DANGER AURA (all enemies) =====
                const auraSize = 35 + Math.sin(enemy.animFrame * 2) * 8;
                let auraR, auraG, auraB;
                if (enemy.type === ENEMY_TYPE.LAVA_SLUG) {
                    auraR = 255; auraG = 68; auraB = 0;
                } else if (enemy.type === ENEMY_TYPE.WORM) {
                    auraR = 68; auraG = 255; auraB = 68;
                } else {
                    auraR = 255; auraG = 51; auraB = 102;
                }
                
                const auraGrad = ctx.createRadialGradient(screenX, screenY, 3, screenX, screenY, auraSize);
                auraGrad.addColorStop(0, `rgba(${auraR}, ${auraG}, ${auraB}, ${dangerPulse * 0.9})`);
                auraGrad.addColorStop(0.4, `rgba(${auraR}, ${auraG}, ${auraB}, ${dangerPulse * 0.5})`);
                auraGrad.addColorStop(0.7, `rgba(255, 50, 50, ${dangerPulse * 0.25})`);
                auraGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(screenX, screenY, auraSize, 0, Math.PI * 2);
                ctx.fill();
                
                // ===== WARNING INDICATOR =====
                ctx.save();
                ctx.fillStyle = '#ff3366';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 12;
                const warningY = screenY - 25 - Math.sin(enemy.animFrame * 4) * 4;
                ctx.fillText('‚ö†', screenX, warningY);
                ctx.restore();
                
                if (enemy.type === ENEMY_TYPE.WORM) {
                    // Burrowing worm - always visible on top of blocks
                    // Glow effect
                    ctx.shadowColor = '#44ff44';
                    ctx.shadowBlur = 15;
                    
                    // Head outline (white border for visibility)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + wobble, 10, 8, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Head (larger)
                    ctx.fillStyle = '#44ff44';
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + wobble, 9, 7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body segments (larger)
                    ctx.fillStyle = '#33dd33';
                    for (let seg = 1; seg <= 3; seg++) {
                        const segWobble = Math.sin(enemy.animFrame + seg * 0.5) * 2;
                        ctx.beginPath();
                        ctx.ellipse(screenX - seg * 5, screenY + segWobble, 7 - seg * 0.5, 5 - seg * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;
                    
                    // Eyes (larger, angrier)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(screenX + 4, screenY + wobble - 2, 3, 0, Math.PI * 2);
                    ctx.arc(screenX + 4, screenY + wobble + 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(screenX + 5, screenY + wobble - 2, 1.5, 0, Math.PI * 2);
                    ctx.arc(screenX + 5, screenY + wobble + 2, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (enemy.type === ENEMY_TYPE.BEETLE) {
                    // Cave beetle - larger and glowing
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    
                    // Glow
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 12;
                    
                    // Shell outline (white border for visibility)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 13, 10, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Legs (larger)
                    ctx.strokeStyle = '#774422';
                    ctx.lineWidth = 2;
                    const legWobble = Math.sin(enemy.animFrame * 2);
                    ctx.beginPath();
                    ctx.moveTo(-6, 0);
                    ctx.lineTo(-10, 6 + legWobble);
                    ctx.moveTo(6, 0);
                    ctx.lineTo(10, 6 + legWobble);
                    ctx.moveTo(-4, 2);
                    ctx.lineTo(-9, 8 - legWobble);
                    ctx.moveTo(4, 2);
                    ctx.lineTo(9, 8 - legWobble);
                    ctx.stroke();
                    
                    // Shell (larger)
                    const shellGrad = ctx.createRadialGradient(0, -2, 0, 0, 0, 12);
                    shellGrad.addColorStop(0, '#cc8833');
                    shellGrad.addColorStop(0.5, '#996622');
                    shellGrad.addColorStop(1, '#664411');
                    ctx.fillStyle = shellGrad;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 11, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shell line
                    ctx.strokeStyle = '#553311';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(0, 8);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    
                    // Head (larger)
                    ctx.fillStyle = '#553311';
                    ctx.beginPath();
                    ctx.ellipse(enemy.direction * 8, -1, 5, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Antennae
                    ctx.strokeStyle = '#664422';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(enemy.direction * 10, -2);
                    ctx.lineTo(enemy.direction * 15, -8 + wobble);
                    ctx.moveTo(enemy.direction * 10, 0);
                    ctx.lineTo(enemy.direction * 14, 3 + wobble);
                    ctx.stroke();
                    
                    // Eyes (angry red)
                    ctx.fillStyle = '#ff2222';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(enemy.direction * 10, -2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                } else if (enemy.type === ENEMY_TYPE.LAVA_SLUG) {
                    // Lava slug - larger, more glow
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    
                    // Intense glow effect
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 18 + Math.sin(enemy.animFrame) * 5;
                    
                    // Body outline (white border for visibility)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-12, 4);
                    ctx.quadraticCurveTo(-10, -7 + wobble, 0, -6 + wobble * 0.5);
                    ctx.quadraticCurveTo(10, -5 + wobble, 12, 4);
                    ctx.quadraticCurveTo(6, 9, 0, 9);
                    ctx.quadraticCurveTo(-6, 9, -12, 4);
                    ctx.stroke();
                    
                    // Body (larger)
                    const bodyGrad = ctx.createLinearGradient(-10, 0, 10, 0);
                    bodyGrad.addColorStop(0, '#ff2200');
                    bodyGrad.addColorStop(0.5, '#ff7700');
                    bodyGrad.addColorStop(1, '#ff4400');
                    ctx.fillStyle = bodyGrad;
                    
                    ctx.beginPath();
                    ctx.moveTo(-10, 3);
                    ctx.quadraticCurveTo(-8, -6 + wobble, 0, -5 + wobble * 0.5);
                    ctx.quadraticCurveTo(8, -4 + wobble, 10, 3);
                    ctx.quadraticCurveTo(5, 7, 0, 7);
                    ctx.quadraticCurveTo(-5, 7, -10, 3);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    
                    // Hot spots (brighter)
                    const glowPulse = 0.6 + Math.sin(enemy.animFrame * 2) * 0.3;
                    ctx.fillStyle = `rgba(255, 255, 150, ${glowPulse})`;
                    ctx.beginPath();
                    ctx.arc(-4, 0, 3, 0, Math.PI * 2);
                    ctx.arc(4, -1, 2.5, 0, Math.PI * 2);
                    ctx.arc(0, 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye stalks (larger)
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.ellipse(enemy.direction * 5, -7 + wobble, 3, 4, 0, 0, Math.PI * 2);
                    ctx.ellipse(enemy.direction * 1, -8 + wobble * 0.7, 3, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(enemy.direction * 5, -8 + wobble, 1.5, 0, Math.PI * 2);
                    ctx.arc(enemy.direction * 1, -9 + wobble * 0.7, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
        }
        
        function drawParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const screenY = p.y - cameraY;
                
                // Skip off-screen particles
                if (screenY < -20 || screenY > BASE_HEIGHT + 20) continue;
                
                ctx.globalAlpha = p.life;
                
                if (p.type === 'gem') {
                    // Glowing gem particles with trail
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'explosion') {
                    // Bright explosion particles
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    // Trail effect
                    ctx.globalAlpha = p.life * 0.5;
                    ctx.beginPath();
                    ctx.arc(p.x - p.vx * 2, screenY - p.vy * 2, p.size * p.life * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'smoke') {
                    // Rising smoke/steam particles
                    const smokeAlpha = p.life * 0.6;
                    const smokeSize = p.size * (1 + (1 - p.life) * 0.5); // Expand as they rise
                    const gradient = ctx.createRadialGradient(p.x, screenY, 0, p.x, screenY, smokeSize);
                    gradient.addColorStop(0, p.color);
                    gradient.addColorStop(0.5, `rgba(100, 100, 100, ${smokeAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(50, 50, 50, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, smokeSize, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'thruster') {
                    // Fiery thruster particles
                    const gradient = ctx.createRadialGradient(p.x, screenY, 0, p.x, screenY, p.size);
                    gradient.addColorStop(0, p.color);
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'debris' && p.rotation !== undefined) {
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(p.x, screenY);
                    ctx.rotate(p.rotation);
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                    ctx.restore();
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }
        
        function drawFloatingTexts() {
            for (let i = 0; i < floatingTexts.length; i++) {
                const t = floatingTexts[i];
                const screenY = t.y - cameraY;
                
                if (screenY < -50 || screenY > BASE_HEIGHT + 50) continue;
                
                ctx.globalAlpha = t.life;
                ctx.font = `800 ${Math.round(16 * t.scale)}px Oxanium, monospace`;
                ctx.fillStyle = t.color;
                ctx.textAlign = 'center';
                ctx.shadowColor = t.color;
                ctx.shadowBlur = 8;
                ctx.fillText(t.text, t.x, screenY);
                ctx.shadowBlur = 0;
            }
            ctx.globalAlpha = 1;
        }
        
        // ==================== UPGRADE SYSTEM ====================
        function showUpgradeSelector(legendary = false) {
            upgradeSelectionActive = true;
            upgradeSelected = false;
            isLegendaryUpgrade = legendary;
            
            const definitions = legendary ? legendaryUpgradeDefinitions : upgradeDefinitions;
            currentUpgradeChoices = legendary ? [...definitions] : weightedRandomSelect(definitions, 3);
            
            upgradeOverlay.classList.toggle('legendary', legendary);
            
            slots.forEach((slot, i) => {
                if (i < currentUpgradeChoices.length) {
                    slot.className = legendary ? 'upgrade-slot rolling legendary' : 'upgrade-slot rolling';
                    slot.style.display = '';
                    slot.querySelector('.upgrade-icon').textContent = '?';
                    slot.querySelector('.upgrade-name').textContent = '???';
                    slot.querySelector('.upgrade-desc').textContent = '???';
                } else {
                    slot.style.display = 'none';
                }
            });
            
            upgradeOverlay.classList.add('active');
            rollSlots();
        }
        
        function weightedRandomSelect(available, count) {
            const selected = [];
            const pool = [...available];
            
            for (let i = 0; i < count && pool.length > 0; i++) {
                const weights = pool.map(u => Math.pow(upgradeOfferHistory[u.id] || 1, 2));
                const total = weights.reduce((a, b) => a + b, 0);
                let r = Math.random() * total;
                let idx = 0;
                
                for (let j = 0; j < weights.length; j++) {
                    r -= weights[j];
                    if (r <= 0) { idx = j; break; }
                }
                selected.push(pool.splice(idx, 1)[0]);
            }
            
            available.forEach(u => {
                upgradeOfferHistory[u.id] = selected.some(c => c.id === u.id) ? 0 : Math.min((upgradeOfferHistory[u.id] || 0) + 1, 5);
            });
            
            return selected;
        }
        
        function rollSlots() {
            // MEMORY LEAK FIX: Clear any existing intervals/timeouts
            clearRollTimers();
            
            const rollDuration = isLegendaryUpgrade ? 1800 : 1500;
            const staggerDelay = isLegendaryUpgrade ? 400 : 300;
            const rollDefs = isLegendaryUpgrade ? legendaryUpgradeDefinitions : upgradeDefinitions;
            
            slots.forEach((slot, i) => {
                if (i >= currentUpgradeChoices.length) return;
                
                const rollInterval = setInterval(() => {
                    const r = rollDefs[Math.floor(Math.random() * rollDefs.length)];
                    slot.querySelector('.upgrade-icon').textContent = r.icon;
                    slot.querySelector('.upgrade-name').textContent = r.name;
                    slot.querySelector('.upgrade-desc').textContent = r.desc;
                }, 100);
                
                activeRollIntervals.push(rollInterval);
                
                const timeout = setTimeout(() => {
                    clearInterval(rollInterval);
                    const choice = currentUpgradeChoices[i];
                    slot.className = isLegendaryUpgrade ? 'upgrade-slot revealed legendary' : 'upgrade-slot revealed';
                    slot.querySelector('.upgrade-icon').textContent = choice.icon;
                    slot.querySelector('.upgrade-name').textContent = choice.name;
                    slot.querySelector('.upgrade-desc').textContent = choice.desc;
                    slot.onclick = () => selectUpgrade(i);
                    slot.ontouchend = (e) => { e.preventDefault(); e.stopPropagation(); selectUpgrade(i); };
                }, rollDuration + i * staggerDelay);
                
                activeRollTimeouts.push(timeout);
            });
        }
        
        function clearRollTimers() {
            activeRollIntervals.forEach(clearInterval);
            activeRollTimeouts.forEach(clearTimeout);
            activeRollIntervals = [];
            activeRollTimeouts = [];
        }
        
        function selectUpgrade(index) {
            if (!upgradeSelectionActive || upgradeSelected) return;
            upgradeSelected = true;
            
            slots.forEach((slot, i) => {
                if (i === index) {
                    slot.classList.add('selected');
                } else {
                    slot.style.opacity = '0.25';
                    slot.style.pointerEvents = 'none';
                }
            });
            
            currentUpgradeChoices[index].apply();
            updatePermanentUpgradesDisplay();
            
            setTimeout(() => {
                upgradeSelectionActive = false;
                upgradeOverlay.classList.remove('active', 'legendary', 'chest');
                slots.forEach(s => {
                    s.style.display = '';
                    s.style.opacity = '';
                    s.style.pointerEvents = '';
                    s.classList.remove('selected', 'legendary', 'chest');
                    s.onclick = null;
                    s.ontouchend = null;
                });
                isLegendaryUpgrade = false;
                isChestUpgrade = false;
            }, 600);
        }
        
        function updatePermanentUpgradesDisplay() {
            const icons = {
                digSpeed: { icon: '‚ö°', color: '#ff9500', div: 15 },
                fuelCapacity: { icon: '‚õΩ', color: '#ff6600', div: 20 },
                gemMagnet: { icon: 'üß≤', color: '#00f0ff', div: 1 },
                armor: { icon: 'üõ°Ô∏è', color: '#8888aa', div: 25 },
                fuelEfficiency: { icon: 'üåø', color: '#00ff88', div: 10 },
                gemValue: { icon: 'üí∞', color: '#ffd700', div: 15 },
                climbSpeed: { icon: 'ü™ù', color: '#ff00ff', div: 20 },
                drillPower: { icon: 'üíé', color: '#00f0ff', div: 10 }
            };
            
            let html = '';
            for (const [k, v] of Object.entries(permanentUpgrades)) {
                if (v > 0 && icons[k]) {
                    const stacks = Math.max(1, Math.floor(v / icons[k].div));
                    html += `<div class="perm-upgrade" style="color: ${icons[k].color}; border-color: ${icons[k].color}30;">
                        <span class="perm-icon">${icons[k].icon}</span>
                        <span class="perm-stack" style="border-color: ${icons[k].color};">√ó${stacks}</span>
                    </div>`;
                }
            }
            permUpgradesEl.innerHTML = html;
        }
        
        // ==================== GAME OVER ====================
        function gameOver() {
            gameRunning = false;
            clearRollTimers();
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.88)';
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            ctx.font = '800 36px Oxanium, monospace';
            ctx.fillStyle = '#ff00ff';
            ctx.textAlign = 'center';
            const deathReason = hull <= 0 ? 'HULL DESTROYED' : 'OUT OF FUEL';
            ctx.fillText(deathReason, BASE_WIDTH / 2, BASE_HEIGHT / 2 - 45);
            
            ctx.font = '600 20px "Exo 2", sans-serif';
            ctx.fillStyle = '#00f0ff';
            ctx.fillText(`Max Depth: ${maxDepthThisRun}m`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 5);
            ctx.fillStyle = '#ff9500';
            ctx.fillText(`Score: ${score}`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 35);
            
            controlInstructions.classList.remove('visible');
            
            setTimeout(showScoreModal, 1500);
        }
        
        // ==================== SCORE SYSTEM ====================
        function showScoreModal() {
            finalScoreEl.textContent = `${score} pts ‚Ä¢ ${maxDepthThisRun}m`;
            scoreModal.classList.add('active');
            usernameInput.value = '';
            scoreError.textContent = '';
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'SAVE';
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            showGameOverButtons();
        }
        
        function showGameOverButtons() {
            startBtn.textContent = 'DIG AGAIN';
            menuOverlay.classList.remove('hidden');
        }
        
        // ==================== SCORE SYSTEM (Firebase + localStorage fallback) ====================
        function saveLocalScore(name, scoreVal, depthVal) {
            try {
                const scores = JSON.parse(localStorage.getItem('neon_dig_scores') || '[]');
                scores.push({ name: name, score: scoreVal, depth: depthVal, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem('neon_dig_scores', JSON.stringify(scores.slice(0, 100)));
                return true;
            } catch (e) {
                console.warn('Failed to save local score:', e);
                return false;
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem('neon_dig_scores') || '[]');
            } catch (e) {
                return [];
            }
        }
        
        async function saveScore(name, scoreVal, depthVal) {
            if (firebaseReady && db) {
                try {
                    await db.collection(SCORES_COLLECTION).add({
                        name: name,
                        score: scoreVal,
                        depth: depthVal,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    return true;
                } catch (e) {
                    console.error('Failed to save score to Firebase:', e);
                    // Fallback to localStorage
                    return saveLocalScore(name, scoreVal, depthVal);
                }
            } else {
                return saveLocalScore(name, scoreVal, depthVal);
            }
        }
        
        async function getScores() {
            if (firebaseReady && db) {
                try {
                    const snapshot = await db.collection(SCORES_COLLECTION)
                        .orderBy('score', 'desc')
                        .limit(50)
                        .get();
                    
                    return snapshot.docs.map(doc => ({
                        name: doc.data().name,
                        score: doc.data().score,
                        depth: doc.data().depth || 0
                    }));
                } catch (e) {
                    console.error('Failed to fetch Firebase scores:', e);
                    return getLocalScores();
                }
            } else {
                return getLocalScores();
            }
        }
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            const scores = await getScores();
            
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet.<br><br>Start digging!</div>';
                return;
            }
            
            leaderboardList.innerHTML = scores.slice(0, 20).map((e, i) => {
                const rankClass = i < 3 ? `top-3` : '';
                const rankColorClass = i < 3 ? `leaderboard-rank-${i + 1}` : '';
                return `<div class="leaderboard-row ${rankClass}">
                    <span class="leaderboard-rank ${rankColorClass}">#${i + 1}</span>
                    <span class="leaderboard-name">${e.name}</span>
                    <span class="leaderboard-score">${e.score}</span>
                    <span class="leaderboard-depth">${e.depth}m</span>
                </div>`;
            }).join('');
        }
        
        // ==================== INPUT HANDLING ====================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
        });
        
        let touchStartX = 0, touchStartY = 0;
        
        controlZone.addEventListener('touchstart', (e) => {
            if (upgradeSelectionActive) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        controlZone.addEventListener('touchmove', (e) => {
            if (upgradeSelectionActive) return;
            e.preventDefault();
            const dx = e.touches[0].clientX - touchStartX;
            const dy = e.touches[0].clientY - touchStartY;
            keys.left = dx < -15;
            keys.right = dx > 15;
            keys.up = dy < -15;
            keys.down = dy > 15;
        }, { passive: false });
        
        controlZone.addEventListener('touchend', () => {
            keys.left = keys.right = keys.up = keys.down = false;
        });
        
        // ==================== EVENT LISTENERS ====================
        submitScoreBtn.addEventListener('click', async () => {
            const name = usernameInput.value.trim();
            if (name.length < 2) {
                scoreError.textContent = 'Name must be at least 2 characters';
                return;
            }
            if (name.length > 12) {
                scoreError.textContent = 'Name must be 12 characters or less';
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'SAVING...';
            
            const success = await saveScore(name, score, maxDepthThisRun);
            
            if (success) {
                hideScoreModal();
            } else {
                scoreError.textContent = 'Failed to save score. Try again.';
                submitScoreBtn.disabled = false;
                submitScoreBtn.textContent = 'SAVE';
            }
        });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') submitScoreBtn.click();
            if (e.key === 'Escape') hideScoreModal();
        });
        
        usernameInput.addEventListener('input', () => {
            scoreError.textContent = '';
        });
        
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardClose.addEventListener('click', () => leaderboardOverlay.classList.remove('active'));
        
        // ==================== TUTORIAL SYSTEM ====================
        // Create dots
        for (let i = 0; i < totalTutorialSteps; i++) {
            const dot = document.createElement('div');
            dot.className = 'tutorial-dot' + (i === 0 ? ' active' : '');
            dot.addEventListener('click', () => goToTutorialStep(i));
            tutorialDots.appendChild(dot);
        }
        
        function showTutorial() {
            tutorialOverlay.classList.add('active');
            goToTutorialStep(0);
        }
        
        function hideTutorial() {
            tutorialOverlay.classList.remove('active');
        }
        
        function goToTutorialStep(step) {
            currentTutorialStep = step;
            
            // Update steps
            tutorialSteps.forEach((s, i) => {
                s.classList.toggle('active', i === step);
            });
            
            // Update dots
            const dots = tutorialDots.querySelectorAll('.tutorial-dot');
            dots.forEach((d, i) => {
                d.classList.toggle('active', i === step);
            });
            
            // Update buttons
            tutorialPrev.disabled = step === 0;
            tutorialNext.textContent = step === totalTutorialSteps - 1 ? 'Got it!' : 'Next ‚Üí';
        }
        
        function nextTutorialStep() {
            if (currentTutorialStep < totalTutorialSteps - 1) {
                goToTutorialStep(currentTutorialStep + 1);
            } else {
                hideTutorial();
            }
        }
        
        function prevTutorialStep() {
            if (currentTutorialStep > 0) {
                goToTutorialStep(currentTutorialStep - 1);
            }
        }
        
        tutorialBtn.addEventListener('click', showTutorial);
        tutorialClose.addEventListener('click', hideTutorial);
        tutorialPrev.addEventListener('click', prevTutorialStep);
        tutorialNext.addEventListener('click', nextTutorialStep);
        tutorialOverlay.addEventListener('click', (e) => {
            if (e.target === tutorialOverlay) {
                hideTutorial();
            }
        });
        
        // Keyboard navigation for tutorial
        document.addEventListener('keydown', (e) => {
            if (!tutorialOverlay.classList.contains('active')) return;
            if (e.key === 'ArrowRight' || e.key === 'Enter') nextTutorialStep();
            if (e.key === 'ArrowLeft') prevTutorialStep();
            if (e.key === 'Escape') hideTutorial();
        });
        
        // ==================== GAME START ====================
        function startGame() {
            // Clear any lingering timers
            clearRollTimers();
            
            gameRunning = true;
            score = 0;
            depth = 0;
            maxDepthThisRun = 0;
            fuel = 100;
            maxFuel = 100;
            hull = 100;
            maxHull = 100;
            lastUpgradeDepth = 0;
            cameraY = -30;
            upgradeOfferHistory = {};
            screenShake = 0;
            depthColorShift = 0;
            globalTime = 0;
            
            // Reset combo and fever systems
            comboCount = 0;
            comboTimer = 0;
            feverMode = false;
            feverTimer = 0;
            
            // Reset drill heat
            drillHeat = 0;
            drillOverheated = false;
            drillCooldownTimer = 0;
            
            // Reset visual effects
            screenFlash = { active: false, color: '#ffffff', alpha: 0, duration: 0 };
            speedLines = [];
            unstableTiles = [];
            enemies = [];
            firstEnemySpawned = false;
            
            // Reset upgrade overlay states
            upgradeSelectionActive = false;
            isLegendaryUpgrade = false;
            isChestUpgrade = false;
            upgradeOverlay.classList.remove('active', 'legendary', 'chest');
            
            // Reset upgrades
            Object.keys(permanentUpgrades).forEach(k => permanentUpgrades[k] = 0);
            
            // Reset dig direction
            lastDigDirection = null;
            
            player.x = BASE_WIDTH / 2 - 12;
            player.y = 60;
            player.width = 24;
            player.height = 28;
            player.digging = false;
            player.digTarget = null;
            player.digProgress = 0;
            
            particles = [];
            floatingTexts = [];
            
            generateWorld();
            initAmbientParticles();
            initBgStars();
            
            depthEl.textContent = '0';
            scoreEl.textContent = '0';
            updateFuelBar();
            updateHullBar();
            updatePermanentUpgradesDisplay();
            
            menuOverlay.classList.add('hidden');
            controlInstructions.classList.add('visible');
        }
        
        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); }, { passive: false });
        
        // ==================== GAME LOOP ====================
        function gameLoop(timestamp) {
            if (lastFrameTime === 0) lastFrameTime = timestamp;
            const delta = timestamp - lastFrameTime;
            deltaMultiplier = Math.min(delta / TARGET_FRAME_TIME, 3);
            lastFrameTime = timestamp;
            
            update();
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== RESPONSIVE SCALING ====================
        // Fullscreen pixel density scaling
        let currentScale = 1;
        const isDesktop = !('ontouchstart' in window) && window.innerWidth > 768;
        
        function getViewportSize() {
            // Use visualViewport for more accurate sizing in iframes
            if (window.visualViewport) {
                return {
                    width: window.visualViewport.width,
                    height: window.visualViewport.height
                };
            }
            return {
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        
        function handleResize() {
            const viewport = getViewportSize();
            const viewportWidth = viewport.width;
            const viewportHeight = viewport.height;
            
            // Detect if we're in an iframe
            const isInIframe = window.self !== window.top;
            
            // Get HUD height
            const hud = document.querySelector('.hud');
            const hudHeight = hud ? hud.offsetHeight : 50;
            
            // Account for border (3px on each side)
            const borderWidth = 6;
            
            // Check if in fullscreen/iframe mode (viewport larger than base game size OR in iframe)
            const gameContainer = document.querySelector('.game-container');
            const isFullscreen = isInIframe || viewportWidth > BASE_WIDTH * 1.05 || viewportHeight > BASE_HEIGHT * 1.05;
            if (isFullscreen) {
                gameContainer.classList.add('fullscreen-mode');
                document.body.classList.add('fullscreen-active');
            } else {
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
            }
            
            // Scale internal resolution based on display size
            // 1x for mobile, 2x for HD desktop, 2.5x for 2K+
            if (viewportWidth >= 2560 || viewportHeight >= 1440) {
                renderScale = 2.5; // 2K+ displays
            } else if (viewportWidth >= 800) {
                renderScale = 2; // HD desktop
            } else {
                renderScale = 1; // Mobile
            }
            
            // iOS canvas memory safety check
            let bufferWidth = BASE_WIDTH * renderScale;
            let bufferHeight = BASE_HEIGHT * renderScale;
            const totalPixels = bufferWidth * bufferHeight;
            
            if (totalPixels > MAX_CANVAS_PIXELS) {
                // Scale down to fit within limit
                const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                renderScale = renderScale * scaleFactor;
                bufferWidth = BASE_WIDTH * renderScale;
                bufferHeight = BASE_HEIGHT * renderScale;
            }
            
            // Set internal canvas resolution (scaled for quality)
            canvas.width = Math.round(bufferWidth);
            canvas.height = Math.round(bufferHeight);
            
            // Scale the context so drawing code stays the same
            ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);
            
            // Stretch canvas via CSS to fill available space (minus border)
            const availableWidth = viewportWidth - borderWidth;
            const availableHeight = viewportHeight - hudHeight - borderWidth;
            
            canvas.style.width = availableWidth + 'px';
            canvas.style.height = availableHeight + 'px';
            
            // Update world width (based on base dimensions, not scaled)
            WORLD_WIDTH = Math.floor(BASE_WIDTH / TILE_SIZE);
        }
        
        function handleFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
            
            // Just call resize - it handles both fullscreen and normal
            handleResize();
            
            if (!gameRunning) {
                draw();
            }
        }
        
        // Initialize scaling
        handleResize();
        window.addEventListener('resize', handleResize);
        
        // Use visualViewport resize event if available (better for iframes)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', handleResize);
            window.visualViewport.addEventListener('scroll', handleResize);
        }
        
        // Handle fullscreen changes
        document.addEventListener('fullscreenchange', () => {
            setTimeout(handleFullscreenChange, 50);
            setTimeout(handleResize, 150);
            setTimeout(handleResize, 500);
        });
        document.addEventListener('webkitfullscreenchange', () => {
            setTimeout(handleFullscreenChange, 50);
            setTimeout(handleResize, 150);
            setTimeout(handleResize, 500);
        });
        
        // Handle orientation changes on mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(handleResize, 100);
            setTimeout(handleResize, 300);
        });
        
        // Re-check size after delays for iframe loading
        setTimeout(handleResize, 100);
        setTimeout(handleResize, 300);
        setTimeout(handleResize, 500);
        
        // ==================== INITIALIZATION ====================
        createScanlinePattern();
        generateWorld();
        initAmbientParticles();
        initBgStars();
        draw();
        
        // Title screen
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        ctx.font = '800 30px Oxanium, monospace';
        ctx.fillStyle = '#00f0ff';
        ctx.textAlign = 'center';
        ctx.fillText('GOLDMINE', BASE_WIDTH / 2, BASE_HEIGHT / 2 - 35);
        ctx.font = '400 13px "Exo 2", sans-serif';
        ctx.fillStyle = '#ff00ff';
        ctx.fillText('Dig Deep  ‚Ä¢  Collect Gems  ‚Ä¢  Survive', BASE_WIDTH / 2, BASE_HEIGHT / 2 + 5);
        
        requestAnimationFrame(gameLoop);
    })();
    </script>
</body>
</html>
