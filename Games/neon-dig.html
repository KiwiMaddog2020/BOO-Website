<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Goldmine</title>
    <script>
        // Immediate iframe detection - runs before CSS layout
        if (window.self !== window.top) {
            document.documentElement.classList.add('in-iframe');
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600;700;800&family=Exo+2:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --cyan: #00f0ff;
            --cyan-dim: #00a0aa;
            --magenta: #ff00ff;
            --magenta-dim: #aa00aa;
            --orange: #ff9500;
            --green: #00ff88;
            --bg-deep: #020408;
            --bg-card: rgba(8, 12, 20, 0.85);
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --scale: 1;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            height: 100dvh;
            background: linear-gradient(160deg, rgba(10, 15, 25, 1) 0%, rgba(5, 8, 15, 1) 100%);
            font-family: 'Exo 2', sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: 
                linear-gradient(90deg, rgba(0, 240, 255, 0.02) 1px, transparent 1px),
                linear-gradient(rgba(0, 240, 255, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: -1;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            max-height: 100dvh;
            touch-action: none;
            position: relative;
            overflow: hidden;
            background: linear-gradient(160deg, rgba(10, 15, 25, 0.95) 0%, rgba(5, 8, 15, 0.98) 100%);
            box-sizing: border-box;
        }

        /* Fullscreen/iframe mode: center content */
        .game-container.fullscreen-mode {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0;
        }
        
        /* Fullscreen body centering - JS adds this class */
        body.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            overflow: hidden !important;
        }
        
        /* Force fullscreen layout when in iframe (CSS kicks in immediately) */
        html.in-iframe body {
            align-items: flex-start;
        }
        
        /* Tablet in iframe - center vertically */
        @media (min-width: 769px) and (pointer: coarse) {
            html.in-iframe body {
                align-items: center;
            }
        }
        
        html.in-iframe .game-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: clamp(6px, 2vw, 10px) clamp(8px, 3vw, 16px);
            background: linear-gradient(0deg, rgba(0, 15, 25, 0.9) 0%, rgba(0, 10, 18, 0.95) 100%);
            border-top: 1px solid rgba(0, 240, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            order: 1;
            position: relative;
        }
        
        .hud-left, .hud-right {
            display: flex;
            gap: clamp(6px, 2vw, 20px);
            min-width: clamp(50px, 12vw, 100px);
        }
        
        .hud-right {
            justify-content: flex-end;
        }

        .hud-item { display: flex; flex-direction: column; gap: 2px; }

        .hud-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: clamp(6px, 1.5vw, 10px);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: clamp(0.3px, 0.3vw, 1.5px);
        }

        .hud-value {
            color: var(--cyan);
            font-family: 'Oxanium', monospace;
            font-size: clamp(10px, 3vw, 20px);
            font-weight: 400;
            text-shadow: 0 0 20px var(--cyan);
            letter-spacing: -0.5px;
        }

        .hud-value.score { 
            color: var(--magenta); 
            text-shadow: 0 0 20px var(--magenta);
        }
        
        .hud-value.max-depth {
            color: var(--magenta);
            text-shadow: 0 0 20px var(--magenta);
        }
        
        .hud-value.depth {
            color: #ffffff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.7);
        }

        .hud-center { 
            display: flex; 
            align-items: center; 
            justify-content: center;
            gap: clamp(10px, 4vw, 36px);
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .bar-container { display: flex; flex-direction: column; gap: 4px; align-items: center; }

        .fuel-bar-wrapper { position: relative; width: clamp(60px, 25vw, 180px); height: clamp(18px, 4vw, 28px); }

        .hull-bar-wrapper { position: relative; width: clamp(60px, 25vw, 180px); height: clamp(18px, 4vw, 28px); }

        .hull-bar {
            width: 100%; height: 100%;
            background: rgba(0, 240, 255, 0.1);
            border: 2px solid rgba(0, 240, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .hull-fill {
            height: 100%;
            background: linear-gradient(90deg, #00aacc, #00f0ff, #66ffff);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
        }

        .hull-bar.critical .hull-fill {
            background: linear-gradient(90deg, #0088aa, #00ccff);
            animation: criticalPulse 0.858s ease-in-out infinite;
        }

        .hull-percent {
            position: absolute;
            left: 50%; 
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(10px, 2vw, 14px);
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            color: rgba(0, 0, 0, 0.85);
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .fuel-bar {
            width: 100%; height: 100%;
            background: rgba(255, 150, 0, 0.1);
            border: 2px solid rgba(255, 150, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .fuel-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4400, #ff9500, #ffcc00);
            box-shadow: 0 0 15px rgba(255, 150, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
        }

        .fuel-bar.critical .fuel-fill {
            background: linear-gradient(90deg, #ff0033, #ff4400);
            animation: criticalPulseFuel 0.858s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 15px rgba(0, 200, 255, 0.5); }
            50% { opacity: 0.7; box-shadow: 0 0 25px rgba(0, 200, 255, 0.8); }
        }
        
        @keyframes criticalPulseFuel {
            0%, 100% { opacity: 1; box-shadow: 0 0 15px rgba(255, 0, 50, 0.5); }
            50% { opacity: 0.7; box-shadow: 0 0 25px rgba(255, 0, 50, 0.8); }
        }

        .fuel-percent {
            position: absolute;
            left: 50%; 
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(10px, 2vw, 14px);
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            color: rgba(0, 0, 0, 0.85);
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            touch-action: manipulation;
        }

        .menu-overlay.hidden {
            display: none;
            pointer-events: none;
        }

        .game-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 10px #ffcc00, 0 0 25px #ffcc00, 0 0 50px rgba(255, 204, 0, 0.5);
            margin-bottom: 10px;
            letter-spacing: 4px;
            text-align: center;
        }

        .game-subtitle {
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-bottom: 40px;
            text-align: center;
        }

        .menu-buttons { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            align-items: center;
            margin-top: 15px;
        }

        .menu-btn {
            padding: 10px 20px;
            width: 160px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            touch-action: manipulation;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .menu-btn:hover {
            background: #0ff;
            color: #000;
        }

        .menu-btn.btn-tutorial {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 8px #f0f;
        }

        .menu-btn.btn-tutorial:hover {
            background: #f0f;
            color: #000;
        }

        .menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }

        .menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
        }

        .game-btn {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Oxanium', monospace;
            background: transparent;
            border: 2px solid var(--cyan);
            border-radius: 6px;
            color: var(--cyan);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px var(--cyan);
            text-align: center;
            letter-spacing: 2px;
        }

        .game-btn:hover {
            background: var(--cyan);
            color: #000;
            box-shadow: 0 0 20px var(--cyan);
        }

        .control-zone {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 53px;
            min-height: 53px;
            padding: 4px 16px 6px;
            touch-action: none;
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(5, 12, 20, 0.9) 0%, rgba(2, 8, 15, 0.95) 100%);
            border-top: 1px solid rgba(0, 240, 255, 0.08);
            gap: 2px;
            order: 2;
        }

        .control-instructions {
            font-size: 10px;
            color: rgba(0, 240, 255, 0.4);
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 500;
            display: none;
            margin-top: -10px;
        }

        .control-instructions.visible {
            display: block;
        }

        .permanent-upgrades {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 5px;
            width: 100%;
            pointer-events: none;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 240, 255, 0.08);
        }

        .perm-upgrade {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 32px; height: 32px;
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.08) 0%, rgba(0, 240, 255, 0.02) 100%);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 8px;
        }

        .perm-icon { font-size: 15px; filter: drop-shadow(0 0 6px currentColor); }

        .perm-stack {
            position: absolute;
            bottom: -3px; right: -3px;
            font-size: 9px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: #fff;
            background: rgba(0, 0, 0, 0.85);
            padding: 2px 5px;
            border-radius: 6px;
            border: 1px solid currentColor;
            line-height: 1;
        }

        .upgrade-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(5, 15, 30, 0.97) 0%, rgba(2, 5, 12, 0.99) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
            touch-action: manipulation;
            pointer-events: none;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .upgrade-overlay.active { display: flex; pointer-events: auto; }

        .upgrade-header { text-align: center; margin-bottom: 24px; }

        .upgrade-title {
            font-size: 27px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: var(--cyan);
            text-shadow: 0 0 40px var(--cyan), 0 0 80px var(--cyan);
            letter-spacing: 6px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        .upgrade-subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 13px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        @keyframes titlePulse {
            0%, 100% { opacity: 1; filter: brightness(1); }
            50% { opacity: 0.9; filter: brightness(1.2); }
        }

        .upgrade-slots { display: flex; gap: 14px; }

        .upgrade-slot {
            width: 125px; height: 165px;
            background: linear-gradient(170deg, rgba(15, 20, 35, 0.95) 0%, rgba(8, 10, 20, 0.98) 100%);
            border: 1px solid rgba(60, 70, 100, 0.3);
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.03);
            -webkit-tap-highlight-color: transparent;
        }

        .upgrade-slot::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 40%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02) 0%, transparent 100%);
            pointer-events: none;
        }

        .upgrade-slot.rolling { pointer-events: none; }
        .upgrade-slot.rolling .upgrade-content { animation: slotRoll 0.12s ease-in-out infinite; }

        @keyframes slotRoll {
            0%, 100% { opacity: 0.4; transform: translateY(0) scale(0.98); }
            50% { opacity: 0.8; transform: translateY(-3px) scale(1); }
        }

        .upgrade-slot.revealed {
            border-color: rgba(0, 240, 255, 0.5);
            box-shadow: 0 0 35px rgba(0, 240, 255, 0.2), 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .upgrade-slot.revealed:hover {
            transform: translateY(-10px) scale(1.03);
            border-color: var(--cyan);
            box-shadow: 0 0 50px rgba(0, 240, 255, 0.35), 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .upgrade-slot.selected {
            border-color: var(--green);
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.5);
            transform: scale(1.05);
        }

        .upgrade-slot.legendary { border-color: rgba(255, 0, 255, 0.5); box-shadow: 0 0 40px rgba(255, 0, 255, 0.25); }
        .upgrade-slot.legendary.revealed:hover { box-shadow: 0 0 55px rgba(255, 0, 255, 0.45); }
        .upgrade-overlay.legendary .upgrade-title { color: var(--magenta); text-shadow: 0 0 40px var(--magenta), 0 0 80px var(--magenta); }
        
        /* Chest upgrade style */
        .upgrade-overlay.chest .upgrade-title { color: #ffd700; text-shadow: 0 0 40px #ffd700, 0 0 80px #ff9500; }
        .upgrade-slot.chest { border-color: rgba(255, 215, 0, 0.5); box-shadow: 0 0 40px rgba(255, 215, 0, 0.25); }
        .upgrade-slot.chest.revealed { border-color: rgba(255, 215, 0, 0.7); box-shadow: 0 0 50px rgba(255, 215, 0, 0.35); }
        .upgrade-slot.chest.revealed:hover { box-shadow: 0 0 60px rgba(255, 215, 0, 0.5); border-color: #ffd700; }

        /* Boss intro overlay */
        .boss-intro-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 5, 30, 0.97) 0%, rgba(5, 2, 12, 0.99) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 600;
            touch-action: manipulation;
            pointer-events: none;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .boss-intro-overlay.active { display: flex; pointer-events: auto; }
        
        .boss-intro-container {
            text-align: center;
            max-width: 380px;
            padding: 20px;
        }
        
        .boss-intro-icon {
            font-size: 64px;
            margin-bottom: 15px;
            filter: drop-shadow(0 0 20px rgba(255, 0, 150, 0.8));
            animation: bossIconPulse 2s ease-in-out infinite;
        }
        @keyframes bossIconPulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(255, 0, 150, 0.8)); }
            50% { transform: scale(1.1); filter: drop-shadow(0 0 35px rgba(255, 0, 150, 1)); }
        }
        
        .boss-intro-name {
            font-size: 28px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: #ff00aa;
            text-shadow: 0 0 30px #ff00aa, 0 0 60px #ff0066;
            letter-spacing: 4px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .boss-intro-depth {
            font-size: 14px;
            color: rgba(255, 150, 200, 0.7);
            margin-bottom: 20px;
            letter-spacing: 2px;
        }
        
        .boss-intro-objective {
            background: rgba(255, 0, 150, 0.1);
            border: 1px solid rgba(255, 0, 150, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .boss-intro-objective-title {
            font-size: 12px;
            font-weight: 700;
            color: #ff66aa;
            letter-spacing: 3px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .boss-intro-objective-text {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.5;
        }
        
        .boss-intro-tip {
            font-size: 13px;
            color: rgba(255, 200, 100, 0.8);
            margin-bottom: 25px;
            font-style: italic;
        }
        
        .boss-intro-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .boss-intro-btn {
            padding: 12px 28px;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            letter-spacing: 2px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }
        
        .boss-intro-btn.battle {
            background: linear-gradient(180deg, #ff0088 0%, #aa0055 100%);
            color: white;
            box-shadow: 0 0 20px rgba(255, 0, 136, 0.5);
        }
        .boss-intro-btn.battle:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 136, 0.8);
        }
        
        .boss-intro-btn.leave {
            background: rgba(100, 100, 120, 0.3);
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .boss-intro-btn.leave:hover {
            background: rgba(100, 100, 120, 0.5);
            color: white;
        }
        
        /* Boss victory overlay */
        .boss-victory-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(5, 30, 20, 0.97) 0%, rgba(2, 12, 8, 0.99) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 600;
            touch-action: manipulation;
            pointer-events: none;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .boss-victory-overlay.active { display: flex; pointer-events: auto; }
        
        .boss-victory-container {
            text-align: center;
            max-width: 380px;
            padding: 20px;
        }
        
        .boss-victory-title {
            font-size: 32px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: #00ffaa;
            text-shadow: 0 0 30px #00ffaa, 0 0 60px #00ff66;
            letter-spacing: 4px;
            margin-bottom: 10px;
            text-transform: uppercase;
            animation: victoryPulse 2s ease-in-out infinite;
        }
        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .boss-victory-subtitle {
            font-size: 14px;
            color: rgba(150, 255, 200, 0.8);
            margin-bottom: 25px;
            letter-spacing: 2px;
        }
        
        .boss-victory-key-box {
            background: rgba(0, 255, 150, 0.1);
            border: 2px solid rgba(0, 255, 150, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }
        
        .boss-victory-key-label {
            font-size: 12px;
            font-weight: 700;
            color: #00ffaa;
            letter-spacing: 3px;
            margin-bottom: 15px;
            text-transform: uppercase;
        }
        
        .boss-victory-key {
            width: 64px;
            height: 64px;
            background: radial-gradient(ellipse at center, #00ffcc 0%, #0066aa 50%, #003366 100%);
            border: 3px solid #00ffaa;
            border-radius: 50% 50% 20% 20%;
            margin: 0 auto 10px;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 200, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.4);
            animation: keyFloat 3s ease-in-out infinite;
        }
        @keyframes keyFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .boss-victory-key::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 15px #00ffff;
        }
        .boss-victory-key::after {
            content: '';
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 24px;
            background: linear-gradient(180deg, #00ffcc, #006688);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 0 10px rgba(0, 255, 200, 0.6);
        }
        
        .boss-victory-key-depth {
            font-size: 16px;
            font-weight: 700;
            color: #00ffcc;
            margin-top: 20px;
        }
        
        .boss-victory-refuel {
            font-size: 13px;
            color: #88ff88;
            margin-top: 15px;
            margin-bottom: 20px;
            padding: 8px 15px;
            background: rgba(0, 255, 100, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 100, 0.3);
        }
        
        .boss-victory-btn {
            padding: 15px 40px;
            font-size: 16px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            letter-spacing: 3px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(180deg, #00cc88 0%, #008855 100%);
            color: white;
            box-shadow: 0 0 25px rgba(0, 200, 136, 0.6);
            text-transform: uppercase;
            transition: all 0.2s ease;
        }
        .boss-victory-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 200, 136, 0.9);
        }

        .upgrade-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 18px 10px;
            width: 100%; height: 100%;
            position: relative;
            z-index: 1;
        }

        .upgrade-icon { font-size: 38px; margin-bottom: 12px; filter: drop-shadow(0 0 15px currentColor); }
        .upgrade-name { font-size: 13px; font-weight: 700; font-family: 'Oxanium', monospace; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255,255,255,0.4); }
        .upgrade-desc { font-size: 11px; color: rgba(255, 255, 255, 0.5); line-height: 1.4; }

        @media (max-width: 500px) {
            .upgrade-slot { width: 100px; height: 145px; }
            .upgrade-icon { font-size: 30px; }
            .upgrade-name { font-size: 11px; }
            .upgrade-desc { font-size: 10px; }
            .upgrade-title { font-size: 21px; letter-spacing: 4px; }
            .upgrade-slots { gap: 8px; }
            .hud { padding: 8px 10px; }
            .hud-value { font-size: 12px; }
            .hud-label { font-size: 7px; letter-spacing: 0.5px; }
            /* Mobile HUD bar scaling */
            .hud-center { gap: 10px; }
            .hud-left, .hud-right { gap: 10px; min-width: 70px; }
            .fuel-bar-wrapper, .hull-bar-wrapper { width: 80px; height: 20px; }
            .fuel-percent, .hull-percent { font-size: 11px; }
            .control-zone { height: 98px; min-height: 98px; }
            .menu-btn, .game-btn { padding: 8px 16px; font-size: 12px; width: 140px; }
            .game-title { font-size: 32px; letter-spacing: 2px; }
            .game-subtitle { font-size: 14px; margin-bottom: 30px; }
            .menu-subtitle { font-size: 11px; margin-bottom: 25px; }
            .leaderboard-container { padding: 15px; }
            .leaderboard-title { font-size: 20px; }
            .score-modal-content { padding: 20px; }
            .score-modal-title { font-size: 20px; }
        }
        
        @media (max-width: 400px) {
            .hud { padding: 6px 8px; }
            .hud-value { font-size: 9px; }
            .hud-label { font-size: 6px; letter-spacing: 0.3px; }
            .hud-center { gap: 8px; }
            .hud-left, .hud-right { gap: 6px; min-width: 55px; }
            .fuel-bar-wrapper, .hull-bar-wrapper { width: 65px; height: 18px; }
            .fuel-percent, .hull-percent { font-size: 10px; }
            .bar-container .hud-label { font-size: 8px; }
        }
        
        @media (max-width: 350px) {
            .hud { padding: 5px 6px; }
            .hud-value { font-size: 7px; }
            .hud-label { font-size: 5px; letter-spacing: 0; }
            .hud-center { gap: 6px; }
            .hud-left, .hud-right { gap: 4px; min-width: 45px; }
            .fuel-bar-wrapper, .hull-bar-wrapper { width: 55px; height: 16px; }
            .fuel-percent, .hull-percent { font-size: 9px; }
        }

        /* Leaderboard Overlay */
        .leaderboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid var(--cyan);
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.3);
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 240, 255, 0.3);
        }
        
        .leaderboard-title {
            font-size: 24px;
            font-family: 'Oxanium', monospace;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            letter-spacing: 2px;
        }
        
        .leaderboard-close {
            width: 32px;
            height: 32px;
            background: transparent;
            border: 2px solid #ff3366;
            border-radius: 50%;
            color: #ff3366;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .leaderboard-close:hover {
            background: #ff3366;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .leaderboard-list::-webkit-scrollbar { width: 6px; }
        .leaderboard-list::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); border-radius: 3px; }
        .leaderboard-list::-webkit-scrollbar-thumb { background: var(--cyan); border-radius: 3px; }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .leaderboard-row:hover {
            background: rgba(0, 240, 255, 0.1);
        }
        
        .leaderboard-row.top-3 {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .leaderboard-rank {
            font-size: 14px;
            font-weight: bold;
            color: #888;
            min-width: 40px;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank { font-size: 16px; }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 14px;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .leaderboard-score {
            font-size: 15px;
            font-weight: bold;
            color: var(--cyan);
            min-width: 70px;
            text-align: right;
        }
        
        .leaderboard-depth {
            font-size: 12px;
            color: #888;
            min-width: 50px;
            text-align: right;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }
        
        .leaderboard-error { color: #ff3366; }

        /* Score Modal */
        .score-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-content {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid var(--magenta);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.3);
            max-width: 350px;
            width: 90%;
        }
        
        .score-modal-title {
            font-size: 24px;
            font-family: 'Oxanium', monospace;
            color: var(--magenta);
            text-shadow: 0 0 20px var(--magenta);
            margin-bottom: 15px;
            letter-spacing: 2px;
        }
        
        .score-stats {
            font-size: 16px;
            color: #fff;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .score-stats span {
            color: var(--cyan);
            font-weight: bold;
        }
        
        .score-input-label {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }
        
        .score-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--cyan);
            border-radius: 8px;
            color: #fff;
            text-transform: uppercase;
            margin-bottom: 10px;
            outline: none;
        }
        
        .score-input:focus {
            border-color: var(--magenta);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }
        
        .score-input.error {
            border-color: #ff3366;
            animation: inputShake 0.3s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .score-error {
            font-size: 12px;
            color: #ff3366;
            margin-bottom: 10px;
            min-height: 18px;
        }
        
        .score-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .score-btn {
            padding: 12px 25px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Oxanium', monospace;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 1px;
        }
        
        .score-btn.submit {
            background: linear-gradient(180deg, var(--cyan), #00a0aa);
            border-color: var(--cyan);
            color: #000;
        }
        
        .score-btn.submit:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5);
        }
        
        .score-btn.skip {
            background: transparent;
            border-color: #666;
            color: #888;
        }
        
        .score-btn.skip:hover {
            border-color: #999;
            color: #fff;
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .tutorial-overlay.active { display: flex; }
        
        .tutorial-container {
            position: relative;
            background: linear-gradient(145deg, #0a1520, #050a10);
            border: 2px solid var(--cyan);
            border-radius: 12px;
            padding: 20px 24px;
            max-width: 380px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.2);
        }
        
        .tutorial-title {
            font-size: 20px;
            font-family: 'Oxanium', monospace;
            color: var(--cyan);
            text-shadow: 0 0 20px var(--cyan);
            margin-bottom: 16px;
            letter-spacing: 3px;
        }
        
        .tutorial-step {
            display: none;
            animation: tutorialFadeIn 0.3s ease-out;
        }
        
        .tutorial-step.active { display: block; }
        
        @keyframes tutorialFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .tutorial-icon { font-size: 40px; margin-bottom: 12px; }
        
        .tutorial-heading {
            font-size: 16px;
            font-family: 'Oxanium', monospace;
            color: #fff;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .tutorial-text {
            font-size: 13px;
            font-family: 'Exo 2', sans-serif;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.5;
            margin-bottom: 16px;
        }
        
        .tutorial-highlight {
            color: var(--cyan);
            font-weight: 600;
        }
        
        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 240, 255, 0.15);
        }
        
        .tutorial-nav-btn {
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-prev {
            background: transparent;
            border-color: #555;
            color: #888;
        }
        
        .tutorial-prev:hover { border-color: #888; color: #fff; }
        .tutorial-prev:disabled { opacity: 0.3; cursor: not-allowed; }
        
        .tutorial-next {
            background: linear-gradient(180deg, var(--cyan), #00a0aa);
            border-color: var(--cyan);
            color: #000;
        }
        
        .tutorial-next:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
        }
        
        .tutorial-dots { display: flex; gap: 6px; }
        
        .tutorial-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .tutorial-dot.active {
            background: var(--cyan);
            box-shadow: 0 0 8px var(--cyan);
        }
        
        .tutorial-close {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            background: transparent;
            border: 2px solid #ff3366;
            border-radius: 50%;
            color: #ff3366;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tutorial-close:hover { background: #ff3366; color: #000; }
        
        /* ==================== SHOP ==================== */
        .shop-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .shop-overlay.active { display: flex; }
        .shop-container {
            position: relative;
            background: linear-gradient(145deg, #0a1520, #050a10);
            border: 2px solid var(--cyan);
            border-radius: 12px;
            padding: 20px;
            max-width: 380px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            overflow-x: visible;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.2);
        }
        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 240, 255, 0.3);
        }
        .shop-title {
            font-family: 'Oxanium', monospace;
            font-size: 22px;
            font-weight: 700;
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan);
        }
        .shop-score {
            font-family: 'Oxanium', monospace;
            font-size: 16px;
            color: var(--orange);
        }
        .shop-close {
            position: absolute;
            top: -14px;
            right: -14px;
            width: 28px;
            height: 28px;
            background: rgba(0, 10, 20, 0.9);
            border: 2px solid var(--cyan);
            border-radius: 50%;
            color: var(--cyan);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .shop-close:hover { background: var(--cyan); color: #000; }
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }
        .shop-item {
            display: flex;
            align-items: center;
            background: rgba(0, 240, 255, 0.05);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .shop-item:hover:not(.maxed) {
            background: rgba(0, 240, 255, 0.1);
            border-color: var(--cyan);
        }
        .shop-item.maxed {
            opacity: 0.5;
            cursor: default;
        }
        .shop-item.cant-afford {
            opacity: 0.6;
        }
        .shop-item-icon {
            font-size: 24px;
            width: 40px;
            text-align: center;
        }
        .shop-item-info {
            flex: 1;
            margin-left: 10px;
        }
        .shop-item-name {
            font-family: 'Oxanium', monospace;
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }
        .shop-item-level {
            font-size: 13px;
            color: var(--cyan);
            opacity: 0.8;
        }
        .shop-item-desc {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }
        .shop-item-cost {
            font-family: 'Oxanium', monospace;
            font-size: 16px;
            font-weight: 600;
            color: var(--orange);
            min-width: 60px;
            text-align: right;
        }
        .shop-item.maxed .shop-item-cost {
            color: var(--green);
        }
        
        /* Keys display - bottom center */
        .keys-display {
            position: absolute;
            bottom: 68px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            z-index: 50;
            pointer-events: none;
        }
        .keys-container {
            display: flex;
            gap: 6px;
        }
        .alien-key {
            width: 24px;
            height: 24px;
            background: radial-gradient(ellipse at center, #00ffcc 0%, #0066aa 50%, #003366 100%);
            border: 2px solid #00ffaa;
            border-radius: 50% 50% 20% 20%;
            position: relative;
            box-shadow: 0 0 12px rgba(0, 255, 200, 0.6), inset 0 0 8px rgba(255, 255, 255, 0.3);
            animation: keyPulse 2s ease-in-out infinite;
        }
        .alien-key::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 7px;
            height: 7px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 6px #00ffff;
        }
        .alien-key::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 9px;
            background: linear-gradient(180deg, #00ffcc, #006688);
            border-radius: 0 0 2px 2px;
            box-shadow: 0 0 4px rgba(0, 255, 200, 0.5);
        }
        @keyframes keyPulse {
            0%, 100% { box-shadow: 0 0 12px rgba(0, 255, 200, 0.6), inset 0 0 8px rgba(255, 255, 255, 0.3); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 200, 0.9), inset 0 0 12px rgba(255, 255, 255, 0.5); }
        }
        
        /* Gate unlock animation */
        .gate-unlock-effect {
            position: absolute;
            pointer-events: none;
            z-index: 200;
        }
        
        /* Surface upgrade button */
        .surface-upgrade-btn {
            position: absolute;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, #cc00ff, #9900cc);
            color: #fff;
            font-family: 'Oxanium', monospace;
            font-size: 16px;
            font-weight: 700;
            padding: 9px 22px;
            border: none;
            border-radius: 22px;
            cursor: pointer;
            z-index: 100;
            display: none;
            box-shadow: 0 0 15px rgba(200, 0, 255, 0.5);
            text-shadow: 0 0 8px rgba(255, 100, 255, 0.8);
            pointer-events: auto;
        }
        .surface-upgrade-btn:hover {
            background: linear-gradient(180deg, #dd44ff, #bb00dd);
            box-shadow: 0 0 25px rgba(200, 0, 255, 0.7);
        }
        .surface-upgrade-btn.visible {
            display: block;
            animation: upgradeBounce 2s ease-in-out infinite;
        }
        @keyframes upgradeBounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            15% { transform: translateX(-50%) translateY(-8px); }
            30% { transform: translateX(-50%) translateY(0); }
            45% { transform: translateX(-50%) translateY(-5px); }
            60% { transform: translateX(-50%) translateY(0); }
        }
        
        /* Pause button */
        .pause-btn {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 36px;
            height: 36px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 6px;
            cursor: pointer;
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(0, 255, 255, 0.9);
            transition: all 0.15s;
            opacity: 0.7;
        }
        
        .pause-btn.visible {
            display: flex;
        }
        
        .pause-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.9);
            border-color: #0ff;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.5);
        }
        
        .pause-btn.paused {
            opacity: 1;
            background: rgba(0, 255, 255, 0.2);
            border-color: #0ff;
        }
        
        /* Pause Menu Overlay */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 550;
        }
        
        .pause-overlay.active {
            display: flex;
        }
        
        .pause-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 30px #39ff14, 0 0 60px #39ff14;
            margin-bottom: 40px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }
        
        .pause-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .pause-menu-btn {
            padding: 10px 20px;
            width: 180px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s, box-shadow 0.2s, transform 0.15s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .pause-menu-btn:hover {
            transform: scale(1.05);
        }
        
        .pause-menu-btn:active {
            transform: scale(0.98);
        }
        
        .pause-menu-btn.btn-resume {
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 8px #0ff;
        }
        
        .pause-menu-btn.btn-resume:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        .pause-menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }
        
        .pause-menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
            box-shadow: 0 0 20px #ffcc00;
        }
        
        .pause-menu-btn.btn-exit {
            border-color: #ff3366;
            color: #ff3366;
            box-shadow: 0 0 8px #ff3366;
        }
        
        .pause-menu-btn.btn-exit:hover {
            background: #ff3366;
            color: #000;
            box-shadow: 0 0 20px #ff3366;
        }
        
        /* Confirmation Dialog */
        .confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 560;
        }
        
        .confirm-overlay.active {
            display: flex;
        }
        
        .confirm-box {
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        
        .confirm-text {
            font-size: 22px;
            color: #fff;
            margin-bottom: 25px;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        
        .confirm-btn {
            padding: 12px 35px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        
        .confirm-btn:hover {
            transform: scale(1.05);
        }
        
        .confirm-btn.btn-yes {
            background: rgba(200, 50, 50, 0.8);
            border: 2px solid #ff4444;
            color: #fff;
        }
        
        .confirm-btn.btn-no {
            background: rgba(80, 80, 100, 0.8);
            border: 2px solid #888;
            color: #fff;
        }
        
        .hud-value.points {
            color: #ffffff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.7);
        }
        
        /* Virtual joystick for mobile */
        .joystick-base {
            position: fixed;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 240, 255, 0.15) 0%, rgba(0, 240, 255, 0.05) 70%, transparent 100%);
            border: 2px solid rgba(0, 240, 255, 0.4);
            pointer-events: none;
            z-index: 1000;
            display: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.3), inset 0 0 30px rgba(0, 240, 255, 0.1);
        }
        .joystick-base.active {
            display: block;
        }
        .joystick-thumb {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 240, 255, 0.9) 0%, rgba(0, 180, 220, 0.7) 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.8), 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        /* Touch tutorial overlay */
        .touch-tutorial {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s ease-out;
        }
        .touch-tutorial.active {
            display: flex;
        }
        .touch-tutorial.fading {
            opacity: 0;
        }
        .touch-tutorial-text {
            font-family: 'Oxanium', monospace;
            font-size: 18px;
            color: #00f0ff;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0, 240, 255, 0.8);
            padding: 0 20px;
        }
        .touch-tutorial-joystick {
            position: relative;
            width: 120px;
            height: 120px;
        }
        .tutorial-joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 240, 255, 0.2) 0%, rgba(0, 240, 255, 0.08) 70%, transparent 100%);
            border: 3px solid rgba(0, 240, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.4), inset 0 0 40px rgba(0, 240, 255, 0.15);
        }
        .tutorial-joystick-thumb {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 240, 255, 0.95) 0%, rgba(0, 180, 220, 0.8) 100%);
            border: 3px solid rgba(255, 255, 255, 0.7);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.9), 0 3px 15px rgba(0, 0, 0, 0.4);
            animation: joystickDemo 2s ease-in-out infinite;
        }
        @keyframes joystickDemo {
            0%, 100% { transform: translate(-50%, -50%); }
            25% { transform: translate(-20%, -50%); }
            50% { transform: translate(-50%, -20%); }
            75% { transform: translate(-80%, -50%); }
        }
        .tutorial-finger {
            position: absolute;
            font-size: 40px;
            bottom: -20px;
            right: -20px;
            animation: fingerTap 2s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
        }
        @keyframes fingerTap {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.9; }
            25% { transform: translate(-30px, 0) scale(0.95); opacity: 1; }
            50% { transform: translate(0, -30px) scale(0.95); opacity: 1; }
            75% { transform: translate(30px, 0) scale(0.95); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="menu-overlay" id="menuOverlay">
        <div class="game-title">GOLDMINE</div>
        <div class="game-subtitle">Dig Deep  Collect Riches  Upgrade & Survive</div>
        <div class="menu-buttons">
            <button class="menu-btn" id="startBtn">start game</button>
            <button class="menu-btn btn-tutorial" id="tutorialBtn">HOW TO PLAY</button>
            <button class="menu-btn btn-leaderboard" id="leaderboardBtn">LEADER BOARD</button>
        </div>
    </div>
    <div class="game-wrapper">
        <div class="game-container">
        <div class="hud">
            <div class="hud-left">
                <div class="hud-item">
                    <div class="hud-label">Max</div>
                    <div class="hud-value max-depth"><span id="maxDepth">0</span>m</div>
                </div>
                <div class="hud-item">
                    <div class="hud-label">Depth</div>
                    <div class="hud-value depth"><span id="depth">0</span>m</div>
                </div>
            </div>
            <div class="hud-center">
                <div class="bar-container">
                    <div class="hud-label">Fuel</div>
                    <div class="fuel-bar-wrapper">
                        <div class="fuel-bar" id="fuelBarContainer">
                            <div class="fuel-fill" id="fuelBar" style="width: 100%"></div>
                        </div>
                        <span class="fuel-percent" id="fuelPercent">100</span>
                    </div>
                </div>
                <div class="bar-container">
                    <div class="hud-label">Hull</div>
                    <div class="hull-bar-wrapper">
                        <div class="hull-bar" id="hullBarContainer">
                            <div class="hull-fill" id="hullBar" style="width: 100%"></div>
                        </div>
                        <span class="hull-percent" id="hullPercent">100</span>
                    </div>
                </div>
            </div>
            <div class="hud-right">
                <div class="hud-item" style="align-items: flex-end;">
                    <div class="hud-label">Points</div>
                    <div class="hud-value points" id="points">0</div>
                </div>
                <div class="hud-item" style="align-items: flex-end;">
                    <div class="hud-label">Score</div>
                    <div class="hud-value score" id="score">0</div>
                </div>
            </div>
        </div>
        
        <!-- Keys Display -->
        <div class="keys-display" id="keysDisplay" style="display: none;">
            <div class="keys-container" id="keysContainer"></div>
        </div>
        
        <!-- Pause Button -->
        <div class="pause-btn" id="pauseBtn" title="Pause (P)"></div>
        
        <button class="surface-upgrade-btn" id="surfaceUpgradeBtn">UPGRADES</button>

        <canvas id="gameCanvas" width="560" height="550"></canvas>

        <div class="control-zone" id="controlZone">
            <div class="control-instructions" id="controlInstructions">arrow keys/wasd - touch and drag on mobile</div>
            <div class="permanent-upgrades" id="permUpgrades"></div>
        </div>

        <div class="upgrade-overlay" id="upgradeOverlay">
            <div class="upgrade-header">
                <div class="upgrade-title">UPGRADE</div>
                <div class="upgrade-subtitle">Choose your enhancement</div>
            </div>
            <div class="upgrade-slots">
                <div class="upgrade-slot" id="slot1"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
                <div class="upgrade-slot" id="slot2"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
                <div class="upgrade-slot" id="slot3"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
            </div>
        </div>

        <div class="boss-intro-overlay" id="bossIntroOverlay">
            <div class="boss-intro-container">
                <div class="boss-intro-icon" id="bossIntroIcon"></div>
                <div class="boss-intro-name" id="bossIntroName">UNKNOWN BOSS</div>
                <div class="boss-intro-depth" id="bossIntroDepth">Depth: 100m</div>
                <div class="boss-intro-objective">
                    <div class="boss-intro-objective-title">Objective</div>
                    <div class="boss-intro-objective-text" id="bossIntroObjective">Defeat the boss to obtain a key!</div>
                </div>
                <div class="boss-intro-tip" id="bossIntroTip"> Tip: Watch for attack patterns!</div>
                <div class="boss-intro-buttons">
                    <button class="boss-intro-btn battle" id="bossIntroBattle"> BATTLE</button>
                    <button class="boss-intro-btn leave" id="bossIntroLeave"> LEAVE</button>
                </div>
            </div>
        </div>
        
        <div class="boss-victory-overlay" id="bossVictoryOverlay">
            <div class="boss-victory-container">
                <div class="boss-victory-title"> VICTORY!</div>
                <div class="boss-victory-subtitle" id="bossVictorySubtitle">You defeated THE BURROWER</div>
                <div class="boss-victory-key-box">
                    <div class="boss-victory-key-label"> Key Obtained!</div>
                    <div class="boss-victory-key"></div>
                    <div class="boss-victory-key-depth" id="bossVictoryKeyDepth">100m Boss Key</div>
                </div>
                <div class="boss-victory-refuel"> Hull & Fuel Fully Restored!</div>
                <button class="boss-victory-btn" id="bossVictoryTeleport"> TELEPORT BACK</button>
            </div>
        </div>

        <div class="leaderboard-overlay" id="leaderboardOverlay">
            <div class="leaderboard-container">
                <div class="leaderboard-header">
                    <div class="leaderboard-title">HIGH SCORES</div>
                    <button class="leaderboard-close" id="leaderboardClose"></button>
                </div>
                <div class="leaderboard-list" id="leaderboardList"></div>
            </div>
        </div>

        <div class="score-modal" id="scoreModal">
            <div class="score-modal-content">
                <div class="score-modal-title">RUN COMPLETE</div>
                <div class="score-stats" id="finalScore">0</div>
                <label class="score-input-label">Enter your name for the leaderboard</label>
                <input type="text" class="score-input" id="usernameInput" placeholder="YOUR NAME" maxlength="12">
                <div class="score-error" id="scoreError"></div>
                <div class="score-buttons">
                    <button class="score-btn submit" id="submitScoreBtn">SAVE</button>
                    <button class="score-btn skip" id="skipScoreBtn">SKIP</button>
                </div>
            </div>
        </div>

        <!-- Tutorial Overlay -->
        <div class="tutorial-overlay" id="tutorialOverlay">
            <div class="tutorial-container">
                <button class="tutorial-close" id="tutorialClose"></button>
                <div class="tutorial-title"> HOW TO PLAY</div>
                
                <div class="tutorial-step active" data-step="0">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Controls</div>
                    <div class="tutorial-text">
                        <strong>Mobile:</strong> Swipe in any direction to move and dig.<br><br>
                        <strong>Desktop:</strong> Use <span class="tutorial-highlight">Arrow Keys</span> or <span class="tutorial-highlight">WASD</span> to move.
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="1">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Dig & Collect</div>
                    <div class="tutorial-text">
                        Dig through colored blocks to find treasures:<br>
                        <span class="tutorial-highlight"> Dirt</span> - Easy to dig<br>
                        <span class="tutorial-highlight">ite; Rock</span> - Generates heat<br>
                        <span class="tutorial-highlight"> Gems</span> - Worth points!<br>
                        Deeper gems = higher value!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="2">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Fuel & Hull</div>
                    <div class="tutorial-text">
                        <span class="tutorial-highlight"> Yellow Bar</span> = Fuel (drains as you move)<br>
                        <span class="tutorial-highlight"> Cyan Bar</span> = Hull HP<br><br>
                        Return to the <span class="tutorial-highlight"> surface station</span> to refuel and repair!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="3">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Hazards</div>
                    <div class="tutorial-text">
                        <span class="tutorial-highlight"> Lava</span> - Burns your hull!<br>
                        <span class="tutorial-highlight"> Toxic Gas</span> - Damages over time<br>
                        <span class="tutorial-highlight"> Overheat</span> - Drill too much rock = cooldown<br><br>
                        Surface cools your drill faster!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="4">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Special Blocks</div>
                    <div class="tutorial-text">
                        <span class="tutorial-highlight"> Bombs</span> - Clear area, reveal hidden gems<br>
                        <span class="tutorial-highlight"> Chests</span> - Bonus rewards<br>
                        <span class="tutorial-highlight"> Upgrade Chests</span> - Free upgrades!<br>
                        <span class="tutorial-highlight"> Fuel Cans</span> - Emergency refuel
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="5">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Upgrades</div>
                    <div class="tutorial-text">
                        Every <span class="tutorial-highlight">50m depth</span>, choose 1 of 3 upgrades:<br><br>
                         Hull capacity<br>
                         Fuel efficiency<br>
                         Heat sink<br>
                         Drill power<br>
                        ...and more!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="6">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Creatures</div>
                    <div class="tutorial-text">
                        Below <span class="tutorial-highlight">50m</span>, enemies appear!<br><br>
                        <span class="tutorial-highlight"> Worms</span> - Burrow toward you<br>
                        <span class="tutorial-highlight"> Beetles</span> - Patrol tunnels<br>
                        <span class="tutorial-highlight"> Lava Slugs</span> - Lurk in hot zones<br><br>
                        Drill into them to defeat them!
                    </div>
                </div>
                
                <div class="tutorial-step" data-step="7">
                    <div class="tutorial-icon"></div>
                    <div class="tutorial-heading">Fever Mode</div>
                    <div class="tutorial-text">
                        Build a <span class="tutorial-highlight">10x combo</span> by collecting gems quickly!<br><br>
                         <strong>FEVER MODE:</strong><br>
                         2x points<br>
                         Half fuel cost<br>
                         Reduced heat buildup<br>
                        Lasts 10 seconds!
                    </div>
                </div>
                
                <div class="tutorial-nav">
                    <button class="tutorial-nav-btn tutorial-prev" id="tutorialPrev"> Back</button>
                    <div class="tutorial-dots" id="tutorialDots"></div>
                    <button class="tutorial-nav-btn tutorial-next" id="tutorialNext">Next </button>
                </div>
            </div>
        </div>

        <!-- Shop Overlay -->
        <div class="shop-overlay" id="shopOverlay">
            <div class="shop-container">
                <button class="shop-close" id="shopClose"></button>
                <div class="shop-header">
                    <div class="shop-title"> UPGRADES</div>
                    <div class="shop-score"> <span id="shopScore">0</span></div>
                </div>
                <div class="shop-grid" id="shopGrid"></div>
            </div>
        </div>
    </div>
    </div>
    
    <!-- Virtual Joystick for Mobile -->
    <div class="joystick-base" id="joystickBase">
        <div class="joystick-thumb" id="joystickThumb"></div>
    </div>
    
    <!-- Pause Menu Overlay -->
    <div class="pause-overlay" id="pauseOverlay">
        <div class="pause-title">Paused</div>
        <div class="pause-menu-buttons">
            <div class="pause-menu-btn btn-resume" id="resumeBtn">Resume</div>
            <div class="pause-menu-btn btn-leaderboard" id="pauseLeaderboardBtn">Leaderboard</div>
            <div class="pause-menu-btn btn-exit" id="exitGameBtn">Exit Game</div>
        </div>
    </div>
    
    <!-- Confirmation Overlay -->
    <div class="confirm-overlay" id="confirmOverlay">
        <div class="confirm-box">
            <div class="confirm-text">Are you sure?</div>
            <div class="confirm-buttons">
                <div class="confirm-btn btn-yes" id="confirmYes">Yes</div>
                <div class="confirm-btn btn-no" id="confirmNo">No</div>
            </div>
        </div>
    </div>
    
    <!-- Touch Tutorial Overlay -->
    <div class="touch-tutorial" id="touchTutorial">
        <div class="touch-tutorial-text">Touch anywhere and slide to move</div>
        <div class="touch-tutorial-joystick">
            <div class="tutorial-joystick-base"></div>
            <div class="tutorial-joystick-thumb"></div>
            <div class="tutorial-finger"></div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';
        
        // ==================== FIREBASE CONFIGURATION ====================
        // BOO Website Game Leaderboard (consolidated)
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        const SCORES_COLLECTION = 'neondig_scores';
        
        // Initialize Firebase (only if config is set)
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        
        // Start loading Firebase
        loadFirebaseSDK();
        
        // ==================== CONSTANTS ====================
        const TILE_SIZE = 28;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
        const MAX_PARTICLES = 150;
        const MAX_FLOATING_TEXTS = 30;
        const WORLD_BUFFER_ROWS = 60;
        const WORLD_TRIM_THRESHOLD = 100;
        
        // Base canvas dimensions (logical size) - widened for modern screens
        const BASE_WIDTH = 560;  // 20 tiles  28px
        const BASE_HEIGHT = 550;
        let renderScale = 1;
        
        // iOS canvas memory limit: 16,777,216 pixels max (approx 4096x4096)
        const MAX_CANVAS_PIXELS = 16777216;
        
        // ========== DEBUG UTILITY ==========
        const GameDebug = {
            enabled: false, // Toggle for debugging
            el: null,
            show(data) {
                if (!this.enabled) return this.hide();
                if (!this.el) {
                    this.el = document.createElement('div');
                    this.el.id = 'game-debug';
                    this.el.style.cssText = `
                        position: fixed; top: 60px; left: 10px;
                        background: rgba(255,0,0,0.9); color: #fff;
                        padding: 8px; font: 12px monospace;
                        z-index: 99999; border-radius: 4px;
                        max-width: 300px; pointer-events: none;
                    `;
                    document.body.appendChild(this.el);
                }
                this.el.innerHTML = Object.entries(data)
                    .map(([k, v]) => `${k}: ${v}`)
                    .join('<br>');
            },
            hide() {
                if (this.el) {
                    this.el.remove();
                    this.el = null;
                }
            }
        };
        
        // ========== iOS GESTURE PREVENTION ==========
        // Prevent iOS "swipe down to exit fullscreen" gesture
        (function() {
            if (!('ontouchstart' in window)) return;
            
            let touchStartY = 0;
            const EDGE_THRESHOLD = 50; // Pixels from top edge
            
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                // If touch started near top edge and is moving down, block it
                if (touchStartY < EDGE_THRESHOLD) {
                    const currentY = e.touches[0].clientY;
                    if (currentY > touchStartY + 10) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });
        })();
        
        // Tile types
        const TILE = Object.freeze({
            AIR: 0, DIRT: 1, ROCK: 2, HARD_ROCK: 3,
            GEM_COMMON: 4, GEM_RARE: 5, GEM_EPIC: 6,
            LAVA: 7, GAS: 8, FUEL: 9,
            BOMB: 10, CHEST: 11, UNSTABLE: 12, BEDROCK: 13,
            UPGRADE_CHEST: 14,
            PORTAL: 15,      // Boss portal (2x2)
            PORTAL_PART: 16, // Secondary portal tiles (top-right, bottom-left, bottom-right)
            GATE: 17,        // Locked gate requiring boss key
            ALIEN_NODE: 18,  // Alien gem node - drops multiple gems
            CHAIN_CRYSTAL: 19, // Breaks adjacent chain crystals in chain reaction
            BOUNCE_PAD: 20,    // Up Charge - clears blocks above
            MYSTERY_BLOCK: 21, // Random reward when broken
            DEPTH_CHARGE: 22,  // Clears 5 blocks below when broken
            MAGNET_ORE: 23,    // Pulls nearby gems toward player
            CHERRY_BOMB: 24    // Smaller bomb, 3x3 explosion (red)
        });
        
        // Surface refuel settings
        const SURFACE_REFUEL_DEPTH = 2; // Rows from surface to trigger refuel (legacy)
        const REFUEL_LINE_Y = 84; // World Y position of refuel line (10% of player must be above this)
        const REFUEL_RATE = 2.5; // Fuel and hull per frame when at surface
        const FIRST_DIGGABLE_ROW = 3; // Rows 0-2 are sky/air, first diggable row is 3
        
        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        // ==================== DEVICE DETECTION ====================
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isIPad = /iPad/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
                      (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
        const isTablet = isTouchDevice && (isIPad || Math.min(window.screen.width, window.screen.height) >= 600);
        const rawDPR = window.devicePixelRatio || 1;
        
        const depthEl = document.getElementById('depth');
        const maxDepthEl = document.getElementById('maxDepth');
        const scoreEl = document.getElementById('score');
        const fuelBar = document.getElementById('fuelBar');
        const fuelBarContainer = document.getElementById('fuelBarContainer');
        const fuelPercent = document.getElementById('fuelPercent');
        const hullBar = document.getElementById('hullBar');
        const hullBarContainer = document.getElementById('hullBarContainer');
        const hullPercent = document.getElementById('hullPercent');
        const startBtn = document.getElementById('startBtn');
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const tutorialBtn = document.getElementById('tutorialBtn');
        const menuOverlay = document.getElementById('menuOverlay');
        const controlZone = document.getElementById('controlZone');
        const controlInstructions = document.getElementById('controlInstructions');
        const permUpgradesEl = document.getElementById('permUpgrades');
        const upgradeOverlay = document.getElementById('upgradeOverlay');
        const slots = [document.getElementById('slot1'), document.getElementById('slot2'), document.getElementById('slot3')];
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        const scoreModal = document.getElementById('scoreModal');
        const finalScoreEl = document.getElementById('finalScore');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreError = document.getElementById('scoreError');
        const gameContainer = document.querySelector('.game-container');
        
        // Tutorial elements
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialClose = document.getElementById('tutorialClose');
        const tutorialPrev = document.getElementById('tutorialPrev');
        const tutorialNext = document.getElementById('tutorialNext');
        const tutorialDots = document.getElementById('tutorialDots');
        const tutorialSteps = document.querySelectorAll('.tutorial-step');
        const totalTutorialSteps = tutorialSteps.length;
        let currentTutorialStep = 0;
        
        // Shop elements
        const shopOverlay = document.getElementById('shopOverlay');
        const shopClose = document.getElementById('shopClose');
        const shopGrid = document.getElementById('shopGrid');
        const shopScoreEl = document.getElementById('shopScore');
        const surfaceUpgradeBtn = document.getElementById('surfaceUpgradeBtn');
        const pointsEl = document.getElementById('points');
        
        // Keys display elements
        const keysDisplayEl = document.getElementById('keysDisplay');
        const keysContainerEl = document.getElementById('keysContainer');
        
        let WORLD_WIDTH = 20; // Will be updated on resize
        
        // ==================== GAME STATE ====================
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let depth = 0;
        let maxDepthThisRun = 0; // Track deepest point reached
        let fuel = 100;
        let maxFuel = 100;
        let hull = 100;
        let maxHull = 100;
        let lastUpgradeDepth = 0;
        let upgradeSelectionActive = false;
        let upgradeSelected = false;
        let isLegendaryUpgrade = false;
        let isChestUpgrade = false;
        let lastFrameTime = 0;
        let deltaMultiplier = 1;
        let screenShake = 0;
        let deathAnimationActive = false;
        let deathAnimationTimer = 0;
        const DEATH_ANIMATION_DURATION = 60; // 1 second at 60fps
        let deathReason = '';
        let depthColorShift = 0;
        let globalTime = 0;
        let worldRowOffset = 0;
        
        // ==================== ALIEN TIP SYSTEM ====================
        const alienTipsRegular = [
            "Hold against walls to drill sideways!",
            "Hover mode uses 80% less fuel!",
            "Combo gems quickly for bonus points!",
            "Bombs blast open a large area!",
            "Drill overheats - let it cool!",
            "Green gas and lava hurt your hull!",
            "Upgrades appear every 50m depth!",
            "Spend points on permanent upgrades!",
            "Blue chests hold powerful upgrades!"
        ];
        const alienTipSpecial = "Not such a long time 'till you see me again, eh?";
        let alienTipHistory = []; // Track shown tips for bad luck protection
        let alienPassCount = 0; // Track number of alien passes
        let alienActive = false;
        let alienX = 0;
        let alienY = 0;
        let alienTip = '';
        let alienCooldown = 0;
        const ALIEN_SPEED = 0.8;
        const ALIEN_COOLDOWN = 1200; // ~20 seconds between tips
        
        function getNextAlienTip() {
            // Special line only after 5th pass, with 20% chance
            if (alienPassCount >= 5 && Math.random() < 0.2) {
                return alienTipSpecial;
            }
            
            // Bad luck protection: reset history when all tips shown
            if (alienTipHistory.length >= alienTipsRegular.length) {
                alienTipHistory = [];
            }
            
            // Get available tips (not recently shown)
            const availableTips = alienTipsRegular.filter(tip => !alienTipHistory.includes(tip));
            
            // Pick random from available
            const tip = availableTips[Math.floor(Math.random() * availableTips.length)];
            alienTipHistory.push(tip);
            
            return tip;
        }
        
        // ==================== SHOP UPGRADES (Per-Run) ====================
        // Define the 10 shop upgrades - purchasable at surface during a run
        const shopUpgradesDef = [
            { id: 'digSpeed', name: 'Drill Efficiency', icon: '', desc: '+4% dig speed', bonus: 4, max: 10 },
            { id: 'fuelCap', name: 'Fuel Tank', icon: '', desc: '+5% max fuel', bonus: 5, max: 10 },
            { id: 'fuelEff', name: 'Fuel Saver', icon: '', desc: '+3% fuel efficiency', bonus: 3, max: 10 },
            { id: 'hullCap', name: 'Hull Plating', icon: '', desc: '+5% max hull', bonus: 5, max: 10 },
            { id: 'armor', name: 'Hazard Resist', icon: '', desc: '+3% damage reduction', bonus: 3, max: 10 },
            { id: 'cooling', name: 'Heat Sink', icon: '', desc: '+4% cooling', bonus: 4, max: 10 },
            { id: 'feverLen', name: 'Fever Boost', icon: '', desc: '+5% fever duration', bonus: 5, max: 10 },
            { id: 'comboTime', name: 'Combo Window', icon: '', desc: '+4% combo time', bonus: 4, max: 10 },
            { id: 'gemValue', name: 'Gem Appraisal', icon: '', desc: '+3% gem value', bonus: 3, max: 10 },
            { id: 'climbSpeed', name: 'Thruster Power', icon: '', desc: '+4% climb speed', bonus: 4, max: 10 }
        ];
        
        // Shop upgrades reset each run
        let shopUpgrades = {};
        let spentScore = 0;
        
        function initShopUpgrades() {
            shopUpgrades = {};
            shopUpgradesDef.forEach(u => shopUpgrades[u.id] = 0);
            spentScore = 0;
        }
        
        function getAvailablePoints() {
            return score - spentScore;
        }
        
        // Cost scaling: starts cheap, increases per level
        function getUpgradeCost(upgradeId, level) {
            // Exact costs per level
            const costs = [200, 300, 450, 675, 1000, 1500, 2250, 3500, 5000, 7500];
            return costs[level] || costs[costs.length - 1];
        }
        
        function buyShopUpgrade(upgradeId) {
            const def = shopUpgradesDef.find(u => u.id === upgradeId);
            if (!def) return false;
            
            const currentLevel = shopUpgrades[upgradeId] || 0;
            if (currentLevel >= def.max) return false;
            
            const cost = getUpgradeCost(upgradeId, currentLevel);
            if (getAvailablePoints() < cost) return false;
            
            spentScore += cost;
            shopUpgrades[upgradeId] = currentLevel + 1;
            updatePointsDisplay();
            return true;
        }
        
        function updatePointsDisplay() {
            pointsEl.textContent = getAvailablePoints();
        }
        
        function updateScoreDisplay() {
            scoreEl.textContent = score;
            updatePointsDisplay();
        }
        
        function updateKeysDisplay() {
            if (bossKeys.length === 0) {
                keysDisplayEl.style.display = 'none';
                return;
            }
            
            keysDisplayEl.style.display = 'flex';
            keysContainerEl.innerHTML = '';
            
            for (const keyDepth of bossKeys) {
                const keyEl = document.createElement('div');
                keyEl.className = 'alien-key';
                keysContainerEl.appendChild(keyEl);
            }
        }
        
        function getShopBonus(upgradeId) {
            const def = shopUpgradesDef.find(u => u.id === upgradeId);
            if (!def) return 0;
            return (shopUpgrades[upgradeId] || 0) * def.bonus;
        }
        
        // Initialize on load
        initShopUpgrades();
        
        // ==================== COMBO & FEVER SYSTEM ====================
        let comboCount = 0;
        let comboTimer = 0;
        const COMBO_DECAY_BASE = 150; // frames (~2.5 sec at 60fps) - baseline
        function getComboDecayTime() {
            return Math.floor(COMBO_DECAY_BASE * (1 + getShopBonus('comboTime') / 100));
        }
        let feverMode = false;
        let feverTimer = 0;
        const FEVER_DURATION_BASE = 480; // frames (~8 sec) - baseline
        function getFeverDuration() {
            return Math.floor(FEVER_DURATION_BASE * (1 + getShopBonus('feverLen') / 100));
        }
        const FEVER_COMBO_THRESHOLD = 8;
        
        // ==================== DRILL HEAT SYSTEM ====================
        let drillHeat = 0;
        let maxDrillHeat = 100;
        let drillOverheated = false;
        let drillCooldownTimer = 0;
        const DRILL_COOLDOWN_FRAMES = 180; // 3 seconds to recover from overheat
        const HEAT_DECAY_RATE = 1.0; // Heat lost per frame when not drilling hard materials
        
        // ==================== HOVER MODE ====================
        let hoverMode = false;
        let flightTimer = 0;
        let groundedTimer = 0;
        let blockedTimer = 0; // Track time stuck against ceiling
        let blockedTimerLeft = 0; // Track time stuck against left wall
        let blockedTimerRight = 0; // Track time stuck against right wall
        let hoverUpDrillTimer = 0; // Dedicated timer for hover mode upward drilling
        let hoverDrillMomentum = 0; // Momentum after drilling in hover mode - allows immediate chaining
        let upDigMomentum = 0; // Track momentum for continuous upward digging
        const HOVER_MODE_DELAY = 20; // ~0.33 seconds of unobstructed flight
        const GROUNDED_EXIT_DELAY = 15; // ~0.25 seconds on ground to exit hover
        const BLOCKED_DRILL_DELAY = 24; // ~0.4 seconds stuck to auto-drill (upward)
        const UP_DIG_MOMENTUM_FRAMES = 25; // ~0.4 seconds of momentum after completing an upward dig
        const HOVER_DRILL_MOMENTUM_FRAMES = 30; // ~0.5 seconds of momentum for chaining in hover mode
        
        // ==================== VISUAL EFFECTS ====================
        let screenFlash = { active: false, color: '#ffffff', alpha: 0, duration: 0 };
        let speedLines = [];
        let unstableTiles = []; // Track tiles that are about to collapse
        
        // ==================== ENEMY SYSTEM ====================
        const ENEMY_TYPE = {
            WORM: 'worm',
            BEETLE: 'beetle', 
            LAVA_SLUG: 'lava_slug'
        };
        
        const ENEMY_MIN_DEPTH = 50; // No worms/lava slugs until 50m
        let enemies = [];
        let firstEnemySpawned = false; // Track if player has encountered first enemy
        let secondEnemySpawned = false; // Track if player has encountered second enemy
        let drillKillGracePeriod = 0;   // Brief invulnerability after killing enemy with drill
        
        // Spawn rates per 100 tiles generated (very low, scales with depth)
        function getEnemySpawnChance(depth, biome) {
            // Beetles can spawn early (easiest enemy - predictable patrol)
            let beetleChance = 0;
            if (depth >= 8) {
                if (depth < ENEMY_MIN_DEPTH) {
                    // Early game: higher chance for earlier encounters
                    beetleChance = 0.018; // ~1.8% per tile dug
                } else {
                    // Normal scaling after 50m
                    const depthFactor = Math.min(1, (depth - ENEMY_MIN_DEPTH) / 400);
                    beetleChance = 0.004 + depthFactor * 0.010;
                }
            }
            
            // Worms and lava slugs only after 50m
            if (depth < ENEMY_MIN_DEPTH) {
                return { worm: 0, beetle: beetleChance, lava_slug: 0 };
            }
            
            // Gradual scaling: starts very low, slowly increases
            const depthFactor = Math.min(1, (depth - ENEMY_MIN_DEPTH) / 400); // Max at depth 450
            
            return {
                worm: 0.005 + depthFactor * 0.012,      // 0.5% to 1.7%
                beetle: beetleChance,
                lava_slug: biome === BIOME.LAVA_ZONE ? (0.006 + depthFactor * 0.014) : 0  // Only in lava
            };
        }
        
        // ==================== BOSS BATTLE SYSTEM ====================
        const BOSS_PORTAL_INTERVAL = 50;  // Portal every 50m (first at 50m)
        const BOSS_GATE_OFFSET = 25;      // Gate 25m below each portal
        
        // Boss types
        const BOSS_TYPE = {
            BURROWER: 'burrower',       // 50m - Dig to expose weak spot
            CRYSTAL_GOLEM: 'golem',     // 100m - Break barriers + shockwaves
            LAVA_WURM: 'wurm',          // 150m - Rising lava survival
            HIVE_MIND: 'hive',          // 200m - Swarm management
            COLLECTOR: 'collector'      // 250m+ - Combined mechanics
        };
        
        // Boss state
        let bossKeys = [];              // Array of defeated boss depths (50, 100, etc.)
        let bossArenaActive = false;
        let bossTransitionTimer = 0;
        let bossTransitionPhase = 'none'; // 'entering', 'active', 'victory', 'exiting', 'none'
        let currentBossDepth = 0;       // Which portal tier (50, 100, etc.)
        
        // Portal cooldown (inactive until player moves away)
        let portalCooldown = {};        // { depth: true } if portal is on cooldown
        
        // Current boss data (populated when arena active)
        let boss = null;
        let bossArena = {
            width: 14,                  // Arena width in tiles
            height: 16,                 // Arena height in tiles  
            tiles: [],                  // Arena terrain
            particles: [],              // Boss-specific particles
            projectiles: [],            // Boss attacks
            weakPoints: [],             // Exposed weak points to hit
            hazards: [],                // Environmental hazards
            healingPickups: [],         // Hull healing pickups
            healingTimer: 0,            // Timer for next healing spawn
            portalTx: null,             // Portal X position for return
            portalRow: null             // Portal row for return
        };
        
        // Pre-computed portal/gate locations
        let portalLocations = [];       // {depth, tx, spawned}
        let gateLocations = [];         // {depth, spawned}
        
        // Alien node quota tracking - VERY limited spawns
        // Max 1 in 100-199m band, max 2 in 200-299m band, max 3 in 300-399m band, etc.
        let alienNodeCounts = {};       // { "100": count, "200": count, ... }
        
        // Fuel canister quota tracking - max 3 per 100m band, decreasing with depth
        let fuelCanisterCounts = {};    // { "0": count, "100": count, "200": count, ... }
        let lastFuelRow = -100;         // Track last fuel spawn row for spacing
        const FUEL_MIN_ROW_DISTANCE = 8; // Minimum rows between fuel canisters
        
        function getFuelQuotaForBand(band) {
            // Band 0: 3, Band 100: 3, Band 200: 2, Band 300+: 2
            if (band < 200) return 3;
            return 2;
        }
        
        function canSpawnFuelCanister(depth, x, y) {
            const band = Math.floor(depth / 100) * 100; // 0, 100, 200, etc.
            const quota = getFuelQuotaForBand(band);
            const currentCount = fuelCanisterCounts[band] || 0;
            if (currentCount >= quota) return false;
            
            // Check row distance from last fuel canister
            if (Math.abs(y - lastFuelRow) < FUEL_MIN_ROW_DISTANCE) {
                return false;
            }
            return true;
        }
        
        function recordFuelCanisterSpawn(depth, x, y) {
            const band = Math.floor(depth / 100) * 100;
            fuelCanisterCounts[band] = (fuelCanisterCounts[band] || 0) + 1;
            lastFuelRow = y;
        }
        
        function getAlienNodeQuotaForBand(band) {
            // Band 100 = 1 max, Band 200 = 2 max, Band 300 = 3 max, etc.
            return Math.floor(band / 100);
        }
        
        function canSpawnAlienNode(depth) {
            if (depth < 100) return false;
            const band = Math.floor(depth / 100) * 100; // 100, 200, 300, etc.
            const quota = getAlienNodeQuotaForBand(band);
            const currentCount = alienNodeCounts[band] || 0;
            return currentCount < quota;
        }
        
        function recordAlienNodeSpawn(depth) {
            const band = Math.floor(depth / 100) * 100;
            alienNodeCounts[band] = (alienNodeCounts[band] || 0) + 1;
            // Alien node spawned at depth (debug removed for production)
        }
        
        function initBossSystem() {
            bossKeys = [];
            bossArenaActive = false;
            bossTransitionTimer = 0;
            bossTransitionPhase = 'none';
            currentBossDepth = 0;
            boss = null;
            portalLocations = [];
            gateLocations = [];
            alienNodeCounts = {}; // Reset alien node tracking
            fuelCanisterCounts = {}; // Reset fuel canister tracking
            lastFuelRow = -100; // Reset fuel row tracking
            portalCooldown = {}; // Reset portal cooldowns
            
            // Pre-compute portal and gate depths
            for (let i = 1; i <= 10; i++) {
                const portalDepth = i * BOSS_PORTAL_INTERVAL;
                const gateDepth = portalDepth + BOSS_GATE_OFFSET;
                portalLocations.push({ depth: portalDepth, tx: null, spawned: false });
                gateLocations.push({ depth: gateDepth, forBossDepth: portalDepth, spawned: false });
            }
            // Boss system initialized (debug removed for production)
        }
        
        function getBossTypeForDepth(depth) {
            const tier = Math.floor(depth / BOSS_PORTAL_INTERVAL);
            const cycledTier = ((tier - 1) % 5) + 1; // Cycle through 1-5
            
            switch(cycledTier) {
                case 1: return BOSS_TYPE.BURROWER;
                case 2: return BOSS_TYPE.CRYSTAL_GOLEM;
                case 3: return BOSS_TYPE.LAVA_WURM;
                case 4: return BOSS_TYPE.HIVE_MIND;
                case 5: return BOSS_TYPE.COLLECTOR;
                default: return BOSS_TYPE.BURROWER;
            }
        }
        
        function getBossDifficultyMultiplier(depth) {
            // After first cycle (500m), bosses get harder
            const cycle = Math.floor((depth - 1) / 500);
            return 1 + cycle * 0.25; // +25% per cycle
        }
        
        function hasKeyForGate(gateDepth) {
            // Find which boss this gate requires
            const gate = gateLocations.find(g => g.depth === gateDepth);
            if (!gate) return true; // Unknown gate, allow passage
            return bossKeys.includes(gate.forBossDepth);
        }
        
        function spawnEnemy(type, tx, ty) {
            const enemy = {
                type: type,
                x: tx * TILE_SIZE + TILE_SIZE / 2,
                y: (ty + worldRowOffset) * TILE_SIZE + TILE_SIZE / 2,
                tx: tx,  // Tile coordinates
                ty: ty + worldRowOffset,
                width: 14,
                height: 14,
                moveTimer: 0,
                moveDelay: type === ENEMY_TYPE.WORM ? 45 : (type === ENEMY_TYPE.LAVA_SLUG ? 60 : 30),
                direction: Math.random() < 0.5 ? -1 : 1, // For beetles/slugs
                health: 1,
                damage: type === ENEMY_TYPE.LAVA_SLUG ? 15 : 8,
                inGround: false, // Enemies now spawn on surface
                animFrame: 0
            };
            enemies.push(enemy);
        }
        
        // Find a valid surface spawn position (AIR tile with solid ground below, outside player view)
        function findSurfaceSpawnPosition(aroundTx, aroundTy, searchRadius) {
            const cameraBottomRow = Math.ceil((cameraY + BASE_HEIGHT) / TILE_SIZE);
            
            // First try: find existing AIR tile with solid below
            for (let attempt = 0; attempt < 30; attempt++) {
                const offsetX = Math.floor(Math.random() * (searchRadius * 2 + 1)) - searchRadius;
                const offsetY = Math.floor(Math.random() * searchRadius) + 2;
                
                const testTx = aroundTx + offsetX;
                const testAbsTy = aroundTy + worldRowOffset + offsetY;
                const testLocalTy = testAbsTy - worldRowOffset;
                
                // Must be outside player view (below camera bottom)
                if (testAbsTy <= cameraBottomRow + 2) continue;
                
                // Check bounds
                if (testTx < 1 || testTx >= WORLD_WIDTH - 1) continue;
                if (testLocalTy < 0 || testLocalTy >= world.length - 1) continue;
                
                const tileHere = world[testLocalTy][testTx];
                const tileBelow = world[testLocalTy + 1] ? world[testLocalTy + 1][testTx] : TILE.AIR;
                
                if (tileHere === TILE.AIR && tileBelow !== TILE.AIR && tileBelow !== TILE.LAVA &&
                    tileBelow !== TILE.PORTAL && tileBelow !== TILE.PORTAL_PART) {
                    return { tx: testTx, ty: testLocalTy };
                }
            }
            
            // Second try: Create a spawn pocket by clearing a tile
            for (let attempt = 0; attempt < 15; attempt++) {
                const offsetX = Math.floor(Math.random() * (searchRadius * 2 + 1)) - searchRadius;
                const offsetY = 3 + Math.floor(Math.random() * 5); // 3-8 rows below
                
                const testTx = aroundTx + offsetX;
                const testAbsTy = aroundTy + worldRowOffset + offsetY;
                const testLocalTy = testAbsTy - worldRowOffset;
                
                if (testAbsTy <= cameraBottomRow + 2) continue;
                if (testTx < 1 || testTx >= WORLD_WIDTH - 1) continue;
                if (testLocalTy < 0 || testLocalTy >= world.length - 1) continue;
                
                const tileHere = world[testLocalTy][testTx];
                const tileBelow = world[testLocalTy + 1] ? world[testLocalTy + 1][testTx] : null;
                
                // Can carve if tile is diggable and has solid floor
                if (tileBelow && tileHere !== TILE.AIR && tileHere !== TILE.BEDROCK && 
                    tileHere !== TILE.HARD_ROCK && tileHere !== TILE.PORTAL && 
                    tileHere !== TILE.PORTAL_PART && tileHere !== TILE.GAS &&
                    tileBelow !== TILE.AIR && tileBelow !== TILE.LAVA) {
                    // Carve out space for enemy
                    world[testLocalTy][testTx] = TILE.AIR;
                    return { tx: testTx, ty: testLocalTy };
                }
            }
            
            return null;
        }
        
        // Find surface spawn for lava slugs (can walk on lava)
        function findLavaSurfaceSpawnPosition(aroundTx, aroundTy, searchRadius) {
            const cameraBottomRow = Math.ceil((cameraY + BASE_HEIGHT) / TILE_SIZE);
            
            for (let attempt = 0; attempt < 30; attempt++) {
                const offsetX = Math.floor(Math.random() * (searchRadius * 2 + 1)) - searchRadius;
                const offsetY = Math.floor(Math.random() * searchRadius) + 2;
                
                const testTx = aroundTx + offsetX;
                const testAbsTy = aroundTy + worldRowOffset + offsetY;
                const testLocalTy = testAbsTy - worldRowOffset;
                
                if (testAbsTy <= cameraBottomRow + 2) continue;
                if (testTx < 1 || testTx >= WORLD_WIDTH - 1) continue;
                if (testLocalTy < 0 || testLocalTy >= world.length - 1) continue;
                
                const tileHere = world[testLocalTy][testTx];
                const tileBelow = world[testLocalTy + 1] ? world[testLocalTy + 1][testTx] : TILE.AIR;
                
                // Lava slugs can stand on any solid including lava
                if (tileHere === TILE.AIR && tileBelow !== TILE.AIR &&
                    tileBelow !== TILE.PORTAL && tileBelow !== TILE.PORTAL_PART) {
                    return { tx: testTx, ty: testLocalTy };
                }
            }
            
            // Fallback: Create a spawn point
            for (let attempt = 0; attempt < 15; attempt++) {
                const offsetX = Math.floor(Math.random() * (searchRadius * 2 + 1)) - searchRadius;
                const offsetY = 3 + Math.floor(Math.random() * 5);
                
                const testTx = aroundTx + offsetX;
                const testAbsTy = aroundTy + worldRowOffset + offsetY;
                const testLocalTy = testAbsTy - worldRowOffset;
                
                if (testAbsTy <= cameraBottomRow + 2) continue;
                if (testTx < 1 || testTx >= WORLD_WIDTH - 1) continue;
                if (testLocalTy < 0 || testLocalTy >= world.length - 1) continue;
                
                const tileHere = world[testLocalTy][testTx];
                const tileBelow = world[testLocalTy + 1] ? world[testLocalTy + 1][testTx] : null;
                
                if (tileBelow && tileHere !== TILE.AIR && tileHere !== TILE.BEDROCK && 
                    tileHere !== TILE.HARD_ROCK && tileHere !== TILE.PORTAL &&
                    tileHere !== TILE.PORTAL_PART && tileHere !== TILE.GAS &&
                    tileBelow !== TILE.AIR) {
                    world[testLocalTy][testTx] = TILE.AIR;
                    return { tx: testTx, ty: testLocalTy };
                }
            }
            
            return null;
        }
        
        // Upgrade intervals for cleanup
        let activeRollIntervals = [];
        let activeRollTimeouts = [];
        
        // ==================== UPGRADE DEFINITIONS ====================
        // BUG FIX: Cap percentages to prevent exceeding 100%
        const permanentUpgrades = {
            digSpeed: 0,
            fuelCapacity: 0,
            gemMagnet: 0,
            armor: 0,
            fuelEfficiency: 0,
            gemValue: 0,
            climbSpeed: 0,
            drillPower: 0,
            drillCooling: 0
        };
        
        // Helper to get effective values with caps
        function getEffectiveUpgrade(key, maxPercent = 90) {
            return Math.min(permanentUpgrades[key], maxPercent);
        }
        
        const upgradeDefinitions = [
            { id: 'digSpeed', name: 'Turbo Drill', icon: '', desc: '+15% dig speed', apply: () => permanentUpgrades.digSpeed += 15 },
            { id: 'fuelCapacity', name: 'Fuel Tank', icon: '', desc: '+25% fuel  Dive deeper!', apply: () => { permanentUpgrades.fuelCapacity += 25; const baseMax = 100 * (1 + getShopBonus('fuelCap') / 100); maxFuel = baseMax * (1 + permanentUpgrades.fuelCapacity / 100); } },
            { id: 'gemMagnet', name: 'Gem Magnet', icon: '', desc: '+1 attraction range', apply: () => permanentUpgrades.gemMagnet += 1 },
            { id: 'fuelEfficiency', name: 'Eco Mode', icon: '', desc: '-15% fuel usage', apply: () => permanentUpgrades.fuelEfficiency += 15 },
            { id: 'gemValue', name: 'Appraiser', icon: '', desc: '+15% gem value', apply: () => permanentUpgrades.gemValue += 15 },
            { id: 'climbSpeed', name: 'Grapple', icon: '', desc: '+25% climb speed', apply: () => permanentUpgrades.climbSpeed += 25 },
            { id: 'drillPower', name: 'Diamond Tip', icon: '', desc: '+10% instant break', apply: () => permanentUpgrades.drillPower += 10 },
            { id: 'drillCooling', name: 'Heat Sink', icon: '', desc: '-20% drill heat buildup', apply: () => permanentUpgrades.drillCooling += 20 }
        ];
        
        const legendaryUpgradeDefinitions = [
            { id: 'armor', name: 'Titanium Hull', icon: '', desc: '-25% hazard damage', apply: () => permanentUpgrades.armor += 25 },
            { id: 'doubleGems', name: 'Lucky Strike', icon: '', desc: '2x gems this run', apply: () => permanentUpgrades.gemValue += 100 },
            { id: 'megaTank', name: 'Mega Tank', icon: '', desc: '+50% fuel + full refill', apply: () => { permanentUpgrades.fuelCapacity += 50; const baseMax = 100 * (1 + getShopBonus('fuelCap') / 100); maxFuel = baseMax * (1 + permanentUpgrades.fuelCapacity / 100); fuel = maxFuel; } },
            { id: 'superCooling', name: 'Cryo Drill', icon: '', desc: 'Drill never overheats', apply: () => permanentUpgrades.drillCooling += 200 }
        ];
        
        let upgradeOfferHistory = {};
        let currentUpgradeChoices = [];
        
        // ==================== WORLD ====================
        let world = [];
        let cameraY = -80; // Start with sky visible
        
        // ==================== PLAYER ====================
        const player = {
            x: BASE_WIDTH / 2 - 12,
            y: 60,
            width: 24,
            height: 28,
            speed: 3,
            digging: false,
            digProgress: 0,
            digTarget: null,
            thrusterFlicker: 0,
            vy: 0  // Vertical velocity for falling physics
        };
        
        // Slide animation for smooth repositioning when drilling
        let slideAnimation = {
            active: false,
            targetX: 0,
            targetY: 0,
            speed: 0.075,  // Lerp factor (0-1, lower = slower slide) - 50% slower than original
            direction: 'down', // 'down', 'left', 'right' - determines Y slide behavior
            timer: 0 // Safety timeout to prevent getting stuck
        };
        
        // Falling physics constants
        const GRAVITY = 0.2;           // Acceleration per frame (slower buildup)
        const MAX_FALL_SPEED = 12;     // Maximum fall velocity
        const LANDING_SHAKE_THRESHOLD = 6;  // Min velocity for landing shake
        
        // ==================== ANTI-CLUSTERING SYSTEM ====================
        // Tracks tile number when each item type last spawned
        let spawnHistory = {
            gem: -100,           // Tile index of last gem spawn
            fuel: -100,          // Tile index of last fuel spawn
            chest: -100,         // Tile index of last chest spawn
            upgradeChest: -100,  // Tile index of last upgrade chest spawn
            mystery: -100,       // Mystery blocks
            chainCrystal: -100,  // Chain crystals
            bouncePad: -100,     // Up charges
            depthCharge: -100,   // Depth charges
            magnetOre: -100,     // Magnet ore
            currentTile: 0       // Current tile being generated
        };
        
        // Anti-clustering windows (minimum tiles between same item type)
        const CLUSTER_WINDOWS = {
            gem: 6,            // Gems shouldn't spawn within 6 tiles of each other
            fuel: 12,          // Fuel spread out more
            chest: 20,         // Chests well spaced
            upgradeChest: 40,  // Upgrade chests very spread out
            mystery: 25,       // Mystery blocks closer (can cause chain reactions)
            chainCrystal: 8,   // Chain crystals can cluster a bit (it's fun!)
            bouncePad: 35,     // Up charges closer for chain reactions (was 50)
            depthCharge: 30,   // Depth charges closer for chain reactions (was 45)
            magnetOre: 60,     // Magnet ore more spread out
            bomb: 15           // Bombs moderately spaced (but hard blocked from adjacent)
        };
        
        // GOOD LUCK PROTECTION - Pity windows (tiles without item before chance ramps up)
        // After this many tiles without finding one, spawn chance starts increasing
        const PITY_WINDOWS = {
            chest: 150,         // Pity kicks in after ~150 tiles without a chest
            upgradeChest: 400,  // Very rare, long pity window
            mystery: 200,       // Mystery blocks have medium pity
            bouncePad: 300,     // Up charges are rare, longer pity
            depthCharge: 250,   // Medium pity window
            magnetOre: 200      // Medium pity window
            // Note: gems, fuel, chainCrystal intentionally excluded (no pity needed)
        };
        
        // Anti-clustering: REDUCES chance if item spawned recently
        // Pity system: INCREASES chance if item hasn't spawned in a long time
        function antiClusterRandom(baseChance, itemType) {
            const tilesSinceLast = spawnHistory.currentTile - spawnHistory[itemType];
            const window = CLUSTER_WINDOWS[itemType] || 10;
            
            let modifier = 1.0;
            if (tilesSinceLast < window) {
                // Reduce chance based on how recently the item spawned
                // At 0 tiles since last: 10% of normal chance (strong anti-cluster)
                // At window/2: 55% of normal chance
                // At window: 100% of normal chance (no modification)
                modifier = 0.1 + 0.9 * (tilesSinceLast / window);
            }
            
            // GOOD LUCK PROTECTION (Pity system)
            // If player hasn't seen this item in a long time, boost the chance
            const pityWindow = PITY_WINDOWS[itemType];
            if (pityWindow && tilesSinceLast > pityWindow) {
                // Ramp up chance the longer they go without finding one
                // At pity window: 100% normal
                // At 2x pity window: 200% chance
                // At 3x pity window: 300% chance (capped)
                const pityMultiplier = Math.min(1 + (tilesSinceLast - pityWindow) / pityWindow, 3);
                modifier = Math.max(modifier, pityMultiplier);
            }
            
            const result = Math.random() < (baseChance * modifier);
            
            if (result) {
                spawnHistory[itemType] = spawnHistory.currentTile;
            }
            
            return result;
        }
        
        // Record a spawn without the random check (for guaranteed/structured spawns)
        function recordSpawn(itemType) {
            if (spawnHistory.hasOwnProperty(itemType)) {
                spawnHistory[itemType] = spawnHistory.currentTile;
            }
        }
        
        // Call at start of each tile generation
        function nextTile() {
            spawnHistory.currentTile++;
        }
        
        function resetSpawnHistory() {
            spawnHistory = {
                gem: -100,
                fuel: -100,
                chest: -100,
                upgradeChest: -100,
                mystery: -100,
                chainCrystal: -100,
                bouncePad: -100,
                depthCharge: -100,
                magnetOre: -100,
                currentTile: 0
            };
        }
        
        // ==================== PARTICLES (Object Pool) ====================
        let particles = [];
        let floatingTexts = [];
        let floatingTextQueue = []; // Queue for staggered text display
        let floatingTextQueueTimer = 0; // Timer for queue processing
        let lastTextShowTime = -100; // Track when we last showed a text directly
        const FLOATING_TEXT_QUEUE_DELAY = 30; // ~0.5 seconds at 60fps
        let ambientParticles = [];
        let bgStars = [];
        
        const keys = { left: false, right: false, up: false, down: false };
        
        // ==================== CACHED GRADIENTS ====================
        let cachedScanlinePattern = null;
        let cachedVignette = null;
        let cachedVignetteState = null; // Track state to know when to recreate
        let cachedBgGradient = null;
        let cachedBgState = null;
        
        function createScanlinePattern() {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 4;
            patternCanvas.height = 6;
            const pctx = patternCanvas.getContext('2d');
            pctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            pctx.fillRect(0, 0, 4, 1);
            pctx.fillRect(0, 3, 4, 1);
            cachedScanlinePattern = ctx.createPattern(patternCanvas, 'repeat');
        }
        
        function getVignetteState() {
            // Return a key representing current vignette state
            if (drillOverheated) return 'overheat';
            const heatPercent = drillHeat / maxDrillHeat;
            if (heatPercent > 0.7) return 'warning';
            if (feverMode) return 'fever';
            return 'normal';
        }
        
        function createCachedVignette(state) {
            const vignette = ctx.createRadialGradient(
                BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.25,
                BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.85
            );
            
            if (state === 'overheat') {
                vignette.addColorStop(0, 'rgba(50, 0, 0, 0)');
                vignette.addColorStop(0.5, 'rgba(100, 0, 0, 0.12)');
                vignette.addColorStop(1, 'rgba(150, 0, 0, 0.35)');
            } else if (state === 'warning') {
                vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignette.addColorStop(0.6, 'rgba(80, 30, 0, 0.1)');
                vignette.addColorStop(1, 'rgba(120, 40, 0, 0.2)');
            } else if (state === 'fever') {
                vignette.addColorStop(0, 'rgba(50, 0, 50, 0)');
                vignette.addColorStop(0.6, 'rgba(80, 0, 80, 0.15)');
                vignette.addColorStop(1, 'rgba(100, 0, 100, 0.4)');
            } else {
                vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0.15)');
                vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            }
            
            return vignette;
        }
        
        function getBgState() {
            // Return a key for background state - only recreate on significant changes
            const depthBucket = Math.floor(depthColorShift * 10);
            return feverMode ? `fever_${depthBucket}` : `normal_${depthBucket}`;
        }
        
        function createCachedBgGradient(isFever, depthShift) {
            const bgGrad = ctx.createLinearGradient(0, 0, 0, BASE_HEIGHT);
            const hue1 = 220 - depthShift * 40;
            const hue2 = 240 - depthShift * 50;
            
            if (isFever) {
                bgGrad.addColorStop(0, 'hsl(300, 50%, 2.5%)');
                bgGrad.addColorStop(0.5, 'hsl(280, 45%, 2%)');
                bgGrad.addColorStop(1, 'hsl(260, 55%, 1.5%)');
            } else {
                bgGrad.addColorStop(0, `hsl(${hue1}, 40%, 3%)`);
                bgGrad.addColorStop(0.5, `hsl(${hue2}, 35%, 2%)`);
                bgGrad.addColorStop(1, `hsl(${hue2 - 10}, 45%, 1%)`);
            }
            
            return bgGrad;
        }
        
        // ==================== INITIALIZATION ====================
        function initBgStars() {
            bgStars = [];
            for (let i = 0; i < 40; i++) {
                bgStars.push({
                    x: Math.random() * BASE_WIDTH,
                    y: Math.random() * 2000,
                    size: 0.5 + Math.random() * 1.5,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }
        
        function initAmbientParticles() {
            ambientParticles = [];
            for (let i = 0; i < 20; i++) {
                ambientParticles.push({
                    x: Math.random() * BASE_WIDTH,
                    y: Math.random() * BASE_HEIGHT * 3,
                    size: 1 + Math.random() * 2,
                    speed: 0.15 + Math.random() * 0.4,
                    alpha: 0.1 + Math.random() * 0.2,
                    hue: Math.random() < 0.5 ? 180 : 300
                });
            }
        }
        
        // ==================== WORLD GENERATION ====================
        // Biome types for variety
        const BIOME = {
            NORMAL: 0,
            CRYSTAL_CAVE: 1,
            LAVA_ZONE: 2,
            ANCIENT_RUINS: 3,
            SOFT_EARTH: 4,
            GEM_VEIN: 5
        };
        
        // Helper function to clear blocks around a portal
        // Portal is 2x2, we clear a buffer zone around it
        function clearPortalArea(portalLocalY, portalTx) {
            // Clear just the 4 tiles for the 2x2 portal area
            for (let dy = 0; dy <= 1; dy++) {
                const clearY = portalLocalY + dy;
                if (clearY >= 0 && clearY < world.length) {
                    for (let dx = 0; dx <= 1; dx++) {
                        const clearX = portalTx + dx;
                        if (clearX >= 0 && clearX < WORLD_WIDTH) {
                            // Set portal tiles
                            if (dy === 0 && dx === 0) {
                                world[clearY][clearX] = TILE.PORTAL;
                            } else {
                                world[clearY][clearX] = TILE.PORTAL_PART;
                            }
                        }
                    }
                }
            }
        }
        
        let currentBiome = BIOME.NORMAL;
        let biomeStartY = 0;
        let biomeLength = 0;
        
        function generateWorld() {
            world = [];
            worldRowOffset = 0;
            currentBiome = BIOME.NORMAL;
            biomeStartY = 0;
            biomeLength = 50;
            
            for (let y = 0; y < 200; y++) {
                const row = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    row.push(generateTile(x, y, row));
                }
                
                // Post-process: ensure chain crystals always have at least one horizontal partner
                for (let pass = 0; pass < 2; pass++) {
                    for (let x = 1; x < WORLD_WIDTH - 1; x++) {
                        if (row[x] === TILE.CHAIN_CRYSTAL) {
                            const hasLeftPartner = x > 0 && row[x - 1] === TILE.CHAIN_CRYSTAL;
                            const hasRightPartner = x < WORLD_WIDTH - 1 && row[x + 1] === TILE.CHAIN_CRYSTAL;
                            
                            if (!hasLeftPartner && !hasRightPartner) {
                                if (x + 1 < WORLD_WIDTH - 1 && row[x + 1] !== TILE.BEDROCK && row[x + 1] !== TILE.PORTAL && row[x + 1] !== TILE.PORTAL_PART) {
                                    row[x + 1] = TILE.CHAIN_CRYSTAL;
                                } else if (x > 1 && row[x - 1] !== TILE.BEDROCK && row[x - 1] !== TILE.PORTAL && row[x - 1] !== TILE.PORTAL_PART) {
                                    row[x - 1] = TILE.CHAIN_CRYSTAL;
                                } else {
                                    row[x] = TILE.DIRT;
                                }
                            }
                        }
                    }
                }
                
                world.push(row);
                
                // Spawn portals at 50m intervals (same logic as extendWorld)
                // We check for portalRow + 1 so both rows of the 2x2 portal exist
                for (const portal of portalLocations) {
                    if (portal.spawned) continue;
                    
                    const portalRow = portal.depth + 2;
                    
                    // Spawn portal when we've generated the SECOND row (so both rows exist)
                    if (y === portalRow + 1 && y < 200) {
                        const portalTx = Math.floor(WORLD_WIDTH / 2) - 1;
                        portal.tx = portalTx;
                        portal.spawned = true;
                        
                        // Set portal tiles (2x2) - both rows now exist
                        world[portalRow][portalTx] = TILE.PORTAL;
                        world[portalRow][portalTx + 1] = TILE.PORTAL_PART;
                        world[portalRow + 1][portalTx] = TILE.PORTAL_PART;
                        world[portalRow + 1][portalTx + 1] = TILE.PORTAL_PART;
                        
                        // Clear blocks around the portal (buffer on sides and above)
                        clearPortalArea(portalRow, portalTx);
                    }
                }
                
                // Spawn gates at portal depth + 25m
                for (const gate of gateLocations) {
                    if (gate.spawned) continue;
                    
                    const gateRow = gate.depth + 2;
                    
                    if (y === gateRow) {
                        gate.spawned = true;
                        for (let x = 1; x < WORLD_WIDTH - 1; x++) {
                            world[y][x] = TILE.GATE;
                        }
                    }
                }
            }
            
            // Add bedrock foundation under gas station
            // Station is at BASE_WIDTH / 4 - TILE_SIZE, convert to tile coordinates
            const stationTileX = Math.floor((BASE_WIDTH / 4 - TILE_SIZE) / TILE_SIZE);
            for (let y = 3; y <= 4; y++) {
                for (let x = Math.max(0, stationTileX - 1); x <= Math.min(WORLD_WIDTH - 1, stationTileX + 2); x++) {
                    if (world[y] && world[y][x] !== undefined) {
                        world[y][x] = TILE.BEDROCK;
                    }
                }
            }
            
            // Add bedrock foundation under repair shop (mirrored on right side)
            // Shop is at 3 * BASE_WIDTH / 4 + TILE_SIZE, convert to tile coordinates
            const shopTileX = Math.floor((3 * BASE_WIDTH / 4 + TILE_SIZE) / TILE_SIZE);
            for (let y = 3; y <= 4; y++) {
                for (let x = Math.max(0, shopTileX - 3); x <= Math.min(WORLD_WIDTH - 1, shopTileX); x++) {
                    if (world[y] && world[y][x] !== undefined) {
                        world[y][x] = TILE.BEDROCK;
                    }
                }
            }
        }
        
        function selectNewBiome(y) {
            // Deeper = more interesting biomes
            const depthTier = Math.floor(y / 100);
            const rand = Math.random();
            
            if (depthTier === 0) {
                // Early game: mostly normal with occasional crystal caves
                if (rand < 0.15) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.25) return BIOME.SOFT_EARTH;
                return BIOME.NORMAL;
            } else if (depthTier === 1) {
                // Mid game: introduce lava and gems
                if (rand < 0.12) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.22) return BIOME.LAVA_ZONE;
                if (rand < 0.32) return BIOME.SOFT_EARTH;
                if (rand < 0.42) return BIOME.GEM_VEIN;
                return BIOME.NORMAL;
            } else {
                // Deep game: all biomes, more special ones
                if (rand < 0.10) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.22) return BIOME.LAVA_ZONE;
                if (rand < 0.32) return BIOME.ANCIENT_RUINS;
                if (rand < 0.44) return BIOME.SOFT_EARTH;
                if (rand < 0.56) return BIOME.GEM_VEIN;
                return BIOME.NORMAL;
            }
        }
        
        function generateTile(x, y, currentRow = null) {
            // Row 0-2: Air (above ground)
            if (y < 3) return TILE.AIR;
            
            // Edge walls - unbreakable bedrock on left and right columns
            if (x === 0 || x === WORLD_WIDTH - 1) {
                return TILE.BEDROCK;
            }
            
            // Track tile generation for anti-clustering
            nextTile();
            
            // Check for biome transition
            if (y >= biomeStartY + biomeLength) {
                biomeStartY = y;
                biomeLength = 15 + Math.floor(Math.random() * 25); // 15-40 rows per biome
                currentBiome = selectNewBiome(y);
            }
            
            const depthFactor = Math.min(y / 150, 1);
            const rand = Math.random();
            
            // Generate based on current biome
            switch (currentBiome) {
                case BIOME.CRYSTAL_CAVE:
                    return generateCrystalCave(x, y, rand, depthFactor);
                case BIOME.LAVA_ZONE:
                    return generateLavaZone(x, y, rand, depthFactor);
                case BIOME.ANCIENT_RUINS:
                    return generateAncientRuins(x, y, rand, depthFactor);
                case BIOME.SOFT_EARTH:
                    return generateSoftEarth(x, y, rand, depthFactor);
                case BIOME.GEM_VEIN:
                    return generateGemVein(x, y, rand, depthFactor);
                default:
                    return generateNormalTile(x, y, rand, depthFactor, currentRow);
            }
        }
        
        // Check if there's a magnet ore nearby (for spawn boosting)
        function hasMagnetNearby(x, currentRow) {
            const range = 3; // Check 3 tiles in each direction
            
            // Check current row (already generated tiles to the left)
            if (currentRow) {
                for (let dx = 1; dx <= range; dx++) {
                    if (x - dx >= 0 && currentRow[x - dx] === TILE.MAGNET_ORE) return true;
                }
            }
            
            // Check previous row
            if (world.length > 0) {
                const prevRow = world[world.length - 1];
                for (let dx = -range; dx <= range; dx++) {
                    const checkX = x + dx;
                    if (checkX >= 0 && checkX < WORLD_WIDTH && prevRow[checkX] === TILE.MAGNET_ORE) return true;
                }
            }
            
            // Check 2 rows up
            if (world.length > 1) {
                const prevRow2 = world[world.length - 2];
                for (let dx = -range; dx <= range; dx++) {
                    const checkX = x + dx;
                    if (checkX >= 0 && checkX < WORLD_WIDTH && prevRow2[checkX] === TILE.MAGNET_ORE) return true;
                }
            }
            
            return false;
        }
        
        // Check if there's a bomb directly adjacent (prevents bomb chains that are too easy)
        function hasBombAdjacent(x, currentRow) {
            // Check current row (already generated tiles to the left)
            if (currentRow) {
                if (x - 1 >= 0 && (currentRow[x - 1] === TILE.BOMB || currentRow[x - 1] === TILE.CHERRY_BOMB)) return true;
            }
            
            // Check previous row (directly above and diagonals)
            if (world.length > 0) {
                const prevRow = world[world.length - 1];
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = x + dx;
                    if (checkX >= 0 && checkX < WORLD_WIDTH && (prevRow[checkX] === TILE.BOMB || prevRow[checkX] === TILE.CHERRY_BOMB)) return true;
                }
            }
            
            return false;
        }
        
        function generateNormalTile(x, y, rand, depthFactor, currentRow) {
            // Alien gem nodes - start at 100m, quota-limited
            const depth = y - 2;
            if (depth >= 100 && canSpawnAlienNode(depth)) {
                const alienChance = 0.00004;
                if (rand < alienChance) {
                    recordAlienNodeSpawn(depth);
                    return TILE.ALIEN_NODE;
                }
            }
            
            // Check for magnet proximity boost (gems, chain crystals, bombs more likely near magnets)
            const nearMagnet = hasMagnetNearby(x, currentRow);
            const magnetBoost = nearMagnet ? 1.5 : 1.0; // 50% boost near magnets
            
            // Very rare upgrade chest - anti-clustered
            if (antiClusterRandom(0.00035 + depthFactor * 0.000175, 'upgradeChest')) {
                return TILE.UPGRADE_CHEST;
            }
            
            // Rare chests - anti-clustered
            if (antiClusterRandom(0.0056 + depthFactor * 0.0028, 'chest')) {
                return TILE.CHEST;
            }
            
            // === NEW SPECIAL BLOCKS ===
            // Mystery Block - uncommon (rainbow shimmer, random reward)
            if (antiClusterRandom(0.0016 + depthFactor * 0.0008, 'mystery')) {
                return TILE.MYSTERY_BLOCK;
            }
            
            // Chain Crystal - spawns in veins, boosted near magnets
            let chainChance = (0.002 + depthFactor * 0.001) * magnetBoost;
            
            // Check previous row for chain clustering (increases vein continuation chance)
            if (world.length > 0) {
                const prevRow = world[world.length - 1];
                // Check if above tile is a chain crystal
                if (prevRow && prevRow[x] === TILE.CHAIN_CRYSTAL) {
                    chainChance = 0.4; // 40% chance to continue a vein vertically
                }
                // Check diagonal neighbors too for more organic veins
                if (prevRow && x > 0 && prevRow[x - 1] === TILE.CHAIN_CRYSTAL) {
                    chainChance = Math.max(chainChance, 0.25);
                }
                if (prevRow && x < WORLD_WIDTH - 1 && prevRow[x + 1] === TILE.CHAIN_CRYSTAL) {
                    chainChance = Math.max(chainChance, 0.25);
                }
            }
            if (Math.random() < chainChance) {
                return TILE.CHAIN_CRYSTAL;
            }
            
            // Up Charge - rare (clears blocks above)
            if (depth >= 30 && antiClusterRandom(0.0012 + depthFactor * 0.0006, 'bouncePad')) {
                return TILE.BOUNCE_PAD;
            }
            
            // Depth Charge - rare (clears blocks below)
            if (depth >= 30 && antiClusterRandom(0.0012 + depthFactor * 0.0006, 'depthCharge')) {
                return TILE.DEPTH_CHARGE;
            }
            
            // Magnet Ore - uncommon (pulls gems)
            if (antiClusterRandom(0.0025 + depthFactor * 0.001, 'magnetOre')) {
                return TILE.MAGNET_ORE;
            }
            
            // Bombs - boosted near magnets, but never adjacent to other bombs
            // 50/50 split between big bomb (5x5) and cherry bomb (3x3)
            const bombChance = (0.01125 + depthFactor * 0.006) * magnetBoost;
            if (rand < bombChance && !hasBombAdjacent(x, currentRow) && antiClusterRandom(1.0, 'bomb')) {
                return Math.random() < 0.5 ? TILE.BOMB : TILE.CHERRY_BOMB;
            }
            if (rand < 0.04 + depthFactor * 0.03) return TILE.UNSTABLE;
            
            // Fuel canisters - anti-clustered with quota limit and spatial check
            if (canSpawnFuelCanister(depth, x, y) && antiClusterRandom(0.0042 + depthFactor * 0.00175, 'fuel')) {
                recordFuelCanisterSpawn(depth, x, y);
                return TILE.FUEL;
            }
            
            // Rock distribution
            const hardRockChance = 0.06 + depthFactor * 0.12;
            const rockChance = 0.15 + depthFactor * 0.10;
            
            if (rand < hardRockChance) return TILE.HARD_ROCK;
            if (rand < hardRockChance + rockChance) return TILE.ROCK;
            
            // Gems - anti-clustered, boosted near magnets
            if (antiClusterRandom(0.10 * magnetBoost, 'gem')) {
                return selectGemType(depthFactor);
            }
            
            if (y > 30 && rand < hardRockChance + rockChance + 0.17 + depthFactor * 0.02) {
                return Math.random() < 0.6 ? TILE.LAVA : TILE.GAS;
            }
            
            return TILE.DIRT;
        }
        
        // Simple gem type selection based on depth
        function selectGemType(depthFactor) {
            const epicChance = 0.1 + depthFactor * 0.15;
            const rareChance = 0.25 + depthFactor * 0.1;
            
            const roll = Math.random();
            if (roll < epicChance) return TILE.GEM_EPIC;
            if (roll < epicChance + rareChance) return TILE.GEM_RARE;
            return TILE.GEM_COMMON;
        }
        
        function generateCrystalCave(x, y, rand, depthFactor) {
            const depth = y - 2;
            if (depth >= 100 && canSpawnAlienNode(depth)) {
                if (rand < 0.00006) {
                    recordAlienNodeSpawn(depth);
                    return TILE.ALIEN_NODE;
                }
            }
            
            if (antiClusterRandom(0.00049, 'upgradeChest')) return TILE.UPGRADE_CHEST;
            if (antiClusterRandom(0.014, 'chest')) return TILE.CHEST;
            if (rand < 0.029 && !hasBombAdjacent(x, null) && antiClusterRandom(1.0, 'bomb')) return Math.random() < 0.5 ? TILE.BOMB : TILE.CHERRY_BOMB;
            if (canSpawnFuelCanister(depth, x, y) && antiClusterRandom(0.00245, 'fuel')) {
                recordFuelCanisterSpawn(depth, x, y);
                return TILE.FUEL;
            }
            if (rand < 0.18) return TILE.AIR;
            if (antiClusterRandom(0.238, 'gem')) return selectGemType(depthFactor + 0.1);
            if (rand < 0.60 + depthFactor * 0.08) return TILE.ROCK;
            if (rand < 0.68 + depthFactor * 0.06) return TILE.HARD_ROCK;
            return TILE.DIRT;
        }
        
        function generateLavaZone(x, y, rand, depthFactor) {
            const depth = y - 2;
            if (depth >= 100 && canSpawnAlienNode(depth)) {
                if (rand < 0.00004) {
                    recordAlienNodeSpawn(depth);
                    return TILE.ALIEN_NODE;
                }
            }
            
            if (antiClusterRandom(0.0007, 'upgradeChest')) return TILE.UPGRADE_CHEST;
            if (antiClusterRandom(0.0098, 'chest')) return TILE.CHEST;
            if (rand < 0.03 && !hasBombAdjacent(x, null) && antiClusterRandom(1.0, 'bomb')) return Math.random() < 0.5 ? TILE.BOMB : TILE.CHERRY_BOMB;
            if (canSpawnFuelCanister(depth, x, y) && antiClusterRandom(0.0035, 'fuel')) {
                recordFuelCanisterSpawn(depth, x, y);
                return TILE.FUEL;
            }
            if (rand < 0.11) return TILE.UNSTABLE;
            if (rand < 0.31) return TILE.LAVA;
            if (rand < 0.37) return TILE.GAS;
            if (antiClusterRandom(0.126, 'gem')) {
                const roll = Math.random();
                if (roll < 0.35) return TILE.GEM_EPIC;
                if (roll < 0.65) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.75 + depthFactor * 0.05) return TILE.HARD_ROCK;
            return TILE.ROCK;
        }
        
        function generateAncientRuins(x, y, rand, depthFactor) {
            const patternX = x % 5;
            const patternY = (y - biomeStartY) % 5;
            
            // Room structure
            if (patternX === 0 || patternX === 4) return TILE.HARD_ROCK;
            if (patternY === 0 && patternX > 0 && patternX < 4) return TILE.HARD_ROCK;
            if (patternY === 4 && patternX === 2) return TILE.AIR;
            
            // Inside rooms
            if (patternX >= 1 && patternX <= 3 && patternY >= 1 && patternY <= 3) {
                if (patternX === 2 && patternY === 2) {
                    // Center treasure - guaranteed spawn
                    if (Math.random() < 0.35) {
                        recordSpawn('chest');
                        return TILE.CHEST;
                    }
                    recordSpawn('gem');
                    return TILE.GEM_EPIC;
                }
                if (rand < 0.25) return TILE.AIR;
                if (antiClusterRandom(0.14, 'gem')) {
                    return Math.random() < 0.4 ? TILE.GEM_RARE : TILE.GEM_COMMON;
                }
                if (rand < 0.435 && !hasBombAdjacent(x, null) && antiClusterRandom(1.0, 'bomb')) return Math.random() < 0.5 ? TILE.BOMB : TILE.CHERRY_BOMB;
                return TILE.AIR;
            }
            
            if (rand < 0.08) return TILE.UNSTABLE;
            return rand < 0.35 ? TILE.ROCK : TILE.DIRT;
        }
        
        function generateSoftEarth(x, y, rand, depthFactor) {
            const depth = y - 2;
            if (depth >= 100 && canSpawnAlienNode(depth)) {
                if (rand < 0.00003) {
                    recordAlienNodeSpawn(depth);
                    return TILE.ALIEN_NODE;
                }
            }
            
            if (antiClusterRandom(0.0105, 'chest')) return TILE.CHEST;
            if (rand < 0.0225 && !hasBombAdjacent(x, null) && antiClusterRandom(1.0, 'bomb')) return Math.random() < 0.5 ? TILE.BOMB : TILE.CHERRY_BOMB;
            if (canSpawnFuelCanister(depth, x, y) && antiClusterRandom(0.00245, 'fuel')) {
                recordFuelCanisterSpawn(depth, x, y);
                return TILE.FUEL;
            }
            if (rand < 0.20) return TILE.AIR;
            if (antiClusterRandom(0.14, 'gem')) {
                return Math.random() < 0.15 ? TILE.GEM_RARE : TILE.GEM_COMMON;
            }
            if (rand < 0.50) return TILE.ROCK;
            return TILE.DIRT;
        }
        
        function generateGemVein(x, y, rand, depthFactor) {
            const depth = y - 2;
            if (depth >= 100 && canSpawnAlienNode(depth)) {
                if (rand < 0.00008) {
                    recordAlienNodeSpawn(depth);
                    return TILE.ALIEN_NODE;
                }
            }
            
            if (antiClusterRandom(0.0175, 'chest')) return TILE.CHEST;
            if (rand < 0.0375 && !hasBombAdjacent(x, null) && antiClusterRandom(1.0, 'bomb')) return Math.random() < 0.5 ? TILE.BOMB : TILE.CHERRY_BOMB;
            if (canSpawnFuelCanister(depth, x, y) && antiClusterRandom(0.00175, 'fuel')) {
                recordFuelCanisterSpawn(depth, x, y);
                return TILE.FUEL;
            }
            if (antiClusterRandom(0.3234, 'gem')) return selectGemType(depthFactor + 0.15);
            if (rand < 0.52) return TILE.ROCK;
            if (rand < 0.65) return TILE.HARD_ROCK;
            if (rand < 0.69) return TILE.UNSTABLE;
            return TILE.DIRT;
        }
        
        function extendWorld() {
            const neededRows = Math.floor(cameraY / TILE_SIZE) + WORLD_BUFFER_ROWS - worldRowOffset;
            while (world.length < neededRows) {
                const y = world.length + worldRowOffset;
                const row = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    row.push(generateTile(x, y, row));
                }
                
                // Post-process: ensure chain crystals always have at least one horizontal partner (same row)
                // This guarantees groups of 2+ that are visible together
                // Run twice to handle edge cases where a newly-added crystal still needs a partner
                for (let pass = 0; pass < 2; pass++) {
                    for (let x = 1; x < WORLD_WIDTH - 1; x++) {
                        if (row[x] === TILE.CHAIN_CRYSTAL) {
                            // Check if this crystal has any horizontal partner (same row only)
                            const hasLeftPartner = x > 0 && row[x - 1] === TILE.CHAIN_CRYSTAL;
                            const hasRightPartner = x < WORLD_WIDTH - 1 && row[x + 1] === TILE.CHAIN_CRYSTAL;
                            
                            if (!hasLeftPartner && !hasRightPartner) {
                                // No horizontal partner - add one to the right if possible
                                if (x + 1 < WORLD_WIDTH - 1 && row[x + 1] !== TILE.BEDROCK && row[x + 1] !== TILE.PORTAL && row[x + 1] !== TILE.PORTAL_PART) {
                                    row[x + 1] = TILE.CHAIN_CRYSTAL;
                                } else if (x > 1 && row[x - 1] !== TILE.BEDROCK && row[x - 1] !== TILE.PORTAL && row[x - 1] !== TILE.PORTAL_PART) {
                                    // Can't go right, add to the left
                                    row[x - 1] = TILE.CHAIN_CRYSTAL;
                                } else {
                                    // Can't add partner, remove solo crystal
                                    row[x] = TILE.DIRT;
                                }
                            }
                        }
                    }
                }
                
                world.push(row);
                
                const localY = world.length - 1;
                
                // Spawn portals at 50m intervals
                // Depth formula: depth = floor((playerY - 60) / TILE_SIZE)
                // For depth D: row = floor((60 + D*TILE_SIZE) / TILE_SIZE) = D + 2
                // We check for portalRow + 1 so both rows of the 2x2 portal exist
                for (const portal of portalLocations) {
                    if (portal.spawned) continue;
                    
                    const portalRow = portal.depth + 2;
                    
                    // Spawn portal when we've generated the SECOND row (so both rows exist)
                    if (y === portalRow + 1) {
                        const portalTx = Math.floor(WORLD_WIDTH / 2) - 1;
                        portal.tx = portalTx;
                        portal.spawned = true;
                        
                        // Get local row indices
                        const topLocalY = portalRow - worldRowOffset;
                        const bottomLocalY = topLocalY + 1;
                        
                        // Set portal tiles (2x2) - both rows now exist
                        if (topLocalY >= 0 && bottomLocalY < world.length) {
                            world[topLocalY][portalTx] = TILE.PORTAL;
                            world[topLocalY][portalTx + 1] = TILE.PORTAL_PART;
                            world[bottomLocalY][portalTx] = TILE.PORTAL_PART;
                            world[bottomLocalY][portalTx + 1] = TILE.PORTAL_PART;
                            
                            // Clear blocks around the portal
                            clearPortalArea(topLocalY, portalTx);
                        }
                    }
                }
                
                // Spawn gates at portal depth + 25m
                for (const gate of gateLocations) {
                    if (gate.spawned) continue;
                    
                    const gateRow = gate.depth + 2;
                    
                    if (y === gateRow) {
                        // Full width gate barrier (except edge bedrock)
                        gate.spawned = true;
                        for (let x = 1; x < WORLD_WIDTH - 1; x++) {
                            world[localY][x] = TILE.GATE;
                        }
                    }
                }
                
                // Try to spawn enemies on surfaces (not inside blocks)
                const depthM = Math.max(0, y - 2); // Depth in tiles/meters
                const spawnChances = getEnemySpawnChance(depthM, currentBiome);
                
                // Spawn beetles (early game)
                if (Math.random() < spawnChances.beetle * WORLD_WIDTH * 0.3) {
                    const spawnPos = findSurfaceSpawnPosition(Math.floor(WORLD_WIDTH / 2), localY, 8);
                    if (spawnPos) {
                        spawnEnemy(ENEMY_TYPE.BEETLE, spawnPos.tx, spawnPos.ty);
                        if (!firstEnemySpawned) firstEnemySpawned = true;
                        else if (!secondEnemySpawned) secondEnemySpawned = true;
                    }
                }
                
                // Spawn worms (deeper game - faster, green variant)
                if (Math.random() < spawnChances.worm * WORLD_WIDTH * 0.3) {
                    const spawnPos = findSurfaceSpawnPosition(Math.floor(WORLD_WIDTH / 2), localY, 8);
                    if (spawnPos) {
                        spawnEnemy(ENEMY_TYPE.WORM, spawnPos.tx, spawnPos.ty);
                        if (!firstEnemySpawned) firstEnemySpawned = true;
                        else if (!secondEnemySpawned) secondEnemySpawned = true;
                    }
                }
                
                // Lava slugs spawn on lava surfaces
                if (Math.random() < spawnChances.lava_slug * WORLD_WIDTH * 0.3) {
                    const spawnPos = findLavaSurfaceSpawnPosition(Math.floor(WORLD_WIDTH / 2), localY, 8);
                    if (spawnPos) {
                        spawnEnemy(ENEMY_TYPE.LAVA_SLUG, spawnPos.tx, spawnPos.ty);
                        if (!firstEnemySpawned) firstEnemySpawned = true;
                        else if (!secondEnemySpawned) secondEnemySpawned = true;
                    }
                }
            }
            
            // MEMORY OPTIMIZATION: Trim old rows that are far above camera
            const trimThreshold = Math.floor(cameraY / TILE_SIZE) - WORLD_TRIM_THRESHOLD;
            if (trimThreshold > worldRowOffset + 50) {
                const rowsToTrim = trimThreshold - worldRowOffset - 20;
                if (rowsToTrim > 0) {
                    world.splice(0, rowsToTrim);
                    worldRowOffset += rowsToTrim;
                    
                    // Remove enemies that are now above the world
                    enemies = enemies.filter(e => e.ty >= worldRowOffset);
                }
            }
        }
        
        function getWorldRow(absoluteY) {
            return absoluteY - worldRowOffset;
        }
        
        function getTile(worldX, worldY) {
            const tx = Math.floor(worldX / TILE_SIZE);
            const ty = getWorldRow(Math.floor(worldY / TILE_SIZE));
            if (tx < 0 || tx >= WORLD_WIDTH || ty < 0 || ty >= world.length) return TILE.ROCK;
            return world[ty][tx];
        }
        
        function setTile(tx, absoluteTy, value) {
            const ty = getWorldRow(absoluteTy);
            if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < world.length) {
                world[ty][tx] = value;
            }
        }
        
        // Check if a tile can be passed through (walked on)
        function isTilePassable(tile) {
            return tile === TILE.AIR || tile === TILE.PORTAL || tile === TILE.PORTAL_PART;
        }
        
        function checkCollision(x, y, width, height) {
            const points = [
                [x + 3, y + 1],              // Top left (tighter margin)
                [x + width - 3, y + 1],      // Top right (tighter margin)
                [x + width / 2, y + 1],      // Top center (new)
                [x + 3, y + height - 3],
                [x + width - 3, y + height - 3],
                [x + width / 2, y + height - 3]
            ];
            for (const [px, py] of points) {
                if (!isTilePassable(getTile(px, py))) return true;
            }
            return false;
        }
        
        // Check horizontal collision with multiple points
        function checkHorizontalCollision(x, y, width, height, direction) {
            const checkX = direction > 0 ? x + width - 2 : x + 2;
            const points = [
                [checkX, y + 4],           // Top
                [checkX, y + height / 2],   // Middle
                [checkX, y + height - 4]    // Bottom
            ];
            for (const [px, py] of points) {
                if (!isTilePassable(getTile(px, py))) return true;
            }
            return false;
        }
        
        // Push player out of walls if stuck
        function unstuckPlayer() {
            const margin = 2;
            let stuck = true;
            let attempts = 0;
            
            while (stuck && attempts < 10) {
                stuck = false;
                attempts++;
                
                // Check each corner and determine best push direction
                const topLeft = !isTilePassable(getTile(player.x + margin, player.y + margin));
                const topRight = !isTilePassable(getTile(player.x + player.width - margin, player.y + margin));
                const bottomLeft = !isTilePassable(getTile(player.x + margin, player.y + player.height - margin));
                const bottomRight = !isTilePassable(getTile(player.x + player.width - margin, player.y + player.height - margin));
                
                if (topLeft || topRight || bottomLeft || bottomRight) {
                    stuck = true;
                    
                    // Determine best push direction based on which corners are stuck
                    const stuckTop = topLeft || topRight;
                    const stuckBottom = bottomLeft || bottomRight;
                    const stuckLeft = topLeft || bottomLeft;
                    const stuckRight = topRight || bottomRight;
                    
                    // Priority: push up if bottom is stuck, push sideways if only one side stuck
                    if (stuckBottom && !stuckTop) {
                        // Most common case: landed on ground, push up
                        player.y -= 1;
                    } else if (stuckTop && !stuckBottom) {
                        // Hit ceiling, push down
                        player.y += 1;
                    } else if (stuckLeft && !stuckRight) {
                        // Hit left wall, push right
                        player.x += 1;
                    } else if (stuckRight && !stuckLeft) {
                        // Hit right wall, push left
                        player.x -= 1;
                    } else {
                        // Multiple sides stuck - default to pushing up (falling into ground is most common)
                        player.y -= 1;
                    }
                }
            }
        }
        
        // Periodic sanity check to clear stuck/orphaned states
        let sanityCheckTimer = 0;
        function sanityCheck() {
            sanityCheckTimer++;
            if (sanityCheckTimer < 30) return; // Run every ~0.5 seconds
            sanityCheckTimer = 0;
            
            // If digging but no valid target, reset dig state
            if (player.digging && !player.digTarget) {
                player.digging = false;
                player.digProgress = 0;
            }
            
            // If digging but target tile is already AIR, reset
            if (player.digging && player.digTarget) {
                const ty = getWorldRow(player.digTarget.y);
                if (ty >= 0 && ty < world.length) {
                    const tile = world[ty][player.digTarget.x];
                    if (tile === TILE.AIR) {
                        player.digging = false;
                        player.digTarget = null;
                        player.digProgress = 0;
                    }
                }
            }
            
            // If player is not pressing any movement key and not digging, 
            // ensure they're not stuck in weird states
            if (!keys.up && !keys.down && !keys.left && !keys.right && !player.digging) {
                // Reset hover drill timers if not actively trying to move
                hoverUpDrillTimer = 0;
                blockedTimer = 0;
            }
        }
        
        // ==================== DIGGING ====================
        function dig(tx, absoluteTy) {
            // Don't dig in sky rows (0-2 are air above ground)
            if (absoluteTy < FIRST_DIGGABLE_ROW) return;
            
            const ty = getWorldRow(absoluteTy);
            if (ty < 0 || ty >= world.length || tx < 0 || tx >= WORLD_WIDTH) return;
            
            const tile = world[ty][tx];
            if (tile === TILE.AIR) return;
            if (tile === TILE.BEDROCK) return; // Can't dig bedrock
            if (drillOverheated) return; // Can't dig when overheated
            
            // Portal tiles are entered by collision, not digging
            if (tile === TILE.PORTAL || tile === TILE.PORTAL_PART) {
                return; // Can't dig portals - walk into them instead
            }
            
            // Handle gate blocking
            if (tile === TILE.GATE) {
                // Find which gate this is
                const gateRow = absoluteTy;
                const gate = gateLocations.find(g => g.depth + 2 === gateRow);
                
                if (gate && !hasKeyForGate(gate.depth)) {
                    // Blocked! Need boss key
                    triggerScreenFlash('#ff0000', 0.2, 10);
                    screenShake = 5;
                    createFloatingText(' LOCKED!', tx * TILE_SIZE + TILE_SIZE/2, absoluteTy * TILE_SIZE - 10, '#ff6666');
                    createFloatingText(`Defeat boss at ${gate.forBossDepth}m`, tx * TILE_SIZE + TILE_SIZE/2, absoluteTy * TILE_SIZE + 15, '#ffaa00');
                    return;
                } else {
                    // Has key - trigger unlock animation and clear the gate row
                    triggerGateUnlockAnimation(tx, absoluteTy, gate.forBossDepth);
                    
                    // Clear gate row (preserve edge bedrock)
                    for (let gx = 1; gx < WORLD_WIDTH - 1; gx++) {
                        world[ty][gx] = TILE.AIR;
                    }
                    return;
                }
            }
            
            // Speed multipliers (includes shop bonus)
            const shopDigBonus = 1 + getShopBonus('digSpeed') / 100;
            const speedMultiplier = 1 + getEffectiveUpgrade('digSpeed', 300) / 100;
            const feverBonus = feverMode ? 1.5 : 1;
            const totalSpeed = speedMultiplier * feverBonus * shopDigBonus * 1.15; // 10% faster again
            
            let digTime = 0.66 / totalSpeed; // Base dig time (10% faster)
            
            if (tile === TILE.ROCK) digTime = 1.04 / totalSpeed;
            if (tile === TILE.HARD_ROCK) {
                const drillChance = getEffectiveUpgrade('drillPower', 90);
                digTime = Math.random() * 100 < drillChance ? 0.09 : 0.64 / totalSpeed;
            }
            if (tile === TILE.UNSTABLE) {
                digTime = 0.45 / totalSpeed;
                // Start collapse timer if not already started
                const existing = unstableTiles.find(u => u.tx === tx && u.absoluteTy === absoluteTy);
                if (!existing) {
                    startUnstableTimer(tx, absoluteTy);
                }
            }
            if (tile === TILE.BOMB) digTime = 0.11 / totalSpeed;
            if (tile === TILE.CHERRY_BOMB) digTime = 0.09 / totalSpeed; // Slightly faster than big bomb
            if (tile === TILE.CHEST) digTime = 0.26 / totalSpeed;
            if (tile === TILE.UPGRADE_CHEST) digTime = 0.38 / totalSpeed;
            if (tile === TILE.ALIEN_NODE) digTime = 0.45 / totalSpeed;
            
            // New special blocks
            if (tile === TILE.CHAIN_CRYSTAL) digTime = 0.23 / totalSpeed;
            if (tile === TILE.BOUNCE_PAD) digTime = 0.14 / totalSpeed;
            if (tile === TILE.MYSTERY_BLOCK) digTime = 0.36 / totalSpeed;
            if (tile === TILE.DEPTH_CHARGE) digTime = 0.32 / totalSpeed;
            if (tile === TILE.MAGNET_ORE) digTime = 0.27 / totalSpeed;
            
            player.digging = true;
            player.digTarget = { x: tx, y: absoluteTy, time: digTime };
            player.digProgress = 0;
        }
        
        // Track last dig direction for continuous digging
        let lastDigDirection = null; // 'down', 'up', 'left', 'right'
        
        // ==================== COMBO & EFFECTS FUNCTIONS ====================
        function addCombo() {
            comboCount++;
            comboTimer = getComboDecayTime();
            
            // Check for fever mode activation
            if (comboCount >= FEVER_COMBO_THRESHOLD && !feverMode) {
                activateFeverMode();
            }
        }
        
        function getComboMultiplier() {
            if (comboCount < 2) return 1;
            if (comboCount < 5) return 2;
            if (comboCount < 10) return 3;
            if (comboCount < 20) return 4;
            return 5;
        }
        
        function activateFeverMode() {
            feverMode = true;
            feverTimer = getFeverDuration();
            triggerScreenFlash('#ff00ff', 0.4, 20);
            screenShake = 10;
            createFloatingText(' FEVER MODE! ', player.x + player.width/2, player.y - 30, '#ff00ff');
        }
        
        function triggerScreenFlash(color, alpha, duration) {
            screenFlash = { active: true, color: color, alpha: alpha, duration: duration };
        }
        
        function triggerGateUnlockAnimation(tx, absoluteTy, bossDepth) {
            // Epic unlock animation
            const centerX = BASE_WIDTH / 2;
            const worldY = absoluteTy * TILE_SIZE + TILE_SIZE / 2;
            
            // Screen effects
            screenShake = 15;
            triggerScreenFlash('#00ffcc', 0.6, 40);
            
            // Create sweeping energy wave across the entire row
            for (let x = 0; x < WORLD_WIDTH; x++) {
                const delay = Math.abs(x - Math.floor(WORLD_WIDTH / 2)) * 2;
                setTimeout(() => {
                    const px = x * TILE_SIZE + TILE_SIZE / 2;
                    
                    // Explosion particles at each tile
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8;
                        particles.push({
                            x: px,
                            y: worldY,
                            vx: Math.cos(angle) * (4 + Math.random() * 3),
                            vy: Math.sin(angle) * (4 + Math.random() * 3),
                            size: 3 + Math.random() * 4,
                            color: ['#00ffcc', '#00ff88', '#00aaff', '#88ffff'][Math.floor(Math.random() * 4)],
                            life: 1.2,
                            type: 'gem'
                        });
                    }
                }, delay * 16);
            }
            
            // Central key activation effect
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const dist = 20 + Math.random() * 40;
                particles.push({
                    x: tx * TILE_SIZE + TILE_SIZE / 2,
                    y: worldY,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6 - 2,
                    size: 4 + Math.random() * 6,
                    color: '#00ffcc',
                    life: 1.5,
                    type: 'explosion'
                });
            }
            
            // Rising energy pillars
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const pillarX = (WORLD_WIDTH / 6 + i * WORLD_WIDTH / 4) * TILE_SIZE;
                    for (let j = 0; j < 15; j++) {
                        particles.push({
                            x: pillarX + (Math.random() - 0.5) * 20,
                            y: worldY + 30,
                            vx: (Math.random() - 0.5) * 2,
                            vy: -8 - Math.random() * 6,
                            size: 3 + Math.random() * 5,
                            color: ['#00ffaa', '#00ddff', '#66ffcc'][Math.floor(Math.random() * 3)],
                            life: 1.5,
                            type: 'gem'
                        });
                    }
                }, i * 80);
            }
            
            // Floating text
            createFloatingText(' GATE UNLOCKED!', centerX, worldY - 30, '#00ffcc');
            createFloatingText(`Key from ${bossDepth}m boss used`, centerX, worldY - 10, '#88ffff');
        }
        
        function createSpeedLine() {
            if (speedLines.length < 20) {
                speedLines.push({
                    x: Math.random() * BASE_WIDTH,
                    y: -20,
                    length: 30 + Math.random() * 50,
                    speed: 15 + Math.random() * 10,
                    alpha: 0.3 + Math.random() * 0.4
                });
            }
        }
        
        function explodeBomb(centerTX, centerAbsTY) {
            // 5x5 explosion (big bomb)
            let totalGemValue = 0;
            let fuelCollected = 0;
            let gemsCollected = 0;
            
            // Collect triggerable tiles first (to trigger after clearing)
            const triggerables = [];
            
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const tx = centerTX + dx;
                    const absoluteTy = centerAbsTY + dy;
                    const ty = getWorldRow(absoluteTy);
                    
                    if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < world.length) {
                        const tile = world[ty][tx];
                        
                        // Don't destroy hard rock or bedrock with bombs
                        if (tile !== TILE.AIR && tile !== TILE.HARD_ROCK && tile !== TILE.BEDROCK && 
                            tile !== TILE.PORTAL && tile !== TILE.PORTAL_PART && tile !== TILE.GATE) {
                            
                            const tileCenterX = tx * TILE_SIZE + TILE_SIZE/2;
                            const tileCenterY = absoluteTy * TILE_SIZE + TILE_SIZE/2;
                            
                            // Collect gems
                            if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                                let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                                let value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                                if (feverMode) value = Math.floor(value * 1.5);
                                totalGemValue += value;
                                gemsCollected++;
                                addCombo();
                                
                                const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                                createGemParticles(tileCenterX, tileCenterY, color);
                            }
                            
                            // Collect fuel
                            if (tile === TILE.FUEL) {
                                const fuelGain = feverMode ? 35 : 25;
                                fuelCollected += fuelGain;
                                createParticles(tileCenterX, tileCenterY, '#ff9500', 6);
                            }
                            
                            // Open chests automatically
                            if (tile === TILE.CHEST) {
                                const baseValue = 150 + Math.floor(Math.random() * 100);
                                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                                const value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                                totalGemValue += value;
                                addCombo();
                                
                                // Chest particles
                                for (let i = 0; i < 15; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 3 + Math.random() * 4;
                                    particles.push({
                                        x: tileCenterX, y: tileCenterY,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed - 2,
                                        size: 3 + Math.random() * 4,
                                        color: ['#ffd700', '#ff9500', '#00f0ff'][Math.floor(Math.random() * 3)],
                                        life: 1, type: 'gem'
                                    });
                                }
                            }
                            
                            // Upgrade chests give random upgrade
                            if (tile === TILE.UPGRADE_CHEST) {
                                // Grant a random upgrade bonus
                                const upgradeTypes = ['digSpeed', 'fuelCapacity', 'hullStrength', 'gemValue'];
                                const randomType = upgradeTypes[Math.floor(Math.random() * upgradeTypes.length)];
                                const bonus = 10 + Math.floor(Math.random() * 15);
                                permanentUpgrades[randomType] += bonus;
                                
                                createFloatingText(` +${bonus}% ${randomType}!`, tileCenterX, absoluteTy * TILE_SIZE - 10, '#00ff88');
                                
                                // Special particles
                                for (let i = 0; i < 20; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 4 + Math.random() * 5;
                                    particles.push({
                                        x: tileCenterX, y: tileCenterY,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed - 3,
                                        size: 4 + Math.random() * 5,
                                        color: ['#00ff88', '#00ffff', '#88ff00'][Math.floor(Math.random() * 3)],
                                        life: 1.2, type: 'gem'
                                    });
                                }
                            }
                            
                            // Unstable rock bonus
                            if (tile === TILE.UNSTABLE) {
                                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                                const bonus = Math.floor(15 * (1 + totalGemBonus / 100) * getComboMultiplier());
                                totalGemValue += bonus;
                                addCombo();
                            }
                            
                            // Collect triggerable items (will trigger AFTER clearing)
                            if (tile === TILE.BOMB || tile === TILE.CHERRY_BOMB || tile === TILE.CHAIN_CRYSTAL || 
                                tile === TILE.DEPTH_CHARGE || tile === TILE.BOUNCE_PAD ||
                                tile === TILE.MAGNET_ORE || tile === TILE.MYSTERY_BLOCK ||
                                tile === TILE.ALIEN_NODE) {
                                // Skip the center bomb (already being processed)
                                if (!(dx === 0 && dy === 0 && tile === TILE.BOMB)) {
                                    triggerables.push({ tile, tx, absoluteTy, tileCenterX, tileCenterY });
                                }
                            }
                            
                            world[ty][tx] = TILE.AIR;
                            createParticles(tileCenterX, tileCenterY, '#ff6600', 4);
                        }
                    }
                }
            }
            
            // Apply collected rewards
            if (totalGemValue > 0) {
                score += totalGemValue;
                const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
                const cy = centerAbsTY * TILE_SIZE;
                createFloatingText(` +${totalGemValue}!`, cx, cy - 20, '#ffd700');
            }
            
            if (fuelCollected > 0) {
                fuel = Math.min(fuel + fuelCollected, maxFuel);
                const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
                const cy = centerAbsTY * TILE_SIZE;
                createFloatingText(` +${fuelCollected}`, cx, cy - 40, '#ff9500');
            }
            
            // Big explosion effects (larger for 5x5)
            const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
            const cy = centerAbsTY * TILE_SIZE + TILE_SIZE/2;
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                particles.push({
                    x: cx, y: cy,
                    vx: Math.cos(angle) * (6 + Math.random() * 7),
                    vy: Math.sin(angle) * (6 + Math.random() * 7),
                    size: 5 + Math.random() * 7,
                    color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00',
                    life: 1.2,
                    type: 'explosion'
                });
            }
            
            triggerScreenFlash('#ff6600', 0.6, 18);
            screenShake = 15;
            updateScoreDisplay();
            updateFuelBar();
            
            // Now trigger all collected special items
            for (const item of triggerables) {
                if (item.tile === TILE.BOMB) {
                    // Chain bomb explosion (big)
                    explodeBomb(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.CHERRY_BOMB) {
                    // Chain cherry bomb explosion (small)
                    explodeCherryBomb(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.CHAIN_CRYSTAL) {
                    // Trigger chain crystal reaction
                    triggerChainCrystalExplosion(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.DEPTH_CHARGE) {
                    // Trigger depth charge
                    triggerDepthCharge(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.BOUNCE_PAD) {
                    // Trigger up charge
                    triggerUpCharge(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.MAGNET_ORE) {
                    // Trigger magnet pull
                    triggerMagnetPull(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.ALIEN_NODE) {
                    // Trigger alien node (multi-gem burst)
                    const nodeDepth = item.absoluteTy - 2;
                    const baseGems = 4;
                    const bonusGems = Math.min(Math.floor((nodeDepth - 100) / 100), 4);
                    const gemCount = baseGems + bonusGems;
                    const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                    const comboMult = getComboMultiplier();
                    const feverMult = feverMode ? 2 : 1;
                    let nodeValue = 0;
                    for (let i = 0; i < gemCount; i++) {
                        const gemType = Math.random();
                        let gemValue, gemColor;
                        if (gemType < 0.25) { gemValue = 75; gemColor = '#ff9500'; }
                        else if (gemType < 0.6) { gemValue = 38; gemColor = '#ff00ff'; }
                        else { gemValue = 15; gemColor = '#00f0ff'; }
                        gemValue = Math.floor(gemValue * (1 + totalGemBonus / 100) * comboMult * feverMult);
                        nodeValue += gemValue;
                        const angle = (i / gemCount) * Math.PI * 2;
                        createParticles(item.tileCenterX + Math.cos(angle) * 8, item.tileCenterY + Math.sin(angle) * 8, gemColor, 5);
                    }
                    score += nodeValue;
                    createFloatingText(` ALIEN NODE +${nodeValue}! `, item.tileCenterX, item.absoluteTy * TILE_SIZE - 10, '#cc88ff');
                    updateScoreDisplay();
                } else if (item.tile === TILE.MYSTERY_BLOCK) {
                    // Trigger mystery block (inline handling)
                    const roll = Math.random();
                    if (roll < 0.40) {
                        // Random gem
                        const gemRoll = Math.random();
                        let gemValue, gemColor;
                        if (gemRoll < 0.1) { gemValue = 50; gemColor = '#ff9500'; }
                        else if (gemRoll < 0.4) { gemValue = 25; gemColor = '#ff00ff'; }
                        else { gemValue = 10; gemColor = '#00f0ff'; }
                        const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                        gemValue = Math.floor(gemValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                        if (feverMode) gemValue = Math.floor(gemValue * 1.5);
                        score += gemValue;
                        createFloatingText(`+${gemValue}`, item.tileCenterX, item.absoluteTy * TILE_SIZE - 10, gemColor);
                        createGemParticles(item.tileCenterX, item.absoluteTy * TILE_SIZE + TILE_SIZE/2, gemColor);
                        addCombo();
                    } else if (roll < 0.50) {
                        // Fuel
                        const fuelGain = 7 + Math.floor(Math.random() * 5);
                        fuel = Math.min(fuel + fuelGain, maxFuel);
                        createFloatingText(`+${fuelGain}`, item.tileCenterX, item.absoluteTy * TILE_SIZE - 10, '#ff9500');
                    } else if (roll < 0.60) {
                        // Magnet
                        triggerMagnetPull(item.tx, item.absoluteTy);
                    } else if (roll < 0.70) {
                        // Up Charge
                        triggerUpCharge(item.tx, item.absoluteTy);
                    } else if (roll < 0.80) {
                        // Depth Charge
                        triggerDepthCharge(item.tx, item.absoluteTy);
                    } else if (roll < 0.92) {
                        // Bomb (50/50 big or cherry)
                        if (Math.random() < 0.5) {
                            explodeBomb(item.tx, item.absoluteTy);
                        } else {
                            explodeCherryBomb(item.tx, item.absoluteTy);
                        }
                    } else {
                        // Jackpot
                        const jackpotValue = 100 + Math.floor(Math.random() * 50);
                        score += jackpotValue;
                        createFloatingText(`JACKPOT! +${jackpotValue}`, item.tileCenterX, item.absoluteTy * TILE_SIZE - 10, '#ffff00');
                        for (let i = 0; i < 5; i++) addCombo();
                    }
                    updateScoreDisplay();
                    updateFuelBar();
                }
            }
        }
        
        // Cherry Bomb - smaller 3x3 explosion (red)
        function explodeCherryBomb(centerTX, centerAbsTY) {
            // 3x3 explosion (cherry bomb)
            let totalGemValue = 0;
            let fuelCollected = 0;
            
            // Collect triggerable tiles first (to trigger after clearing)
            const triggerables = [];
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const tx = centerTX + dx;
                    const absoluteTy = centerAbsTY + dy;
                    const ty = getWorldRow(absoluteTy);
                    
                    if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < world.length) {
                        const tile = world[ty][tx];
                        
                        // Don't destroy hard rock or bedrock with bombs
                        if (tile !== TILE.AIR && tile !== TILE.HARD_ROCK && tile !== TILE.BEDROCK && 
                            tile !== TILE.PORTAL && tile !== TILE.PORTAL_PART && tile !== TILE.GATE) {
                            
                            const tileCenterX = tx * TILE_SIZE + TILE_SIZE/2;
                            const tileCenterY = absoluteTy * TILE_SIZE + TILE_SIZE/2;
                            
                            // Collect gems
                            if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                                let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                                let value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                                if (feverMode) value = Math.floor(value * 1.5);
                                totalGemValue += value;
                                addCombo();
                                
                                const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                                createGemParticles(tileCenterX, tileCenterY, color);
                            }
                            
                            // Collect fuel
                            if (tile === TILE.FUEL) {
                                const fuelGain = feverMode ? 35 : 25;
                                fuelCollected += fuelGain;
                                createParticles(tileCenterX, tileCenterY, '#ff9500', 6);
                            }
                            
                            // Open chests automatically
                            if (tile === TILE.CHEST) {
                                const baseValue = 150 + Math.floor(Math.random() * 100);
                                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                                const value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                                totalGemValue += value;
                                addCombo();
                            }
                            
                            // Unstable rock bonus
                            if (tile === TILE.UNSTABLE) {
                                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                                const bonus = Math.floor(15 * (1 + totalGemBonus / 100) * getComboMultiplier());
                                totalGemValue += bonus;
                                addCombo();
                            }
                            
                            // Collect triggerable items (will trigger AFTER clearing)
                            if (tile === TILE.BOMB || tile === TILE.CHERRY_BOMB || tile === TILE.CHAIN_CRYSTAL || 
                                tile === TILE.DEPTH_CHARGE || tile === TILE.BOUNCE_PAD ||
                                tile === TILE.MAGNET_ORE || tile === TILE.MYSTERY_BLOCK ||
                                tile === TILE.ALIEN_NODE) {
                                // Skip the center cherry bomb (already being processed)
                                if (!(dx === 0 && dy === 0 && tile === TILE.CHERRY_BOMB)) {
                                    triggerables.push({ tile, tx, absoluteTy, tileCenterX, tileCenterY });
                                }
                            }
                            
                            world[ty][tx] = TILE.AIR;
                            createParticles(tileCenterX, tileCenterY, '#ff3333', 3); // Red particles
                        }
                    }
                }
            }
            
            // Apply collected rewards
            if (totalGemValue > 0) {
                score += totalGemValue;
                const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
                const cy = centerAbsTY * TILE_SIZE;
                createFloatingText(` +${totalGemValue}!`, cx, cy - 20, '#ffd700');
            }
            
            if (fuelCollected > 0) {
                fuel = Math.min(fuel + fuelCollected, maxFuel);
                const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
                const cy = centerAbsTY * TILE_SIZE;
                createFloatingText(` +${fuelCollected}`, cx, cy - 40, '#ff9500');
            }
            
            // Smaller red explosion effects
            const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
            const cy = centerAbsTY * TILE_SIZE + TILE_SIZE/2;
            for (let i = 0; i < 15; i++) {
                const angle = (Math.PI * 2 * i) / 15;
                particles.push({
                    x: cx, y: cy,
                    vx: Math.cos(angle) * (4 + Math.random() * 4),
                    vy: Math.sin(angle) * (4 + Math.random() * 4),
                    size: 3 + Math.random() * 4,
                    color: Math.random() < 0.5 ? '#ff3333' : '#ff6666',
                    life: 0.8,
                    type: 'explosion'
                });
            }
            
            triggerScreenFlash('#ff3333', 0.4, 10);
            screenShake = 8;
            updateScoreDisplay();
            updateFuelBar();
            
            // Trigger collected special items
            for (const item of triggerables) {
                if (item.tile === TILE.BOMB) {
                    explodeBomb(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.CHERRY_BOMB) {
                    explodeCherryBomb(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.CHAIN_CRYSTAL) {
                    triggerChainCrystalExplosion(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.DEPTH_CHARGE) {
                    triggerDepthCharge(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.BOUNCE_PAD) {
                    triggerUpCharge(item.tx, item.absoluteTy);
                } else if (item.tile === TILE.MAGNET_ORE) {
                    triggerMagnetPull(item.tx, item.absoluteTy);
                }
                // Simplified triggering for cherry bomb (skip complex items like mystery/alien for brevity)
            }
        }
        
        // Chain Crystal - breaks all adjacent chain crystals in a chain reaction
        function triggerChainCrystalExplosion(startTX, startAbsTY) {
            const MAX_CHAIN_SIZE = 50; // Maximum blocks in a chain
            let crystalsToBreak = [{tx: startTX, absoluteTy: startAbsTY}];
            let brokenCrystals = new Set();
            let totalValue = 0;
            let chainCount = 0;
            
            while (crystalsToBreak.length > 0 && chainCount < MAX_CHAIN_SIZE) {
                const current = crystalsToBreak.shift();
                const key = `${current.tx},${current.absoluteTy}`;
                
                if (brokenCrystals.has(key)) continue;
                brokenCrystals.add(key);
                
                const ty = getWorldRow(current.absoluteTy);
                if (ty < 0 || ty >= world.length) continue;
                if (current.tx < 0 || current.tx >= WORLD_WIDTH) continue;
                
                const tile = world[ty][current.tx];
                if (tile !== TILE.CHAIN_CRYSTAL && chainCount > 0) continue;
                
                // Break this crystal
                world[ty][current.tx] = TILE.AIR;
                chainCount++;
                
                const tileCenterX = current.tx * TILE_SIZE + TILE_SIZE/2;
                const tileCenterY = current.absoluteTy * TILE_SIZE + TILE_SIZE/2;
                
                // Value increases with chain length!
                const chainBonus = Math.min(chainCount, 10);
                const value = 5 * chainBonus;
                totalValue += value;
                
                // Electric explosion particles
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    particles.push({
                        x: tileCenterX, y: tileCenterY,
                        vx: Math.cos(angle) * (3 + Math.random() * 2),
                        vy: Math.sin(angle) * (3 + Math.random() * 2),
                        size: 3 + Math.random() * 2,
                        color: Math.random() < 0.5 ? '#00ffff' : '#ffffff',
                        life: 0.6,
                        type: 'gem'
                    });
                }
                
                // Check all 8 neighbors for more chain crystals (only if under limit)
                if (chainCount < MAX_CHAIN_SIZE) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const neighborTX = current.tx + dx;
                            const neighborAbsTY = current.absoluteTy + dy;
                            const neighborTY = getWorldRow(neighborAbsTY);
                            
                            if (neighborTY >= 0 && neighborTY < world.length && 
                                neighborTX >= 0 && neighborTX < WORLD_WIDTH) {
                                if (world[neighborTY][neighborTX] === TILE.CHAIN_CRYSTAL) {
                                    crystalsToBreak.push({tx: neighborTX, absoluteTy: neighborAbsTY});
                                }
                            }
                        }
                    }
                }
                
                addCombo();
            }
            
            // Award points
            score += totalValue;
            updateScoreDisplay();
            
            const centerX = startTX * TILE_SIZE + TILE_SIZE/2;
            const centerY = startAbsTY * TILE_SIZE;
            
            if (chainCount > 1) {
                createFloatingText(` CHAIN x${chainCount}! `, centerX, centerY - 15, '#00ffff');
                createFloatingText(`+${totalValue}`, centerX, centerY, '#ffffff');
                triggerScreenFlash('#00ffff', 0.3, 10 + chainCount);
                screenShake = 4 + chainCount;
            } else {
                createFloatingText(` +${totalValue}`, centerX, centerY - 5, '#00ffff');
                triggerScreenFlash('#00ffff', 0.15, 6);
                screenShake = 3;
            }
        }
        
        // Depth Charge - clears 5 blocks directly below
        // Up Charge - clears 7 blocks directly above
        function triggerUpCharge(tx, startAbsTY) {
            const centerX = tx * TILE_SIZE + TILE_SIZE/2;
            let blocksCleared = 0;
            let totalValue = 0;
            
            createFloatingText(' UP CHARGE ', centerX, startAbsTY * TILE_SIZE - 10, '#50ff64');
            
            // Clear 7 blocks above
            for (let i = 1; i <= 7; i++) {
                const targetAbsTY = startAbsTY - i;
                const targetTY = getWorldRow(targetAbsTY);
                
                // Don't clear sky rows
                if (targetAbsTY < FIRST_DIGGABLE_ROW) break;
                if (targetTY < 0 || targetTY >= world.length) continue;
                
                const tile = world[targetTY][tx];
                const tileCenterX = tx * TILE_SIZE + TILE_SIZE/2;
                const tileCenterY = targetAbsTY * TILE_SIZE + TILE_SIZE/2;
                
                // Truly unbreakable - always stop
                if (tile === TILE.BEDROCK || tile === TILE.PORTAL || 
                    tile === TILE.PORTAL_PART || tile === TILE.GATE) {
                    break;
                }
                
                // Skip air
                if (tile === TILE.AIR) continue;
                
                // Hard rock: break on first block, stop on subsequent
                if (tile === TILE.HARD_ROCK) {
                    if (blocksCleared === 0) {
                        // First block - break through hard rock
                        world[targetTY][tx] = TILE.AIR;
                        blocksCleared++;
                        for (let j = 0; j < 4; j++) {
                            particles.push({
                                x: tileCenterX + (Math.random() - 0.5) * 10,
                                y: tileCenterY,
                                vx: (Math.random() - 0.5) * 3,
                                vy: -2 - Math.random() * 3,
                                size: 3 + Math.random() * 3,
                                color: Math.random() < 0.5 ? '#44ff44' : '#aaffaa',
                                life: 0.5,
                                type: 'explosion'
                            });
                        }
                        continue;
                    } else {
                        // Subsequent blocks - stop at hard rock
                        break;
                    }
                }
                
                // Collect gems
                if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                    let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                    const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                    const value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                    totalValue += value;
                    addCombo();
                    const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                    createGemParticles(tileCenterX, tileCenterY, color);
                }
                
                // Collect fuel
                if (tile === TILE.FUEL) {
                    const fuelGain = 10;
                    fuel = Math.min(fuel + fuelGain, maxFuel);
                    createParticles(tileCenterX, tileCenterY, '#ff9500', 6);
                }
                
                // Trigger chain crystals
                if (tile === TILE.CHAIN_CRYSTAL) {
                    triggerChainCrystalExplosion(tx, targetAbsTY);
                }
                
                // Trigger bombs
                if (tile === TILE.BOMB) {
                    explodeBomb(tx, targetAbsTY);
                }
                if (tile === TILE.CHERRY_BOMB) {
                    explodeCherryBomb(tx, targetAbsTY);
                }
                
                world[targetTY][tx] = TILE.AIR;
                blocksCleared++;
                
                // Upward explosion particles
                for (let j = 0; j < 4; j++) {
                    particles.push({
                        x: tileCenterX + (Math.random() - 0.5) * 10,
                        y: tileCenterY,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -2 - Math.random() * 3,
                        size: 3 + Math.random() * 3,
                        color: Math.random() < 0.5 ? '#44ff44' : '#aaffaa',
                        life: 0.5,
                        type: 'explosion'
                    });
                }
            }
            
            if (totalValue > 0) {
                score += totalValue;
                updateScoreDisplay();
                createFloatingText(`+${totalValue}`, centerX, (startAbsTY - 3) * TILE_SIZE, '#ffff00');
            }
            
            triggerScreenFlash('#50ff64', 0.3, 12);
            screenShake = 8;
            updateFuelBar();
        }
        
        // Depth Charge - clears 5 blocks directly below
        function triggerDepthCharge(tx, startAbsTY) {
            const centerX = tx * TILE_SIZE + TILE_SIZE/2;
            let blocksCleared = 0;
            let totalValue = 0;
            
            createFloatingText(' DEPTH CHARGE ', centerX, startAbsTY * TILE_SIZE - 10, '#ff6644');
            
            // Clear 7 blocks below
            for (let i = 1; i <= 7; i++) {
                const targetAbsTY = startAbsTY + i;
                const targetTY = getWorldRow(targetAbsTY);
                
                if (targetTY < 0 || targetTY >= world.length) continue;
                
                const tile = world[targetTY][tx];
                const tileCenterX = tx * TILE_SIZE + TILE_SIZE/2;
                const tileCenterY = targetAbsTY * TILE_SIZE + TILE_SIZE/2;
                
                // Truly unbreakable - always stop
                if (tile === TILE.BEDROCK || tile === TILE.PORTAL || 
                    tile === TILE.PORTAL_PART || tile === TILE.GATE) {
                    break;
                }
                
                // Skip air
                if (tile === TILE.AIR) continue;
                
                // Hard rock: break on first block, stop on subsequent
                if (tile === TILE.HARD_ROCK) {
                    if (blocksCleared === 0) {
                        // First block - break through hard rock
                        world[targetTY][tx] = TILE.AIR;
                        blocksCleared++;
                        for (let j = 0; j < 4; j++) {
                            particles.push({
                                x: tileCenterX + (Math.random() - 0.5) * 10,
                                y: tileCenterY,
                                vx: (Math.random() - 0.5) * 3,
                                vy: 2 + Math.random() * 3,
                                size: 3 + Math.random() * 3,
                                color: Math.random() < 0.5 ? '#ff4400' : '#ffaa00',
                                life: 0.5,
                                type: 'explosion'
                            });
                        }
                        continue;
                    } else {
                        // Subsequent blocks - stop at hard rock
                        break;
                    }
                }
                
                // Collect gems
                if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                    let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                    const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                    const value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                    totalValue += value;
                    addCombo();
                    const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                    createGemParticles(tileCenterX, tileCenterY, color);
                }
                
                // Collect fuel
                if (tile === TILE.FUEL) {
                    const fuelGain = 10;
                    fuel = Math.min(fuel + fuelGain, maxFuel);
                    createParticles(tileCenterX, tileCenterY, '#ff9500', 6);
                }
                
                // Trigger chain crystals
                if (tile === TILE.CHAIN_CRYSTAL) {
                    triggerChainCrystalExplosion(tx, targetAbsTY);
                }
                
                // Trigger bombs
                if (tile === TILE.BOMB) {
                    explodeBomb(tx, targetAbsTY);
                }
                if (tile === TILE.CHERRY_BOMB) {
                    explodeCherryBomb(tx, targetAbsTY);
                }
                
                world[targetTY][tx] = TILE.AIR;
                blocksCleared++;
                
                // Downward explosion particles
                for (let j = 0; j < 4; j++) {
                    particles.push({
                        x: tileCenterX + (Math.random() - 0.5) * 10,
                        y: tileCenterY,
                        vx: (Math.random() - 0.5) * 3,
                        vy: 2 + Math.random() * 3,
                        size: 3 + Math.random() * 3,
                        color: Math.random() < 0.5 ? '#ff4400' : '#ffaa00',
                        life: 0.5,
                        type: 'explosion'
                    });
                }
            }
            
            if (totalValue > 0) {
                score += totalValue;
                updateScoreDisplay();
                createFloatingText(`+${totalValue}`, centerX, (startAbsTY + 3) * TILE_SIZE, '#ffff00');
            }
            
            triggerScreenFlash('#ff4400', 0.3, 12);
            screenShake = 8;
            updateFuelBar();
        }
        
        // Magnet Ore - pulls all gems within 3 tiles toward player
        function triggerMagnetPull(centerTX, centerAbsTY) {
            const MAGNET_RANGE = 5; // Increased range for better pull effect
            let gemsCollected = 0;
            let totalValue = 0;
            
            for (let dy = -MAGNET_RANGE; dy <= MAGNET_RANGE; dy++) {
                for (let dx = -MAGNET_RANGE; dx <= MAGNET_RANGE; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const targetTX = centerTX + dx;
                    const targetAbsTY = centerAbsTY + dy;
                    const targetTY = getWorldRow(targetAbsTY);
                    
                    if (targetTY < 0 || targetTY >= world.length) continue;
                    if (targetTX < 0 || targetTX >= WORLD_WIDTH) continue;
                    
                    const tile = world[targetTY][targetTX];
                    
                    // Pull gems
                    if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                        let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                        const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                        let value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                        if (feverMode) value = Math.floor(value * 1.5);
                        totalValue += value;
                        gemsCollected++;
                        addCombo();
                        
                        const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                        const startX = targetTX * TILE_SIZE + TILE_SIZE/2;
                        const startY = targetAbsTY * TILE_SIZE + TILE_SIZE/2;
                        const endX = centerTX * TILE_SIZE + TILE_SIZE/2;
                        const endY = centerAbsTY * TILE_SIZE + TILE_SIZE/2;
                        
                        // Create trail particles from gem to center
                        for (let i = 0; i < 5; i++) {
                            const t = i / 5;
                            particles.push({
                                x: startX + (endX - startX) * t,
                                y: startY + (endY - startY) * t,
                                vx: (endX - startX) * 0.1,
                                vy: (endY - startY) * 0.1,
                                size: 3 + Math.random() * 2,
                                color: color,
                                life: 0.3 + t * 0.3,
                                type: 'gem'
                            });
                        }
                        
                        world[targetTY][targetTX] = TILE.AIR;
                    }
                }
            }
            
            const centerX = centerTX * TILE_SIZE + TILE_SIZE/2;
            const centerY = centerAbsTY * TILE_SIZE;
            
            if (gemsCollected > 0) {
                score += totalValue;
                updateScoreDisplay();
                createFloatingText(` ${gemsCollected} GEMS!`, centerX, centerY - 20, '#ff66ff');
                createFloatingText(`+${totalValue}`, centerX, centerY - 5, '#ffff00');
                triggerScreenFlash('#ff66ff', 0.25, 8 + gemsCollected);
                screenShake = 4 + gemsCollected;
            } else {
                triggerScreenFlash('#ff66ff', 0.15, 5);
                screenShake = 3;
            }
            
            // Magnetic field effect particles - match the pull range
            const particleRadius = 5 * TILE_SIZE; // Match MAGNET_RANGE
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                particles.push({
                    x: centerX + Math.cos(angle) * particleRadius,
                    y: centerAbsTY * TILE_SIZE + TILE_SIZE/2 + Math.sin(angle) * particleRadius,
                    vx: -Math.cos(angle) * 5,
                    vy: -Math.sin(angle) * 5,
                    size: 3 + Math.random() * 2,
                    color: '#ff66ff',
                    life: 0.6,
                    type: 'gem'
                });
            }
        }
        
        function openChest(tx, absoluteTy) {
            // Huge gem payout!
            const baseValue = 150 + Math.floor(Math.random() * 100);
            const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
            const value = Math.floor(baseValue * (1 + totalGemBonus / 100) * getComboMultiplier());
            score += value;
            
            const worldY = absoluteTy * TILE_SIZE;
            createFloatingText(` +${value}! `, tx * TILE_SIZE + TILE_SIZE/2, worldY, '#ffd700');
            
            // Shower of particles
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 5;
                particles.push({
                    x: tx * TILE_SIZE + TILE_SIZE/2,
                    y: worldY + TILE_SIZE/2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 3,
                    size: 3 + Math.random() * 5,
                    color: ['#ffd700', '#ff9500', '#00f0ff', '#ff00ff'][Math.floor(Math.random() * 4)],
                    life: 1.2,
                    type: 'gem'
                });
            }
            
            triggerScreenFlash('#ffd700', 0.4, 25);
            screenShake = 8;
            addCombo();
            updateScoreDisplay();
            updateFuelBar();
        }
        
        function openUpgradeChest(tx, absoluteTy) {
            const worldY = absoluteTy * TILE_SIZE;
            
            // Pick a random upgrade from all available (regular + legendary)
            const allUpgrades = [...upgradeDefinitions, ...legendaryUpgradeDefinitions];
            const upgrade = allUpgrades[Math.floor(Math.random() * allUpgrades.length)];
            
            // Rainbow particle explosion
            for (let i = 0; i < 35; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 4 + Math.random() * 6;
                const hue = (i / 35) * 360;
                particles.push({
                    x: tx * TILE_SIZE + TILE_SIZE/2,
                    y: worldY + TILE_SIZE/2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 4,
                    size: 4 + Math.random() * 4,
                    color: `hsl(${hue}, 100%, 60%)`,
                    life: 1.5,
                    type: 'gem'
                });
            }
            
            // Screen effects
            triggerScreenFlash('#ffd700', 0.5, 30);
            screenShake = 12;
            
            // Bonus score
            const bonusScore = 100;
            score += bonusScore;
            updateScoreDisplay();
            
            // Show upgrade overlay with single slot
            showChestUpgrade(upgrade);
        }
        
        function showChestUpgrade(upgrade) {
            upgradeSelectionActive = true;
            upgradeSelected = false;
            isChestUpgrade = true;
            isLegendaryUpgrade = false;
            
            currentUpgradeChoices = [upgrade];
            
            // Update title and subtitle
            const titleEl = upgradeOverlay.querySelector('.upgrade-title');
            const subtitleEl = upgradeOverlay.querySelector('.upgrade-subtitle');
            titleEl.textContent = 'TREASURE FOUND';
            subtitleEl.textContent = 'Claim your reward';
            
            // Set chest styling
            upgradeOverlay.classList.remove('legendary');
            upgradeOverlay.classList.add('chest');
            
            // Show only the first slot, hide others
            slots.forEach((slot, i) => {
                if (i === 0) {
                    slot.className = 'upgrade-slot rolling chest';
                    slot.style.display = '';
                    slot.querySelector('.upgrade-icon').textContent = '?';
                    slot.querySelector('.upgrade-name').textContent = '???';
                    slot.querySelector('.upgrade-desc').textContent = '???';
                } else {
                    slot.style.display = 'none';
                }
            });
            
            upgradeOverlay.classList.add('active');
            rollChestSlot(upgrade);
        }
        
        function rollChestSlot(upgrade) {
            clearRollTimers();
            
            const rollDuration = 1200;
            const allDefs = [...upgradeDefinitions, ...legendaryUpgradeDefinitions];
            const slot = slots[0];
            
            const rollInterval = setInterval(() => {
                const r = allDefs[Math.floor(Math.random() * allDefs.length)];
                slot.querySelector('.upgrade-icon').textContent = r.icon;
                slot.querySelector('.upgrade-name').textContent = r.name;
                slot.querySelector('.upgrade-desc').textContent = r.desc;
            }, 100);
            
            activeRollIntervals.push(rollInterval);
            
            const timeout = setTimeout(() => {
                clearInterval(rollInterval);
                slot.className = 'upgrade-slot revealed chest';
                slot.querySelector('.upgrade-icon').textContent = upgrade.icon;
                slot.querySelector('.upgrade-name').textContent = upgrade.name;
                slot.querySelector('.upgrade-desc').textContent = upgrade.desc;
                slot.onclick = () => selectChestUpgrade(upgrade);
                slot.ontouchend = (e) => { e.preventDefault(); e.stopPropagation(); selectChestUpgrade(upgrade); };
            }, rollDuration);
            
            activeRollTimeouts.push(timeout);
        }
        
        function selectChestUpgrade(upgrade) {
            if (!upgradeSelectionActive || upgradeSelected) return;
            upgradeSelected = true;
            
            slots[0].classList.add('selected');
            
            // Apply the upgrade
            upgrade.apply();
            updatePermanentUpgradesDisplay();
            updateFuelBar();
            updateHullBar();
            
            setTimeout(() => {
                upgradeSelectionActive = false;
                isChestUpgrade = false;
                upgradeOverlay.classList.remove('active', 'chest');
                
                // Reset title and subtitle for next time
                const titleEl = upgradeOverlay.querySelector('.upgrade-title');
                const subtitleEl = upgradeOverlay.querySelector('.upgrade-subtitle');
                titleEl.textContent = 'UPGRADE';
                subtitleEl.textContent = 'Choose your enhancement';
                
                slots.forEach(s => {
                    s.style.display = '';
                    s.style.opacity = '';
                    s.style.pointerEvents = '';
                    s.classList.remove('selected', 'chest');
                    s.onclick = null;
                    s.ontouchend = null;
                });
            }, 600);
        }
        
        function startUnstableTimer(tx, absoluteTy) {
            // Add to unstable tiles list with a timer
            unstableTiles.push({
                tx: tx,
                absoluteTy: absoluteTy,
                timer: 75, // ~1.25 seconds to break before collapse
                warned: false
            });
        }
        
        function completeDig(fromMagnet = false) {
            if (!player.digTarget) return;
            
            const { x: tx, y: absoluteTy } = player.digTarget;
            const ty = getWorldRow(absoluteTy);
            if (ty < 0 || ty >= world.length) {
                player.digging = false;
                player.digTarget = null;
                return;
            }
            
            const tile = world[ty][tx];
            const worldY = absoluteTy * TILE_SIZE;
            const tileCenterX = tx * TILE_SIZE + TILE_SIZE/2;
            const tileCenterY = worldY + TILE_SIZE/2;
            
            // Apply fever mode speed bonus
            const feverMultiplier = feverMode ? 1.5 : 1;
            
            // ===== GEMS =====
            if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                addCombo();
                const multiplier = getComboMultiplier();
                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                let value = Math.floor(baseValue * (1 + totalGemBonus / 100) * multiplier);
                
                // Fever mode bonus
                if (feverMode) value = Math.floor(value * 1.5);
                
                score += value;
                updateScoreDisplay();
                
                const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                const text = multiplier > 1 ? `+${value} x${multiplier}!` : `+${value}`;
                createFloatingText(text, tileCenterX, worldY - 5, color);
                createGemParticles(tileCenterX, tileCenterY, color);
                
                // Epic gem screen flash
                if (tile === TILE.GEM_EPIC) {
                    triggerScreenFlash('#ff9500', 0.3, 12);
                    screenShake = 5;
                } else {
                    screenShake = 3;
                }
            }
            
            // ===== FUEL CANISTER =====
            if (tile === TILE.FUEL) {
                const fuelGain = feverMode ? 15 : 10;
                fuel = Math.min(fuel + fuelGain, maxFuel);
                updateFuelBar();
                createFloatingText(`+${fuelGain} `, tileCenterX, worldY - 5, '#ff9500');
                createParticles(tileCenterX, tileCenterY, '#ff9500', 10);
                triggerScreenFlash('#ff8800', 0.15, 8);
            }
            
            // ===== BOMB =====
            if (tile === TILE.BOMB) {
                world[ty][tx] = TILE.AIR; // Clear bomb first
                explodeBomb(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return; // Skip normal completion
            }
            
            // ===== CHERRY BOMB =====
            if (tile === TILE.CHERRY_BOMB) {
                world[ty][tx] = TILE.AIR; // Clear cherry bomb first
                explodeCherryBomb(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return; // Skip normal completion
            }
            
            // ===== CHEST =====
            if (tile === TILE.CHEST) {
                world[ty][tx] = TILE.AIR;
                openChest(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== UPGRADE CHEST =====
            if (tile === TILE.UPGRADE_CHEST) {
                world[ty][tx] = TILE.AIR;
                openUpgradeChest(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== ALIEN GEM NODE =====
            if (tile === TILE.ALIEN_NODE) {
                world[ty][tx] = TILE.AIR;
                
                // Determine gem count based on depth (4-8 gems, starts at 100m)
                const nodeDepth = absoluteTy - 2; // Actual depth in meters
                const baseGems = 4;
                const bonusGems = Math.min(Math.floor((nodeDepth - 100) / 100), 4); // +1 gem every 100m past 100, max +4
                const gemCount = baseGems + bonusGems;
                
                // Calculate value for each gem type (50% increased from base)
                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                const comboMult = getComboMultiplier();
                const feverMult = feverMode ? 2 : 1;
                
                let totalValue = 0;
                
                // Spawn multiple gems with particle effects
                for (let i = 0; i < gemCount; i++) {
                    const gemType = Math.random();
                    let gemValue, gemColor;
                    
                    if (gemType < 0.25) {
                        // Epic gem (25% chance) - 50 -> 75
                        gemValue = 75;
                        gemColor = '#ff9500';
                    } else if (gemType < 0.6) {
                        // Rare gem (35% chance) - 25 -> 38
                        gemValue = 38;
                        gemColor = '#ff00ff';
                    } else {
                        // Common gem (40% chance) - 10 -> 15
                        gemValue = 15;
                        gemColor = '#00f0ff';
                    }
                    
                    gemValue = Math.floor(gemValue * (1 + totalGemBonus / 100) * comboMult * feverMult);
                    totalValue += gemValue;
                    
                    // Spawn particles in a burst pattern
                    const angle = (i / gemCount) * Math.PI * 2;
                    const burstX = tileCenterX + Math.cos(angle) * 8;
                    const burstY = tileCenterY + Math.sin(angle) * 8;
                    createParticles(burstX, burstY, gemColor, 5);
                }
                
                // Add score
                score += totalValue;
                updateScoreDisplay();
                
                // Epic floating text
                createFloatingText(` ALIEN NODE `, tileCenterX, worldY - 20, '#cc88ff');
                createFloatingText(` +${totalValue}!`, tileCenterX, worldY - 5, '#00ffcc');
                
                // Big particle explosion
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({
                        x: tileCenterX,
                        y: tileCenterY,
                        vx: Math.cos(angle) * (4 + Math.random() * 3),
                        vy: Math.sin(angle) * (4 + Math.random() * 3),
                        size: 3 + Math.random() * 3,
                        color: ['#00ffff', '#ff00ff', '#ff9500', '#cc88ff'][Math.floor(Math.random() * 4)],
                        life: 1.2,
                        type: 'gem'
                    });
                }
                
                // Screen effects
                triggerScreenFlash('#cc88ff', 0.3, 15);
                screenShake = 8;
                
                // Add combo for each gem
                for (let i = 0; i < gemCount; i++) {
                    addCombo();
                }
                
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== UNSTABLE ROCK =====
            if (tile === TILE.UNSTABLE) {
                // Breaking unstable rock always damages player
                const shopArmor = getShopBonus('armor');
                const damage = 15 * (1 - (getEffectiveUpgrade('armor', 90) + shopArmor) / 100);
                hull -= damage;
                comboCount = 0;
                comboTimer = 0;
                createFloatingText(`-${Math.floor(damage)}`, player.x + 12, player.y, '#ff3355');
                triggerScreenFlash('#ff0000', 0.2, 6);
                screenShake = 8;
                updateHullBar();
                
                // Still give some points for the risk
                const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                const value = Math.floor(10 * (1 + totalGemBonus / 100));
                score += value;
                updateScoreDisplay();
                createFloatingText(`+${value}`, tileCenterX, worldY - 5, '#aaaaff');
                createParticles(tileCenterX, tileCenterY, '#8888aa', 10);
                
                // Remove from unstable tracking
                unstableTiles = unstableTiles.filter(u => !(u.tx === tx && u.absoluteTy === absoluteTy));
            }
            
            // ===== HAZARDS =====
            if (tile === TILE.LAVA || tile === TILE.GAS) {
                const baseDamage = tile === TILE.LAVA ? 40 : 20; // Doubled damage
                const shopArmor = getShopBonus('armor');
                const damage = baseDamage * (1 - (getEffectiveUpgrade('armor', 90) + shopArmor) / 100);
                hull -= damage;
                comboCount = 0; // Break combo on damage
                comboTimer = 0;
                createFloatingText(`-${Math.floor(damage)}`, player.x + 12, player.y, '#ff3355');
                createParticles(player.x + 12, player.y + 14 + cameraY, '#ff3355', 8);
                triggerScreenFlash('#ff0000', 0.25, 8);
                screenShake = 6;
                updateHullBar();
            }
            
            // ===== CHAIN CRYSTAL =====
            if (tile === TILE.CHAIN_CRYSTAL) {
                world[ty][tx] = TILE.AIR;
                triggerChainCrystalExplosion(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== UP CHARGE =====
            if (tile === TILE.BOUNCE_PAD) {
                world[ty][tx] = TILE.AIR;
                triggerUpCharge(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== MYSTERY BLOCK =====
            if (tile === TILE.MYSTERY_BLOCK) {
                world[ty][tx] = TILE.AIR;
                const roll = Math.random();
                
                if (roll < 0.40) {
                    // 40% - Random gem
                    const gemRoll = Math.random();
                    let gemValue, gemColor;
                    if (gemRoll < 0.1) {
                        gemValue = 50; gemColor = '#ff9500';
                    } else if (gemRoll < 0.4) {
                        gemValue = 25; gemColor = '#ff00ff';
                    } else {
                        gemValue = 10; gemColor = '#00f0ff';
                    }
                    const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
                    gemValue = Math.floor(gemValue * (1 + totalGemBonus / 100) * getComboMultiplier());
                    if (feverMode) gemValue = Math.floor(gemValue * 1.5);
                    score += gemValue;
                    updateScoreDisplay();
                    createFloatingText(`+${gemValue}`, tileCenterX, worldY - 10, gemColor);
                    createGemParticles(tileCenterX, tileCenterY, gemColor);
                    addCombo();
                } else if (roll < 0.50) {
                    // 10% - Fuel
                    const fuelGain = 7 + Math.floor(Math.random() * 5);
                    fuel = Math.min(fuel + fuelGain, maxFuel);
                    updateFuelBar();
                    createFloatingText(`+${fuelGain}`, tileCenterX, worldY - 10, '#ff9500');
                    createParticles(tileCenterX, tileCenterY, '#ff9500', 12);
                } else if (roll < 0.60) {
                    // 10% - Magnet effect!
                    triggerMagnetPull(tx, absoluteTy);
                } else if (roll < 0.70) {
                    // 10% - Up Charge effect (clears up)
                    triggerUpCharge(tx, absoluteTy);
                } else if (roll < 0.80) {
                    // 10% - Depth Charge effect (clears down)
                    triggerDepthCharge(tx, absoluteTy);
                } else if (roll < 0.85) {
                    // 5% - Nothing (dud)
                    createFloatingText('Empty...', tileCenterX, worldY - 10, '#888888');
                    createParticles(tileCenterX, tileCenterY, '#555555', 5);
                } else if (roll < 0.92) {
                    // 7% - Bomb (oops!)
                    explodeBomb(tx, absoluteTy);
                } else {
                    // 8% - Jackpot! Big reward
                    const jackpotValue = 100 + Math.floor(Math.random() * 50);
                    score += jackpotValue;
                    updateScoreDisplay();
                    createFloatingText(`JACKPOT! +${jackpotValue}`, tileCenterX, worldY - 10, '#ffff00');
                    triggerScreenFlash('#ffff00', 0.4, 15);
                    screenShake = 8;
                    for (let i = 0; i < 5; i++) addCombo();
                    createParticles(tileCenterX, tileCenterY, '#ffff00', 25);
                }
                
                triggerScreenFlash('#ffffff', 0.15, 6);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== DEPTH CHARGE =====
            if (tile === TILE.DEPTH_CHARGE) {
                world[ty][tx] = TILE.AIR;
                triggerDepthCharge(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== MAGNET ORE =====
            if (tile === TILE.MAGNET_ORE) {
                world[ty][tx] = TILE.AIR;
                triggerMagnetPull(tx, absoluteTy);
                
                // Small base reward
                score += 15;
                updateScoreDisplay();
                createFloatingText(' MAGNET!', tileCenterX, worldY - 10, '#ff66ff');
                addCombo();
                
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // Don't charge fuel for magnet-collected gems
            if (!fromMagnet) {
                const shopFuelEff = getShopBonus('fuelEff');
                let fuelCost = 1.0 * (1 - (getEffectiveUpgrade('fuelEfficiency', 90) + shopFuelEff) / 100);
                if (feverMode) fuelCost *= 0.5; // Half fuel cost in fever mode
                if (hoverMode) fuelCost *= 0.2; // 80% reduction in hover mode
                fuel -= fuelCost;
            }
            
            updateFuelBar();
            
            // Chance to spawn beetle when digging creates tunnel
            const depthM = Math.max(0, absoluteTy - 2); // Depth in meters
            const spawnChances = getEnemySpawnChance(depthM, currentBiome);
            
            // Guaranteed first enemy encounter between 15-35m depth (was 20)
            let shouldSpawnBeetle = false;
            if (!firstEnemySpawned && depthM >= 15) {
                // Very high chance starting at 15m
                shouldSpawnBeetle = Math.random() < 0.5; // 50% per dig!
            } 
            // Guaranteed second enemy encounter between 40-55m depth
            else if (firstEnemySpawned && !secondEnemySpawned && depthM >= 40 && depthM < 55) {
                const urgency = (depthM - 40) / 10; // 0 at 40m, 1 at 50m
                shouldSpawnBeetle = Math.random() < (0.25 + urgency * 0.75);
            }
            else if (spawnChances.beetle > 0) {
                shouldSpawnBeetle = Math.random() < spawnChances.beetle * 0.5; // Increased from 0.3
            }
            
            if (shouldSpawnBeetle) {
                // Spawn beetle on a surface position outside player view
                const spawnPos = findSurfaceSpawnPosition(tx, ty, 6);
                if (spawnPos) {
                    spawnEnemy(ENEMY_TYPE.BEETLE, spawnPos.tx, spawnPos.ty);
                    if (!firstEnemySpawned) firstEnemySpawned = true;
                    else if (!secondEnemySpawned) secondEnemySpawned = true;
                } else {
                    // Forced spawn: create space directly below dig location
                    const forcedTy = ty + 4;
                    if (forcedTy < world.length - 1) {
                        world[forcedTy][tx] = TILE.AIR;
                        spawnEnemy(ENEMY_TYPE.BEETLE, tx, forcedTy);
                        if (!firstEnemySpawned) firstEnemySpawned = true;
                        else if (!secondEnemySpawned) secondEnemySpawned = true;
                    }
                }
            }
            
            // Clear tile
            world[ty][tx] = TILE.AIR;
            createDigParticles(tileCenterX, absoluteTy * TILE_SIZE + TILE_SIZE/2, tile);
            
            // When drilling DOWN, snap player horizontally and slide vertically
            if (lastDigDirection === 'down') {
                // Snap X immediately to stay in the same column (funnel behavior)
                const targetX = tx * TILE_SIZE + TILE_SIZE/2 - player.width/2;
                player.x = targetX;
                
                // Animate Y with slide
                const targetY = absoluteTy * TILE_SIZE + 4; // Slightly into the hole
                slideAnimation.active = true;
                slideAnimation.targetX = targetX; // Already snapped, but keep for reference
                slideAnimation.targetY = targetY;
                slideAnimation.direction = 'down';
                slideAnimation.timer = 0; // Reset timeout
                player.vy = 0; // Reset fall velocity during slide
            }
            
            // When drilling LEFT or RIGHT, slide player vertically to align with tile row
            if (lastDigDirection === 'left' || lastDigDirection === 'right') {
                // Target Y: center player vertically on the tile being drilled
                const targetY = absoluteTy * TILE_SIZE + TILE_SIZE/2 - player.height/2;
                const targetX = lastDigDirection === 'left' ? 
                    (tx + 1) * TILE_SIZE - player.width + 4 : // Slide into the hole from right
                    tx * TILE_SIZE - 4; // Slide into the hole from left
                
                slideAnimation.active = true;
                slideAnimation.targetX = targetX;
                slideAnimation.targetY = targetY;
                slideAnimation.direction = lastDigDirection; // 'left' or 'right'
                slideAnimation.timer = 0; // Reset timeout
                player.vy = 0; // Reset fall velocity during slide
            }
            
            player.digging = false;
            player.digTarget = null;
            
            // Grant momentum for continuous upward digging only
            if (lastDigDirection === 'up') {
                upDigMomentum = UP_DIG_MOMENTUM_FRAMES;
            }
            
            // Continue digging if direction key still held
            // In hover mode: first drill requires 0.5s delay, but chaining is immediate after that
            if (!fromMagnet && lastDigDirection) {
                // Grant hover drill momentum for chaining (allows bypassing delay)
                if (hoverMode && (lastDigDirection === 'up' || lastDigDirection === 'left' || lastDigDirection === 'right')) {
                    hoverDrillMomentum = HOVER_DRILL_MOMENTUM_FRAMES;
                }
                
                if (lastDigDirection === 'down') {
                    // Down can always chain
                    tryDigInDirection(lastDigDirection);
                } else {
                    // Up/Left/Right - chain immediately (delay only applies to FIRST drill)
                    tryDigInDirection(lastDigDirection);
                }
            }
        }
        
        // Find the block to dig when pressing down
        // Simply target the tile directly below the player's center
        // Player must be close to the block (within ~half a tile)
        function findDownDigTarget() {
            const playerCenterX = player.x + player.width / 2;
            const playerBottomY = player.y + player.height;
            const targetTX = Math.floor(playerCenterX / TILE_SIZE);
            
            // The row at the player's feet
            const feetRow = Math.floor(playerBottomY / TILE_SIZE);
            
            // Only check the row directly at feet and one below
            // Player must actually be near the block (feet within the tile or just above it)
            for (let rowOffset = 0; rowOffset < 2; rowOffset++) {
                const absoluteTy = feetRow + rowOffset;
                
                // Don't dig sky rows
                if (absoluteTy < FIRST_DIGGABLE_ROW) continue;
                
                // Check proximity - player's bottom must be within half a tile of the target row's top
                const tileTopY = absoluteTy * TILE_SIZE;
                const distanceToTile = tileTopY - playerBottomY;
                
                // Only allow targeting if player is touching or very close (within 4px gap)
                if (distanceToTile > 4) continue;
                
                const ty = getWorldRow(absoluteTy);
                if (ty < 0 || ty >= world.length) continue;
                if (targetTX < 0 || targetTX >= WORLD_WIDTH) continue;
                
                const tile = world[ty][targetTX];
                
                // Skip non-diggable tiles
                if (tile === TILE.AIR || tile === TILE.BEDROCK || tile === TILE.PORTAL || tile === TILE.PORTAL_PART) continue;
                
                return { tx: targetTX, absoluteTy };
            }
            
            return null;
        }
        
        // Attempt to dig in a specific direction
        function tryDigInDirection(direction) {
            let targetTX, targetAbsTY;
            
            if (direction === 'down') {
                // Use smart targeting for down-dig
                const result = findDownDigTarget();
                if (!result) return false;
                targetTX = result.tx;
                targetAbsTY = result.absoluteTy;
            } else if (direction === 'up') {
                targetTX = Math.floor((player.x + player.width / 2) / TILE_SIZE);
                targetAbsTY = Math.floor((player.y - 1) / TILE_SIZE);
            } else if (direction === 'left') {
                targetTX = Math.floor(player.x / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
            } else if (direction === 'right') {
                targetTX = Math.floor((player.x + player.width) / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
            } else {
                return false;
            }
            
            const ty = getWorldRow(targetAbsTY);
            if (ty >= 0 && ty < world.length && targetTX >= 0 && targetTX < WORLD_WIDTH) {
                // Don't dig in sky rows (0-2)
                if (targetAbsTY < FIRST_DIGGABLE_ROW) return false;
                
                const tile = world[ty][targetTX];
                // Can't dig through bedrock
                if (tile === TILE.BEDROCK) return false;
                // Can't dig when overheated
                if (drillOverheated) {
                    if (Math.random() < 0.05) {
                        createFloatingText(' Cooling...', player.x + player.width/2, player.y - 15, '#ff8844');
                    }
                    return false;
                }
                if (tile !== TILE.AIR && tile !== TILE.PORTAL && tile !== TILE.PORTAL_PART) {
                    // Start unstable timer when we begin digging unstable rock
                    if (tile === TILE.UNSTABLE) {
                        const existing = unstableTiles.find(u => u.tx === targetTX && u.absoluteTy === targetAbsTY);
                        if (!existing) {
                            startUnstableTimer(targetTX, targetAbsTY);
                        }
                    }
                    dig(targetTX, targetAbsTY);
                    return true;
                }
            }
            return false;
        }
        
        // ==================== PARTICLES ====================
        function createParticles(x, y, color, count) {
            // OPTIMIZATION: Limit particle count
            const available = MAX_PARTICLES - particles.length;
            const toCreate = Math.min(count, available);
            
            for (let i = 0; i < toCreate; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5 - 2,
                    size: 2 + Math.random() * 3,
                    color: color,
                    life: 1,
                    type: 'normal'
                });
            }
        }
        
        function createGemParticles(x, y, color) {
            const available = MAX_PARTICLES - particles.length;
            const count = Math.min(10, available);
            
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (3 + Math.random() * 2),
                    vy: Math.sin(angle) * (3 + Math.random() * 2),
                    size: 3 + Math.random() * 4,
                    color: color,
                    life: 1,
                    type: 'gem'
                });
            }
        }
        
        function createDigParticles(x, y, tile) {
            const colors = {
                [TILE.DIRT]: ['#5a4535', '#3d2d20'],
                [TILE.ROCK]: ['#555', '#444'],
                [TILE.HARD_ROCK]: ['#3a3a50', '#2a2a40']
            };
            const colorSet = colors[tile] || ['#555'];
            
            const available = MAX_PARTICLES - particles.length;
            const count = Math.min(5, available);
            
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 10,
                    y: y + (Math.random() - 0.5) * 10,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 3 - 1,
                    size: 2 + Math.random() * 4,
                    color: colorSet[Math.floor(Math.random() * colorSet.length)],
                    life: 1,
                    type: 'debris',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }
        
        function createFloatingText(text, x, worldY, color, immediate = false) {
            // Check for existing texts at similar position and offset vertically
            const STACK_THRESHOLD = 20; // Pixels - if texts are this close, stack them
            const STACK_OFFSET = 16; // Pixels to offset each stacked text
            
            let yOffset = 0;
            for (const existingText of floatingTexts) {
                const xDist = Math.abs(existingText.x - x);
                const yDist = Math.abs(existingText.y - worldY);
                if (xDist < STACK_THRESHOLD && yDist < STACK_THRESHOLD + yOffset) {
                    yOffset += STACK_OFFSET;
                }
            }
            // Also check queue
            for (const queuedText of floatingTextQueue) {
                const xDist = Math.abs(queuedText.x - x);
                const yDist = Math.abs(queuedText.y - worldY);
                if (xDist < STACK_THRESHOLD && yDist < STACK_THRESHOLD + yOffset) {
                    yOffset += STACK_OFFSET;
                }
            }
            
            // Clamp X position to keep text visible on screen (accounting for centered text)
            const TEXT_MARGIN = 70; // Margin from edges to account for text width
            const clampedX = Math.max(TEXT_MARGIN, Math.min(BASE_WIDTH - TEXT_MARGIN, x));
            
            const textData = {
                text: text,
                x: clampedX,
                y: worldY - yOffset,
                vy: -1.5,
                life: 2,
                color: color,
                scale: 1.3
            };
            
            const now = performance.now();
            const timeSinceLastText = now - lastTextShowTime;
            
            // If immediate, queue is empty AND enough time passed, show right away
            if (immediate || (floatingTextQueue.length === 0 && timeSinceLastText > 500)) {
                // OPTIMIZATION: Limit floating texts
                if (floatingTexts.length >= MAX_FLOATING_TEXTS) {
                    floatingTexts.shift();
                }
                floatingTexts.push(textData);
                lastTextShowTime = now;
            } else {
                // Add to queue for staggered display
                floatingTextQueue.push(textData);
            }
        }
        
        function processFloatingTextQueue() {
            if (floatingTextQueue.length === 0) return;
            
            floatingTextQueueTimer += deltaMultiplier;
            if (floatingTextQueueTimer >= FLOATING_TEXT_QUEUE_DELAY) {
                floatingTextQueueTimer = 0;
                const textData = floatingTextQueue.shift();
                if (floatingTexts.length >= MAX_FLOATING_TEXTS) {
                    floatingTexts.shift();
                }
                floatingTexts.push(textData);
                lastTextShowTime = performance.now();
            }
        }
        
        function updateParticles() {
            // OPTIMIZATION: Filter in place to reduce allocations
            let writeIndex = 0;
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                p.x += p.vx * deltaMultiplier;
                p.y += p.vy * deltaMultiplier;
                p.vy += 0.15 * deltaMultiplier;
                p.vx *= 0.98;
                p.life -= 0.025 * deltaMultiplier;
                if (p.rotation !== undefined) {
                    p.rotation += p.rotationSpeed * deltaMultiplier;
                }
                if (p.life > 0) {
                    particles[writeIndex++] = p;
                }
            }
            particles.length = writeIndex;
            
            writeIndex = 0;
            for (let i = 0; i < floatingTexts.length; i++) {
                const t = floatingTexts[i];
                t.y -= 1.5 * deltaMultiplier;
                t.vy *= 0.94;
                t.life -= 0.006 * deltaMultiplier;
                t.scale = 0.8 + t.life * 0.5;
                if (t.life > 0) {
                    floatingTexts[writeIndex++] = t;
                }
            }
            floatingTexts.length = writeIndex;
            
            // Update ambient particles
            for (let i = 0; i < ambientParticles.length; i++) {
                const p = ambientParticles[i];
                p.y -= p.speed * deltaMultiplier;
                if (p.y < cameraY - 50) {
                    p.y = cameraY + BASE_HEIGHT + 50;
                    p.x = Math.random() * BASE_WIDTH;
                }
            }
        }
        
        // ==================== ENEMY UPDATE ====================
        function updateEnemies() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            
            // Decrement drill kill grace period
            if (drillKillGracePeriod > 0) {
                drillKillGracePeriod -= deltaMultiplier;
            }
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Animation
                enemy.animFrame = (enemy.animFrame + 0.1 * deltaMultiplier) % (Math.PI * 2);
                
                // Movement timer
                enemy.moveTimer += deltaMultiplier;
                
                if (enemy.moveTimer >= enemy.moveDelay) {
                    enemy.moveTimer = 0;
                    
                    const localTy = enemy.ty - worldRowOffset;
                    
                    // All enemies now walk on surfaces
                    // Walk along floors, reverse at walls
                    const nextTx = enemy.tx + enemy.direction;
                    const belowTy = localTy + 1;
                    
                    // Check if can move forward and has ground below
                    if (nextTx >= 0 && nextTx < WORLD_WIDTH && belowTy < world.length) {
                        const nextTile = world[localTy] ? world[localTy][nextTx] : TILE.ROCK;
                        const belowTile = world[belowTy] ? world[belowTy][nextTx] : TILE.AIR;
                        
                        // For lava slugs, they can walk on lava
                        const canWalkOn = enemy.type === ENEMY_TYPE.LAVA_SLUG ? 
                            (belowTile !== TILE.AIR) : 
                            (belowTile !== TILE.AIR && belowTile !== TILE.LAVA);
                        
                        if (nextTile === TILE.AIR && canWalkOn) {
                            enemy.tx = nextTx;
                            enemy.x = nextTx * TILE_SIZE + TILE_SIZE / 2;
                        } else {
                            // Reverse direction
                            enemy.direction *= -1;
                        }
                    } else {
                        enemy.direction *= -1;
                    }
                    
                    // Check if ground disappeared - enemy falls
                    const currentBelowTy = localTy + 1;
                    if (currentBelowTy < world.length) {
                        const belowTile = world[currentBelowTy] ? world[currentBelowTy][enemy.tx] : TILE.AIR;
                        const canStandOn = enemy.type === ENEMY_TYPE.LAVA_SLUG ? 
                            (belowTile !== TILE.AIR) : 
                            (belowTile !== TILE.AIR && belowTile !== TILE.LAVA);
                        
                        if (!canStandOn) {
                            // Fall down
                            enemy.ty += 1;
                            enemy.y = enemy.ty * TILE_SIZE + TILE_SIZE / 2;
                        }
                    }
                }
                
                // Check collision with player
                const distX = Math.abs(enemy.x - playerCenterX);
                const distY = Math.abs(enemy.y - playerCenterY);
                
                if (distX < (enemy.width + player.width) / 2 && distY < (enemy.height + player.height) / 2) {
                    // Player hit by enemy!
                    // Check if drill is facing the enemy (works even after dig completes)
                    const enemyDx = enemy.x - playerCenterX;
                    const enemyDy = enemy.y - playerCenterY;
                    let drillFacingEnemy = false;
                    
                    // Check based on last dig direction OR current key held
                    const effectiveDirection = player.digging ? lastDigDirection : 
                        (keys.down ? 'down' : keys.up ? 'up' : keys.left ? 'left' : keys.right ? 'right' : lastDigDirection);
                    
                    if (effectiveDirection === 'down' && enemyDy > 0) drillFacingEnemy = true;
                    else if (effectiveDirection === 'up' && enemyDy < 0) drillFacingEnemy = true;
                    else if (effectiveDirection === 'left' && enemyDx < 0) drillFacingEnemy = true;
                    else if (effectiveDirection === 'right' && enemyDx > 0) drillFacingEnemy = true;
                    
                    // Also check if in slide animation toward enemy
                    if (slideAnimation.active) {
                        if (slideAnimation.direction === 'down' && enemyDy > 0) drillFacingEnemy = true;
                        else if (slideAnimation.direction === 'left' && enemyDx < 0) drillFacingEnemy = true;
                        else if (slideAnimation.direction === 'right' && enemyDx > 0) drillFacingEnemy = true;
                    }
                    
                    if (drillFacingEnemy) {
                        // Drill facing enemy - kill it and set grace period
                        killEnemy(i);
                        drillKillGracePeriod = 20; // ~0.33 second grace period
                        continue;
                    }
                    
                    // Check if we're in grace period from recent drill kill
                    if (drillKillGracePeriod > 0) {
                        // Still in grace period - kill enemy without taking damage
                        killEnemy(i);
                        continue;
                    }
                    
                    // Take damage from enemy
                    const shopArmor = getShopBonus('armor');
                    const damage = enemy.damage * (1 - (getEffectiveUpgrade('armor', 90) + shopArmor) / 100);
                    hull -= damage;
                    comboCount = 0;
                    comboTimer = 0;
                    createFloatingText(`-${Math.floor(damage)}`, player.x + player.width/2, player.y, '#ff3355');
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff3355', 8);
                    triggerScreenFlash('#ff0000', 0.3, 10);
                    screenShake = 8;
                    updateHullBar();
                    
                    // Kill enemy after contact
                    enemies.splice(i, 1);
                    continue;
                }
                
                // Check if player is drilling into enemy's tile (for enemies not yet colliding)
                if (player.digging && player.digTarget) {
                    const digTx = player.digTarget.x;
                    const digTy = player.digTarget.y;
                    if (enemy.tx === digTx && enemy.ty === digTy) {
                        // Player drilling into enemy tile - kill enemy
                        killEnemy(i);
                        drillKillGracePeriod = 15; // ~0.25 second grace period
                        continue;
                    }
                }
                
                // Remove enemies that are too far above camera
                if (enemy.y < cameraY - 200) {
                    enemies.splice(i, 1);
                }
            }
        }
        
        function killEnemy(index) {
            const enemy = enemies[index];
            
            // Reward
            const baseValue = enemy.type === ENEMY_TYPE.LAVA_SLUG ? 30 : 
                             enemy.type === ENEMY_TYPE.WORM ? 20 : 15;
            const totalGemBonus = permanentUpgrades.gemValue + getShopBonus('gemValue');
            const value = Math.floor(baseValue * (1 + totalGemBonus / 100));
            score += value;
            updateScoreDisplay();
            
            // Effects
            const color = enemy.type === ENEMY_TYPE.LAVA_SLUG ? '#ff6600' : 
                         enemy.type === ENEMY_TYPE.WORM ? '#88ff88' : '#ffaa00';
            createFloatingText(`+${value} `, enemy.x, enemy.y - 10, color);
            createParticles(enemy.x, enemy.y, color, 12);
            screenShake = 4;
            
            enemies.splice(index, 1);
        }
        
        // ==================== BOSS ARENA SYSTEM ====================
        function checkPortalCollision() {
            // Check if player is touching a portal tile
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            
            // Check tiles around player
            const checkPoints = [
                [playerCenterX, player.y + player.height - 5], // Bottom center
                [player.x + 5, playerCenterY],                  // Left
                [player.x + player.width - 5, playerCenterY],   // Right
                [playerCenterX, player.y + 5]                   // Top
            ];
            
            for (const [px, py] of checkPoints) {
                const tile = getTile(px, py);
                if (tile === TILE.PORTAL || tile === TILE.PORTAL_PART) {
                    // Found portal! Calculate which depth it is
                    const tileRow = Math.floor(py / TILE_SIZE);
                    
                    // Find matching portal
                    for (const portal of portalLocations) {
                        const portalRow = portal.depth + 2;
                        if (Math.abs(tileRow - portalRow) <= 1 && portal.spawned) {
                            // Check if already defeated
                            if (bossKeys.includes(portal.depth)) {
                                // Already beaten - convert to air and continue
                                const tx = Math.floor(px / TILE_SIZE);
                                const ty = getWorldRow(tileRow);
                                if (ty >= 0 && ty < world.length) {
                                    world[ty][tx] = TILE.AIR;
                                }
                                return;
                            }
                            
                            // Check portal cooldown (must be 3+ tiles away to re-enter)
                            if (portalCooldown[portal.depth]) {
                                // Portal is on cooldown, check if player is far enough
                                const portalCenterX = portal.tx * TILE_SIZE + TILE_SIZE;
                                const portalCenterY = portalRow * TILE_SIZE + TILE_SIZE;
                                const distX = Math.abs(player.x + player.width/2 - portalCenterX);
                                const distY = Math.abs(player.y + player.height/2 - portalCenterY);
                                const tileDist = Math.max(distX, distY) / TILE_SIZE;
                                
                                if (tileDist < 3) {
                                    // Still too close, don't enter
                                    return;
                                } else {
                                    // Far enough, clear cooldown
                                    delete portalCooldown[portal.depth];
                                }
                            }
                            
                            // Enter boss arena with teleport effect!
                            triggerPortalTeleport(portal.depth);
                            return;
                        }
                    }
                }
            }
        }
        
        function triggerPortalTeleport(portalDepth) {
            // Teleportation animation before entering arena
            bossTransitionPhase = 'teleporting';
            bossTransitionTimer = 90; // 1.5 second teleport animation
            currentBossDepth = portalDepth;
            
            // Create swirling teleport particles around player
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const dist = 20 + Math.random() * 40;
                particles.push({
                    x: player.x + player.width / 2 + Math.cos(angle) * dist,
                    y: player.y + player.height / 2 + Math.sin(angle) * dist,
                    vx: -Math.cos(angle) * 2,
                    vy: -Math.sin(angle) * 2,
                    size: 3 + Math.random() * 4,
                    color: Math.random() < 0.5 ? '#ff00ff' : '#aa00ff',
                    life: 1.5
                });
            }
            
            screenShake = 10;
            triggerScreenFlash('#ff00ff', 0.5, 30);
            
            // Disable player control during teleport
            player.digging = false;
            player.digTarget = null;
        }
        
        function enterBossArena(portalDepth) {
            // Show intro screen instead of entering directly
            showBossIntro(portalDepth);
        }
        
        function initBoss(portalDepth) {
            const bossType = getBossTypeForDepth(portalDepth);
            const difficulty = getBossDifficultyMultiplier(portalDepth);
            
            // Arena dimensions (slightly smaller than game canvas)
            const arenaPixelWidth = BASE_WIDTH - 28;
            const arenaPixelHeight = BASE_HEIGHT - 60;
            bossArena.width = Math.floor(arenaPixelWidth / TILE_SIZE);
            bossArena.height = Math.floor(arenaPixelHeight / TILE_SIZE);
            bossArena.offsetX = 14; // Center arena
            bossArena.offsetY = 30;
            bossArena.tiles = [];
            bossArena.particles = [];
            bossArena.projectiles = [];
            bossArena.weakPoints = [];
            bossArena.hazards = [];
            
            // Generate arena terrain (alien cavern)
            generateBossArena(bossType);
            
            // Create boss entity
            boss = {
                type: bossType,
                x: arenaPixelWidth / 2 + bossArena.offsetX,
                y: arenaPixelHeight / 3 + bossArena.offsetY,
                width: 56,
                height: 56,
                maxHealth: Math.floor(getBossBaseHealth(bossType) * difficulty),
                health: Math.floor(getBossBaseHealth(bossType) * difficulty),
                damage: Math.floor(getBossBaseDamage(bossType) * difficulty),
                phase: 1,
                maxPhases: 3,
                phaseTimer: 0,
                attackTimer: 0,
                attackCooldown: 90,
                state: 'idle', // idle, burrowing, attacking, vulnerable, stunned
                stateTimer: 0,
                animFrame: 0,
                targetX: 0,
                targetY: 0,
                burrowProgress: 0,
                vulnerableTimer: 0,
                hitCount: 0,
                hitsToStun: 3
            };
            
            // Position player at bottom of arena in cleared spawn zone
            const spawnTileY = bossArena.height - 3; // Match the cleared zone
            player.x = arenaPixelWidth / 2 - player.width / 2 + bossArena.offsetX;
            player.y = spawnTileY * TILE_SIZE + bossArena.offsetY;
        }
        
        function getBossBaseHealth(bossType) {
            switch(bossType) {
                case BOSS_TYPE.BURROWER: return 3;
                case BOSS_TYPE.CRYSTAL_GOLEM: return 4;
                case BOSS_TYPE.LAVA_WURM: return 4;
                case BOSS_TYPE.HIVE_MIND: return 5;
                case BOSS_TYPE.COLLECTOR: return 5;
                default: return 3;
            }
        }
        
        function getBossBaseDamage(bossType) {
            switch(bossType) {
                case BOSS_TYPE.BURROWER: return 10;
                case BOSS_TYPE.CRYSTAL_GOLEM: return 15;
                case BOSS_TYPE.LAVA_WURM: return 20;
                case BOSS_TYPE.HIVE_MIND: return 15;
                case BOSS_TYPE.COLLECTOR: return 25;
                default: return 10;
            }
        }
        
        function getBossName(bossType) {
            switch(bossType) {
                case BOSS_TYPE.BURROWER: return 'THE BURROWER';
                case BOSS_TYPE.CRYSTAL_GOLEM: return 'CRYSTAL GOLEM';
                case BOSS_TYPE.LAVA_WURM: return 'LAVA WURM';
                case BOSS_TYPE.HIVE_MIND: return 'HIVE MIND';
                case BOSS_TYPE.COLLECTOR: return 'THE COLLECTOR';
                default: return 'UNKNOWN ENTITY';
            }
        }
        
        function getBossIcon(bossType) {
            switch(bossType) {
                case BOSS_TYPE.BURROWER: return '';
                case BOSS_TYPE.CRYSTAL_GOLEM: return '';
                case BOSS_TYPE.LAVA_WURM: return '';
                case BOSS_TYPE.HIVE_MIND: return '';
                case BOSS_TYPE.COLLECTOR: return '';
                default: return '';
            }
        }
        
        function getBossObjective(bossType) {
            switch(bossType) {
                case BOSS_TYPE.BURROWER: 
                    return 'Dodge the acid spit when it surfaces! It turns GREEN after attacking - drill it then to deal damage!';
                case BOSS_TYPE.CRYSTAL_GOLEM: 
                    return 'Dodge shockwaves and crystals! After it attacks, drill it while EXPOSED (yellow ring). Stun it to expose the core (cyan ring) for damage!';
                case BOSS_TYPE.LAVA_WURM: 
                    return 'Survive the rising lava while attacking the Wurm. Stay mobile and watch for its dive attacks!';
                case BOSS_TYPE.HIVE_MIND: 
                    return 'Destroy the smaller drones to weaken the Hive Mind. Target the core when its shields drop!';
                case BOSS_TYPE.COLLECTOR: 
                    return 'This ancient machine uses all previous boss abilities. Adapt quickly and exploit each vulnerability!';
                default: 
                    return 'Defeat the boss to obtain a key for the gate below!';
            }
        }
        
        function getBossTip(bossType) {
            switch(bossType) {
                case BOSS_TYPE.BURROWER: 
                    return ' Tip: Dodge the acid spit when it surfaces, then drill when it turns GREEN!';
                case BOSS_TYPE.CRYSTAL_GOLEM: 
                    return ' Tip: Jump shockwaves! Attack when you see EXPOSED, then drill the cyan core!';
                case BOSS_TYPE.LAVA_WURM: 
                    return ' Tip: Stay near the top but watch for ceiling attacks!';
                case BOSS_TYPE.HIVE_MIND: 
                    return ' Tip: Clear drones first - they heal the core!';
                case BOSS_TYPE.COLLECTOR: 
                    return ' Tip: It cycles through boss patterns - recognize them!';
                default: 
                    return ' Tip: Watch the boss patterns and strike when safe!';
            }
        }
        
        function showBossIntro(portalDepth) {
            const bossType = getBossTypeForDepth(portalDepth);
            
            document.getElementById('bossIntroIcon').textContent = getBossIcon(bossType);
            document.getElementById('bossIntroName').textContent = getBossName(bossType);
            document.getElementById('bossIntroDepth').textContent = `Depth: ${portalDepth}m`;
            document.getElementById('bossIntroObjective').textContent = getBossObjective(bossType);
            document.getElementById('bossIntroTip').textContent = getBossTip(bossType);
            
            document.getElementById('bossIntroOverlay').classList.add('active');
            
            // Store depth for battle button
            document.getElementById('bossIntroOverlay').dataset.portalDepth = portalDepth;
        }
        
        function hideBossIntro() {
            document.getElementById('bossIntroOverlay').classList.remove('active');
        }
        
        function startBossBattle() {
            const portalDepth = parseInt(document.getElementById('bossIntroOverlay').dataset.portalDepth);
            hideBossIntro();
            
            // Reset combat state
            playerInvulnerable = 0;
            bossHitFlash = 0;
            bossInvulnerable = 0;
            
            // Find portal location for return
            const portalInfo = portalLocations.find(p => p.depth === portalDepth);
            
            // Now actually enter the arena
            currentBossDepth = portalDepth;
            bossArenaActive = true;
            bossTransitionPhase = 'entering';
            bossTransitionTimer = 60;
            
            // Store portal location for return teleport
            bossArena.portalTx = portalInfo ? portalInfo.tx : Math.floor(WORLD_WIDTH / 2);
            bossArena.portalRow = portalDepth + 2;
            
            // Store player state for return
            bossArena.savedPlayerX = player.x;
            bossArena.savedPlayerY = player.y;
            bossArena.savedCameraY = cameraY;
            
            // Initialize healing pickups
            bossArena.healingPickups = [];
            bossArena.healingTimer = 25 * 60; // 25 seconds at 60fps
            
            // Reset camera for boss arena
            cameraY = 0;
            
            // Initialize boss
            initBoss(portalDepth);
        }
        
        function leaveBossPortal() {
            hideBossIntro();
            // Player just walks away - no penalty
            createFloatingText('Retreated from portal...', player.x + player.width/2, player.y - 20, '#888888');
        }
        
        // Set up boss intro button handlers
        document.getElementById('bossIntroBattle').addEventListener('click', startBossBattle);
        document.getElementById('bossIntroLeave').addEventListener('click', leaveBossPortal);
        document.getElementById('bossIntroBattle').addEventListener('touchend', function(e) {
            e.preventDefault();
            startBossBattle();
        });
        document.getElementById('bossIntroLeave').addEventListener('touchend', function(e) {
            e.preventDefault();
            leaveBossPortal();
        });
        
        function generateBossArena(bossType) {
            // Create alien cavern terrain - all interior is AIR (no diggable blocks)
            for (let y = 0; y < bossArena.height; y++) {
                const row = [];
                for (let x = 0; x < bossArena.width; x++) {
                    // Walls around edges - use BEDROCK (indestructible look)
                    if (x === 0 || x === bossArena.width - 1 || 
                        y === 0 || y === bossArena.height - 1) {
                        row.push(TILE.BEDROCK);
                    }
                    // Second layer of walls (irregular) - also BEDROCK
                    else if ((x === 1 || x === bossArena.width - 2) && Math.random() < 0.6) {
                        row.push(TILE.BEDROCK);
                    }
                    else if ((y === 1 || y === bossArena.height - 2) && Math.random() < 0.4) {
                        row.push(TILE.BEDROCK);
                    }
                    // All interior is AIR - no diggable blocks in boss fights
                    else {
                        row.push(TILE.AIR);
                    }
                }
                bossArena.tiles.push(row);
            }
            
            // Clear a safe spawn zone at bottom center (3x3 area)
            const spawnCenterX = Math.floor(bossArena.width / 2);
            const spawnCenterY = bossArena.height - 3;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const tx = spawnCenterX + dx;
                    const ty = spawnCenterY + dy;
                    if (tx > 0 && tx < bossArena.width - 1 && 
                        ty > 0 && ty < bossArena.height - 1) {
                        bossArena.tiles[ty][tx] = TILE.AIR;
                    }
                }
            }
        }
        
        function updateBossArena() {
            if (!bossArenaActive) return;
            // Allow execution during 'exiting' even if boss is null
            if (!boss && bossTransitionPhase !== 'exiting') return;
            
            // Update global time for animations
            globalTime = (globalTime + deltaMultiplier) % 100000;
            
            // Handle screen shake
            if (screenShake > 0) {
                screenShake *= 0.85;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            // Handle transitions
            if (bossTransitionPhase === 'entering') {
                bossTransitionTimer--;
                if (bossTransitionTimer <= 0) {
                    bossTransitionPhase = 'active';
                }
                return;
            }
            
            if (bossTransitionPhase === 'victory_screen') {
                // Just update particles for visual effect, wait for player to click teleport
                updateBossParticles();
                return;
            }
            
            if (bossTransitionPhase === 'victory') {
                bossTransitionTimer--;
                if (bossTransitionTimer <= 0) {
                    exitBossArena(true);
                }
                return;
            }
            
            if (bossTransitionPhase === 'exiting') {
                bossTransitionTimer--;
                if (bossTransitionTimer <= 0) {
                    bossArenaActive = false;
                    bossTransitionPhase = 'none';
                    boss = null;
                }
                return;
            }
            
            // Player movement in boss arena
            updateBossArenaPlayer();
            
            // Decrement invulnerability timers
            if (playerInvulnerable > 0) {
                playerInvulnerable--;
            }
            if (bossInvulnerable > 0) {
                bossInvulnerable--;
            }
            
            // Boss AI
            updateBossAI();
            
            // Update projectiles
            updateBossProjectiles();
            
            // Update particles
            updateBossParticles();
            
            // Check player collision with boss
            checkBossCollision();
            
            // Update healing pickups
            updateHealingPickups();
            
            // Check if boss defeated
            if (boss.health <= 0) {
                triggerBossVictory();
            }
            
            // Check player death
            if (hull <= 0) {
                // Boss death = game over
                deathReason = 'hull';
                gameOver();
            }
        }
        
        // Healing pickup system for boss fights
        function updateHealingPickups() {
            // Countdown to spawn new healing pickup
            bossArena.healingTimer--;
            
            if (bossArena.healingTimer <= 0) {
                // Spawn new healing pickup only if none currently exists
                if (bossArena.healingPickups.length === 0) {
                    spawnHealingPickup();
                }
                bossArena.healingTimer = 25 * 60; // Reset to 25 seconds
            }
            
            // Update existing pickups
            for (let i = bossArena.healingPickups.length - 1; i >= 0; i--) {
                const pickup = bossArena.healingPickups[i];
                
                // Fade-in animation (3 seconds = 180 frames)
                if (pickup.spawnTimer < 180) {
                    pickup.spawnTimer++;
                }
                
                // Check player collision (only when visible enough)
                if (pickup.spawnTimer > 90) { // After 1.5s of spawn animation
                    const dx = (player.x + player.width/2) - pickup.x;
                    const dy = (player.y + player.height/2) - pickup.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 20) {
                        // Collect healing!
                        const healAmount = Math.floor(maxHull * 0.3); // 30% hull heal
                        hull = Math.min(hull + healAmount, maxHull);
                        updateHullBar();
                        
                        // Feedback
                        createFloatingText(` +${healAmount} HULL`, pickup.x, pickup.y - 20, '#00ff88');
                        triggerScreenFlash('#00ff88', 0.3, 15);
                        
                        // Healing particles
                        for (let j = 0; j < 15; j++) {
                            bossArena.particles.push({
                                x: pickup.x,
                                y: pickup.y,
                                vx: (Math.random() - 0.5) * 8,
                                vy: (Math.random() - 0.5) * 8 - 2,
                                size: 3 + Math.random() * 4,
                                color: Math.random() < 0.5 ? '#00ff88' : '#88ffaa',
                                life: 1
                            });
                        }
                        
                        // Remove pickup
                        bossArena.healingPickups.splice(i, 1);
                    }
                }
            }
        }
        
        function spawnHealingPickup() {
            // Random position within arena bounds
            const minX = bossArena.offsetX + TILE_SIZE * 3;
            const maxX = bossArena.offsetX + (bossArena.width - 3) * TILE_SIZE;
            const minY = bossArena.offsetY + TILE_SIZE * 3;
            const maxY = bossArena.offsetY + (bossArena.height - 4) * TILE_SIZE;
            
            const x = minX + Math.random() * (maxX - minX);
            const y = minY + Math.random() * (maxY - minY);
            
            bossArena.healingPickups.push({
                x: x,
                y: y,
                spawnTimer: 0 // 0-180 for fade-in animation
            });
        }
        
        function updateBossArenaPlayer() {
            // Simplified player movement for boss arena
            const moveSpeed = player.speed * 1.2; // Slightly faster in arena
            
            let dx = 0, dy = 0;
            
            if (keys.left) dx = -moveSpeed;
            if (keys.right) dx = moveSpeed;
            if (keys.up) dy = -moveSpeed * 0.8;
            if (keys.down) dy = moveSpeed * 0.5;
            
            // Apply movement with arena bounds checking
            const newX = player.x + dx * deltaMultiplier;
            const newY = player.y + dy * deltaMultiplier;
            
            // Arena bounds (with offset)
            const minX = bossArena.offsetX + TILE_SIZE * 2;
            const maxX = bossArena.offsetX + (bossArena.width - 2) * TILE_SIZE - player.width;
            const minY = bossArena.offsetY + TILE_SIZE * 2;
            const maxY = bossArena.offsetY + (bossArena.height - 2) * TILE_SIZE - player.height;
            
            // Check arena tile collision
            const tileX = Math.floor((newX + player.width / 2 - bossArena.offsetX) / TILE_SIZE);
            const tileY = Math.floor((newY + player.height / 2 - bossArena.offsetY) / TILE_SIZE);
            
            let canMoveX = true;
            let canMoveY = true;
            
            // Check X movement
            const checkTileX = Math.floor((newX + (dx > 0 ? player.width : 0) - bossArena.offsetX) / TILE_SIZE);
            if (checkTileX >= 0 && checkTileX < bossArena.width) {
                for (let y = 0; y < 2; y++) {
                    const checkY = Math.floor((player.y + y * player.height * 0.8 - bossArena.offsetY) / TILE_SIZE);
                    if (checkY >= 0 && checkY < bossArena.height) {
                        const tile = bossArena.tiles[checkY] ? bossArena.tiles[checkY][checkTileX] : TILE.BEDROCK;
                        if (tile !== TILE.AIR && tile !== TILE.DIRT) {
                            canMoveX = false;
                            break;
                        }
                    }
                }
            }
            
            // Check Y movement
            const checkTileY = Math.floor((newY + (dy > 0 ? player.height : 0) - bossArena.offsetY) / TILE_SIZE);
            if (checkTileY >= 0 && checkTileY < bossArena.height) {
                for (let x = 0; x < 2; x++) {
                    const checkX = Math.floor((player.x + x * player.width * 0.8 - bossArena.offsetX) / TILE_SIZE);
                    if (checkX >= 0 && checkX < bossArena.width) {
                        const tile = bossArena.tiles[checkTileY] ? bossArena.tiles[checkTileY][checkX] : TILE.BEDROCK;
                        if (tile !== TILE.AIR && tile !== TILE.DIRT) {
                            canMoveY = false;
                            break;
                        }
                    }
                }
            }
            
            if (canMoveX && newX >= minX && newX <= maxX) {
                player.x = newX;
            }
            if (canMoveY && newY >= minY && newY <= maxY) {
                player.y = newY;
            }
            
            // Simple gravity in arena
            if (!keys.up && canMoveY) {
                const gravityY = player.y + 2 * deltaMultiplier;
                const gravTileY = Math.floor((gravityY + player.height - bossArena.offsetY) / TILE_SIZE);
                if (gravTileY >= 0 && gravTileY < bossArena.height) {
                    const centerTileX = Math.floor((player.x + player.width / 2 - bossArena.offsetX) / TILE_SIZE);
                    const groundTile = bossArena.tiles[gravTileY] ? bossArena.tiles[gravTileY][centerTileX] : TILE.BEDROCK;
                    if (groundTile === TILE.AIR || groundTile === TILE.DIRT) {
                        player.y = Math.min(gravityY, maxY);
                    }
                }
            }
            
            // Digging state for boss collision detection
            player.digging = keys.down || keys.left || keys.right;
            
            // Thruster animation
            player.thrusterFlicker = Math.sin(globalTime * 0.3) * 0.3 + 0.7;
        }
        
        function updateBossAI() {
            boss.animFrame = (boss.animFrame + 0.1 * deltaMultiplier) % (Math.PI * 2);
            boss.attackTimer += deltaMultiplier;
            boss.stateTimer += deltaMultiplier;
            
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            
            switch(boss.type) {
                case BOSS_TYPE.BURROWER:
                    updateBurrowerAI(playerCenterX, playerCenterY);
                    break;
                case BOSS_TYPE.CRYSTAL_GOLEM:
                    updateCrystalGolemAI(playerCenterX, playerCenterY);
                    break;
                // Other bosses will be added in future updates
                default:
                    updateBurrowerAI(playerCenterX, playerCenterY);
            }
        }
        
        function updateBurrowerAI(playerX, playerY) {
            // The Burrower: Burrows through dirt, surfaces to attack, vulnerable when exposed
            
            switch(boss.state) {
                case 'idle':
                    // Choose next action
                    if (boss.attackTimer >= boss.attackCooldown) {
                        boss.state = 'burrowing';
                        boss.stateTimer = 0;
                        boss.burrowProgress = 0;
                        boss.burrowPhase = 0; // Track which phase of burrowing
                        boss.burrowWaypoints = [];
                        
                        // Create 2-3 random waypoints before targeting player
                        const numWaypoints = 2 + Math.floor(Math.random() * 2);
                        const arenaLeft = bossArena.offsetX + TILE_SIZE * 3;
                        const arenaRight = bossArena.offsetX + (bossArena.width - 3) * TILE_SIZE;
                        const arenaTop = bossArena.offsetY + TILE_SIZE * 3;
                        const arenaBottom = bossArena.offsetY + (bossArena.height - 4) * TILE_SIZE;
                        
                        for (let i = 0; i < numWaypoints; i++) {
                            boss.burrowWaypoints.push({
                                x: arenaLeft + Math.random() * (arenaRight - arenaLeft),
                                y: arenaTop + Math.random() * (arenaBottom - arenaTop)
                            });
                        }
                        
                        // Final waypoint: predict where player will be
                        const predictOffset = (Math.random() - 0.5) * 60;
                        boss.burrowWaypoints.push({
                            x: playerX + predictOffset,
                            y: playerY - 50 + (Math.random() - 0.5) * 30
                        });
                        
                        // Set first target
                        boss.targetX = boss.burrowWaypoints[0].x;
                        boss.targetY = boss.burrowWaypoints[0].y;
                        
                        // Find nearest dirt to burrow into
                        const tx = Math.floor((boss.x - bossArena.offsetX) / TILE_SIZE);
                        const ty = Math.floor((boss.y - bossArena.offsetY) / TILE_SIZE);
                        if (tx >= 0 && tx < bossArena.width && ty >= 0 && ty < bossArena.height) {
                            bossArena.tiles[ty][tx] = TILE.DIRT;
                        }
                    }
                    break;
                    
                case 'burrowing':
                    boss.burrowProgress += 0.008 * deltaMultiplier; // Slower overall progress
                    
                    // Move toward current waypoint
                    const dx = boss.targetX - boss.x;
                    const dy = boss.targetY - boss.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Variable speed - faster between waypoints, slower near target
                    const isLastWaypoint = boss.burrowPhase >= boss.burrowWaypoints.length - 1;
                    const speed = isLastWaypoint ? 2.5 : 3.5;
                    
                    if (dist > 10) {
                        // Add slight wobble to movement
                        const wobble = Math.sin(boss.burrowProgress * 20) * 0.3;
                        boss.x += ((dx / dist) + wobble) * speed * deltaMultiplier;
                        boss.y += (dy / dist) * speed * deltaMultiplier;
                        
                        // Leave dirt trail (burrow effect) - more particles
                        if (Math.random() < 0.4) {
                            bossArena.particles.push({
                                x: boss.x + (Math.random() - 0.5) * 40,
                                y: boss.y + (Math.random() - 0.5) * 40,
                                vx: (Math.random() - 0.5) * 3,
                                vy: -Math.random() * 3 - 1,
                                size: 3 + Math.random() * 5,
                                color: '#5a4030',
                                life: 0.9
                            });
                        }
                        
                        // Ground rumble indicator
                        if (Math.random() < 0.15) {
                            screenShake = Math.max(screenShake, 2);
                        }
                    } else {
                        // Reached waypoint - move to next or surface
                        boss.burrowPhase++;
                        
                        if (boss.burrowPhase < boss.burrowWaypoints.length) {
                            // Update target to next waypoint
                            const nextWP = boss.burrowWaypoints[boss.burrowPhase];
                            boss.targetX = nextWP.x;
                            boss.targetY = nextWP.y;
                            
                            // On last waypoint, update to current player position for better tracking
                            if (boss.burrowPhase === boss.burrowWaypoints.length - 1) {
                                const finalPredictOffset = (Math.random() - 0.5) * 40;
                                boss.targetX = playerX + finalPredictOffset;
                                boss.targetY = playerY - 40;
                            }
                        }
                    }
                    
                    // Surface when progress complete OR reached final waypoint
                    if (boss.burrowProgress >= 1 || (boss.burrowPhase >= boss.burrowWaypoints.length && dist <= 15)) {
                        boss.state = 'attacking';
                        boss.stateTimer = 0;
                        screenShake = 12;
                        triggerScreenFlash('#ff6600', 0.4, 12);
                        
                        // Spawn dirt explosion
                        for (let i = 0; i < 18; i++) {
                            bossArena.particles.push({
                                x: boss.x,
                                y: boss.y,
                                vx: (Math.random() - 0.5) * 10,
                                vy: -2 - Math.random() * 7,
                                size: 4 + Math.random() * 6,
                                color: Math.random() < 0.5 ? '#5a4030' : '#3d2d20',
                                life: 1.2
                            });
                        }
                        
                        createFloatingText(' SURFACE!', boss.x, boss.y - 50, '#ff6600');
                    }
                    break;
                    
                case 'attacking':
                    // Surface and attack - fire projectiles then become vulnerable
                    
                    // Telegraph first shot (charging particles)
                    if (boss.stateTimer >= 5 && boss.stateTimer < 18) {
                        if (Math.random() < 0.4) {
                            const angle = Math.atan2(playerY - boss.y, playerX - boss.x);
                            bossArena.particles.push({
                                x: boss.x + (Math.random() - 0.5) * 30,
                                y: boss.y + (Math.random() - 0.5) * 30,
                                vx: Math.cos(angle) * 1 + (Math.random() - 0.5),
                                vy: Math.sin(angle) * 1 + (Math.random() - 0.5),
                                size: 2 + Math.random() * 2,
                                color: '#ff66ff',
                                life: 0.4
                            });
                        }
                    }
                    
                    // Fire first projectile
                    if (boss.stateTimer >= 18 && boss.stateTimer < 20) {
                        if (!boss.firedShot1) {
                            boss.firedShot1 = true;
                            const angle = Math.atan2(playerY - boss.y, playerX - boss.x);
                            bossArena.projectiles.push({
                                x: boss.x,
                                y: boss.y,
                                vx: Math.cos(angle) * 2.5,
                                vy: Math.sin(angle) * 2.5,
                                radius: 10,
                                damage: 8,
                                life: 4,
                                color: '#aa44ff'
                            });
                            // Spit particles
                            for (let i = 0; i < 6; i++) {
                                bossArena.particles.push({
                                    x: boss.x,
                                    y: boss.y,
                                    vx: Math.cos(angle) * 3 + (Math.random() - 0.5) * 2,
                                    vy: Math.sin(angle) * 3 + (Math.random() - 0.5) * 2,
                                    size: 2 + Math.random() * 3,
                                    color: '#cc66ff',
                                    life: 0.5
                                });
                            }
                        }
                    }
                    
                    // Telegraph second shot (charging particles)
                    if (boss.stateTimer >= 38 && boss.stateTimer < 50) {
                        if (Math.random() < 0.4) {
                            const angle = Math.atan2(playerY - boss.y, playerX - boss.x);
                            bossArena.particles.push({
                                x: boss.x + (Math.random() - 0.5) * 30,
                                y: boss.y + (Math.random() - 0.5) * 30,
                                vx: Math.cos(angle) * 1 + (Math.random() - 0.5),
                                vy: Math.sin(angle) * 1 + (Math.random() - 0.5),
                                size: 2 + Math.random() * 2,
                                color: '#ff66ff',
                                life: 0.4
                            });
                        }
                    }
                    
                    // Fire second projectile
                    if (boss.stateTimer >= 50 && boss.stateTimer < 52) {
                        if (!boss.firedShot2) {
                            boss.firedShot2 = true;
                            const angle = Math.atan2(playerY - boss.y, playerX - boss.x);
                            bossArena.projectiles.push({
                                x: boss.x,
                                y: boss.y,
                                vx: Math.cos(angle) * 2.5,
                                vy: Math.sin(angle) * 2.5,
                                radius: 10,
                                damage: 8,
                                life: 4,
                                color: '#aa44ff'
                            });
                            // Spit particles
                            for (let i = 0; i < 6; i++) {
                                bossArena.particles.push({
                                    x: boss.x,
                                    y: boss.y,
                                    vx: Math.cos(angle) * 3 + (Math.random() - 0.5) * 2,
                                    vy: Math.sin(angle) * 3 + (Math.random() - 0.5) * 2,
                                    size: 2 + Math.random() * 3,
                                    color: '#cc66ff',
                                    life: 0.5
                                });
                            }
                        }
                    }
                    
                    // Become vulnerable after attack
                    if (boss.stateTimer >= 65) {
                        boss.state = 'vulnerable';
                        boss.stateTimer = 0;
                        boss.vulnerableTimer = 120; // 2 seconds vulnerable
                        boss.firedShot1 = false;
                        boss.firedShot2 = false;
                        
                        // Spawn weak point
                        bossArena.weakPoints = [{
                            x: boss.x,
                            y: boss.y,
                            radius: 20,
                            active: true
                        }];
                        
                        createFloatingText(' DIG NOW!', boss.x, boss.y - 40, '#00ff88');
                    }
                    break;
                    
                case 'vulnerable':
                    boss.vulnerableTimer -= deltaMultiplier;
                    
                    // Pulse effect
                    const pulse = Math.sin(globalTime * 0.3) * 0.3;
                    boss.width = 56 + pulse * 8;
                    boss.height = 56 + pulse * 8;
                    
                    if (boss.vulnerableTimer <= 0) {
                        boss.state = 'idle';
                        boss.stateTimer = 0;
                        boss.attackTimer = 0;
                        boss.width = 56;
                        boss.height = 56;
                        bossArena.weakPoints = [];
                    }
                    break;
                    
                case 'stunned':
                    if (boss.stateTimer >= 60) {
                        boss.state = 'idle';
                        boss.stateTimer = 0;
                        boss.attackTimer = 0;
                        boss.hitCount = 0;
                    }
                    break;
            }
        }
        
        function updateCrystalGolemAI(playerX, playerY) {
            // Crystal Golem: Walks side to side, slams ground for shockwaves, shoots crystals
            // Hit it during recovery to stun, then drill the core
            
            // Initialize golem-specific properties if needed
            if (boss.walkDirection === undefined) {
                boss.walkDirection = 1;
                boss.slamCount = 0;
                boss.shotsFired = 0;
            }
            
            const arenaLeft = bossArena.offsetX + TILE_SIZE * 2;
            const arenaRight = bossArena.offsetX + (bossArena.width - 2) * TILE_SIZE;
            const groundY = bossArena.offsetY + (bossArena.height - 3) * TILE_SIZE;
            
            // Keep golem on ground for most states
            if (boss.state !== 'windup') {
                boss.y = groundY;
            }
            
            switch(boss.state) {
                case 'idle':
                    // Walk side to side
                    boss.x += boss.walkDirection * 1.5 * deltaMultiplier;
                    
                    // Bounce off walls
                    if (boss.x <= arenaLeft) {
                        boss.x = arenaLeft;
                        boss.walkDirection = 1;
                    } else if (boss.x >= arenaRight) {
                        boss.x = arenaRight;
                        boss.walkDirection = -1;
                    }
                    
                    // Attack pattern
                    if (boss.attackTimer >= boss.attackCooldown) {
                        boss.attackTimer = 0;
                        boss.slamCount++;
                        
                        // Alternate between slam and shoot
                        if (boss.slamCount % 3 === 0) {
                            boss.state = 'shooting';
                            boss.stateTimer = 0;
                            boss.shotsFired = 0;
                        } else {
                            boss.state = 'windup';
                            boss.stateTimer = 0;
                        }
                    }
                    break;
                    
                case 'windup':
                    // Pause before slam - small hop
                    boss.y = groundY - Math.sin(boss.stateTimer * 0.1) * 8;
                    
                    if (boss.stateTimer >= 25) {
                        boss.state = 'slam';
                        boss.stateTimer = 0;
                    }
                    break;
                    
                case 'slam':
                    // Ground slam - create shockwave on first frame
                    if (boss.stateTimer < 2) {
                        screenShake = 15;
                        triggerScreenFlash('#8844ff', 0.4, 12);
                        
                        // Create shockwave projectiles that travel along ground
                        const shockwaveY = groundY + 15;
                        bossArena.projectiles.push({
                            x: boss.x - 25,
                            y: shockwaveY,
                            vx: -3.5,
                            vy: 0,
                            radius: 14,
                            damage: 12,
                            life: 2.5,
                            color: '#aa66ff',
                            type: 'shockwave'
                        });
                        bossArena.projectiles.push({
                            x: boss.x + 25,
                            y: shockwaveY,
                            vx: 3.5,
                            vy: 0,
                            radius: 14,
                            damage: 12,
                            life: 2.5,
                            color: '#aa66ff',
                            type: 'shockwave'
                        });
                        
                        // Ground particles
                        for (let i = 0; i < 10; i++) {
                            bossArena.particles.push({
                                x: boss.x + (Math.random() - 0.5) * 50,
                                y: groundY,
                                vx: (Math.random() - 0.5) * 5,
                                vy: -2 - Math.random() * 3,
                                size: 3 + Math.random() * 4,
                                color: Math.random() < 0.5 ? '#7744cc' : '#553388',
                                life: 0.7
                            });
                        }
                    }
                    
                    // Recovery period - CAN BE HIT during this time
                    if (boss.stateTimer >= 35) {
                        boss.state = 'recovery';
                        boss.stateTimer = 0;
                        createFloatingText(' EXPOSED!', boss.x, boss.y - 50, '#ffff00');
                    }
                    break;
                    
                case 'shooting':
                    // Fire crystal projectiles at player
                    if (Math.floor(boss.stateTimer) % 18 === 0 && boss.shotsFired < 3) {
                        const angle = Math.atan2(playerY - boss.y, playerX - boss.x);
                        const spread = (Math.random() - 0.5) * 0.2;
                        
                        bossArena.projectiles.push({
                            x: boss.x,
                            y: boss.y - 15,
                            vx: Math.cos(angle + spread) * 3.5,
                            vy: Math.sin(angle + spread) * 3.5,
                            radius: 10,
                            damage: 10,
                            life: 3,
                            color: '#00ffff'
                        });
                        
                        boss.shotsFired++;
                        
                        // Crystal particles
                        for (let i = 0; i < 4; i++) {
                            bossArena.particles.push({
                                x: boss.x,
                                y: boss.y - 15,
                                vx: Math.cos(angle) * 2 + (Math.random() - 0.5) * 2,
                                vy: Math.sin(angle) * 2 + (Math.random() - 0.5) * 2,
                                size: 2 + Math.random() * 2,
                                color: '#66ffff',
                                life: 0.4
                            });
                        }
                    }
                    
                    if (boss.stateTimer >= 55) {
                        boss.state = 'recovery';
                        boss.stateTimer = 0;
                        createFloatingText(' EXPOSED!', boss.x, boss.y - 50, '#ffff00');
                    }
                    break;
                
                case 'recovery':
                    // Brief window where golem can be hit by drilling into it
                    // Wobble to show vulnerability
                    boss.x += Math.sin(boss.stateTimer * 0.3) * 0.5;
                    
                    if (boss.stateTimer >= 60) {
                        boss.state = 'idle';
                        boss.stateTimer = 0;
                    }
                    break;
                    
                case 'vulnerable':
                    // Exposed crystal core - can be drilled for damage
                    boss.vulnerableTimer -= deltaMultiplier;
                    
                    // Pulse effect
                    const pulse = Math.sin(globalTime * 0.3) * 0.3;
                    boss.width = 56 + pulse * 8;
                    boss.height = 56 + pulse * 8;
                    
                    // Weak point for drilling
                    if (bossArena.weakPoints.length === 0) {
                        bossArena.weakPoints = [{
                            x: boss.x,
                            y: boss.y,
                            radius: 30,
                            active: true
                        }];
                        createFloatingText(' DRILL THE CORE!', boss.x, boss.y - 50, '#00ff88');
                    } else {
                        // Update weak point position
                        bossArena.weakPoints[0].x = boss.x;
                        bossArena.weakPoints[0].y = boss.y;
                        bossArena.weakPoints[0].active = true;
                    }
                    
                    if (boss.vulnerableTimer <= 0) {
                        boss.state = 'idle';
                        boss.stateTimer = 0;
                        boss.attackTimer = 0;
                        boss.width = 56;
                        boss.height = 56;
                        bossArena.weakPoints = [];
                    }
                    break;
                    
                case 'stunned':
                    // Brief stun after being hit during recovery
                    if (boss.stateTimer >= 30) {
                        boss.state = 'vulnerable';
                        boss.stateTimer = 0;
                        boss.vulnerableTimer = 120; // 2 seconds to drill
                        boss.hitCount = 0;
                    }
                    break;
            }
        }
        
        function updateBossProjectiles() {
            for (let i = bossArena.projectiles.length - 1; i >= 0; i--) {
                const proj = bossArena.projectiles[i];
                proj.x += proj.vx * deltaMultiplier;
                proj.y += proj.vy * deltaMultiplier;
                proj.life -= 0.02 * deltaMultiplier;
                
                // Check player collision
                const dx = proj.x - (player.x + player.width / 2);
                const dy = proj.y - (player.y + player.height / 2);
                if (Math.sqrt(dx * dx + dy * dy) < proj.radius + 10) {
                    // Hit player
                    const shopArmor = getShopBonus('armor');
                    const damage = proj.damage * (1 - (getEffectiveUpgrade('armor', 90) + shopArmor) / 100);
                    hull -= damage;
                    updateHullBar();
                    createFloatingText(`-${Math.floor(damage)}`, player.x + player.width/2, player.y, '#ff3355');
                    triggerScreenFlash('#ff0000', 0.3, 10);
                    screenShake = 8;
                    bossArena.projectiles.splice(i, 1);
                    continue;
                }
                
                if (proj.life <= 0) {
                    bossArena.projectiles.splice(i, 1);
                }
            }
        }
        
        function updateBossParticles() {
            for (let i = bossArena.particles.length - 1; i >= 0; i--) {
                const p = bossArena.particles[i];
                p.x += p.vx * deltaMultiplier;
                p.y += p.vy * deltaMultiplier;
                p.vy += 0.15 * deltaMultiplier; // Gravity
                p.life -= 0.02 * deltaMultiplier;
                
                if (p.life <= 0) {
                    bossArena.particles.splice(i, 1);
                }
            }
            
            // Update floating texts in boss arena too
            let writeIndex = 0;
            for (let i = 0; i < floatingTexts.length; i++) {
                const t = floatingTexts[i];
                t.y -= 1.5 * deltaMultiplier;
                t.vy *= 0.94;
                t.life -= 0.006 * deltaMultiplier;
                t.scale = 0.8 + t.life * 0.5;
                if (t.life > 0) {
                    floatingTexts[writeIndex++] = t;
                }
            }
            floatingTexts.length = writeIndex;
            
            // Also process floating text queue in boss arena
            processFloatingTextQueue();
        }
        
        function checkBossCollision() {
            if (!boss || boss.state === 'burrowing') return;
            
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            
            // Check collision with boss body
            const dx = playerCenterX - boss.x;
            const dy = playerCenterY - boss.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < (boss.width / 2 + player.width / 2) && boss.state !== 'stunned') {
                // Check if player is digging (attacking)
                if (player.digging && (boss.state === 'vulnerable' || boss.state === 'recovery')) {
                    // Hit the boss! Recovery hits stun, vulnerable hits damage
                    if (boss.state === 'recovery') {
                        boss.hitCount++;
                        bossHitFlash = 12;
                        screenShake = 10;
                        triggerScreenFlash('#ffff00', 0.3, 10);
                        createFloatingText(' HIT!', boss.x, boss.y - 40, '#ffff00');
                        
                        if (boss.hitCount >= boss.hitsToStun) {
                            boss.state = 'stunned';
                            boss.stateTimer = 0;
                            createFloatingText(' STUNNED!', boss.x, boss.y - 55, '#00ffff');
                        }
                    } else {
                        damageBoss(1);
                    }
                } else if (boss.state === 'attacking' || boss.state === 'idle' || boss.state === 'slam' || boss.state === 'shooting') {
                    // Player takes damage from active boss
                    playerTakeDamage(boss.damage, dx, dy);
                }
            }
            
            // Check weak points (dig to damage)
            if (player.digging) {
                for (const wp of bossArena.weakPoints) {
                    if (!wp.active) continue;
                    
                    const wpDx = playerCenterX - wp.x;
                    const wpDy = playerCenterY - wp.y;
                    const wpDist = Math.sqrt(wpDx * wpDx + wpDy * wpDy);
                    
                    if (wpDist < wp.radius + 15) {
                        damageBoss(1);
                        wp.active = false;
                    }
                }
            }
        }
        
        // Invulnerability timer for player
        let playerInvulnerable = 0;
        
        function playerTakeDamage(baseDamage, knockX, knockY) {
            // Check invulnerability
            if (playerInvulnerable > 0) return;
            
            const shopArmor = getShopBonus('armor');
            const damage = baseDamage * (1 - (getEffectiveUpgrade('armor', 90) + shopArmor) / 100);
            hull -= damage;
            updateHullBar();
            
            // Damage feedback
            createFloatingText(` -${Math.floor(damage)}`, player.x + player.width/2, player.y - 10, '#ff3355');
            triggerScreenFlash('#ff0000', 0.5, 20);
            screenShake = 15;
            
            // Strong knockback away from damage source
            const knockbackForce = 50;
            const knockDir = Math.atan2(knockY, knockX);
            player.x -= Math.cos(knockDir) * knockbackForce;
            player.y -= Math.sin(knockDir) * knockbackForce;
            
            // Keep player in bounds
            player.x = Math.max(bossArena.offsetX + 20, Math.min(player.x, bossArena.offsetX + (bossArena.width - 2) * TILE_SIZE - player.width));
            player.y = Math.max(bossArena.offsetY + 20, Math.min(player.y, bossArena.offsetY + (bossArena.height - 2) * TILE_SIZE - player.height));
            
            // Blood/damage particles
            for (let i = 0; i < 15; i++) {
                bossArena.particles.push({
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    vx: (Math.random() - 0.5) * 12 - Math.cos(knockDir) * 5,
                    vy: (Math.random() - 0.5) * 12 - Math.sin(knockDir) * 5,
                    size: 2 + Math.random() * 4,
                    color: Math.random() < 0.7 ? '#ff3355' : '#ff6688',
                    life: 0.8
                });
            }
            
            // Brief invulnerability
            playerInvulnerable = 45; // ~0.75 seconds
        }
        
        // Boss hit flash timer
        let bossHitFlash = 0;
        // Boss invulnerability timer (cooldown between taking damage)
        let bossInvulnerable = 0;
        
        function damageBoss(amount) {
            // Check if boss is invulnerable
            if (bossInvulnerable > 0) {
                return; // Can't damage yet
            }
            
            boss.health -= amount;
            boss.hitCount++;
            
            // Set invulnerability (60 frames = 1 second cooldown)
            bossInvulnerable = 60;
            
            // Hit flash effect
            bossHitFlash = 12; // Frames to flash
            
            screenShake = 18;
            triggerScreenFlash('#00ffff', 0.5, 18);
            
            // Spawn hit particles - more dramatic
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = 5 + Math.random() * 10;
                bossArena.particles.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 6,
                    color: ['#00ffff', '#ff00ff', '#ffffff', '#88ffff'][Math.floor(Math.random() * 4)],
                    life: 1.2
                });
            }
            
            // Health bar style floating text
            const healthPercent = Math.floor((boss.health / boss.maxHealth) * 100);
            createFloatingText(` -1 HP`, boss.x, boss.y - 40, '#ff00ff');
            createFloatingText(`${boss.health}/${boss.maxHealth} (${healthPercent}%)`, boss.x, boss.y - 55, '#00ffff');
            
            if (boss.hitCount >= boss.hitsToStun && boss.health > 0) {
                boss.state = 'stunned';
                boss.stateTimer = 0;
                bossArena.weakPoints = [];
                createFloatingText(' STUNNED!', boss.x, boss.y - 70, '#ffff00');
            }
        }
        
        function triggerBossVictory() {
            // Pause game updates
            bossTransitionPhase = 'victory_screen';
            
            // Add boss key
            bossKeys.push(currentBossDepth);
            updateKeysDisplay();
            
            // Big score bonus
            const bonusScore = 500 * (currentBossDepth / BOSS_PORTAL_INTERVAL);
            score += bonusScore;
            updateScoreDisplay();
            
            // Full refill
            fuel = maxFuel;
            hull = maxHull;
            updateFuelBar();
            updateHullBar();
            
            // Victory effects
            screenShake = 20;
            triggerScreenFlash('#00ff88', 0.5, 30);
            
            // Spawn lots of particles
            for (let i = 0; i < 50; i++) {
                bossArena.particles.push({
                    x: boss.x + (Math.random() - 0.5) * 100,
                    y: boss.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    size: 5 + Math.random() * 10,
                    color: ['#00ffff', '#ff00ff', '#00ff88', '#ff9500'][Math.floor(Math.random() * 4)],
                    life: 2
                });
            }
            
            // Show victory overlay after a brief delay
            setTimeout(() => {
                showBossVictory();
            }, 1500);
        }
        
        function showBossVictory() {
            const bossType = getBossTypeForDepth(currentBossDepth);
            document.getElementById('bossVictorySubtitle').textContent = `You defeated ${getBossName(bossType)}`;
            document.getElementById('bossVictoryKeyDepth').textContent = `${currentBossDepth}m Boss Key`;
            document.getElementById('bossVictoryOverlay').classList.add('active');
        }
        
        function hideBossVictory() {
            document.getElementById('bossVictoryOverlay').classList.remove('active');
        }
        
        function teleportFromBoss() {
            hideBossVictory();
            exitBossArena(true);
        }
        
        // Set up victory button handlers
        document.getElementById('bossVictoryTeleport').addEventListener('click', teleportFromBoss);
        document.getElementById('bossVictoryTeleport').addEventListener('touchend', function(e) {
            e.preventDefault();
            teleportFromBoss();
        });
        
        function exitBossArena(victory) {
            bossTransitionPhase = 'exiting';
            bossTransitionTimer = 60;
            
            // Teleport player back to saved position (where they entered the portal)
            player.x = bossArena.savedPlayerX;
            player.y = bossArena.savedPlayerY;
            cameraY = bossArena.savedCameraY;
            
            // Set portal on cooldown (won't trigger until player moves 3 tiles away)
            // Portal remains visible but inactive until player moves away
            portalCooldown[currentBossDepth] = true;
            
            // Note: boss is cleared when exiting transition completes in updateBossArena
        }
        
        function drawBossArena() {
            if (!bossArenaActive) return;
            
            // Dark background
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // Alien cavern background effect
            const bgPulse = 0.3 + Math.sin(globalTime * 0.02) * 0.1;
            const bgGrad = ctx.createRadialGradient(
                BASE_WIDTH / 2, BASE_HEIGHT / 2, 50,
                BASE_WIDTH / 2, BASE_HEIGHT / 2, 300
            );
            bgGrad.addColorStop(0, `rgba(80, 0, 120, ${bgPulse})`);
            bgGrad.addColorStop(0.5, `rgba(30, 0, 60, ${bgPulse * 0.5})`);
            bgGrad.addColorStop(1, 'rgba(5, 5, 16, 0)');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // Draw arena tiles
            for (let y = 0; y < bossArena.height; y++) {
                for (let x = 0; x < bossArena.width; x++) {
                    const tile = bossArena.tiles[y] ? bossArena.tiles[y][x] : TILE.AIR;
                    const screenX = x * TILE_SIZE + bossArena.offsetX;
                    const screenY = y * TILE_SIZE + bossArena.offsetY;
                    
                    if (tile === TILE.BEDROCK) {
                        // Alien wall
                        ctx.fillStyle = '#1a0a2e';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = 'rgba(150, 50, 200, 0.2)';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, 2);
                        ctx.fillRect(screenX, screenY, 2, TILE_SIZE);
                    } else if (tile === TILE.HARD_ROCK) {
                        ctx.fillStyle = '#150825';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = 'rgba(100, 30, 150, 0.3)';
                        ctx.fillRect(screenX + 2, screenY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    } else if (tile === TILE.DIRT) {
                        ctx.fillStyle = '#2a1a35';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#3a2545';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE * 0.4);
                    }
                }
            }
            
            // Draw boss particles (behind boss)
            for (const p of bossArena.particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // Draw weak points
            for (const wp of bossArena.weakPoints) {
                if (!wp.active) continue;
                
                const wpPulse = 0.5 + Math.sin(globalTime * 0.2) * 0.5;
                ctx.beginPath();
                ctx.arc(wp.x, wp.y, wp.radius + wpPulse * 5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 136, ${0.3 + wpPulse * 0.3})`;
                ctx.fill();
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Target reticle
                ctx.strokeStyle = `rgba(0, 255, 136, ${wpPulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(wp.x - wp.radius - 10, wp.y);
                ctx.lineTo(wp.x - wp.radius + 5, wp.y);
                ctx.moveTo(wp.x + wp.radius + 10, wp.y);
                ctx.lineTo(wp.x + wp.radius - 5, wp.y);
                ctx.moveTo(wp.x, wp.y - wp.radius - 10);
                ctx.lineTo(wp.x, wp.y - wp.radius + 5);
                ctx.moveTo(wp.x, wp.y + wp.radius + 10);
                ctx.lineTo(wp.x, wp.y + wp.radius - 5);
                ctx.stroke();
            }
            
            // Draw healing pickups
            for (const pickup of bossArena.healingPickups) {
                const spawnProgress = pickup.spawnTimer / 180; // 0-1 over 3 seconds
                
                // Fade and flash during spawn
                let alpha = spawnProgress;
                if (spawnProgress < 1) {
                    // Flash effect while spawning
                    const flash = Math.sin(pickup.spawnTimer * 0.3) * 0.3 + 0.7;
                    alpha = spawnProgress * flash;
                }
                
                ctx.globalAlpha = alpha;
                
                // Outer glow
                const glowPulse = 0.5 + Math.sin(globalTime * 0.15) * 0.5;
                const glowGrad = ctx.createRadialGradient(pickup.x, pickup.y, 5, pickup.x, pickup.y, 25);
                glowGrad.addColorStop(0, `rgba(0, 255, 136, ${0.4 * glowPulse})`);
                glowGrad.addColorStop(1, 'rgba(0, 255, 136, 0)');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(pickup.x, pickup.y, 25, 0, Math.PI * 2);
                ctx.fill();
                
                // Core pickup circle
                ctx.fillStyle = '#004422';
                ctx.beginPath();
                ctx.arc(pickup.x, pickup.y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Green fill
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(pickup.x, pickup.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Cross symbol
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(pickup.x - 5, pickup.y - 2, 10, 4);
                ctx.fillRect(pickup.x - 2, pickup.y - 5, 4, 10);
                
                // Border
                ctx.strokeStyle = '#00ffaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pickup.x, pickup.y, 12, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.globalAlpha = 1;
            }
            
            // Draw boss
            if (boss && boss.state !== 'burrowing') {
                drawBoss();
            }
            
            // Draw projectiles
            for (const proj of bossArena.projectiles) {
                ctx.fillStyle = proj.color || '#ff6600';
                if (proj.type === 'shockwave') {
                    // Shockwave - wider, flatter shape
                    ctx.beginPath();
                    ctx.ellipse(proj.x, proj.y, proj.radius * 1.5, proj.radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Inner glow
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(proj.x, proj.y - 2, proj.radius * 0.8, proj.radius * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw player in arena
            drawPlayer();
            
            // Boss HP bar at top
            if (boss) {
                const hpBarWidth = 200;
                const hpBarHeight = 16;
                const hpBarX = (BASE_WIDTH - hpBarWidth) / 2;
                const hpBarY = 25;
                const hpPercent = boss.health / boss.maxHealth;
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(hpBarX - 2, hpBarY - 2, hpBarWidth + 4, hpBarHeight + 4);
                
                // HP bar
                const hpColor = hpPercent > 0.5 ? '#00ff88' : hpPercent > 0.25 ? '#ffaa00' : '#ff3355';
                ctx.fillStyle = hpColor;
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpPercent, hpBarHeight);
                
                // Border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                
                // Boss name
                ctx.font = 'bold 14px Oxanium, monospace';
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'center';
                ctx.fillText(getBossName(boss.type), BASE_WIDTH / 2, hpBarY + hpBarHeight + 18);
            }
            
            // Transition overlay
            if (bossTransitionPhase === 'entering' || bossTransitionPhase === 'exiting') {
                const alpha = bossTransitionTimer / 60;
                ctx.fillStyle = `rgba(0, 0, 0, ${bossTransitionPhase === 'entering' ? alpha : 1 - alpha})`;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            }
            
            // Victory overlay
            if (bossTransitionPhase === 'victory') {
                const pulse = 0.3 + Math.sin(globalTime * 0.2) * 0.2;
                ctx.fillStyle = `rgba(0, 255, 136, ${pulse * 0.3})`;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                
                ctx.font = 'bold 36px Oxanium, monospace';
                ctx.fillStyle = '#00ff88';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 20;
                ctx.fillText('VICTORY!', BASE_WIDTH / 2, BASE_HEIGHT / 2 - 20);
                ctx.shadowBlur = 0;
            }
        }
        
        function drawBoss() {
            if (!boss) return;
            
            // Decrement hit flash
            if (bossHitFlash > 0) bossHitFlash--;
            
            const wobble = Math.sin(boss.animFrame) * 3;
            const x = boss.x;
            const y = boss.y + wobble;
            const halfW = boss.width / 2;
            const halfH = boss.height / 2;
            
            ctx.save();
            
            // Hit flash effect - make boss white/bright when hit
            if (bossHitFlash > 0) {
                ctx.globalAlpha = 0.6 + (bossHitFlash / 12) * 0.4;
                ctx.filter = 'brightness(2.5) saturate(0.3)';
            }
            
            // Boss glow
            const glowAlpha = boss.state === 'vulnerable' ? 0.6 : 0.3;
            const glowColor = boss.state === 'vulnerable' ? '#00ff88' : 
                             boss.state === 'stunned' ? '#ffaa00' : '#ff00ff';
            ctx.shadowColor = bossHitFlash > 0 ? '#ffffff' : glowColor;
            ctx.shadowBlur = bossHitFlash > 0 ? 40 : 20;
            
            switch(boss.type) {
                case BOSS_TYPE.BURROWER:
                    // Worm-like creature
                    // Body segments
                    ctx.fillStyle = boss.state === 'vulnerable' ? '#40aa60' : '#604080';
                    for (let i = 3; i >= 0; i--) {
                        const segOffset = Math.sin(boss.animFrame + i * 0.5) * 5;
                        const segSize = halfW - i * 5;
                        ctx.beginPath();
                        ctx.ellipse(x + segOffset, y + i * 12, segSize, segSize * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Head
                    ctx.fillStyle = boss.state === 'vulnerable' ? '#50cc70' : '#8060a0';
                    ctx.beginPath();
                    ctx.ellipse(x, y - 15, halfW + 5, halfH * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(x - 12, y - 20, 6, 0, Math.PI * 2);
                    ctx.arc(x + 12, y - 20, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pupils
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(x - 12, y - 20, 3, 0, Math.PI * 2);
                    ctx.arc(x + 12, y - 20, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Mandibles
                    ctx.strokeStyle = '#403060';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x - 20, y - 5);
                    ctx.quadraticCurveTo(x - 30, y + 10, x - 15, y + 15);
                    ctx.moveTo(x + 20, y - 5);
                    ctx.quadraticCurveTo(x + 30, y + 10, x + 15, y + 15);
                    ctx.stroke();
                    
                    // Weak point indicator when vulnerable
                    if (boss.state === 'vulnerable') {
                        const pulseSize = 5 + Math.sin(globalTime * 0.3) * 3;
                        ctx.strokeStyle = '#00ff88';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(x, y, halfW + pulseSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;
                
                case BOSS_TYPE.CRYSTAL_GOLEM:
                    // Rocky golem with crystal core
                    const stompOffset = boss.state === 'slam' ? Math.sin(boss.stateTimer * 0.5) * 3 : 0;
                    const recoveryWobble = boss.state === 'recovery' ? Math.sin(boss.stateTimer * 0.4) * 4 : 0;
                    const isExposed = boss.state === 'vulnerable' || boss.state === 'recovery';
                    
                    // Body (rocky shape)
                    ctx.fillStyle = isExposed ? '#5588aa' : '#445566';
                    ctx.beginPath();
                    ctx.moveTo(x - halfW + recoveryWobble, y + halfH);
                    ctx.lineTo(x - halfW * 0.8 + recoveryWobble, y - halfH * 0.3);
                    ctx.lineTo(x - halfW * 0.3, y - halfH);
                    ctx.lineTo(x + halfW * 0.3, y - halfH);
                    ctx.lineTo(x + halfW * 0.8 - recoveryWobble, y - halfH * 0.3);
                    ctx.lineTo(x + halfW - recoveryWobble, y + halfH);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Rock texture lines
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - halfW * 0.5, y - halfH * 0.5);
                    ctx.lineTo(x - halfW * 0.2, y + halfH * 0.5);
                    ctx.moveTo(x + halfW * 0.4, y - halfH * 0.3);
                    ctx.lineTo(x + halfW * 0.3, y + halfH * 0.6);
                    ctx.stroke();
                    
                    // Crystal core (center)
                    const coreGlow = isExposed ? 0.9 : 0.5 + Math.sin(globalTime * 0.15) * 0.3;
                    ctx.fillStyle = `rgba(0, 255, 255, ${coreGlow})`;
                    ctx.beginPath();
                    ctx.moveTo(x, y - 15);
                    ctx.lineTo(x + 12, y);
                    ctx.lineTo(x, y + 15);
                    ctx.lineTo(x - 12, y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Core highlight
                    ctx.fillStyle = `rgba(200, 255, 255, ${coreGlow * 0.8})`;
                    ctx.beginPath();
                    ctx.moveTo(x, y - 8);
                    ctx.lineTo(x + 5, y);
                    ctx.lineTo(x, y + 8);
                    ctx.lineTo(x - 5, y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Eyes (glowing)
                    ctx.fillStyle = isExposed ? '#ffff00' : '#ff44aa';
                    ctx.beginPath();
                    ctx.arc(x - 15, y - halfH * 0.4, 5, 0, Math.PI * 2);
                    ctx.arc(x + 15, y - halfH * 0.4, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Arms (blocky)
                    ctx.fillStyle = isExposed ? '#6699bb' : '#556677';
                    ctx.fillRect(x - halfW - 12, y - 10 + stompOffset, 14, 30);
                    ctx.fillRect(x + halfW - 2, y - 10 + stompOffset, 14, 30);
                    
                    // Fists
                    ctx.fillStyle = '#334455';
                    ctx.fillRect(x - halfW - 14, y + 15 + stompOffset, 18, 15);
                    ctx.fillRect(x + halfW - 4, y + 15 + stompOffset, 18, 15);
                    
                    // Recovery/Vulnerable indicator
                    if (boss.state === 'recovery') {
                        const pulseSize = 5 + Math.sin(globalTime * 0.5) * 3;
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, pulseSize + 20, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (boss.state === 'vulnerable') {
                        const pulseSize = 8 + Math.sin(globalTime * 0.3) * 4;
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(x, y, pulseSize + 15, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;
                    
                default:
                    // Default boss shape
                    ctx.fillStyle = '#8060a0';
                    ctx.beginPath();
                    ctx.arc(x, y, halfW, 0, Math.PI * 2);
                    ctx.fill();
            }
            
            ctx.restore();
        }
        
        function getBossName(bossType) {
            switch(bossType) {
                case BOSS_TYPE.BURROWER: return 'THE BURROWER';
                case BOSS_TYPE.CRYSTAL_GOLEM: return 'CRYSTAL GOLEM';
                case BOSS_TYPE.LAVA_WURM: return 'LAVA WURM';
                case BOSS_TYPE.HIVE_MIND: return 'HIVE MIND';
                case BOSS_TYPE.COLLECTOR: return 'THE COLLECTOR';
                default: return 'ALIEN BOSS';
            }
        }
        
        // ==================== UPDATE ====================
        function update() {
            if (!gameRunning || upgradeSelectionActive || gamePaused) return;
            
            // Handle teleporting to boss arena
            if (bossTransitionPhase === 'teleporting') {
                globalTime = (globalTime + deltaMultiplier) % 100000;
                
                if (screenShake > 0) {
                    screenShake *= 0.9;
                }
                
                bossTransitionTimer -= deltaMultiplier;
                
                // Swirl particles toward player during teleport
                if (bossTransitionTimer > 30) {
                    if (Math.random() < 0.4) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 60 + Math.random() * 40;
                        particles.push({
                            x: player.x + player.width / 2 + Math.cos(angle) * dist,
                            y: player.y + player.height / 2 + Math.sin(angle) * dist,
                            vx: -Math.cos(angle) * 3,
                            vy: -Math.sin(angle) * 3,
                            size: 2 + Math.random() * 4,
                            color: Math.random() < 0.5 ? '#ff00ff' : '#8800ff',
                            life: 0.8
                        });
                    }
                }
                
                // Update particles
                updateParticles();
                processFloatingTextQueue();
                
                if (bossTransitionTimer <= 0) {
                    // Teleport complete - enter boss arena
                    enterBossArena(currentBossDepth);
                }
                return;
            }
            
            // Boss arena has its own update loop
            if (bossArenaActive) {
                updateBossArena();
                return;
            }
            
            // Keep points display in sync with score
            updatePointsDisplay();
            
            extendWorld();
            updateEnemies();
            
            // OPTIMIZATION: Wrap globalTime to prevent overflow
            globalTime = (globalTime + deltaMultiplier) % 100000;
            
            if (screenShake > 0) {
                screenShake *= 0.85;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            // ===== COMBO TIMER DECAY (paused during upgrade selection) =====
            if (comboTimer > 0 && !upgradeSelectionActive) {
                comboTimer -= deltaMultiplier;
                if (comboTimer <= 0) {
                    comboCount = 0;
                    comboTimer = 0;
                }
            }
            
            // ===== FEVER MODE UPDATE (paused during upgrade selection) =====
            if (feverMode && !upgradeSelectionActive) {
                feverTimer -= deltaMultiplier;
                if (feverTimer <= 0) {
                    feverMode = false;
                    feverTimer = 0;
                    createFloatingText('Fever ended!', player.x + player.width/2, player.y - 20, '#888888');
                }
                // Fever mode speed lines
                if (Math.random() < 0.3) createSpeedLine();
            }
            
            // ===== SURFACE REFUELING & REPAIR =====
            // Trigger when 10% of player sprite is above the refuel line
            const refuelThresholdY = player.y + player.height * 0.9;
            const isAboveRefuelLine = refuelThresholdY <= REFUEL_LINE_Y;
            
            if (isAboveRefuelLine && fuel < maxFuel) {
                const refuelAmount = REFUEL_RATE * deltaMultiplier;
                fuel = Math.min(fuel + refuelAmount, maxFuel);
                updateFuelBar();
                
                // Occasional refuel particles
                if (Math.random() < 0.1) {
                    createParticles(player.x + player.width/2, player.y, '#00ff88', 2);
                }
            }
            
            // Hull repair at surface (same rate as refueling)
            if (isAboveRefuelLine && hull < maxHull) {
                const repairAmount = REFUEL_RATE * deltaMultiplier;
                hull = Math.min(hull + repairAmount, maxHull);
                updateHullBar();
                
                // Occasional repair particles (cyan sparks)
                if (Math.random() < 0.05) {
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#00ffff', 2);
                }
            }
            
            // Show upgrade button when at surface with score > 0
            if (isAboveRefuelLine && gameRunning && !upgradeSelectionActive && score > 0) {
                surfaceUpgradeBtn.classList.add('visible');
            } else {
                surfaceUpgradeBtn.classList.remove('visible');
            }
            
            // ===== DRILL HEAT MANAGEMENT =====
            // Heat decays when not actively drilling hard materials
            if (!player.digging) {
                const shopCooling = getShopBonus('cooling');
                const coolRate = HEAT_DECAY_RATE * (1 + (permanentUpgrades.drillCooling + shopCooling) / 50);
                drillHeat = Math.max(0, drillHeat - coolRate * deltaMultiplier);
            }
            
            // Surface cools drill faster (uses same isAboveRefuelLine check)
            if (isAboveRefuelLine) {
                drillHeat = Math.max(0, drillHeat - 1.5 * deltaMultiplier);
            }
            
            // Heat visual effects - smoke/steam particles
            const heatPercent = drillHeat / maxDrillHeat;
            
            // Calculate drill position for particles (same logic as drawPlayer)
            let particleDrillX = player.x + player.width / 2;
            let particleDrillY = player.y + player.height;
            
            // Determine drill direction
            let particleDrillDirection = 'down';
            
            // Check if actively digging - this takes priority even in hover mode
            if (player.digging && player.digTarget) {
                const targetWorldX = player.digTarget.x * TILE_SIZE + TILE_SIZE / 2;
                const targetWorldY = player.digTarget.y * TILE_SIZE + TILE_SIZE / 2;
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const dx = targetWorldX - playerCenterX;
                const dy = targetWorldY - playerCenterY;
                
                if (dy < -TILE_SIZE / 2) {
                    particleDrillDirection = 'up';
                } else if (Math.abs(dx) > TILE_SIZE / 2) {
                    particleDrillDirection = dx < 0 ? 'left' : 'right';
                }
            }
            // In hover mode and not digging, drill points down
            else if (hoverMode) {
                particleDrillDirection = 'down';
            }
            // If not digging but holding direction keys
            else if (keys.up && !keys.down) {
                particleDrillDirection = 'up';
            } else if (keys.left && !keys.right) {
                particleDrillDirection = 'left';
            } else if (keys.right && !keys.left) {
                particleDrillDirection = 'right';
            }
            // When overheated, remember last dig direction
            else if (drillOverheated && lastDigDirection === 'up') {
                particleDrillDirection = 'up';
            } else if (drillOverheated && lastDigDirection === 'left') {
                particleDrillDirection = 'left';
            } else if (drillOverheated && lastDigDirection === 'right') {
                particleDrillDirection = 'right';
            }
            
            // Apply direction offsets
            if (particleDrillDirection === 'up') {
                particleDrillX = player.x + player.width / 2;
                particleDrillY = player.y - 3;
            } else if (particleDrillDirection === 'left') {
                particleDrillX = player.x - 3;
                particleDrillY = player.y + player.height / 2 - 1; // Nudged up 2px
            } else if (particleDrillDirection === 'right') {
                particleDrillX = player.x + player.width + 3;
                particleDrillY = player.y + player.height / 2 - 1; // Nudged up 2px
            }
            
            if (heatPercent > 0.6 && Math.random() < (heatPercent - 0.5) * 0.15) {
                // Heat shimmer particles rising from drill
                particles.push({
                    x: particleDrillX + (Math.random() - 0.5) * 10,
                    y: particleDrillY + 5,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -1 - Math.random() * 1.5,
                    size: 3 + Math.random() * 3,
                    color: drillOverheated ? '#ff4400' : '#ff8844',
                    life: 0.6,
                    type: 'smoke'
                });
            }
            
            // Smoke puffs when overheated
            if (drillOverheated && Math.random() < 0.2) {
                particles.push({
                    x: particleDrillX + (Math.random() - 0.5) * 8,
                    y: particleDrillY,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -2 - Math.random() * 2,
                    size: 5 + Math.random() * 4,
                    color: '#444444',
                    life: 0.8,
                    type: 'smoke'
                });
            }
            
            // Overheat recovery
            if (drillOverheated) {
                drillCooldownTimer -= deltaMultiplier;
                
                // Screen edge warning effect
                if (Math.random() < 0.05) {
                    screenShake = Math.max(screenShake, 1);
                }
                
                if (drillCooldownTimer <= 0) {
                    drillOverheated = false;
                    drillHeat = 50; // Reset to half heat after cooldown
                    createFloatingText(' Drill Cooled', player.x + player.width/2, player.y - 20, '#00ffaa');
                    triggerScreenFlash('#00ffaa', 0.2, 10);
                }
            }
            
            // ===== SCREEN FLASH UPDATE =====
            if (screenFlash.active) {
                screenFlash.duration -= deltaMultiplier;
                if (screenFlash.duration <= 0) {
                    screenFlash.active = false;
                }
            }
            
            // ===== SPEED LINES UPDATE =====
            speedLines = speedLines.filter(line => {
                line.y += line.speed * deltaMultiplier;
                return line.y < BASE_HEIGHT + 50;
            });
            
            // ===== UNSTABLE TILES UPDATE =====
            // Process unstable tile timers (only starts when player digs them)
            unstableTiles = unstableTiles.filter(unstable => {
                unstable.timer -= deltaMultiplier;
                
                // Warning shake when low
                if (unstable.timer < 20 && !unstable.warned) {
                    unstable.warned = true;
                }
                
                // Collapse!
                if (unstable.timer <= 0) {
                    const ty = getWorldRow(unstable.absoluteTy);
                    if (ty >= 0 && ty < world.length && world[ty][unstable.tx] === TILE.UNSTABLE) {
                        // Collapse damages player if nearby
                        const tileCX = unstable.tx * TILE_SIZE + TILE_SIZE/2;
                        const tileCY = unstable.absoluteTy * TILE_SIZE + TILE_SIZE/2;
                        const playerCX = player.x + player.width/2;
                        const playerCY = player.y + player.height/2;
                        const dist = Math.sqrt(Math.pow(tileCX - playerCX, 2) + Math.pow(tileCY - playerCY, 2));
                        
                        if (dist < TILE_SIZE * 2) {
                            const shopArmor = getShopBonus('armor');
                            const damage = 15 * (1 - (getEffectiveUpgrade('armor', 90) + shopArmor) / 100);
                            hull -= damage;
                            comboCount = 0;
                            comboTimer = 0;
                            createFloatingText(`-${Math.floor(damage)}`, player.x + 12, player.y, '#ff3355');
                            triggerScreenFlash('#ff0000', 0.2, 6);
                            screenShake = 8;
                            updateHullBar();
                        }
                        
                        // Turn into rubble (just air with particles)
                        world[ty][unstable.tx] = TILE.AIR;
                        createParticles(tileCX, unstable.absoluteTy * TILE_SIZE + TILE_SIZE/2, '#666688', 12);
                        
                        // Cancel dig if we were digging this tile
                        if (player.digTarget && player.digTarget.x === unstable.tx && player.digTarget.y === unstable.absoluteTy) {
                            player.digging = false;
                            player.digTarget = null;
                        }
                    }
                    return false;
                }
                return true;
            });
            
            player.thrusterFlicker = Math.sin(globalTime * 0.3) * 0.3 + 0.7;
            
            // ===== SLIDE ANIMATION (smooth repositioning when drilling) =====
            if (slideAnimation.active) {
                // Safety timeout - cancel if taking too long (prevents invisible barriers)
                slideAnimation.timer += deltaMultiplier;
                if (slideAnimation.timer > 60) { // ~1 second max
                    slideAnimation.active = false;
                    slideAnimation.timer = 0;
                }
                
                // Lerp towards target position
                const dx = slideAnimation.targetX - player.x;
                const dy = slideAnimation.targetY - player.y;
                
                // Y sliding depends on direction:
                // - 'down': only slide downward (prevents upward snap after down-drilling)
                // - 'left'/'right': slide both directions to center on row
                const isHorizontalDig = slideAnimation.direction === 'left' || slideAnimation.direction === 'right';
                
                // Move towards target X
                player.x += dx * slideAnimation.speed * deltaMultiplier;
                
                if (isHorizontalDig) {
                    // Horizontal drilling: slide Y in both directions to align with tile
                    player.y += dy * slideAnimation.speed * deltaMultiplier;
                } else if (dy > 0) {
                    // Down drilling: only slide down, not up
                    player.y += dy * slideAnimation.speed * deltaMultiplier;
                }
                
                // Check if close enough to snap and end animation
                const yDist = isHorizontalDig ? dy * dy : (dy > 0 ? dy * dy : 0);
                const distSq = dx * dx + yDist;
                if (distSq < 1) {
                    player.x = slideAnimation.targetX;
                    if (isHorizontalDig || dy > 0) player.y = slideAnimation.targetY;
                    slideAnimation.active = false;
                    slideAnimation.timer = 0;
                }
            }
            
            // Skip player input during death animation
            if (deathAnimationActive) {
                // Just let player fall/drift during death
                player.y += 1 * deltaMultiplier;
                player.digging = false;
                player.digTarget = null;
                player.digProgress = 0;
            }
            // ===== SAFETY: Reset stuck digging state =====
            else if (player.digging && !player.digTarget) {
                // Edge case: digging flag is true but no target - reset to prevent getting stuck
                player.digging = false;
                player.digProgress = 0;
            }
            // ===== SAFETY: Reset if target tile no longer exists =====
            else if (player.digging && player.digTarget) {
                const checkTy = getWorldRow(player.digTarget.y);
                const checkTile = (checkTy >= 0 && checkTy < world.length) ? 
                    world[checkTy][player.digTarget.x] : TILE.AIR;
                
                // If target is now air or destroyed, cancel dig immediately
                if (checkTile === TILE.AIR) {
                    player.digging = false;
                    player.digTarget = null;
                    player.digProgress = 0;
                    // Don't auto-continue here - let player initiate new dig
                }
            }
            
            // ===== DIG CANCELLATION WHEN KEY RELEASED =====
            if (player.digging && player.digTarget) {
                // Check if the direction key for current dig is still held
                let keyStillHeld = false;
                if (lastDigDirection === 'down' && keys.down) keyStillHeld = true;
                if (lastDigDirection === 'up' && keys.up) keyStillHeld = true;
                if (lastDigDirection === 'left' && keys.left) keyStillHeld = true;
                if (lastDigDirection === 'right' && keys.right) keyStillHeld = true;
                
                if (!keyStillHeld && lastDigDirection !== null) {
                    // Key released - cancel dig
                    player.digging = false;
                    player.digTarget = null;
                    player.digProgress = 0;
                } else {
                    // Get tile being dug for heat calculation
                    const digTy = getWorldRow(player.digTarget.y);
                    const digTile = (digTy >= 0 && digTy < world.length) ? world[digTy][player.digTarget.x] : TILE.AIR;
                    
                    // If tile was destroyed by something else (bomb, chain, etc.), cancel dig
                    if (digTile === TILE.AIR) {
                        player.digging = false;
                        player.digTarget = null;
                        player.digProgress = 0;
                        // Try to continue in same direction
                        if (lastDigDirection) {
                            tryDigInDirection(lastDigDirection);
                        }
                    } else {
                        // Heat generation based on material hardness
                        let heatGen = 0;
                        if (digTile === TILE.HARD_ROCK) {
                            heatGen = 1.2; // High heat for hard rock
                        } else if (digTile === TILE.ROCK) {
                            heatGen = 0.4; // Moderate heat for rock
                        } else if (digTile === TILE.UNSTABLE) {
                            heatGen = 0.25; // Some heat for unstable
                        }
                        
                        // Apply cooling upgrade reduction (includes shop bonus)
                        const shopCooling = getShopBonus('cooling');
                        const coolingReduction = 1 - Math.min((permanentUpgrades.drillCooling + shopCooling) / 100, 0.95);
                        heatGen *= coolingReduction;
                        
                        // Fever mode reduces heat buildup
                        if (feverMode) heatGen *= 0.5;
                        
                        drillHeat = Math.min(maxDrillHeat, drillHeat + heatGen * deltaMultiplier);
                        
                        // Check for overheat
                        if (drillHeat >= maxDrillHeat && !drillOverheated) {
                            drillOverheated = true;
                            drillCooldownTimer = DRILL_COOLDOWN_FRAMES;
                            player.digging = false;
                            player.digTarget = null;
                            player.digProgress = 0;
                            triggerScreenFlash('#ff4400', 0.4, 15);
                            screenShake = 8;
                            createFloatingText(' OVERHEATED!', player.x + player.width/2, player.y - 20, '#ff4400');
                        } else {
                            player.digProgress += (1/60) * deltaMultiplier;
                            if (player.digProgress >= player.digTarget.time) {
                                completeDig(false);
                            }
                        }
                    }
                }
            } else {
                let dx = 0, dy = 0;
                
                // Apply speed bonuses (fever mode + hover mode stack)
                let moveSpeed = player.speed;
                if (feverMode) moveSpeed *= 1.3;
                if (hoverMode) moveSpeed *= 1.3; // 30% faster in hover mode
                
                if (keys.left) dx = -moveSpeed;
                if (keys.right) dx = moveSpeed;
                if (keys.up) {
                    // Cancel any active slide animation when flying up
                    // This prevents the "invisible barrier" bug after drilling down
                    if (slideAnimation.active) {
                        slideAnimation.active = false;
                    }
                    const shopClimbBonus = getShopBonus('climbSpeed');
                    dy = -moveSpeed * 0.7 * (1 + (permanentUpgrades.climbSpeed + shopClimbBonus) / 100);
                }
                
                // Cancel slide animation when pressing left/right (but not if also pressing down - down takes priority)
                if ((keys.left || keys.right) && !keys.down && slideAnimation.active) {
                    slideAnimation.active = false;
                }
                
                if (keys.down && !player.digging) {
                    // Cancel slide animation when pressing down
                    if (slideAnimation.active) {
                        slideAnimation.active = false;
                    }
                    // Exit hover mode when pressing down to drill
                    if (hoverMode) {
                        hoverMode = false;
                        groundedTimer = 0;
                    }
                    lastDigDirection = 'down';
                    const target = findDownDigTarget();
                    if (target) {
                        // Start unstable timer if digging unstable rock
                        const ty = getWorldRow(target.absoluteTy);
                        if (ty >= 0 && ty < world.length) {
                            const tile = world[ty][target.tx];
                            if (tile === TILE.UNSTABLE) {
                                const existing = unstableTiles.find(u => u.tx === target.tx && u.absoluteTy === target.absoluteTy);
                                if (!existing) {
                                    startUnstableTimer(target.tx, target.absoluteTy);
                                }
                            }
                        }
                        dig(target.tx, target.absoluteTy);
                    }
                }
                
                // Track if player is pressing against a wall (prevents falling)
                let wallGripping = false;
                
                if (dx !== 0) {
                    const newX = player.x + dx * deltaMultiplier;
                    if (newX >= 0 && newX + player.width <= BASE_WIDTH) {
                        // Use multi-point horizontal collision check
                        if (!checkHorizontalCollision(newX, player.y, player.width, player.height, dx)) {
                            player.x = newX;
                            // Speed lines when moving fast in fever mode
                            if (feverMode && Math.random() < 0.2) createSpeedLine();
                            // Reset blocked timers when not blocked
                            if (dx > 0) blockedTimerRight = 0;
                            else blockedTimerLeft = 0;
                        } else {
                            // Blocked horizontally - grip the wall to prevent falling
                            wallGripping = true;
                            if (!player.digging) {
                                const midY = player.y + player.height / 2;
                                const absoluteTy = Math.floor(midY / TILE_SIZE);
                                
                                // Don't drill in sky rows
                                if (absoluteTy >= FIRST_DIGGABLE_ROW) {
                                    if (hoverMode) {
                                        // In hover mode: 0.5s delay OR momentum for horizontal drilling
                                        const hasMomentum = hoverDrillMomentum > 0;
                                        if (dx > 0) {
                                            blockedTimerRight += deltaMultiplier;
                                            if (hasMomentum || blockedTimerRight >= BLOCKED_DRILL_DELAY) {
                                                lastDigDirection = 'right';
                                                const checkX = newX + player.width;
                                                const tx = Math.floor(checkX / TILE_SIZE);
                                                dig(tx, absoluteTy);
                                                blockedTimerRight = 0;
                                                if (hasMomentum) hoverDrillMomentum = 0;
                                            }
                                        } else {
                                            blockedTimerLeft += deltaMultiplier;
                                            if (hasMomentum || blockedTimerLeft >= BLOCKED_DRILL_DELAY) {
                                                lastDigDirection = 'left';
                                                const checkX = newX;
                                                const tx = Math.floor(checkX / TILE_SIZE);
                                                dig(tx, absoluteTy);
                                                blockedTimerLeft = 0;
                                                if (hasMomentum) hoverDrillMomentum = 0;
                                            }
                                        }
                                    } else if (keys.up) {
                                        // Flying upward: require 0.5s delay before horizontal drilling
                                        // Prevents accidental drilling when navigating narrow shafts
                                        if (dx > 0) {
                                            blockedTimerRight += deltaMultiplier;
                                            if (blockedTimerRight >= BLOCKED_DRILL_DELAY) {
                                                lastDigDirection = 'right';
                                                const checkX = newX + player.width;
                                                const tx = Math.floor(checkX / TILE_SIZE);
                                                dig(tx, absoluteTy);
                                                blockedTimerRight = 0;
                                            }
                                        } else {
                                            blockedTimerLeft += deltaMultiplier;
                                            if (blockedTimerLeft >= BLOCKED_DRILL_DELAY) {
                                                lastDigDirection = 'left';
                                                const checkX = newX;
                                                const tx = Math.floor(checkX / TILE_SIZE);
                                                dig(tx, absoluteTy);
                                                blockedTimerLeft = 0;
                                            }
                                        }
                                    } else if (!keys.down) {
                                        // Not flying up and not holding down - drill horizontally immediately
                                        // If holding down, prioritize down (don't start horizontal dig)
                                        if (dx > 0) {
                                            lastDigDirection = 'right';
                                            const checkX = newX + player.width;
                                            const tx = Math.floor(checkX / TILE_SIZE);
                                            dig(tx, absoluteTy);
                                        } else {
                                            lastDigDirection = 'left';
                                            const checkX = newX;
                                            const tx = Math.floor(checkX / TILE_SIZE);
                                            dig(tx, absoluteTy);
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Not pressing left or right, reset horizontal blocked timers
                    blockedTimerLeft = 0;
                    blockedTimerRight = 0;
                }
                
                if (dy < 0) {
                    const MIN_PLAYER_Y = -20; // Allow flying higher for more sky visibility
                    const targetY = Math.max(MIN_PLAYER_Y, player.y + dy * deltaMultiplier);
                    
                    // Step-by-step collision check to prevent tunneling through rocks
                    const step = 2; // Check every 2 pixels
                    let newY = player.y;
                    let blocked = false;
                    
                    while (newY > targetY && !blocked) {
                        const nextY = Math.max(targetY, newY - step);
                        if (checkCollision(player.x, nextY, player.width, player.height)) {
                            blocked = true;
                        } else {
                            newY = nextY;
                        }
                    }
                    
                    // IMPORTANT: Check if we moved BEFORE updating player.y
                    const movedUp = newY < player.y;
                    
                    // Handle blocked state - track time and eventually drill
                    if (blocked) {
                        // Only accumulate timer when NOT already digging
                        // This ensures a fresh 0.5s delay between each drill in hover mode
                        if (!player.digging) {
                            blockedTimer += deltaMultiplier;
                            // Dedicated hover mode timer - only counts in hover mode
                            if (hoverMode) {
                                hoverUpDrillTimer += deltaMultiplier;
                            }
                        }
                        const absoluteTy = Math.floor((player.y - 1) / TILE_SIZE);
                        
                        // In hover mode: use dedicated hover timer for strict 0.5s delay
                        // OR bypass with hover drill momentum (from completing previous drill)
                        // Not in hover mode: drill immediately (0s delay)
                        const hasMomentum = hoverDrillMomentum > 0;
                        const canDrill = hoverMode ? 
                            (hasMomentum || hoverUpDrillTimer >= BLOCKED_DRILL_DELAY) : 
                            true; // Always can drill immediately when not hovering
                        
                        if (canDrill && !player.digging && absoluteTy >= FIRST_DIGGABLE_ROW) {
                            lastDigDirection = 'up';
                            const tx = Math.floor((player.x + player.width / 2) / TILE_SIZE);
                            dig(tx, absoluteTy);
                            blockedTimer = 0; // Reset after initiating dig
                            hoverUpDrillTimer = 0; // Reset hover timer after drilling
                            if (hasMomentum) hoverDrillMomentum = 0; // Consume momentum
                        }
                    } else {
                        blockedTimer = 0; // Reset when not blocked
                        hoverUpDrillTimer = 0; // Reset hover timer when not blocked
                    }
                    
                    // Decay hover drill momentum
                    if (hoverDrillMomentum > 0 && !player.digging) {
                        hoverDrillMomentum -= deltaMultiplier;
                    }
                    
                    // Decay upward dig momentum while holding up (used for non-hover chaining)
                    if (upDigMomentum > 0) {
                        upDigMomentum -= deltaMultiplier;
                    }
                    
                    if (newY < player.y && newY >= MIN_PLAYER_Y) {
                        player.y = newY;
                        const shopFuelEff = getShopBonus('fuelEff');
                        let climbCost = 0.1 * (1 - (getEffectiveUpgrade('fuelEfficiency', 90) + shopFuelEff) / 100);
                        if (feverMode) climbCost *= 0.5;
                        if (hoverMode) climbCost *= 0.2; // 80% reduction in hover mode
                        fuel -= climbCost * deltaMultiplier;
                        updateFuelBar();
                        
                        // Thruster particles
                        if (Math.random() < 0.4 && particles.length < MAX_PARTICLES) {
                            const color = feverMode ? '#ff00ff' : '#ff6600';
                            particles.push({
                                x: player.x + player.width / 2 + (Math.random() - 0.5) * 8,
                                y: player.y + player.height,
                                vx: (Math.random() - 0.5) * 2,
                                vy: 2 + Math.random() * 2,
                                size: 3 + Math.random() * 3,
                                color: color,
                                life: 0.5,
                                type: 'thruster'
                            });
                        }
                    }
                    
                    // Track flight time for hover mode activation
                    // MUST be outside the movement block so it still counts when blocked/drilling
                    // movedUp was calculated BEFORE player.y was updated
                    const tryingToProgress = movedUp || player.digging || blocked;
                    if (tryingToProgress) {
                        flightTimer += deltaMultiplier;
                        if (flightTimer >= HOVER_MODE_DELAY && !hoverMode) {
                            hoverMode = true;
                            // Reset all drill timers to ensure fresh delays in hover mode
                            blockedTimer = 0;
                            hoverUpDrillTimer = 0;
                            hoverDrillMomentum = 0; // No momentum when first entering hover
                        }
                    } else {
                        flightTimer = 0;
                    }
                    groundedTimer = 0; // Reset grounded timer when flying
                }
                
                // Gravity with acceleration (skip during slide animation or wall gripping)
                // Also skip gravity when actively drilling horizontally - prevents dropping between blocks
                const holdingHorizontalDig = (keys.left || keys.right) && player.digging && 
                    (lastDigDirection === 'left' || lastDigDirection === 'right');
                
                if (!keys.up && !slideAnimation.active && !wallGripping && !holdingHorizontalDig) {
                    flightTimer = 0; // Reset flight timer when not holding up
                    blockedTimer = 0; // Reset blocked timer when not flying
                    upDigMomentum = 0; // Clear upward dig momentum when not flying
                    
                    // Apply gravity acceleration
                    player.vy = Math.min(player.vy + GRAVITY * deltaMultiplier, MAX_FALL_SPEED);
                    
                    const newY = player.y + player.vy * deltaMultiplier;
                    if (!checkCollision(player.x, newY, player.width, player.height)) {
                        player.y = newY;
                        groundedTimer = 0; // Falling, not grounded
                    } else {
                        // Landing! Check if we should shake/animate
                        if (player.vy >= LANDING_SHAKE_THRESHOLD) {
                            // Scale shake based on fall velocity
                            const shakeIntensity = Math.min(Math.floor((player.vy - LANDING_SHAKE_THRESHOLD) * 2), 15);
                            screenShake = Math.max(screenShake, shakeIntensity);
                            
                            // Landing particles - dust cloud
                            const particleCount = Math.floor(player.vy);
                            for (let i = 0; i < particleCount; i++) {
                                if (particles.length < MAX_PARTICLES) {
                                    const angle = Math.PI + (Math.random() - 0.5) * Math.PI * 0.8;
                                    const speed = 1 + Math.random() * 3;
                                    particles.push({
                                        x: player.x + player.width / 2 + (Math.random() - 0.5) * player.width,
                                        y: player.y + player.height,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed - 1,
                                        size: 2 + Math.random() * 3,
                                        color: '#8b7355',
                                        life: 0.4 + Math.random() * 0.3,
                                        type: 'dust'
                                    });
                                }
                            }
                            
                            // Quick screen flash for heavy impacts
                            if (player.vy >= MAX_FALL_SPEED * 0.8) {
                                triggerScreenFlash('#ffffff', 0.15, 5);
                            }
                        }
                        
                        // Reset velocity on landing
                        player.vy = 0;
                        
                        // On ground - immediately disable hover mode
                        if (hoverMode) {
                            hoverMode = false;
                            blockedTimerLeft = 0;
                            blockedTimerRight = 0;
                            hoverUpDrillTimer = 0;
                            hoverDrillMomentum = 0;
                        }
                        groundedTimer = 0;
                    }
                } else if (wallGripping) {
                    // Wall gripping - reset fall velocity to prevent accumulation
                    player.vy = 0;
                } else if (holdingHorizontalDig) {
                    // Holding horizontal dig - reset fall velocity to prevent dropping
                    player.vy = 0;
                } else {
                    // Flying up - reset fall velocity
                    player.vy = 0;
                }
                
                // Unstuck player if somehow inside a wall
                unstuckPlayer();
                
                // Periodic check for stuck/orphaned states
                sanityCheck();
            }
            
            // Update facing direction based on key presses (don't clear - retain for resting animation)
            if (!drillOverheated) {
                // Update direction when pressing a key, but don't clear when releasing
                if (keys.down) lastDigDirection = 'down';
                else if (keys.up) lastDigDirection = 'up';
                else if (keys.left) lastDigDirection = 'left';
                else if (keys.right) lastDigDirection = 'right';
            }
            
            // Gem magnet
            if (permanentUpgrades.gemMagnet > 0) {
                const magnetRange = permanentUpgrades.gemMagnet * TILE_SIZE;
                const pcx = player.x + player.width / 2;
                const pcy = player.y + player.height / 2;
                
                const startTX = Math.max(0, Math.floor((pcx - magnetRange) / TILE_SIZE));
                const endTX = Math.min(WORLD_WIDTH - 1, Math.floor((pcx + magnetRange) / TILE_SIZE));
                const startAbsTY = Math.floor((pcy - magnetRange) / TILE_SIZE);
                const endAbsTY = Math.floor((pcy + magnetRange) / TILE_SIZE);
                
                for (let absoluteTy = startAbsTY; absoluteTy <= endAbsTY; absoluteTy++) {
                    const ty = getWorldRow(absoluteTy);
                    if (ty < 0 || ty >= world.length) continue;
                    
                    for (let tx = startTX; tx <= endTX; tx++) {
                        const tile = world[ty][tx];
                        if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                            const gemX = tx * TILE_SIZE + TILE_SIZE / 2;
                            const gemY = absoluteTy * TILE_SIZE + TILE_SIZE / 2;
                            const dist = Math.sqrt(Math.pow(gemX - pcx, 2) + Math.pow(gemY - pcy, 2));
                            
                            if (dist < magnetRange) {
                                // BUG FIX: Pass true to indicate magnet collection (no fuel cost)
                                player.digTarget = { x: tx, y: absoluteTy, time: 0 };
                                completeDig(true);
                            }
                        }
                    }
                }
            }
            
            // Camera follow - faster when player moves up, smoother when going down
            // Allow more sky at max height (-100) for upgrade button space
            const targetCameraY = Math.max(-100, player.y - BASE_HEIGHT * 0.3);
            const cameraDiff = targetCameraY - cameraY;
            // Use faster lerp when camera needs to catch up going upward (player above camera view)
            const lerpSpeed = cameraDiff < 0 ? 0.15 : 0.08;
            cameraY += cameraDiff * lerpSpeed * deltaMultiplier;
            
            // Depth tracking - current depth always updates
            const currentDepth = Math.max(0, Math.floor((player.y - 60) / TILE_SIZE));
            depthEl.textContent = currentDepth;
            
            // Max depth only increases
            if (currentDepth > maxDepthThisRun) {
                maxDepthThisRun = currentDepth;
                maxDepthEl.textContent = maxDepthThisRun;
                depthColorShift = Math.min(maxDepthThisRun / 200, 1);
                
                const milestone = Math.floor(maxDepthThisRun / 50) * 50;
                if (milestone > lastUpgradeDepth && milestone > 0) {
                    lastUpgradeDepth = milestone;
                    showUpgradeSelector(milestone % 250 === 0);
                }
            }
            
            // Update depth variable for other systems (alien spawn check, etc)
            depth = currentDepth;
            
            // ===== PORTAL COLLISION CHECK =====
            // Player walks into portal to enter boss arena
            if (!bossArenaActive && !deathAnimationActive) {
                checkPortalCollision();
            }
            
            updateParticles();
            processFloatingTextQueue();
            updateAlien(deltaMultiplier);
            
            if ((fuel <= 0 || hull <= 0) && !deathAnimationActive) {
                deathAnimationActive = true;
                deathAnimationTimer = DEATH_ANIMATION_DURATION;
                deathReason = hull <= 0 ? 'hull' : 'fuel';
                screenShake = 8; // Reduced shake for more subdued death
                triggerScreenFlash(hull <= 0 ? '#00ccff' : '#ff6600', 0.4, 20);
            }
            
            // Death animation update
            if (deathAnimationActive) {
                deathAnimationTimer -= deltaMultiplier;
                
                // Apply gentle gravity during death - machine sinks/falls limp
                const deathProgress = 1 - (deathAnimationTimer / DEATH_ANIMATION_DURATION);
                if (deathProgress < 0.8) { // Stop sinking near end
                    const sinkSpeed = 1.5 * deltaMultiplier;
                    const newY = player.y + sinkSpeed;
                    // Only sink if there's space below
                    if (!checkCollision(player.x, newY, player.width, player.height)) {
                        player.y = newY;
                    }
                }
                
                if (deathAnimationTimer <= 0) {
                    gameOver();
                }
            }
        }
        
        function updateFuelBar() {
            const percent = Math.max(0, (fuel / maxFuel) * 100);
            fuelBar.style.width = percent + '%';
            fuelPercent.textContent = Math.round(percent);
            fuelBarContainer.classList.toggle('critical', percent < 25);
        }
        
        function updateHullBar() {
            const percent = Math.max(0, (hull / maxHull) * 100);
            hullBar.style.width = percent + '%';
            hullPercent.textContent = Math.round(percent);
            hullBarContainer.classList.toggle('critical', percent < 25);
        }
        
        // ==================== DRAWING ====================
        function draw() {
            ctx.save();
            
            // Boss arena has its own drawing
            if (bossArenaActive) {
                if (screenShake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * screenShake * 2,
                        (Math.random() - 0.5) * screenShake * 2
                    );
                }
                drawBossArena();
                ctx.restore();
                return;
            }
            
            // Teleporting effect - vortex on dark background
            if (bossTransitionPhase === 'teleporting') {
                if (screenShake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * screenShake * 2,
                        (Math.random() - 0.5) * screenShake * 2
                    );
                }
                
                const progress = 1 - (bossTransitionTimer / 90);
                
                // Dark purple background
                ctx.fillStyle = '#050008';
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                
                // Swirling vortex centered on screen
                const centerX = BASE_WIDTH / 2;
                const centerY = BASE_HEIGHT / 2;
                const vortexRadius = 50 + progress * 150;
                
                // Multiple swirling rings
                for (let ring = 0; ring < 6; ring++) {
                    const ringRadius = vortexRadius * (0.2 + ring * 0.15);
                    const ringAlpha = 0.8 - ring * 0.1;
                    const rotation = globalTime * 0.1 * (ring % 2 === 0 ? 1 : -1);
                    
                    ctx.strokeStyle = `rgba(${200 + ring * 10}, ${50 + ring * 20}, 255, ${ringAlpha})`;
                    ctx.lineWidth = 5 - ring * 0.5;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, ringRadius, rotation, rotation + Math.PI * 1.6);
                    ctx.stroke();
                }
                
                // Floating particles
                for (let i = 0; i < 20; i++) {
                    const angle = (globalTime * 0.05 + i * 0.3) % (Math.PI * 2);
                    const dist = 30 + (i % 5) * 25 + Math.sin(globalTime * 0.1 + i) * 20;
                    const px = centerX + Math.cos(angle) * dist;
                    const py = centerY + Math.sin(angle) * dist;
                    
                    ctx.fillStyle = `rgba(255, ${100 + i * 5}, 255, ${0.6 - i * 0.02})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 2 + Math.sin(globalTime * 0.2 + i) * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Central bright core
                const coreGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 60);
                coreGrad.addColorStop(0, `rgba(255, 200, 255, ${0.8 + progress * 0.2})`);
                coreGrad.addColorStop(0.3, `rgba(200, 50, 255, ${0.6})`);
                coreGrad.addColorStop(1, 'rgba(100, 0, 150, 0)');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
                ctx.fill();
                
                // "ENTERING BOSS ARENA" text
                ctx.font = 'bold 22px Oxanium, monospace';
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.fillText(' BOSS PORTAL ', centerX, centerY - 100);
                
                ctx.font = 'bold 28px Oxanium, monospace';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`DEPTH ${currentBossDepth}m`, centerX, centerY + 120);
                
                ctx.font = '16px Oxanium, monospace';
                ctx.fillStyle = '#aa88ff';
                ctx.fillText('Entering arena...', centerX, centerY + 150);
                ctx.shadowBlur = 0;
                
                // Fade to black at end
                if (progress > 0.75) {
                    const fadeAlpha = (progress - 0.75) / 0.25;
                    ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                    ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                }
                
                ctx.restore();
                return;
            }
            
            if (screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake * 2,
                    (Math.random() - 0.5) * screenShake * 2
                );
            }
            
            // Background - use cached gradient, recreate only when state changes
            const bgState = getBgState();
            if (bgState !== cachedBgState) {
                cachedBgGradient = createCachedBgGradient(feverMode, depthColorShift);
                cachedBgState = bgState;
            }
            ctx.fillStyle = cachedBgGradient;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // Background stars (simplified)
            ctx.globalAlpha = 0.35;
            const starTime = globalTime * 0.05;
            for (let i = 0; i < bgStars.length; i++) {
                const star = bgStars[i];
                const sy = star.y - cameraY * 0.3;
                const modY = ((sy % BASE_HEIGHT) + BASE_HEIGHT) % BASE_HEIGHT;
                const twinkle = 0.5 + Math.sin(starTime + star.twinkle) * 0.5;
                ctx.fillStyle = feverMode ? `rgba(255, 150, 255, ${twinkle * 0.6})` : `rgba(200, 220, 255, ${twinkle * 0.5})`;
                ctx.fillRect(star.x - star.size/2, modY - star.size/2, star.size, star.size);
            }
            ctx.globalAlpha = 1;
            
            // Moon, milky way, and clouds (visible further down)
            const skyVisibility = Math.max(0, 1 - cameraY / 100);
            if (skyVisibility > 0) {
                ctx.globalAlpha = skyVisibility;
                
                // Sparse lower stars (visible further down)
                const lowerStarY = 20 - cameraY * 0.6;
                if (lowerStarY > -30 && lowerStarY < BASE_HEIGHT + 50) {
                    const twinkleTime = globalTime * 0.02;
                    for (let i = 0; i < 18; i++) {
                        const sx = (i * 27 + 10) % BASE_WIDTH;
                        const sy = lowerStarY + Math.sin(i * 2.1) * 25 + (i % 3) * 12;
                        const sAlpha = 0.2 + Math.sin(twinkleTime * 1.3 + i * 0.8) * 0.12;
                        const sSize = 0.8 + Math.sin(i * 1.9) * 0.3;
                        
                        ctx.fillStyle = `rgba(220, 215, 255, ${sAlpha})`;
                        ctx.beginPath();
                        ctx.arc(sx, sy, sSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Milky Way - dense star band at top of sky
                const mwCenterY = -20 - cameraY * 0.8;
                if (mwCenterY > -60 && mwCenterY < BASE_HEIGHT + 60) {
                    const twinkleTime = globalTime * 0.02;
                    
                    // Background glow for milky way
                    const mwGlow = ctx.createLinearGradient(0, mwCenterY - 35, 0, mwCenterY + 35);
                    mwGlow.addColorStop(0, 'rgba(120, 100, 160, 0)');
                    mwGlow.addColorStop(0.3, 'rgba(140, 120, 180, 0.12)');
                    mwGlow.addColorStop(0.5, 'rgba(160, 140, 200, 0.18)');
                    mwGlow.addColorStop(0.7, 'rgba(140, 120, 180, 0.12)');
                    mwGlow.addColorStop(1, 'rgba(120, 100, 160, 0)');
                    ctx.fillStyle = mwGlow;
                    ctx.fillRect(0, mwCenterY - 35, BASE_WIDTH, 70);
                    
                    // Dense star field in milky way - fixed positions, only alpha changes
                    for (let i = 0; i < 45; i++) {
                        const starX = (i * 11) % BASE_WIDTH;
                        const starY = mwCenterY + Math.sin(i * 1.7) * 22;
                        const starAlpha = 0.25 + Math.sin(twinkleTime * 1.2 + i * 0.5) * 0.15;
                        const starSize = 1 + Math.sin(i * 2.3) * 0.6;
                        
                        ctx.fillStyle = `rgba(230, 220, 255, ${starAlpha})`;
                        ctx.beginPath();
                        ctx.arc(starX, starY, starSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Brighter accent stars - fixed positions, only alpha changes
                    for (let i = 0; i < 12; i++) {
                        const bx = (i * 37 + 15) % BASE_WIDTH;
                        const by = mwCenterY + Math.sin(i * 2.9) * 18;
                        const bAlpha = 0.4 + Math.sin(twinkleTime * 1.5 + i * 1.1) * 0.2;
                        
                        ctx.fillStyle = `rgba(255, 250, 255, ${bAlpha})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Moon - positioned in upper right
                const moonX = BASE_WIDTH - 45;
                const moonY = -15 - cameraY * 0.7;
                
                if (moonY > -30 && moonY < BASE_HEIGHT) {
                    const moonGlow = ctx.createRadialGradient(moonX, moonY, 8, moonX, moonY, 40);
                    moonGlow.addColorStop(0, 'rgba(200, 220, 255, 0.3)');
                    moonGlow.addColorStop(0.5, 'rgba(150, 180, 220, 0.1)');
                    moonGlow.addColorStop(1, 'rgba(100, 130, 180, 0)');
                    ctx.fillStyle = moonGlow;
                    ctx.beginPath();
                    ctx.arc(moonX, moonY, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#dde8f0';
                    ctx.beginPath();
                    ctx.arc(moonX, moonY, 18, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0a1525';
                    ctx.beginPath();
                    ctx.arc(moonX + 7, moonY - 2, 14, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(180, 195, 210, 0.5)';
                    ctx.beginPath();
                    ctx.arc(moonX - 6, moonY + 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(moonX - 10, moonY - 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Fluffy clouds - compact rounded puffs
                const cloudDrift = globalTime * 0.003;
                const cloudBaseY = -20 - cameraY * 0.65;
                
                if (cloudBaseY > -40 && cloudBaseY < BASE_HEIGHT + 40) {
                    // Cloud 1 - left, round and compact
                    const c1x = 40 + Math.sin(cloudDrift) * 3;
                    const c1y = cloudBaseY + 5;
                    
                    ctx.fillStyle = 'rgba(50, 65, 90, 0.22)';
                    ctx.beginPath(); ctx.arc(c1x, c1y + 8, 15, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c1x + 18, c1y + 9, 14, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c1x + 34, c1y + 7, 12, 0, Math.PI * 2); ctx.fill();
                    
                    ctx.fillStyle = 'rgba(60, 75, 100, 0.18)';
                    ctx.beginPath(); ctx.arc(c1x + 8, c1y, 13, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c1x + 24, c1y + 2, 12, 0, Math.PI * 2); ctx.fill();
                    
                    ctx.fillStyle = 'rgba(75, 90, 115, 0.12)';
                    ctx.beginPath(); ctx.arc(c1x + 15, c1y - 5, 9, 0, Math.PI * 2); ctx.fill();
                    
                    // Cloud 2 - center, small puff
                    const c2x = BASE_WIDTH / 2 + Math.sin(cloudDrift + 1) * 3;
                    const c2y = cloudBaseY + 2;
                    
                    ctx.fillStyle = 'rgba(55, 70, 95, 0.18)';
                    ctx.beginPath(); ctx.arc(c2x - 10, c2y + 6, 11, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c2x + 5, c2y + 7, 12, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c2x + 18, c2y + 5, 10, 0, Math.PI * 2); ctx.fill();
                    
                    ctx.fillStyle = 'rgba(65, 80, 105, 0.14)';
                    ctx.beginPath(); ctx.arc(c2x, c2y, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c2x + 12, c2y + 1, 9, 0, Math.PI * 2); ctx.fill();
                    
                    // Cloud 3 - right, tiny accent
                    const c3x = BASE_WIDTH - 55 + Math.sin(cloudDrift + 2) * 2;
                    const c3y = cloudBaseY + 10;
                    
                    ctx.fillStyle = 'rgba(50, 65, 90, 0.15)';
                    ctx.beginPath(); ctx.arc(c3x - 8, c3y + 4, 9, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c3x + 5, c3y + 5, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c3x + 16, c3y + 3, 8, 0, Math.PI * 2); ctx.fill();
                    
                    ctx.fillStyle = 'rgba(60, 75, 100, 0.1)';
                    ctx.beginPath(); ctx.arc(c3x + 3, c3y - 1, 7, 0, Math.PI * 2); ctx.fill();
                }
                
                ctx.globalAlpha = 1;
            }
            
            // ===== SPEED LINES =====
            if (speedLines.length > 0) {
                ctx.strokeStyle = feverMode ? 'rgba(255, 100, 255, 0.6)' : 'rgba(100, 200, 255, 0.4)';
                ctx.lineWidth = 2;
                for (const line of speedLines) {
                    ctx.globalAlpha = line.alpha;
                    ctx.beginPath();
                    ctx.moveTo(line.x, line.y);
                    ctx.lineTo(line.x, line.y + line.length);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Ambient particles - use fillRect for performance (small particles look identical)
            for (let i = 0; i < ambientParticles.length; i++) {
                const p = ambientParticles[i];
                const sy = p.y - cameraY;
                if (sy > -10 && sy < BASE_HEIGHT + 10) {
                    const hue = feverMode ? 300 : p.hue;
                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${p.alpha})`;
                    ctx.fillRect(p.x - p.size/2, sy - p.size/2, p.size, p.size);
                }
            }
            
            // Draw surface fuel zone indicators and "FUEL HERE" text
            const surfaceScreenY = -cameraY;
            // Line position: at REFUEL_LINE_Y constant
            const refuelLineY = REFUEL_LINE_Y - cameraY;
            
            if (surfaceScreenY > -100 && surfaceScreenY < BASE_HEIGHT + 100) {
                // === "FUEL & REPAIR HERE" flashing text at top of fuel zone ===
                const flashAlpha = 0.25 + Math.sin(globalTime * 0.08) * 0.15; // Slow flash
                ctx.save();
                ctx.fillStyle = `rgba(0, 255, 136, ${flashAlpha})`;
                ctx.font = 'bold 14px Oxanium, monospace';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;
                ctx.fillText(' FUEL & REPAIR HERE ', BASE_WIDTH / 2, surfaceScreenY + 30);
                ctx.restore();
                
                // Refuel zone indicator line (dashed) at bottom of refuel zone
                if (refuelLineY > -20 && refuelLineY < BASE_HEIGHT + 20) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.45)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, refuelLineY);
                    ctx.lineTo(BASE_WIDTH, refuelLineY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Pulsing refuel/repair effect when player is in zone
                const refuelThresholdY = player.y + player.height * 0.9;
                const isAboveRefuelLine = refuelThresholdY <= REFUEL_LINE_Y;
                const needsFuel = fuel < maxFuel;
                const needsRepair = hull < maxHull;
                
                if (isAboveRefuelLine && (needsFuel || needsRepair)) {
                    const pulse = 0.12 + Math.sin(globalTime * 0.2) * 0.06;
                    const refuelGrad = ctx.createLinearGradient(0, 0, 0, refuelLineY + 20);
                    refuelGrad.addColorStop(0, `rgba(0, 255, 136, ${pulse * 0.3})`);
                    refuelGrad.addColorStop(0.5, `rgba(0, 255, 136, ${pulse})`);
                    refuelGrad.addColorStop(1, `rgba(0, 255, 136, 0)`);
                    ctx.fillStyle = refuelGrad;
                    ctx.fillRect(0, 0, BASE_WIDTH, refuelLineY + 20);
                    
                    // Status text based on what's happening
                    let statusText = '';
                    if (needsFuel && needsRepair) statusText = 'REFUELING & REPAIRING...';
                    else if (needsFuel) statusText = 'REFUELING...';
                    else if (needsRepair) statusText = 'REPAIRING...';
                    
                    ctx.fillStyle = `rgba(0, 255, 136, ${0.5 + Math.sin(globalTime * 0.25) * 0.3})`;
                    ctx.font = 'bold 11px Oxanium, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(statusText, BASE_WIDTH / 2, surfaceScreenY + 46);
                }
            }
            
            // === GAS STATION (background layer - drawn before world tiles) ===
            // Positioned at player's starting level, centered between left edge and player
            const stationCenterX = BASE_WIDTH / 4 - TILE_SIZE; // One block left of center
            const stationScreenY = TILE_SIZE * 2 - cameraY; // Row 2 level
            
            if (stationScreenY > -80 && stationScreenY < BASE_HEIGHT + 50) {
                const pumpGlow = 0.7 + Math.sin(globalTime * 0.15) * 0.3;
                const groundY = stationScreenY + TILE_SIZE; // Bottom of station just touches ground
                
                // Station building (main structure)
                ctx.fillStyle = '#2d4a5a';
                ctx.fillRect(stationCenterX - 22, groundY - 38, 44, 38);
                
                // Roof
                ctx.fillStyle = '#1a3040';
                ctx.fillRect(stationCenterX - 25, groundY - 42, 50, 5);
                
                // Roof edge highlight
                ctx.fillStyle = '#3a5a6a';
                ctx.fillRect(stationCenterX - 25, groundY - 43, 50, 2);
                
                // Window
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(stationCenterX - 16, groundY - 32, 18, 12);
                ctx.fillStyle = `rgba(100, 200, 255, ${0.25 + pumpGlow * 0.15})`;
                ctx.fillRect(stationCenterX - 14, groundY - 30, 14, 8);
                
                // Door
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(stationCenterX + 6, groundY - 26, 10, 26);
                ctx.fillStyle = '#3a5a6a';
                ctx.fillRect(stationCenterX + 8, groundY - 24, 6, 10);
                
                // Red canopy over pump area
                ctx.fillStyle = '#cc3333';
                ctx.fillRect(stationCenterX + 20, groundY - 44, 36, 6);
                ctx.fillStyle = '#992222';
                ctx.fillRect(stationCenterX + 20, groundY - 38, 36, 3);
                
                // Canopy pole
                ctx.fillStyle = '#555555';
                ctx.fillRect(stationCenterX + 36, groundY - 35, 4, 35);
                
                // Gas pump
                ctx.fillStyle = '#dddddd';
                ctx.fillRect(stationCenterX + 24, groundY - 30, 16, 30);
                ctx.fillStyle = '#333333';
                ctx.fillRect(stationCenterX + 26, groundY - 26, 12, 10); // Screen
                ctx.fillStyle = `rgba(0, 255, 100, ${pumpGlow})`;
                ctx.fillRect(stationCenterX + 27, groundY - 25, 10, 8); // Screen glow
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(stationCenterX + 26, groundY - 14, 12, 6); // Orange stripe
                
                // Nozzle hanging
                ctx.fillStyle = '#222222';
                ctx.fillRect(stationCenterX + 41, groundY - 22, 6, 3);
                ctx.fillRect(stationCenterX + 45, groundY - 24, 3, 10);
                
                // "GAS" neon sign on building
                ctx.save();
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10 * pumpGlow;
                ctx.fillStyle = `rgba(0, 255, 136, ${0.6 + pumpGlow * 0.3})`;
                ctx.font = 'bold 11px Oxanium, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('GAS', stationCenterX, groundY - 46);
                ctx.restore();
                
                // Price sign on pole
                ctx.fillStyle = '#111111';
                ctx.fillRect(stationCenterX + 50, groundY - 32, 18, 22);
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 7px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('$1.99', stationCenterX + 59, groundY - 20);
                ctx.fillStyle = '#ffff00';
                ctx.font = '5px Arial';
                ctx.fillText('/gal', stationCenterX + 59, groundY - 14);
            }
            
            // === REPAIR SHOP (mirrored on right side) ===
            const shopCenterX = 3 * BASE_WIDTH / 4 + TILE_SIZE; // One block right of center
            const shopScreenY = TILE_SIZE * 2 - cameraY; // Same row as gas station
            
            if (shopScreenY > -80 && shopScreenY < BASE_HEIGHT + 50) {
                const shopGlow = 0.7 + Math.sin(globalTime * 0.06) * 0.3; // Slower flashing
                const groundY = shopScreenY + TILE_SIZE;
                
                // Shop building (main structure) - mirrored
                ctx.fillStyle = '#4a3a2d';
                ctx.fillRect(shopCenterX - 22, groundY - 38, 44, 38);
                
                // Roof
                ctx.fillStyle = '#302518';
                ctx.fillRect(shopCenterX - 25, groundY - 42, 50, 5);
                
                // Roof edge highlight
                ctx.fillStyle = '#5a4a3a';
                ctx.fillRect(shopCenterX - 25, groundY - 43, 50, 2);
                
                // Window (mirrored - on right side of building)
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(shopCenterX - 2, groundY - 32, 18, 12);
                ctx.fillStyle = `rgba(255, 200, 100, ${0.2 + shopGlow * 0.2})`;
                ctx.fillRect(shopCenterX, groundY - 30, 14, 8);
                
                // Door (mirrored - on left side of building)
                ctx.fillStyle = '#1a2530';
                ctx.fillRect(shopCenterX - 16, groundY - 26, 10, 26);
                ctx.fillStyle = '#5a4a3a';
                ctx.fillRect(shopCenterX - 14, groundY - 24, 6, 10);
                
                // Blue canopy over work area (mirrored to left)
                ctx.fillStyle = '#3366cc';
                ctx.fillRect(shopCenterX - 56, groundY - 44, 36, 6);
                ctx.fillStyle = '#224488';
                ctx.fillRect(shopCenterX - 56, groundY - 38, 36, 3);
                
                // Canopy pole (mirrored)
                ctx.fillStyle = '#555555';
                ctx.fillRect(shopCenterX - 40, groundY - 35, 4, 35);
                
                // Tool cabinet / work station - improved design
                // Main cabinet body
                ctx.fillStyle = '#b83030';
                ctx.fillRect(shopCenterX - 52, groundY - 30, 16, 30);
                // Cabinet edge highlight
                ctx.fillStyle = '#d44040';
                ctx.fillRect(shopCenterX - 52, groundY - 30, 2, 30);
                // Cabinet shadow edge
                ctx.fillStyle = '#8a2020';
                ctx.fillRect(shopCenterX - 38, groundY - 30, 2, 30);
                
                // Top drawer
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(shopCenterX - 50, groundY - 27, 12, 9);
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(shopCenterX - 50, groundY - 27, 12, 2); // Drawer top edge
                
                // Bottom drawer (taller)
                ctx.fillStyle = '#252525';
                ctx.fillRect(shopCenterX - 50, groundY - 16, 12, 12);
                ctx.fillStyle = '#353535';
                ctx.fillRect(shopCenterX - 50, groundY - 16, 12, 2); // Drawer top edge
                
                // Drawer handles (chrome look)
                ctx.fillStyle = '#aaaaaa';
                ctx.fillRect(shopCenterX - 47, groundY - 23, 6, 2);
                ctx.fillStyle = '#cccccc';
                ctx.fillRect(shopCenterX - 47, groundY - 23, 6, 1);
                ctx.fillStyle = '#aaaaaa';
                ctx.fillRect(shopCenterX - 47, groundY - 10, 6, 2);
                ctx.fillStyle = '#cccccc';
                ctx.fillRect(shopCenterX - 47, groundY - 10, 6, 1);
                
                // Cabinet top surface
                ctx.fillStyle = '#444444';
                ctx.fillRect(shopCenterX - 53, groundY - 31, 18, 2);
                
                // Wrench hanging (mirrored nozzle equivalent)
                ctx.fillStyle = '#888888';
                ctx.fillRect(shopCenterX - 59, groundY - 22, 6, 3);
                ctx.fillStyle = '#666666';
                ctx.fillRect(shopCenterX - 62, groundY - 26, 4, 12);
                
                // "REPAIR" neon sign on building
                ctx.save();
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10 * shopGlow;
                ctx.fillStyle = `rgba(0, 255, 255, ${0.6 + shopGlow * 0.3})`;
                ctx.font = 'bold 9px Oxanium, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('REPAIR', shopCenterX, groundY - 46);
                ctx.restore();
                
                // Service sign on pole (mirrored)
                ctx.fillStyle = '#111111';
                ctx.fillRect(shopCenterX - 68, groundY - 32, 18, 22);
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 6px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('HULL', shopCenterX - 59, groundY - 22);
                ctx.fillStyle = '#ffff00';
                ctx.font = '5px Arial';
                ctx.fillText('FIX', shopCenterX - 59, groundY - 14);
            }
            
            // Draw world
            const startRow = Math.max(0, Math.floor(cameraY / TILE_SIZE) - worldRowOffset);
            const endRow = Math.min(world.length - 1, Math.ceil((cameraY + BASE_HEIGHT) / TILE_SIZE) - worldRowOffset);
            
            for (let y = startRow; y <= endRow; y++) {
                const absoluteY = y + worldRowOffset;
                const screenY = absoluteY * TILE_SIZE - cameraY;
                
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    const tile = world[y][x];
                    if (tile !== TILE.AIR) {
                        drawTile(tile, x * TILE_SIZE, screenY, x, absoluteY);
                    }
                }
            }
            
            // Draw gate icons overlay (centered, legible)
            drawGateIcons();
            
            drawParticles();
            drawEnemies();
            drawPlayer();
            drawFloatingTexts();
            
            // Vignette - use cached gradient, recreate only when state changes
            const vignetteState = getVignetteState();
            if (vignetteState !== cachedVignetteState) {
                cachedVignette = createCachedVignette(vignetteState);
                cachedVignetteState = vignetteState;
            }
            ctx.fillStyle = cachedVignette;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // OPTIMIZATION: Use cached scanline pattern
            if (cachedScanlinePattern) {
                ctx.fillStyle = cachedScanlinePattern;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            }
            
            // ===== SCREEN FLASH =====
            if (screenFlash.active) {
                const flashAlpha = screenFlash.alpha * (screenFlash.duration / 20);
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = flashAlpha;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                ctx.globalAlpha = 1;
            }
            
            // ===== LOW HULL WARNING (cyan pulse + screen flash) =====
            const hullPercent = hull / maxHull;
            if (hullPercent < 0.30 && hullPercent > 0) {
                const pulseSpeed = hullPercent < 0.15 ? 0.151 : 0.0756; // 20% slower
                const pulse = 0.5 + Math.sin(globalTime * pulseSpeed) * 0.5;
                const baseAlpha = hullPercent < 0.15 ? 0.319 : 0.191; // 50% more transparent
                const warningAlpha = baseAlpha * pulse;
                
                // Full screen cyan flash overlay
                ctx.fillStyle = `rgba(0, 180, 255, ${warningAlpha * 0.268})`;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                
                // Cyan vignette from edges
                const gradient = ctx.createRadialGradient(
                    BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.1,
                    BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.6
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.4, `rgba(0, 80, 120, ${warningAlpha * 0.268})`);
                gradient.addColorStop(0.7, `rgba(0, 150, 200, ${warningAlpha * 0.395})`);
                gradient.addColorStop(1, `rgba(0, 200, 255, ${warningAlpha * 0.565})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            }
            
            // ===== LOW FUEL WARNING (orange pulse + screen flash) =====
            const fuelPercent = fuel / maxFuel;
            if (fuelPercent < 0.30 && fuelPercent > 0) {
                const pulseSpeed = fuelPercent < 0.15 ? 0.151 : 0.0756; // 20% slower
                const pulse = 0.5 + Math.sin(globalTime * pulseSpeed) * 0.5;
                const baseAlpha = fuelPercent < 0.15 ? 0.319 : 0.191; // 50% more transparent
                const warningAlpha = baseAlpha * pulse;
                
                // Full screen orange flash overlay
                ctx.fillStyle = `rgba(255, 100, 0, ${warningAlpha * 0.246})`;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                
                // Orange vignette from edges
                const gradient = ctx.createRadialGradient(
                    BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.1,
                    BASE_WIDTH / 2, BASE_HEIGHT / 2, BASE_HEIGHT * 0.6
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.4, `rgba(100, 50, 0, ${warningAlpha * 0.268})`);
                gradient.addColorStop(0.7, `rgba(200, 100, 0, ${warningAlpha * 0.395})`);
                gradient.addColorStop(1, `rgba(255, 140, 0, ${warningAlpha * 0.565})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            }
            
            // ===== COMBO METER UI =====
            if (comboCount > 0) {
                const comboX = 10;
                const comboY = BASE_HEIGHT - 50;
                const meterWidth = 100;
                const meterHeight = 8;
                const progress = comboTimer / getComboDecayTime();
                const multiplier = getComboMultiplier();
                
                // Meter background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(comboX, comboY + 20, meterWidth, meterHeight);
                
                // Meter fill
                const meterColor = multiplier >= 4 ? '#ff00ff' : multiplier >= 3 ? '#ff9500' : multiplier >= 2 ? '#00f0ff' : '#00ff88';
                ctx.fillStyle = meterColor;
                ctx.fillRect(comboX, comboY + 20, meterWidth * progress, meterHeight);
                
                // Meter border
                ctx.strokeStyle = meterColor;
                ctx.lineWidth = 1;
                ctx.strokeRect(comboX, comboY + 20, meterWidth, meterHeight);
                
                // Combo text
                const comboScale = 1 + (multiplier - 1) * 0.1;
                ctx.font = `bold ${Math.floor(16 * comboScale)}px Oxanium, monospace`;
                ctx.fillStyle = meterColor;
                ctx.textAlign = 'left';
                ctx.shadowColor = meterColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`${comboCount} COMBO`, comboX, comboY + 14);
                
                if (multiplier > 1) {
                    ctx.font = `bold ${Math.floor(20 * comboScale)}px Oxanium, monospace`;
                    ctx.fillText(`x${multiplier}`, comboX + meterWidth + 10, comboY + 26);
                }
                ctx.shadowBlur = 0;
            }
            
            // ===== FEVER MODE INDICATOR (mirrors combo meter on right side) =====
            if (feverMode) {
                const feverX = BASE_WIDTH - 110;
                const feverY = BASE_HEIGHT - 50;
                const meterWidth = 100;
                const meterHeight = 8;
                const feverProgress = feverTimer / getFeverDuration();
                
                // Meter background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(feverX, feverY + 20, meterWidth, meterHeight);
                
                // Meter fill (fills from right to left)
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(feverX + meterWidth * (1 - feverProgress), feverY + 20, meterWidth * feverProgress, meterHeight);
                
                // Meter border
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 1;
                ctx.strokeRect(feverX, feverY + 20, meterWidth, meterHeight);
                
                // Fever text
                const feverPulse = 1 + Math.sin(globalTime * 0.2) * 0.1;
                ctx.font = `bold ${Math.floor(16 * feverPulse)}px Oxanium, monospace`;
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'right';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.fillText('FEVER ', BASE_WIDTH - 10, feverY + 14);
                ctx.shadowBlur = 0;
            }
            
            // Draw alien tip (in world space - scrolls with camera)
            drawAlien();
            
            ctx.restore();
        }
        
        // OPTIMIZATION: Pre-defined gem colors lookup (avoids object creation in hot loop)
        const GEM_COLORS = {
            4: ['#00f0ff', '#00b0bb'],  // GEM_COMMON
            5: ['#ff00ff', '#bb00bb'],  // GEM_RARE
            6: ['#ff9500', '#cc7700']   // GEM_EPIC
        };
        
        function drawTile(tile, x, y, tx, ty) {
            const s = TILE_SIZE;
            const time = globalTime * 0.02;
            
            switch(tile) {
                case TILE.DIRT:
                    ctx.fillStyle = '#3d2d20';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = '#4a3828';
                    ctx.fillRect(x, y, s, s * 0.4);
                    ctx.fillStyle = 'rgba(0,0,0,0.15)';
                    ctx.fillRect(x + ((tx * 7) % s), y + ((ty * 11) % s), 2, 2);
                    ctx.fillRect(x + ((tx * 7 + 13) % s), y + ((ty * 11 + 7) % s), 2, 2);
                    break;
                    
                case TILE.ROCK:
                    ctx.fillStyle = '#404040';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(x, y, s, 1);
                    ctx.fillRect(x, y, 1, s);
                    break;
                    
                case TILE.HARD_ROCK:
                    ctx.fillStyle = '#252530';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = 'rgba(80, 100, 150, 0.2)';
                    ctx.beginPath();
                    ctx.moveTo(x + 3, y + s/2);
                    ctx.lineTo(x + s/2, y + 3);
                    ctx.lineTo(x + s - 3, y + s/2);
                    ctx.lineTo(x + s/2, y + s - 3);
                    ctx.closePath();
                    ctx.fill();
                    break;
                
                case TILE.BEDROCK:
                    // Dark impenetrable stone with metallic sheen
                    ctx.fillStyle = '#151518';
                    ctx.fillRect(x, y, s, s);
                    // Cross-hatch pattern to show it's special
                    ctx.strokeStyle = 'rgba(60, 60, 80, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + s, y + s);
                    ctx.moveTo(x + s, y);
                    ctx.lineTo(x, y + s);
                    ctx.stroke();
                    // Subtle border
                    ctx.strokeStyle = 'rgba(80, 80, 100, 0.3)';
                    ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
                    break;
                    
                case TILE.GEM_COMMON:
                case TILE.GEM_RARE:
                case TILE.GEM_EPIC:
                    ctx.fillStyle = '#1a1a22';
                    ctx.fillRect(x, y, s, s);
                    
                    const colors = GEM_COLORS[tile];
                    const pulse = 0.85 + Math.sin(time * 3 + tx + ty) * 0.15;
                    
                    // OPTIMIZATION: Reduced shadow usage
                    ctx.fillStyle = colors[1];
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + s/2 - 7 * pulse);
                    ctx.lineTo(x + s/2 + 6 * pulse, y + s/2);
                    ctx.lineTo(x + s/2, y + s/2 + 7 * pulse);
                    ctx.lineTo(x + s/2 - 6 * pulse, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = colors[0];
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + s/2 - 3 * pulse);
                    ctx.lineTo(x + s/2 + 2 * pulse, y + s/2);
                    ctx.lineTo(x + s/2, y + s/2 + 3 * pulse);
                    ctx.lineTo(x + s/2 - 2 * pulse, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case TILE.LAVA:
                    const lavaIntensity = 0.5 + Math.sin(time * 1 + tx) * 0.3;
                    ctx.fillStyle = `rgb(${180 + lavaIntensity * 75}, ${30 + lavaIntensity * 40}, 0)`;
                    ctx.fillRect(x, y, s, s);
                    // Multiple bubbles with varying sizes and speeds
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.4)';
                    const bubbleTime1 = (time * 0.833 + tx * 3 + ty) % 1;
                    const bubbleTime2 = (time * 1 + tx * 2 + ty * 2) % 1;
                    const bubbleTime3 = (time * 0.667 + tx + ty * 3) % 1;
                    ctx.beginPath();
                    ctx.arc(x + s * 0.25, y + s * (1 - bubbleTime1 * 0.8), 2 + bubbleTime1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + s * 0.7, y + s * (1 - bubbleTime2 * 0.7), 1.5 + bubbleTime2 * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255, 255, 150, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + s * 0.5, y + s * (1 - bubbleTime3 * 0.9), 1 + bubbleTime3 * 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Occasional large pop bubble
                    if (Math.sin(time * 1.33 + tx * 5 + ty * 7) > 0.7) {
                        ctx.fillStyle = 'rgba(255, 220, 120, 0.5)';
                        ctx.beginPath();
                        ctx.arc(x + s * 0.4, y + s * 0.3, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.strokeStyle = '#ff5500';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
                    break;
                    
                case TILE.GAS:
                    const gasAlpha = 0.35 + Math.sin(time * 2 + tx + ty) * 0.15;
                    ctx.fillStyle = '#101a10';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = `rgba(80, 220, 80, ${gasAlpha})`;
                    ctx.fillRect(x, y, s, s);
                    // Faint skull warning (38% larger than original)
                    const skullAlpha = 0.12 + Math.sin(time * 1.5 + tx * 2 + ty) * 0.06;
                    ctx.fillStyle = `rgba(255, 255, 200, ${skullAlpha})`;
                    // Skull head (slightly larger)
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s * 0.43, s * 0.195, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye sockets (proportionally larger)
                    ctx.fillStyle = `rgba(20, 40, 20, ${skullAlpha + 0.15})`;
                    ctx.beginPath();
                    ctx.arc(x + s * 0.42, y + s * 0.42, s * 0.056, 0, Math.PI * 2);
                    ctx.arc(x + s * 0.58, y + s * 0.42, s * 0.056, 0, Math.PI * 2);
                    ctx.fill();
                    // Jaw/teeth area (proportionally larger)
                    ctx.fillStyle = `rgba(255, 255, 200, ${skullAlpha * 0.8})`;
                    ctx.fillRect(x + s * 0.385, y + s * 0.54, s * 0.215, s * 0.128);
                    // Teeth lines (adjusted for larger jaw)
                    ctx.strokeStyle = `rgba(20, 40, 20, ${skullAlpha + 0.1})`;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + s * (0.43 + i * 0.072), y + s * 0.54);
                        ctx.lineTo(x + s * (0.43 + i * 0.072), y + s * 0.66);
                        ctx.stroke();
                    }
                    break;
                    
                case TILE.FUEL:
                    // Fuel canister - orange with pulsing glow
                    const fuelPulse = 0.8 + Math.sin(time * 3 + tx + ty) * 0.2;
                    ctx.fillStyle = '#1a1208';
                    ctx.fillRect(x, y, s, s);
                    
                    // Canister body
                    ctx.fillStyle = `rgba(255, 140, 0, ${fuelPulse})`;
                    ctx.beginPath();
                    ctx.roundRect(x + 6, y + 4, s - 12, s - 8, 3);
                    ctx.fill();
                    
                    // Canister highlight
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(x + 8, y + 6, s - 16, 3);
                    
                    // Cap
                    ctx.fillStyle = '#666';
                    ctx.fillRect(x + s/2 - 3, y + 2, 6, 4);
                    
                    // "F" symbol
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${Math.floor(s * 0.35)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('F', x + s/2, y + s/2 + 5);
                    break;
                    
                case TILE.BOMB:
                    // Dark background
                    ctx.fillStyle = '#1a1515';
                    ctx.fillRect(x, y, s, s);
                    
                    // Pulsing gold glow behind bomb (subtle but visible)
                    const goldGlow = 0.12 + Math.sin(time * 3 + tx * 2 + ty) * 0.08;
                    ctx.fillStyle = `rgba(255, 200, 50, ${goldGlow})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, s * 0.45, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bomb body (pulsing) - 10% smaller
                    const bombPulse = 0.9 + Math.sin(time * 5 + tx + ty) * 0.1;
                    ctx.fillStyle = '#222222';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, (s * 0.36) * bombPulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bomb highlight
                    ctx.fillStyle = '#444444';
                    ctx.beginPath();
                    ctx.arc(x + s/2 - 2.5, y + s/2 - 0.5, 2.7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gold glint on highlight (stationary sparkle)
                    const glintAlpha = 0.5 + Math.sin(time * 6 + tx) * 0.4;
                    ctx.fillStyle = `rgba(255, 230, 150, ${glintAlpha})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2 - 3.5, y + s/2 - 1.5, 1.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fuse (gold tinted)
                    ctx.strokeStyle = '#cc9933';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 5);
                    ctx.quadraticCurveTo(x + s/2 + 3.5, y + 3, x + s/2 + 5.5, y + 6);
                    ctx.stroke();
                    
                    // Bright spark
                    const sparkAlpha = 0.6 + Math.sin(time * 10) * 0.4;
                    ctx.fillStyle = `rgba(255, 220, 100, ${sparkAlpha})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 5.5, y + 5, 3.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = `rgba(255, 255, 200, ${sparkAlpha * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 5.5, y + 5, 1.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Static grey outline (top layer, crisp, no blur)
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, s * 0.36, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    break;
                    
                case TILE.CHERRY_BOMB:
                    // Dark red background
                    ctx.fillStyle = '#1a0808';
                    ctx.fillRect(x, y, s, s);
                    
                    // Pulsing red glow behind cherry bomb
                    const cherryGlow = 0.15 + Math.sin(time * 4 + tx * 2 + ty) * 0.1;
                    ctx.fillStyle = `rgba(255, 80, 80, ${cherryGlow})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, s * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cherry bomb body (smaller, red)
                    const cherryPulse = 0.9 + Math.sin(time * 6 + tx + ty) * 0.1;
                    ctx.fillStyle = '#cc2222';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, (s * 0.26) * cherryPulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cherry highlight (lighter red)
                    ctx.fillStyle = '#ff5555';
                    ctx.beginPath();
                    ctx.arc(x + s/2 - 2, y + s/2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Small green stem
                    ctx.strokeStyle = '#44aa44';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + s/2 - 4);
                    ctx.quadraticCurveTo(x + s/2 + 2, y + s/2 - 7, x + s/2 + 4, y + s/2 - 5);
                    ctx.stroke();
                    
                    // Small spark at stem tip
                    const cherrySpark = 0.5 + Math.sin(time * 12) * 0.5;
                    ctx.fillStyle = `rgba(255, 200, 100, ${cherrySpark})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 4, y + s/2 - 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Red outline
                    ctx.strokeStyle = '#881111';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, s * 0.26, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                    
                case TILE.CHEST:
                    // Dark background
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x, y, s, s);
                    
                    const chestGlow = 0.85 + Math.sin(time * 2 + tx) * 0.15;
                    
                    // Chest body (wooden brown box)
                    ctx.fillStyle = `rgb(${Math.floor(110 * chestGlow)}, ${Math.floor(65 * chestGlow)}, ${Math.floor(25 * chestGlow)})`;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + s/2 - 1, s - 4, s/2 - 1, 2);
                    ctx.fill();
                    
                    // Rounded lid (dome top)
                    ctx.fillStyle = `rgb(${Math.floor(130 * chestGlow)}, ${Math.floor(80 * chestGlow)}, ${Math.floor(30 * chestGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 1, s/2 - 3, s/3 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Lid top highlight
                    ctx.fillStyle = `rgb(${Math.floor(150 * chestGlow)}, ${Math.floor(95 * chestGlow)}, ${Math.floor(40 * chestGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 3, s/2 - 6, s/5 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Gold metal bands
                    ctx.fillStyle = `rgb(${Math.floor(220 * chestGlow)}, ${Math.floor(180 * chestGlow)}, 60)`;
                    // Horizontal band across front
                    ctx.fillRect(x + 2, y + s/2 - 2, s - 4, 3);
                    // Vertical bands on sides
                    ctx.fillRect(x + 2, y + s/2 - 1, 3, s/2 - 2);
                    ctx.fillRect(x + s - 5, y + s/2 - 1, 3, s/2 - 2);
                    
                    // Gold lock plate (circular)
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Keyhole
                    ctx.fillStyle = '#1a1510';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(x + s/2 - 1, y + s/2 + 4, 2, 3);
                    
                    // Sparkles
                    ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + Math.sin(time * 4 + tx * 2) * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(x + 8, y + s/3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + s - 8, y + s/3 + 2, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case TILE.UPGRADE_CHEST:
                    // Rare upgrade chest - cartoon style with cyan/magenta
                    const upgradeGlow = 0.85 + Math.sin(time * 3 + tx) * 0.15;
                    const pulsePhase = Math.sin(time * 2) * 0.5 + 0.5;
                    
                    // Background glow (contained within tile)
                    ctx.fillStyle = `rgba(0, 255, 200, ${0.2 + pulsePhase * 0.15})`;
                    ctx.fillRect(x, y, s, s);
                    
                    // Dark base
                    ctx.fillStyle = '#0a1520';
                    ctx.fillRect(x + 1, y + 1, s - 2, s - 2);
                    
                    // Chest body (dark teal box)
                    ctx.fillStyle = `rgb(${Math.floor(20 * upgradeGlow)}, ${Math.floor(70 * upgradeGlow)}, ${Math.floor(80 * upgradeGlow)})`;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + s/2 - 1, s - 4, s/2 - 1, 2);
                    ctx.fill();
                    
                    // Rounded lid (dome top - magenta)
                    ctx.fillStyle = `rgb(${Math.floor(100 * upgradeGlow)}, ${Math.floor(30 * upgradeGlow)}, ${Math.floor(120 * upgradeGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 1, s/2 - 3, s/3 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Lid top highlight
                    ctx.fillStyle = `rgb(${Math.floor(130 * upgradeGlow)}, ${Math.floor(50 * upgradeGlow)}, ${Math.floor(150 * upgradeGlow)})`;
                    ctx.beginPath();
                    ctx.ellipse(x + s/2, y + s/2 - 3, s/2 - 6, s/5 - 2, 0, Math.PI, 0);
                    ctx.fill();
                    
                    // Glowing cyan metal bands
                    ctx.fillStyle = `rgba(0, 255, 255, ${0.7 + pulsePhase * 0.3})`;
                    ctx.fillRect(x + 2, y + s/2 - 2, s - 4, 3);
                    ctx.fillRect(x + 2, y + s/2 - 1, 3, s/2 - 2);
                    ctx.fillRect(x + s - 5, y + s/2 - 1, 3, s/2 - 2);
                    
                    // Glowing lock plate
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + pulsePhase * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Lightning bolt on lock
                    ctx.fillStyle = `rgba(0, 200, 255, 1)`;
                    ctx.font = `bold 10px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', x + s/2, y + s/2 + 4);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Sparkle particles
                    for (let i = 0; i < 3; i++) {
                        const sparkleX = x + 6 + (i * (s - 12) / 2);
                        const sparkleY = y + s/3 + Math.sin(time * 5 + i * 2) * 3;
                        ctx.fillStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(time * 6 + i) * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case TILE.ALIEN_NODE:
                    // Alien gem node - pulsing purple/cyan crystalline structure with multiple gems
                    const alienPulse = 0.6 + Math.sin(time * 2.5 + tx + ty) * 0.4;
                    const alienPulse2 = 0.5 + Math.sin(time * 3 + ty) * 0.5;
                    
                    // Dark alien rock base
                    ctx.fillStyle = '#0a0818';
                    ctx.fillRect(x, y, s, s);
                    
                    // Outer glow
                    const alienGlow = ctx.createRadialGradient(x + s/2, y + s/2, 0, x + s/2, y + s/2, s * 0.8);
                    alienGlow.addColorStop(0, `rgba(180, 100, 255, ${alienPulse * 0.5})`);
                    alienGlow.addColorStop(0.5, `rgba(100, 50, 200, ${alienPulse * 0.3})`);
                    alienGlow.addColorStop(1, 'rgba(50, 20, 100, 0)');
                    ctx.fillStyle = alienGlow;
                    ctx.fillRect(x - 2, y - 2, s + 4, s + 4);
                    
                    // Central crystalline core
                    ctx.fillStyle = `rgba(150, 80, 255, ${alienPulse})`;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 3);
                    ctx.lineTo(x + s - 4, y + s/2);
                    ctx.lineTo(x + s/2, y + s - 3);
                    ctx.lineTo(x + 4, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner crystal highlight
                    ctx.fillStyle = `rgba(200, 150, 255, ${alienPulse2})`;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 6);
                    ctx.lineTo(x + s - 8, y + s/2);
                    ctx.lineTo(x + s/2, y + s - 6);
                    ctx.lineTo(x + 8, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Multiple embedded gems (cyan, magenta, orange)
                    const nodeGemColors = ['#00ffff', '#ff00ff', '#ff9500'];
                    for (let i = 0; i < 3; i++) {
                        const gemAngle = (time * 0.5 + i * Math.PI * 2 / 3);
                        const gemDist = 5 + Math.sin(time * 2 + i) * 2;
                        const gemX = x + s/2 + Math.cos(gemAngle) * gemDist;
                        const gemY = y + s/2 + Math.sin(gemAngle) * gemDist;
                        const gemSize = 3 + Math.sin(time * 3 + i * 2) * 1;
                        
                        ctx.fillStyle = nodeGemColors[i];
                        ctx.beginPath();
                        ctx.arc(gemX, gemY, gemSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Gem glow
                        ctx.fillStyle = `${nodeGemColors[i]}44`;
                        ctx.beginPath();
                        ctx.arc(gemX, gemY, gemSize + 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Alien symbol in center
                    ctx.fillStyle = `rgba(255, 255, 255, ${alienPulse * 0.8})`;
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', x + s/2, y + s/2);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Orbiting particles
                    for (let i = 0; i < 4; i++) {
                        const orbitAngle = time * 1.5 + i * Math.PI / 2;
                        const orbitX = x + s/2 + Math.cos(orbitAngle) * (s/2 - 3);
                        const orbitY = y + s/2 + Math.sin(orbitAngle) * (s/2 - 3);
                        ctx.fillStyle = `rgba(200, 150, 255, ${0.6 + Math.sin(time * 4 + i) * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(orbitX, orbitY, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Hexagonal border
                    ctx.strokeStyle = `rgba(150, 100, 255, ${alienPulse})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 1);
                    ctx.lineTo(x + s - 2, y + s/3);
                    ctx.lineTo(x + s - 2, y + s * 2/3);
                    ctx.lineTo(x + s/2, y + s - 1);
                    ctx.lineTo(x + 2, y + s * 2/3);
                    ctx.lineTo(x + 2, y + s/3);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                
                case TILE.CHAIN_CRYSTAL:
                    // Electric blue crystal with lightning
                    const chainPulse = 0.7 + Math.sin(time * 4 + tx * 3 + ty * 2) * 0.3;
                    
                    // Dark base
                    ctx.fillStyle = '#0a1520';
                    ctx.fillRect(x, y, s, s);
                    
                    // Crystal body
                    ctx.fillStyle = `rgba(0, 200, 255, ${chainPulse})`;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 2);
                    ctx.lineTo(x + s - 3, y + s/2);
                    ctx.lineTo(x + s/2, y + s - 2);
                    ctx.lineTo(x + 3, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner glow
                    ctx.fillStyle = `rgba(150, 255, 255, ${chainPulse * 0.8})`;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 6);
                    ctx.lineTo(x + s - 7, y + s/2);
                    ctx.lineTo(x + s/2, y + s - 6);
                    ctx.lineTo(x + 7, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lightning arcs - show less frequently (every ~2.5 seconds for 0.8 seconds)
                    const chainShinePhase = (time * 0.4 + tx * 0.7 + ty * 0.5) % 1; // Slowed cycle
                    if (chainShinePhase < 0.32) { // Only show 32% of the time
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(time * 8 + tx) * 0.5})`;
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            const boltAngle = time * 3 + i * Math.PI * 2 / 3;
                            ctx.beginPath();
                            ctx.moveTo(x + s/2, y + s/2);
                            const midX = x + s/2 + Math.cos(boltAngle) * 6 + Math.sin(time * 10) * 2;
                            const midY = y + s/2 + Math.sin(boltAngle) * 6;
                            ctx.lineTo(midX, midY);
                            ctx.lineTo(x + s/2 + Math.cos(boltAngle) * 11, y + s/2 + Math.sin(boltAngle) * 11);
                            ctx.stroke();
                        }
                    }
                    
                    //  symbol
                    ctx.fillStyle = `rgba(255, 255, 100, ${chainPulse})`;
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', x + s/2 + 1, y + s/2 + 2);
                    ctx.textBaseline = 'alphabetic';
                    break;
                
                case TILE.BOUNCE_PAD:
                    // Green block with upward arrows (mirror of depth charge)
                    const upPulse = 0.6 + Math.sin(time * 3 + tx + ty) * 0.4;
                    const upArrowBob = Math.sin(time * 4) * 2;
                    
                    // Dark green base
                    ctx.fillStyle = '#0a2a0a';
                    ctx.fillRect(x, y, s, s);
                    
                    // Green gradient fill (reversed direction from depth charge)
                    const upGrad = ctx.createLinearGradient(x, y + s, x, y);
                    upGrad.addColorStop(0, `rgba(50, 255, 100, ${upPulse * 0.7})`);
                    upGrad.addColorStop(1, `rgba(0, 200, 50, ${upPulse})`);
                    ctx.fillStyle = upGrad;
                    ctx.fillRect(x + 2, y + 2, s - 4, s - 4);
                    
                    // Upward arrows
                    ctx.fillStyle = `rgba(200, 255, 150, ${upPulse})`;
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', x + s/2, y + s * 2/3 - upArrowBob);
                    ctx.fillText('', x + s/2, y + s/3 - upArrowBob * 0.5);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Warning stripes (at top, mirrored)
                    ctx.strokeStyle = `rgba(200, 255, 100, ${upPulse * 0.5})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + 3 + i * 8, y + 2);
                        ctx.lineTo(x + 7 + i * 8, y + 6);
                        ctx.stroke();
                    }
                    
                    // Glow
                    ctx.fillStyle = `rgba(100, 255, 100, ${upPulse * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2, s/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case TILE.MYSTERY_BLOCK:
                    // Rainbow shimmer with question mark
                    const mysteryTime = time * 2 + tx + ty;
                    const hue1 = (mysteryTime * 60) % 360;
                    const hue2 = (hue1 + 120) % 360;
                    const mysteryPulse = 0.7 + Math.sin(time * 3) * 0.3;
                    
                    // Shifting gradient background
                    const mysteryGrad = ctx.createLinearGradient(x, y, x + s, y + s);
                    mysteryGrad.addColorStop(0, `hsla(${hue1}, 80%, 50%, ${mysteryPulse})`);
                    mysteryGrad.addColorStop(0.5, `hsla(${hue2}, 80%, 60%, ${mysteryPulse})`);
                    mysteryGrad.addColorStop(1, `hsla(${(hue2 + 120) % 360}, 80%, 50%, ${mysteryPulse})`);
                    ctx.fillStyle = '#1a1a2a';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = mysteryGrad;
                    ctx.fillRect(x + 1, y + 1, s - 2, s - 2);
                    
                    // Question mark
                    ctx.fillStyle = `rgba(255, 255, 255, ${mysteryPulse})`;
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('?', x + s/2, y + s/2);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Border shimmer
                    ctx.strokeStyle = `hsla(${hue1}, 100%, 70%, ${mysteryPulse})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1, y + 1, s - 2, s - 2);
                    break;
                
                case TILE.DEPTH_CHARGE:
                    // Red block with downward arrows
                    const depthPulse = 0.6 + Math.sin(time * 3 + tx + ty) * 0.4;
                    const arrowBob = Math.sin(time * 4) * 2;
                    
                    // Dark red base
                    ctx.fillStyle = '#2a0a0a';
                    ctx.fillRect(x, y, s, s);
                    
                    // Red gradient fill
                    const depthGrad = ctx.createLinearGradient(x, y, x, y + s);
                    depthGrad.addColorStop(0, `rgba(255, 50, 50, ${depthPulse * 0.7})`);
                    depthGrad.addColorStop(1, `rgba(200, 0, 0, ${depthPulse})`);
                    ctx.fillStyle = depthGrad;
                    ctx.fillRect(x + 2, y + 2, s - 4, s - 4);
                    
                    // Downward arrows
                    ctx.fillStyle = `rgba(255, 200, 100, ${depthPulse})`;
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', x + s/2, y + s/3 + arrowBob);
                    ctx.fillText('', x + s/2, y + s * 2/3 + arrowBob * 0.5);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Warning stripes
                    ctx.strokeStyle = `rgba(255, 200, 0, ${depthPulse * 0.5})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + 3 + i * 8, y + s - 2);
                        ctx.lineTo(x + 7 + i * 8, y + s - 6);
                        ctx.stroke();
                    }
                    
                    // Glow
                    ctx.fillStyle = `rgba(255, 100, 50, ${depthPulse * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2, s/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case TILE.MAGNET_ORE:
                    // Purple/pink with magnetic field lines and drawn magnet symbol
                    const magnetPulse = 0.6 + Math.sin(time * 2.5 + tx + ty) * 0.4;
                    const fieldRotation = time * 1.5;
                    
                    // Dark purple base
                    ctx.fillStyle = '#1a0a1a';
                    ctx.fillRect(x, y, s, s);
                    
                    // Outer glow (draw first, behind everything)
                    ctx.fillStyle = `rgba(255, 100, 255, ${magnetPulse * 0.15})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2, s/2 + 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Magnetic field lines (radiating outward)
                    ctx.strokeStyle = `rgba(255, 100, 200, ${magnetPulse * 0.5})`;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 6; i++) {
                        const angle = fieldRotation + i * Math.PI / 3;
                        const innerR = 8;
                        const outerR = s/2 - 2;
                        ctx.beginPath();
                        ctx.moveTo(x + s/2 + Math.cos(angle) * innerR, y + s/2 + Math.sin(angle) * innerR);
                        const midAngle = angle + 0.3;
                        ctx.quadraticCurveTo(
                            x + s/2 + Math.cos(midAngle) * (outerR * 0.7),
                            y + s/2 + Math.sin(midAngle) * (outerR * 0.7),
                            x + s/2 + Math.cos(angle + 0.5) * outerR,
                            y + s/2 + Math.sin(angle + 0.5) * outerR
                        );
                        ctx.stroke();
                    }
                    
                    // Draw horseshoe magnet (curve at TOP, arms pointing DOWN, silver tips at bottom)
                    const magCX = x + s/2;
                    const magCY = y + s/2;
                    // 10% smaller base, pulses in sync with background (magnetPulse ranges 0.2-1.0)
                    const magScale = 0.27 + magnetPulse * 0.072;
                    const outerR = s * magScale;
                    const innerR = s * magScale * 0.45;
                    const armLength = s * 0.225 * (0.85 + magnetPulse * 0.15); // Arms also pulse
                    
                    // Draw filled U-shape horseshoe
                    ctx.beginPath();
                    // Start at bottom of left arm (where silver tip will be)
                    ctx.moveTo(magCX - outerR, magCY + armLength);
                    // Up the left outer edge
                    ctx.lineTo(magCX - outerR, magCY);
                    // Outer curve at top
                    ctx.arc(magCX, magCY, outerR, Math.PI, 0, false);
                    // Down the right outer edge
                    ctx.lineTo(magCX + outerR, magCY + armLength);
                    // Across bottom of right arm (will be covered by silver tip)
                    ctx.lineTo(magCX + innerR, magCY + armLength);
                    // Up the right inner edge
                    ctx.lineTo(magCX + innerR, magCY);
                    // Inner curve at top
                    ctx.arc(magCX, magCY, innerR, 0, Math.PI, true);
                    // Down the left inner edge
                    ctx.lineTo(magCX - innerR, magCY + armLength);
                    ctx.closePath();
                    
                    // Create gradient for left half (red) and right half (blue)
                    // Fill left half red
                    ctx.save();
                    ctx.clip();
                    ctx.fillStyle = '#e63333';
                    ctx.fillRect(magCX - outerR - 1, magCY - outerR - 1, outerR + 1, outerR * 2 + armLength + 2);
                    // Red highlight
                    ctx.fillStyle = '#ff5555';
                    ctx.fillRect(magCX - outerR + 1, magCY - outerR + 2, (outerR - innerR) * 0.4, outerR * 2 + armLength - 4);
                    // Fill right half blue
                    ctx.fillStyle = '#3366e6';
                    ctx.fillRect(magCX, magCY - outerR - 1, outerR + 1, outerR * 2 + armLength + 2);
                    // Blue highlight
                    ctx.fillStyle = '#5588ff';
                    ctx.fillRect(magCX + innerR + 1, magCY - outerR + 2, (outerR - innerR) * 0.4, outerR * 2 + armLength - 4);
                    ctx.restore();
                    
                    // Silver tips at bottom of arms (scale with magnet)
                    const tipHeight = s * 0.108 * (0.85 + magnetPulse * 0.15);
                    const tipY = magCY + armLength - 1;
                    
                    // Left silver tip
                    ctx.fillStyle = '#888899';
                    ctx.fillRect(magCX - outerR - 1, tipY, outerR - innerR + 2, tipHeight + 1);
                    ctx.fillStyle = '#aaaabc';
                    ctx.fillRect(magCX - outerR, tipY + 1, outerR - innerR, tipHeight - 2);
                    ctx.fillStyle = '#ccccdd';
                    ctx.fillRect(magCX - outerR + 1, tipY + 1, (outerR - innerR) * 0.3, tipHeight - 2);
                    
                    // Right silver tip
                    ctx.fillStyle = '#888899';
                    ctx.fillRect(magCX + innerR - 1, tipY, outerR - innerR + 2, tipHeight + 1);
                    ctx.fillStyle = '#aaaabc';
                    ctx.fillRect(magCX + innerR, tipY + 1, outerR - innerR, tipHeight - 2);
                    ctx.fillStyle = '#ccccdd';
                    ctx.fillRect(magCX + innerR + 1, tipY + 1, (outerR - innerR) * 0.3, tipHeight - 2);
                    
                    // Subtle center glow (scales with magnet)
                    ctx.fillStyle = `rgba(255, 150, 255, ${magnetPulse * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(magCX, magCY + 2, 1.8 + magnetPulse * 1.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    break;
                    
                case TILE.UNSTABLE:
                    // Check if this tile is about to collapse
                    const unstableData = unstableTiles.find(u => u.tx === tx && u.absoluteTy === ty);
                    const isWarning = unstableData && unstableData.timer < 25;
                    const shakeAmount = isWarning ? Math.sin(time * 20) * 2 : 0;
                    
                    // Cracked rock appearance
                    ctx.fillStyle = isWarning ? '#4a3535' : '#3a3545';
                    ctx.fillRect(x + shakeAmount, y, s, s);
                    
                    // Crack lines
                    ctx.strokeStyle = isWarning ? '#ff6666' : '#555566';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x + s/4 + shakeAmount, y);
                    ctx.lineTo(x + s/3 + shakeAmount, y + s/2);
                    ctx.lineTo(x + s/5 + shakeAmount, y + s);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + s*0.7 + shakeAmount, y);
                    ctx.lineTo(x + s*0.6 + shakeAmount, y + s/3);
                    ctx.lineTo(x + s*0.8 + shakeAmount, y + s*0.7);
                    ctx.stroke();
                    
                    // Warning glow
                    if (isWarning) {
                        ctx.fillStyle = `rgba(255, 100, 100, ${0.2 + Math.sin(time * 15) * 0.2})`;
                        ctx.fillRect(x, y, s, s);
                    }
                    break;
                    
                case TILE.PORTAL:
                    // Boss portal - swirling alien vortex (2x2, this is top-left)
                    const portalPulse = 0.7 + Math.sin(time * 2) * 0.3;
                    const portalRotation = time * 2;
                    
                    // Draw across 2x2 area
                    const portalCenterX = x + s;
                    const portalCenterY = y + s;
                    const portalRadius = s * 0.9;
                    
                    // Outer glow
                    ctx.save();
                    const portalGlow = ctx.createRadialGradient(
                        portalCenterX, portalCenterY, 0,
                        portalCenterX, portalCenterY, portalRadius * 1.5
                    );
                    portalGlow.addColorStop(0, `rgba(180, 50, 255, ${portalPulse * 0.8})`);
                    portalGlow.addColorStop(0.5, `rgba(100, 0, 200, ${portalPulse * 0.5})`);
                    portalGlow.addColorStop(1, 'rgba(50, 0, 100, 0)');
                    ctx.fillStyle = portalGlow;
                    ctx.fillRect(x - 5, y - 5, s * 2 + 10, s * 2 + 10);
                    
                    // Swirling vortex rings
                    for (let ring = 0; ring < 4; ring++) {
                        const ringRadius = portalRadius * (0.3 + ring * 0.2);
                        const ringAlpha = 0.8 - ring * 0.15;
                        const ringOffset = portalRotation + ring * 0.5;
                        
                        ctx.strokeStyle = `rgba(${150 + ring * 30}, ${50 + ring * 20}, 255, ${ringAlpha * portalPulse})`;
                        ctx.lineWidth = 3 - ring * 0.5;
                        ctx.beginPath();
                        ctx.arc(portalCenterX, portalCenterY, ringRadius, ringOffset, ringOffset + Math.PI * 1.5);
                        ctx.stroke();
                    }
                    
                    // Center eye
                    ctx.fillStyle = `rgba(255, 100, 255, ${portalPulse})`;
                    ctx.beginPath();
                    ctx.arc(portalCenterX, portalCenterY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner glow
                    ctx.fillStyle = `rgba(255, 200, 255, ${portalPulse * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(portalCenterX, portalCenterY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Floating particles around portal
                    for (let i = 0; i < 6; i++) {
                        const particleAngle = portalRotation * 0.5 + i * Math.PI / 3;
                        const particleDist = portalRadius * (0.6 + Math.sin(time * 3 + i) * 0.3);
                        const px = portalCenterX + Math.cos(particleAngle) * particleDist;
                        const py = portalCenterY + Math.sin(particleAngle) * particleDist;
                        
                        ctx.fillStyle = `rgba(200, 100, 255, ${0.5 + Math.sin(time * 4 + i) * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(px, py, 2 + Math.sin(time * 5 + i) * 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    break;
                    
                case TILE.PORTAL_PART:
                    // Secondary portal tiles - don't render (handled by TILE.PORTAL)
                    break;
                    
                case TILE.GATE:
                    // Find which gate this is to check for key
                    const gateRow = ty + worldRowOffset;
                    const gateInfo = gateLocations.find(g => g.depth + 2 === gateRow);
                    const hasKey = gateInfo && hasKeyForGate(gateInfo.depth);
                    
                    const gateTime = time * 2;
                    
                    // Calculate position in row for cohesive effects (0-1 normalized)
                    const rowPos = tx / WORLD_WIDTH;
                    const wavePhase = tx * 0.4 + gateTime;
                    
                    if (hasKey) {
                        // KEY READY - Cyan/green cohesive barrier
                        const keyPulse = 0.5 + Math.sin(gateTime * 1.5 + rowPos * Math.PI) * 0.5;
                        
                        // Seamless dark base
                        ctx.fillStyle = '#041015';
                        ctx.fillRect(x, y, s, s);
                        
                        // Flowing energy gradient (uses rowPos for seamless look)
                        const energyIntensity = 0.3 + Math.sin(wavePhase) * 0.15;
                        const keyGateGrad = ctx.createLinearGradient(x, y, x, y + s);
                        keyGateGrad.addColorStop(0, `rgba(0, 80, 60, ${energyIntensity})`);
                        keyGateGrad.addColorStop(0.3, `rgba(0, 255, 200, ${energyIntensity + 0.2})`);
                        keyGateGrad.addColorStop(0.5, `rgba(0, 255, 220, ${energyIntensity + 0.35})`);
                        keyGateGrad.addColorStop(0.7, `rgba(0, 255, 200, ${energyIntensity + 0.2})`);
                        keyGateGrad.addColorStop(1, `rgba(0, 80, 60, ${energyIntensity})`);
                        ctx.fillStyle = keyGateGrad;
                        ctx.fillRect(x, y, s, s);
                        
                        // Continuous energy band across all tiles
                        const bandY = y + s * 0.5;
                        const bandWave = Math.sin(wavePhase * 0.5) * 2;
                        ctx.fillStyle = `rgba(0, 255, 200, ${0.4 + keyPulse * 0.3})`;
                        ctx.fillRect(x, bandY - 4 + bandWave, s, 8);
                        
                        // Thinner accent lines
                        ctx.fillStyle = `rgba(100, 255, 220, ${0.3 + keyPulse * 0.2})`;
                        ctx.fillRect(x, y + s * 0.25 + Math.sin(wavePhase) * 2, s, 2);
                        ctx.fillRect(x, y + s * 0.75 + Math.sin(wavePhase + 1) * 2, s, 2);
                        
                        // Flowing particles (continuous across tiles)
                        const particleX = ((time * 50 + tx * s) % (WORLD_WIDTH * s)) / WORLD_WIDTH;
                        if (Math.abs(rowPos - (particleX % 1)) < 0.08) {
                            ctx.fillStyle = `rgba(150, 255, 220, ${keyPulse})`;
                            ctx.beginPath();
                            ctx.arc(x + s/2, y + s/2 + bandWave, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else {
                        // LOCKED - Red/orange cohesive barrier
                        const lockPulse = 0.5 + Math.sin(gateTime + rowPos * Math.PI) * 0.5;
                        
                        // Seamless dark base
                        ctx.fillStyle = '#100505';
                        ctx.fillRect(x, y, s, s);
                        
                        // Flowing energy gradient
                        const energyIntensity = 0.25 + Math.sin(wavePhase) * 0.12;
                        const gateGrad = ctx.createLinearGradient(x, y, x, y + s);
                        gateGrad.addColorStop(0, `rgba(80, 20, 20, ${energyIntensity})`);
                        gateGrad.addColorStop(0.3, `rgba(255, 80, 50, ${energyIntensity + 0.2})`);
                        gateGrad.addColorStop(0.5, `rgba(255, 120, 50, ${energyIntensity + 0.35})`);
                        gateGrad.addColorStop(0.7, `rgba(255, 80, 50, ${energyIntensity + 0.2})`);
                        gateGrad.addColorStop(1, `rgba(80, 20, 20, ${energyIntensity})`);
                        ctx.fillStyle = gateGrad;
                        ctx.fillRect(x, y, s, s);
                        
                        // Continuous energy band across all tiles
                        const bandY2 = y + s * 0.5;
                        const bandWave2 = Math.sin(wavePhase * 0.5) * 2;
                        ctx.fillStyle = `rgba(255, 100, 50, ${0.4 + lockPulse * 0.3})`;
                        ctx.fillRect(x, bandY2 - 4 + bandWave2, s, 8);
                        
                        // Thinner accent lines
                        ctx.fillStyle = `rgba(255, 150, 80, ${0.3 + lockPulse * 0.2})`;
                        ctx.fillRect(x, y + s * 0.25 + Math.sin(wavePhase) * 2, s, 2);
                        ctx.fillRect(x, y + s * 0.75 + Math.sin(wavePhase + 1) * 2, s, 2);
                        
                        // Occasional energy crackle
                        if (Math.random() < 0.015) {
                            ctx.strokeStyle = `rgba(255, 200, 100, ${0.6 + lockPulse * 0.4})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            const crackleY = y + Math.random() * s;
                            ctx.moveTo(x, crackleY);
                            ctx.lineTo(x + s/3, crackleY + (Math.random() - 0.5) * 6);
                            ctx.lineTo(x + s*2/3, crackleY + (Math.random() - 0.5) * 6);
                            ctx.lineTo(x + s, crackleY);
                            ctx.stroke();
                        }
                    }
                    break;
            }
            
            // Grid lines (simplified)
            if (tile !== TILE.AIR && tile < TILE.LAVA) {
                ctx.strokeStyle = 'rgba(0,0,0,0.08)';
                ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
            }
        }
        
        // Draw gate icons as centered overlay (not tied to tile positions)
        function drawGateIcons() {
            const time = globalTime * 0.05;
            
            // Find visible gate rows
            for (const gateInfo of gateLocations) {
                const gateWorldRow = gateInfo.depth + 2;
                const gateScreenY = gateWorldRow * TILE_SIZE - cameraY;
                
                // Only draw if gate is visible on screen
                if (gateScreenY < -TILE_SIZE || gateScreenY > BASE_HEIGHT + TILE_SIZE) continue;
                
                // Check if we have the key for this gate
                const hasKey = hasKeyForGate(gateInfo.depth);
                
                // Animation timing
                const gateTime = time * 2;
                const pulse = 0.6 + Math.sin(gateTime) * 0.4;
                
                // 4 evenly spaced icon positions (centered with symmetry)
                // Screen width is BASE_WIDTH, divide into 5 equal sections
                const spacing = BASE_WIDTH / 5;
                const iconPositions = [
                    spacing * 1,      // Position 1
                    spacing * 2,      // Position 2
                    spacing * 3,      // Position 3
                    spacing * 4       // Position 4
                ];
                
                const iconY = gateScreenY + TILE_SIZE / 2;
                const icon = hasKey ? '' : '';
                const glowColor = hasKey ? 'rgba(0, 255, 200,' : 'rgba(255, 100, 50,';
                const textColor = hasKey ? '#00ffcc' : '#ff8844';
                const bgColor = hasKey ? 'rgba(0, 40, 35, 0.9)' : 'rgba(40, 15, 10, 0.9)';
                const borderColor = hasKey ? 'rgba(0, 255, 200, 0.8)' : 'rgba(255, 100, 50, 0.8)';
                
                for (const iconX of iconPositions) {
                    // Dark backing circle for legibility
                    ctx.fillStyle = bgColor;
                    ctx.beginPath();
                    ctx.arc(iconX, iconY, 14, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glowing border
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(iconX, iconY, 14, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Outer glow (pulsing)
                    ctx.strokeStyle = `${glowColor} ${pulse * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(iconX, iconY, 16 + pulse * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Icon text with shadow for clarity
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Draw shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillText(icon, iconX + 1, iconY + 1);
                    
                    // Draw icon
                    ctx.fillStyle = textColor;
                    ctx.fillText(icon, iconX, iconY);
                }
                
                // Reset text baseline
                ctx.textBaseline = 'alphabetic';
            }
        }
        
        function drawPlayer() {
            const screenY = Math.round(player.y - cameraY);
            const cx = Math.round(player.x + player.width / 2);
            const heatPercent = drillHeat / maxDrillHeat;
            
            // ===== LOW FUEL SMOKE EFFECT =====
            const fuelPercent = fuel / maxFuel;
            if (fuelPercent < 0.25 && !deathAnimationActive) {
                // Spawn smoke puffs more frequently as fuel gets lower
                const smokeChance = (0.25 - fuelPercent) * 0.4; // Max 10% per frame at 0 fuel
                if (Math.random() < smokeChance) {
                    // Calculate velocity based on player movement
                    const isMoving = keys.up || keys.down || keys.left || keys.right || player.digging;
                    if (isMoving || Math.random() < 0.3) { // Always some smoke, more when moving
                        const grey = 60 + Math.floor(Math.random() * 40);
                        particles.push({
                            x: cx + (Math.random() - 0.5) * 16,
                            y: player.y + player.height - 2,
                            vx: (Math.random() - 0.5) * 1.5,
                            vy: 0.5 + Math.random() * 1.5, // Drift downward/sideways
                            size: 3 + Math.random() * 5,
                            color: `rgba(${grey}, ${grey}, ${grey}, 0.7)`,
                            life: 0.6 + Math.random() * 0.4,
                            type: 'smoke'
                        });
                    }
                }
            }
            
            // Death animation effects - machine powering down
            if (deathAnimationActive) {
                const progress = 1 - (deathAnimationTimer / DEATH_ANIMATION_DURATION);
                
                // Spawn smoke/dust puff particles (initial burst then occasional wisps)
                const particleChance = progress < 0.3 ? 0.5 : 0.15;
                if (Math.random() < particleChance) {
                    // Mix of smoke (grey) and sparks (orange/cyan depending on death type)
                    const isSmoke = Math.random() < 0.7;
                    let color;
                    if (isSmoke) {
                        const grey = 80 + Math.floor(Math.random() * 60);
                        color = `rgb(${grey}, ${grey}, ${grey})`;
                    } else {
                        color = deathReason === 'hull' ? '#00ccff' : '#ff9500';
                    }
                    
                    particles.push({
                        x: cx + (Math.random() - 0.5) * 20,
                        y: player.y + player.height * 0.3 + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -1 - Math.random() * 2, // Float upward
                        size: isSmoke ? (4 + Math.random() * 6) : (2 + Math.random() * 3),
                        color: color,
                        life: isSmoke ? 1.2 : 0.5,
                        type: 'smoke'
                    });
                }
                
                // Tilt sideways and sink down like a broken machine
                ctx.save();
                ctx.translate(cx, screenY + player.height / 2);
                
                // Tilt to the side (ease into final position)
                const tiltAngle = Math.min(progress * 1.5, 1) * (Math.PI / 4); // Max 45 degree tilt
                ctx.rotate(tiltAngle);
                
                // Slight sinking effect
                const sinkAmount = progress * 4;
                ctx.translate(0, sinkAmount);
                
                // Fade out gradually
                ctx.globalAlpha = 1 - progress * 0.6;
                
                ctx.translate(-cx, -(screenY + player.height / 2));
                
                // Occasional dim flicker (like power failing)
                if (progress < 0.7 && Math.random() < 0.1) {
                    ctx.filter = 'brightness(0.5)';
                } else if (progress > 0.5) {
                    // Desaturate as it dies
                    ctx.filter = `saturate(${1 - (progress - 0.5) * 1.5})`;
                }
            }
            
            // Calculate drill position early so all effects can use it
            let drillAngle = 0; // 0 = down, -90 = left, 90 = right
            let drillOffsetX = 0;
            let drillOffsetY = player.height;
            
            // Determine drill direction
            let drillDirection = 'down'; // Track current direction
            
            // Check if actively digging - this takes priority even in hover mode
            if (player.digging && player.digTarget) {
                const targetWorldX = player.digTarget.x * TILE_SIZE + TILE_SIZE / 2;
                const targetWorldY = player.digTarget.y * TILE_SIZE + TILE_SIZE / 2;
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const dx = targetWorldX - playerCenterX;
                const dy = targetWorldY - playerCenterY;
                
                if (dy < -TILE_SIZE / 2) {
                    drillDirection = 'up';
                } else if (Math.abs(dx) > TILE_SIZE / 2) {
                    // Drilling left or right
                    if (dx < 0) {
                        drillDirection = 'left';
                    } else {
                        drillDirection = 'right';
                    }
                }
            }
            // If not digging but holding direction keys, point drill that direction
            else if (keys.up && !keys.down) {
                drillDirection = 'up';
            } else if (keys.left && !keys.right) {
                drillDirection = 'left';
            } else if (keys.right && !keys.left) {
                drillDirection = 'right';
            } else if (keys.down) {
                drillDirection = 'down';
            }
            // When idle (no keys pressed), stay in last dig direction
            else if (lastDigDirection) {
                drillDirection = lastDigDirection;
            }
            // Default to down only if no direction history
            else if (hoverMode) {
                drillDirection = 'down';
            }
            
            // Apply direction offsets
            if (drillDirection === 'up') {
                drillAngle = Math.PI;
                drillOffsetX = 0;
                drillOffsetY = -3;
            } else if (drillDirection === 'left') {
                drillAngle = Math.PI / 2;
                drillOffsetX = -player.width / 2 - 3;
                drillOffsetY = player.height / 2 - 1; // Nudged up 2px
            } else if (drillDirection === 'right') {
                drillAngle = -Math.PI / 2;
                drillOffsetX = player.width / 2 + 3;
                drillOffsetY = player.height / 2 - 1; // Nudged up 2px
            }
            
            // Actual drill world position for effects
            const drillWorldX = Math.round(cx + drillOffsetX);
            const drillWorldY = Math.round(screenY + drillOffsetY);
            
            // ===== OVERHEAT WARNING AURA =====
            if (heatPercent > 0.7 || drillOverheated) {
                const warningIntensity = drillOverheated ? 0.6 : (heatPercent - 0.7) * 2;
                const pulseSpeed = drillOverheated ? 0.4 : 0.2;
                const pulse = Math.sin(globalTime * pulseSpeed) * 0.3 + 0.7;
                const auraSize = 25 + (drillOverheated ? Math.sin(globalTime * 0.3) * 5 : 0);
                
                const heatAura = ctx.createRadialGradient(drillWorldX, drillWorldY, 5, drillWorldX, drillWorldY, auraSize);
                heatAura.addColorStop(0, `rgba(255, ${drillOverheated ? 50 : 150}, 0, ${warningIntensity * pulse})`);
                heatAura.addColorStop(0.5, `rgba(255, ${drillOverheated ? 0 : 100}, 0, ${warningIntensity * pulse * 0.5})`);
                heatAura.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = heatAura;
                ctx.beginPath();
                ctx.arc(drillWorldX, drillWorldY, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ===== FEVER MODE AURA =====
            if (feverMode) {
                const auraSize = 30 + Math.sin(globalTime * 0.15) * 8;
                const auraGrad = ctx.createRadialGradient(cx, screenY + player.height/2, 5, cx, screenY + player.height/2, auraSize);
                auraGrad.addColorStop(0, 'rgba(255, 0, 255, 0.4)');
                auraGrad.addColorStop(0.5, 'rgba(255, 0, 255, 0.15)');
                auraGrad.addColorStop(1, 'rgba(255, 0, 255, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(cx, screenY + player.height/2, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Thruster glow
            if (keys.up) {
                const thrusterColor = feverMode ? 'rgba(255, 0, 255,' : 'rgba(255, 100, 0,';
                ctx.fillStyle = `${thrusterColor} ${0.4 * player.thrusterFlicker})`;
                ctx.beginPath();
                ctx.ellipse(cx, screenY + 22, 10, 15, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Body color shifts with heat when overheated
            let bodyColor = feverMode ? '#d000d8' : '#00d0d8';
            let highlightColor = feverMode ? '#ff00ff' : '#00f0ff';
            if (drillOverheated) {
                const flashPhase = Math.sin(globalTime * 0.5) * 0.5 + 0.5;
                bodyColor = `rgb(${Math.floor(200 + flashPhase * 55)}, ${Math.floor(50 * (1 - flashPhase))}, ${Math.floor(80 * (1 - flashPhase))})`;
                highlightColor = `rgb(255, ${Math.floor(100 * (1 - flashPhase))}, ${Math.floor(50 * (1 - flashPhase))})`;
            }
            
            // Invulnerability flash effect (boss arena only)
            if (bossArenaActive && playerInvulnerable > 0) {
                // Flash white/transparent when invulnerable
                if (Math.floor(playerInvulnerable / 4) % 2 === 0) {
                    ctx.globalAlpha = 0.4;
                } else {
                    ctx.globalAlpha = 1;
                    bodyColor = '#ffffff';
                    highlightColor = '#ffcccc';
                }
            }
            
            // Determine if player should be flipped horizontally
            const facingLeft = drillDirection === 'left';
            
            // Save context for player body flip
            ctx.save();
            if (facingLeft) {
                // Flip horizontally around player center
                ctx.translate(cx, 0);
                ctx.scale(-1, 1);
                ctx.translate(-cx, 0);
            }
            
            // Body
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.roundRect(player.x + 2, screenY + 4, player.width - 4, player.height - 10, 5);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = highlightColor;
            ctx.fillRect(player.x + 4, screenY + 5, player.width - 8, 3);
            
            // Cockpit
            ctx.fillStyle = feverMode ? '#150015' : (drillOverheated ? '#150505' : '#001015');
            ctx.beginPath();
            ctx.roundRect(player.x + 5, screenY + 7, player.width - 10, 10, 3);
            ctx.fill();
            
            ctx.fillStyle = feverMode ? 'rgba(255, 0, 255, 0.7)' : (drillOverheated ? 'rgba(255, 100, 50, 0.7)' : 'rgba(0, 240, 255, 0.7)');
            ctx.beginPath();
            ctx.roundRect(player.x + 6, screenY + 8, player.width - 12, 8, 2);
            ctx.fill();
            
            // Thrusters (draw before drill so drill appears on top)
            ctx.fillStyle = feverMode ? '#450045' : (drillOverheated ? '#452020' : '#004550');
            ctx.fillRect(player.x - 1, screenY + 12, 4, 8);
            ctx.fillRect(player.x + player.width - 3, screenY + 12, 4, 8);
            
            // ===== LOW HULL CRACKING EFFECT =====
            const hullPercent = hull / maxHull;
            if (hullPercent < 0.5 && !deathAnimationActive) {
                ctx.strokeStyle = '#111111';
                ctx.lineWidth = 1.5;
                
                // Crack intensity increases as hull decreases
                const crackIntensity = 1 - (hullPercent / 0.5); // 0 at 50%, 1 at 0%
                
                // First crack (appears at 50% hull) - diagonal from top-left
                ctx.beginPath();
                ctx.moveTo(player.x + 4, screenY + 5);
                ctx.lineTo(player.x + 8, screenY + 10);
                ctx.lineTo(player.x + 6, screenY + 14);
                ctx.stroke();
                
                // Second crack (appears at 35% hull) - from top-right
                if (hullPercent < 0.35) {
                    ctx.beginPath();
                    ctx.moveTo(player.x + player.width - 4, screenY + 6);
                    ctx.lineTo(player.x + player.width - 7, screenY + 11);
                    ctx.lineTo(player.x + player.width - 5, screenY + 15);
                    ctx.stroke();
                }
                
                // Third crack (appears at 20% hull) - across middle
                if (hullPercent < 0.2) {
                    ctx.beginPath();
                    ctx.moveTo(player.x + 6, screenY + 12);
                    ctx.lineTo(player.x + 10, screenY + 14);
                    ctx.lineTo(player.x + player.width - 8, screenY + 13);
                    ctx.stroke();
                    
                    // Sparking effect at very low hull
                    if (Math.random() < 0.15) {
                        const sparkX = player.x + 4 + Math.random() * (player.width - 8);
                        const sparkY = screenY + 6 + Math.random() * 12;
                        particles.push({
                            x: sparkX,
                            y: sparkY + cameraY, // Convert to world coords
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            size: 1 + Math.random() * 2,
                            color: Math.random() < 0.5 ? '#ffff00' : '#ff8800',
                            life: 0.2 + Math.random() * 0.2,
                            type: 'spark'
                        });
                    }
                }
                
                // Pulsing red warning tint overlay at critical hull
                if (hullPercent < 0.15) {
                    const pulse = Math.sin(globalTime * 0.4) * 0.15 + 0.15;
                    ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                    ctx.beginPath();
                    ctx.roundRect(player.x + 2, screenY + 4, player.width - 4, player.height - 10, 5);
                    ctx.fill();
                }
            }
            
            // Restore context after body (drill has its own transform)
            ctx.restore();
            
            // Drill - color changes with heat (drawn last to appear on top)
            let drillColor = feverMode ? '#ff00ff' : '#e8e8e8';
            if (heatPercent > 0.3 && !feverMode) {
                // Transition from white to orange to red based on heat
                const heatTint = Math.min(1, (heatPercent - 0.3) / 0.7);
                const r = Math.floor(232 + (255 - 232) * heatTint);
                const g = Math.floor(232 - 180 * heatTint);
                const b = Math.floor(232 - 200 * heatTint);
                drillColor = `rgb(${r}, ${g}, ${b})`;
            }
            if (drillOverheated) {
                // Pulsing red when overheated
                const pulse = Math.sin(globalTime * 0.4) * 0.3 + 0.7;
                drillColor = `rgb(255, ${Math.floor(50 * pulse)}, ${Math.floor(30 * pulse)})`;
            }
            
            ctx.fillStyle = drillColor;
            ctx.save();
            
            ctx.translate(drillWorldX, drillWorldY);
            ctx.rotate(drillAngle);
            
            // Drill shake when overheated or near overheat
            if (drillOverheated) {
                const shake = Math.sin(globalTime * 0.8) * 2;
                ctx.translate(shake, 0);
            } else if (heatPercent > 0.8) {
                const shake = Math.sin(globalTime * 0.6) * 1;
                ctx.translate(shake, 0);
            }
            
            if (player.digging) {
                const spinSpeed = feverMode ? 0.8 : 0.5;
                ctx.rotate(Math.sin(globalTime * spinSpeed) * 0.15);
            }
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.lineTo(8, -4);
            ctx.lineTo(3, 10);
            ctx.lineTo(0, 14);
            ctx.lineTo(-3, 10);
            ctx.closePath();
            ctx.fill();
            
            // Drill glow when hot
            if (heatPercent > 0.5) {
                ctx.shadowColor = drillOverheated ? '#ff2200' : '#ff8800';
                ctx.shadowBlur = 8 + heatPercent * 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            ctx.strokeStyle = feverMode ? '#aa00aa' : (drillOverheated ? '#aa2200' : '#999999');
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-4, 0);
            ctx.lineTo(0, 10);
            ctx.moveTo(4, 0);
            ctx.lineTo(0, 10);
            ctx.stroke();
            ctx.restore();
            
            // Dig progress indicator
            if (player.digging && player.digTarget) {
                const progress = player.digProgress / player.digTarget.time;
                const barColor = feverMode ? 'rgba(255, 0, 255,' : 'rgba(0, 240, 255,';
                ctx.fillStyle = `${barColor} 0.8)`;
                ctx.fillRect(player.x, screenY - 6, player.width * progress, 3);
                ctx.strokeStyle = `${barColor} 0.4)`;
                ctx.strokeRect(player.x, screenY - 6, player.width, 3);
            }
            
            // Drill heat bar (shows when heat > 20%)
            if (drillHeat > 20 || drillOverheated) {
                const heatPercent = drillHeat / maxDrillHeat;
                const heatBarWidth = player.width + 8;
                const heatBarX = player.x - 4;
                const heatBarY = screenY - 14;
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(heatBarX, heatBarY, heatBarWidth, 5);
                
                // Heat fill - transitions from yellow to orange to red
                let heatColor;
                if (heatPercent < 0.5) {
                    heatColor = `rgb(255, ${Math.floor(255 - heatPercent * 200)}, 50)`;
                } else if (heatPercent < 0.8) {
                    heatColor = `rgb(255, ${Math.floor(155 - (heatPercent - 0.5) * 300)}, 30)`;
                } else {
                    heatColor = '#ff2200';
                }
                
                // Pulsing when near overheat
                if (heatPercent > 0.7) {
                    const pulse = Math.sin(globalTime * 0.3) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                }
                
                ctx.fillStyle = heatColor;
                ctx.fillRect(heatBarX, heatBarY, heatBarWidth * heatPercent, 5);
                ctx.globalAlpha = 1;
                
                // Border
                ctx.strokeStyle = drillOverheated ? '#ff0000' : 'rgba(255, 150, 50, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(heatBarX, heatBarY, heatBarWidth, 5);
                
                // Overheat warning icon
                if (drillOverheated) {
                    ctx.fillStyle = '#ff4400';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('', player.x + player.width/2, heatBarY - 3);
                }
            }
            
            // Close death animation transforms
            if (deathAnimationActive) {
                ctx.filter = 'none';
                ctx.restore();
            }
        }
        
        function drawEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const screenX = enemy.x;
                const screenY = enemy.y - cameraY;
                
                // Skip off-screen enemies
                if (screenY < -30 || screenY > BASE_HEIGHT + 30) continue;
                
                const wobble = Math.sin(enemy.animFrame) * 2;
                const dangerPulse = 0.5 + Math.sin(enemy.animFrame * 3) * 0.3;
                
                // ===== DANGER AURA (all enemies) =====
                const auraSize = 35 + Math.sin(enemy.animFrame * 2) * 8;
                let auraR, auraG, auraB;
                if (enemy.type === ENEMY_TYPE.LAVA_SLUG) {
                    auraR = 255; auraG = 68; auraB = 0;
                } else if (enemy.type === ENEMY_TYPE.WORM) {
                    auraR = 68; auraG = 255; auraB = 68;
                } else {
                    auraR = 255; auraG = 51; auraB = 102;
                }
                
                const auraGrad = ctx.createRadialGradient(screenX, screenY, 3, screenX, screenY, auraSize);
                auraGrad.addColorStop(0, `rgba(${auraR}, ${auraG}, ${auraB}, ${dangerPulse * 0.9})`);
                auraGrad.addColorStop(0.4, `rgba(${auraR}, ${auraG}, ${auraB}, ${dangerPulse * 0.5})`);
                auraGrad.addColorStop(0.7, `rgba(255, 50, 50, ${dangerPulse * 0.25})`);
                auraGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(screenX, screenY, auraSize, 0, Math.PI * 2);
                ctx.fill();
                
                // ===== WARNING INDICATOR =====
                ctx.save();
                ctx.fillStyle = '#ff3366';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 12;
                const warningY = screenY - 25 - Math.sin(enemy.animFrame * 4) * 4;
                ctx.fillText('', screenX, warningY);
                ctx.restore();
                
                if (enemy.type === ENEMY_TYPE.WORM) {
                    // Green worm - walks on surfaces
                    // Glow effect
                    ctx.shadowColor = '#44ff44';
                    ctx.shadowBlur = 15;
                    
                    // Head outline (white border for visibility)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + wobble, 10, 8, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Head (larger)
                    ctx.fillStyle = '#44ff44';
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + wobble, 9, 7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body segments (larger)
                    ctx.fillStyle = '#33dd33';
                    for (let seg = 1; seg <= 3; seg++) {
                        const segWobble = Math.sin(enemy.animFrame + seg * 0.5) * 2;
                        ctx.beginPath();
                        ctx.ellipse(screenX - seg * 5, screenY + segWobble, 7 - seg * 0.5, 5 - seg * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;
                    
                    // Eyes (larger, angrier)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(screenX + 4, screenY + wobble - 2, 3, 0, Math.PI * 2);
                    ctx.arc(screenX + 4, screenY + wobble + 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(screenX + 5, screenY + wobble - 2, 1.5, 0, Math.PI * 2);
                    ctx.arc(screenX + 5, screenY + wobble + 2, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (enemy.type === ENEMY_TYPE.BEETLE) {
                    // Cave beetle - larger and glowing
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    
                    // Glow
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 12;
                    
                    // Shell outline (white border for visibility)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 13, 10, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Legs (larger)
                    ctx.strokeStyle = '#774422';
                    ctx.lineWidth = 2;
                    const legWobble = Math.sin(enemy.animFrame * 2);
                    ctx.beginPath();
                    ctx.moveTo(-6, 0);
                    ctx.lineTo(-10, 6 + legWobble);
                    ctx.moveTo(6, 0);
                    ctx.lineTo(10, 6 + legWobble);
                    ctx.moveTo(-4, 2);
                    ctx.lineTo(-9, 8 - legWobble);
                    ctx.moveTo(4, 2);
                    ctx.lineTo(9, 8 - legWobble);
                    ctx.stroke();
                    
                    // Shell (larger)
                    const shellGrad = ctx.createRadialGradient(0, -2, 0, 0, 0, 12);
                    shellGrad.addColorStop(0, '#cc8833');
                    shellGrad.addColorStop(0.5, '#996622');
                    shellGrad.addColorStop(1, '#664411');
                    ctx.fillStyle = shellGrad;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 11, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shell line
                    ctx.strokeStyle = '#553311';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(0, 8);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    
                    // Head (larger)
                    ctx.fillStyle = '#553311';
                    ctx.beginPath();
                    ctx.ellipse(enemy.direction * 8, -1, 5, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Antennae
                    ctx.strokeStyle = '#664422';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(enemy.direction * 10, -2);
                    ctx.lineTo(enemy.direction * 15, -8 + wobble);
                    ctx.moveTo(enemy.direction * 10, 0);
                    ctx.lineTo(enemy.direction * 14, 3 + wobble);
                    ctx.stroke();
                    
                    // Eyes (angry red)
                    ctx.fillStyle = '#ff2222';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(enemy.direction * 10, -2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                } else if (enemy.type === ENEMY_TYPE.LAVA_SLUG) {
                    // Lava slug - larger, more glow
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    
                    // Intense glow effect
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 18 + Math.sin(enemy.animFrame) * 5;
                    
                    // Body outline (white border for visibility)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-12, 4);
                    ctx.quadraticCurveTo(-10, -7 + wobble, 0, -6 + wobble * 0.5);
                    ctx.quadraticCurveTo(10, -5 + wobble, 12, 4);
                    ctx.quadraticCurveTo(6, 9, 0, 9);
                    ctx.quadraticCurveTo(-6, 9, -12, 4);
                    ctx.stroke();
                    
                    // Body (larger)
                    const bodyGrad = ctx.createLinearGradient(-10, 0, 10, 0);
                    bodyGrad.addColorStop(0, '#ff2200');
                    bodyGrad.addColorStop(0.5, '#ff7700');
                    bodyGrad.addColorStop(1, '#ff4400');
                    ctx.fillStyle = bodyGrad;
                    
                    ctx.beginPath();
                    ctx.moveTo(-10, 3);
                    ctx.quadraticCurveTo(-8, -6 + wobble, 0, -5 + wobble * 0.5);
                    ctx.quadraticCurveTo(8, -4 + wobble, 10, 3);
                    ctx.quadraticCurveTo(5, 7, 0, 7);
                    ctx.quadraticCurveTo(-5, 7, -10, 3);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    
                    // Hot spots (brighter)
                    const glowPulse = 0.6 + Math.sin(enemy.animFrame * 2) * 0.3;
                    ctx.fillStyle = `rgba(255, 255, 150, ${glowPulse})`;
                    ctx.beginPath();
                    ctx.arc(-4, 0, 3, 0, Math.PI * 2);
                    ctx.arc(4, -1, 2.5, 0, Math.PI * 2);
                    ctx.arc(0, 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye stalks (larger)
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.ellipse(enemy.direction * 5, -7 + wobble, 3, 4, 0, 0, Math.PI * 2);
                    ctx.ellipse(enemy.direction * 1, -8 + wobble * 0.7, 3, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(enemy.direction * 5, -8 + wobble, 1.5, 0, Math.PI * 2);
                    ctx.arc(enemy.direction * 1, -9 + wobble * 0.7, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
        }
        
        function drawParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const screenY = p.y - cameraY;
                
                // Skip off-screen particles
                if (screenY < -20 || screenY > BASE_HEIGHT + 20) continue;
                
                ctx.globalAlpha = p.life;
                
                if (p.type === 'gem') {
                    // Glowing gem particles with trail
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'explosion') {
                    // Bright explosion particles
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    // Trail effect
                    ctx.globalAlpha = p.life * 0.5;
                    ctx.beginPath();
                    ctx.arc(p.x - p.vx * 2, screenY - p.vy * 2, p.size * p.life * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'smoke') {
                    // Rising smoke/steam particles - simplified for performance
                    const smokeAlpha = p.life * 0.5;
                    const smokeSize = p.size * (1 + (1 - p.life) * 0.5);
                    ctx.globalAlpha = smokeAlpha;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - smokeSize/2, screenY - smokeSize/2, smokeSize, smokeSize);
                } else if (p.type === 'thruster') {
                    // Fiery thruster particles - simplified for performance
                    ctx.globalAlpha = p.life * 0.8;
                    ctx.fillStyle = p.color;
                    const tSize = p.size * 1.5;
                    ctx.fillRect(p.x - tSize/2, screenY - tSize/2, tSize, tSize);
                } else if (p.type === 'debris' && p.rotation !== undefined) {
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(p.x, screenY);
                    ctx.rotate(p.rotation);
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                    ctx.restore();
                } else {
                    // Normal particles - use fillRect for small ones (faster than arc)
                    ctx.fillStyle = p.color;
                    const drawSize = p.size * p.life;
                    ctx.fillRect(p.x - drawSize/2, screenY - drawSize/2, drawSize, drawSize);
                }
            }
            ctx.globalAlpha = 1;
        }
        
        function drawFloatingTexts() {
            for (let i = 0; i < floatingTexts.length; i++) {
                const t = floatingTexts[i];
                const screenY = t.y - cameraY;
                
                if (screenY < -50 || screenY > BASE_HEIGHT + 50) continue;
                
                ctx.globalAlpha = t.life;
                ctx.font = `800 ${Math.round(13 * t.scale)}px Oxanium, monospace`;
                ctx.fillStyle = t.color;
                ctx.textAlign = 'center';
                ctx.shadowColor = t.color;
                ctx.shadowBlur = 8;
                ctx.fillText(t.text, t.x, screenY);
                ctx.shadowBlur = 0;
            }
            ctx.globalAlpha = 1;
        }
        
        // ==================== ALIEN TIP SYSTEM ====================
        function spawnAlien() {
            if (alienActive || alienCooldown > 0) return;
            
            alienActive = true;
            alienX = BASE_WIDTH + 60;
            alienY = -10; // World Y position - in the sky above ground (row 0 starts at Y=0)
            alienTip = getNextAlienTip();
            alienPassCount++;
        }
        
        function updateAlien(deltaMultiplier) {
            if (alienCooldown > 0) {
                alienCooldown -= deltaMultiplier;
            }
            
            if (!alienActive) {
                // Only spawn when sky is visible (camera showing above ground)
                // cameraY < 50 means sky area is on screen
                const skyVisible = cameraY < 50;
                if (skyVisible && alienCooldown <= 0 && Math.random() < 0.002) {
                    spawnAlien();
                }
                return;
            }
            
            // Move alien left (fixed screen position, doesn't follow camera)
            alienX -= ALIEN_SPEED * deltaMultiplier;
            
            // Remove when off screen
            if (alienX < -180) {
                alienActive = false;
                alienCooldown = ALIEN_COOLDOWN;
            }
        }
        
        function drawAlien() {
            if (!alienActive) return;
            
            // Convert world Y to screen Y (alien stays in sky, scrolls with world)
            const screenY = alienY - cameraY + Math.sin(globalTime * 0.08) * 3;
            
            // Don't draw if off screen
            if (screenY < -50 || screenY > BASE_HEIGHT + 50) return;
            
            const ax = alienX;
            const ay = screenY;
            const time = globalTime * 0.1;
            
            // UFO body (ellipse)
            ctx.fillStyle = '#666688';
            ctx.beginPath();
            ctx.ellipse(ax, ay, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // UFO dome
            ctx.fillStyle = '#88aacc';
            ctx.beginPath();
            ctx.ellipse(ax, ay - 6, 10, 8, 0, Math.PI, 0);
            ctx.fill();
            
            // Dome highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.ellipse(ax - 3, ay - 9, 4, 3, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Alien inside dome
            ctx.fillStyle = '#44ff88';
            ctx.beginPath();
            ctx.ellipse(ax, ay - 6, 5, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Alien eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(ax - 2, ay - 7, 1.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(ax + 2, ay - 7, 1.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // UFO lights (pulsing)
            const lightAlpha = 0.5 + Math.sin(time * 3) * 0.5;
            ctx.fillStyle = `rgba(255, 200, 0, ${lightAlpha})`;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.arc(ax + i * 6, ay + 4, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Speech text on right side of alien
            const textX = ax + 28;
            const textY = ay - 8;
            
            // Small dots leading from alien mouth to text
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(ax + 12, ay - 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ax + 19, ay - 6, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Tip text - white with subtle shadow, single line
            ctx.font = 'bold 10px Oxanium, monospace';
            ctx.textAlign = 'left';
            
            // Dark outline for readability
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            
            // Draw outline then fill - single line
            ctx.fillStyle = '#ffffff';
            ctx.strokeText(alienTip, textX, textY);
            ctx.fillText(alienTip, textX, textY);
        }
        
        // ==================== UPGRADE SYSTEM ====================
        function showUpgradeSelector(legendary = false) {
            upgradeSelectionActive = true;
            upgradeSelected = false;
            isLegendaryUpgrade = legendary;
            
            const definitions = legendary ? legendaryUpgradeDefinitions : upgradeDefinitions;
            currentUpgradeChoices = legendary ? [...definitions] : weightedRandomSelect(definitions, 3);
            
            upgradeOverlay.classList.toggle('legendary', legendary);
            
            slots.forEach((slot, i) => {
                if (i < currentUpgradeChoices.length) {
                    slot.className = legendary ? 'upgrade-slot rolling legendary' : 'upgrade-slot rolling';
                    slot.style.display = '';
                    slot.querySelector('.upgrade-icon').textContent = '?';
                    slot.querySelector('.upgrade-name').textContent = '???';
                    slot.querySelector('.upgrade-desc').textContent = '???';
                } else {
                    slot.style.display = 'none';
                }
            });
            
            upgradeOverlay.classList.add('active');
            rollSlots();
        }
        
        function weightedRandomSelect(available, count) {
            const selected = [];
            const pool = [...available];
            
            for (let i = 0; i < count && pool.length > 0; i++) {
                const weights = pool.map(u => Math.pow(upgradeOfferHistory[u.id] || 1, 2));
                const total = weights.reduce((a, b) => a + b, 0);
                let r = Math.random() * total;
                let idx = 0;
                
                for (let j = 0; j < weights.length; j++) {
                    r -= weights[j];
                    if (r <= 0) { idx = j; break; }
                }
                selected.push(pool.splice(idx, 1)[0]);
            }
            
            available.forEach(u => {
                upgradeOfferHistory[u.id] = selected.some(c => c.id === u.id) ? 0 : Math.min((upgradeOfferHistory[u.id] || 0) + 1, 5);
            });
            
            return selected;
        }
        
        function rollSlots() {
            // MEMORY LEAK FIX: Clear any existing intervals/timeouts
            clearRollTimers();
            
            const rollDuration = isLegendaryUpgrade ? 1800 : 1500;
            const staggerDelay = isLegendaryUpgrade ? 400 : 300;
            const rollDefs = isLegendaryUpgrade ? legendaryUpgradeDefinitions : upgradeDefinitions;
            
            slots.forEach((slot, i) => {
                if (i >= currentUpgradeChoices.length) return;
                
                const rollInterval = setInterval(() => {
                    const r = rollDefs[Math.floor(Math.random() * rollDefs.length)];
                    slot.querySelector('.upgrade-icon').textContent = r.icon;
                    slot.querySelector('.upgrade-name').textContent = r.name;
                    slot.querySelector('.upgrade-desc').textContent = r.desc;
                }, 100);
                
                activeRollIntervals.push(rollInterval);
                
                const timeout = setTimeout(() => {
                    clearInterval(rollInterval);
                    const choice = currentUpgradeChoices[i];
                    slot.className = isLegendaryUpgrade ? 'upgrade-slot revealed legendary' : 'upgrade-slot revealed';
                    slot.querySelector('.upgrade-icon').textContent = choice.icon;
                    slot.querySelector('.upgrade-name').textContent = choice.name;
                    slot.querySelector('.upgrade-desc').textContent = choice.desc;
                    slot.onclick = () => selectUpgrade(i);
                    slot.ontouchend = (e) => { e.preventDefault(); e.stopPropagation(); selectUpgrade(i); };
                }, rollDuration + i * staggerDelay);
                
                activeRollTimeouts.push(timeout);
            });
        }
        
        function clearRollTimers() {
            activeRollIntervals.forEach(clearInterval);
            activeRollTimeouts.forEach(clearTimeout);
            activeRollIntervals = [];
            activeRollTimeouts = [];
        }
        
        function selectUpgrade(index) {
            if (!upgradeSelectionActive || upgradeSelected) return;
            upgradeSelected = true;
            
            slots.forEach((slot, i) => {
                if (i === index) {
                    slot.classList.add('selected');
                } else {
                    slot.style.opacity = '0.25';
                    slot.style.pointerEvents = 'none';
                }
            });
            
            currentUpgradeChoices[index].apply();
            updatePermanentUpgradesDisplay();
            
            setTimeout(() => {
                upgradeSelectionActive = false;
                upgradeOverlay.classList.remove('active', 'legendary', 'chest');
                slots.forEach(s => {
                    s.style.display = '';
                    s.style.opacity = '';
                    s.style.pointerEvents = '';
                    s.classList.remove('selected', 'legendary', 'chest');
                    s.onclick = null;
                    s.ontouchend = null;
                });
                isLegendaryUpgrade = false;
                isChestUpgrade = false;
            }, 600);
        }
        
        function updatePermanentUpgradesDisplay() {
            const icons = {
                digSpeed: { icon: '', color: '#ff9500', div: 15 },
                fuelCapacity: { icon: '', color: '#ff6600', div: 20 },
                gemMagnet: { icon: '', color: '#00f0ff', div: 1 },
                armor: { icon: '', color: '#8888aa', div: 25 },
                fuelEfficiency: { icon: '', color: '#00ff88', div: 10 },
                gemValue: { icon: '', color: '#ffd700', div: 15 },
                climbSpeed: { icon: '', color: '#ff00ff', div: 20 },
                drillPower: { icon: '', color: '#00f0ff', div: 10 }
            };
            
            let html = '';
            for (const [k, v] of Object.entries(permanentUpgrades)) {
                if (v > 0 && icons[k]) {
                    const stacks = Math.max(1, Math.floor(v / icons[k].div));
                    html += `<div class="perm-upgrade" style="color: ${icons[k].color}; border-color: ${icons[k].color}30;">
                        <span class="perm-icon">${icons[k].icon}</span>
                        <span class="perm-stack" style="border-color: ${icons[k].color};">${stacks}</span>
                    </div>`;
                }
            }
            permUpgradesEl.innerHTML = html;
        }
        
        // ==================== GAME OVER ====================
        function gameOver() {
            gameRunning = false;
            gamePaused = false;
            deathAnimationActive = false;
            clearRollTimers();
            
            // Hide pause button and overlays
            const pauseBtnEl = document.getElementById('pauseBtn');
            const pauseOverlayEl = document.getElementById('pauseOverlay');
            const confirmOverlayEl = document.getElementById('confirmOverlay');
            if (pauseBtnEl) {
                pauseBtnEl.classList.remove('visible');
                pauseBtnEl.classList.remove('paused');
                pauseBtnEl.textContent = '';
            }
            if (pauseOverlayEl) pauseOverlayEl.classList.remove('active');
            if (confirmOverlayEl) confirmOverlayEl.classList.remove('active');
            
            controlInstructions.classList.remove('visible');
            
            // Phase 1: Show dramatic "GAME OVER" text
            ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // Big "GAME OVER" text with glow effect
            ctx.save();
            ctx.shadowColor = '#ff0066';
            ctx.shadowBlur = 30;
            ctx.font = '800 52px Oxanium, monospace';
            ctx.fillStyle = '#ff0066';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', BASE_WIDTH / 2, BASE_HEIGHT / 2);
            ctx.shadowBlur = 15;
            ctx.fillText('GAME OVER', BASE_WIDTH / 2, BASE_HEIGHT / 2);
            ctx.restore();
            
            // After a moment, show the detailed death screen
            setTimeout(() => {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.88)';
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                
                ctx.font = '800 36px Oxanium, monospace';
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'center';
                const deathText = deathReason === 'hull' ? 'HULL DESTROYED' : 'OUT OF FUEL';
                ctx.fillText(deathText, BASE_WIDTH / 2, BASE_HEIGHT / 2 - 45);
                
                ctx.font = '600 20px "Exo 2", sans-serif';
                ctx.fillStyle = '#00f0ff';
                ctx.fillText(`Max Depth: ${maxDepthThisRun}m`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 5);
                ctx.fillStyle = '#ff9500';
                ctx.fillText(`Score: ${score}`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 35);
                
                setTimeout(showScoreModal, 1200);
            }, 1000);
        }
        
        // ==================== SCORE SYSTEM ====================
        function showScoreModal() {
            finalScoreEl.textContent = `${score} pts  ${maxDepthThisRun}m`;
            scoreModal.classList.add('active');
            usernameInput.value = '';
            scoreError.textContent = '';
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'SAVE';
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            showGameOverButtons();
        }
        
        function showGameOverButtons() {
            startBtn.textContent = 'DIG AGAIN';
            menuOverlay.classList.remove('hidden');
        }
        
        // ==================== SCORE SYSTEM (Firebase + localStorage fallback) ====================
        function saveLocalScore(name, scoreVal, depthVal) {
            try {
                const scores = JSON.parse(localStorage.getItem('neon_dig_scores') || '[]');
                scores.push({ name: name, score: scoreVal, depth: depthVal, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem('neon_dig_scores', JSON.stringify(scores.slice(0, 100)));
                return true;
            } catch (e) {
                console.warn('Failed to save local score:', e);
                return false;
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem('neon_dig_scores') || '[]');
            } catch (e) {
                return [];
            }
        }
        
        async function saveScore(name, scoreVal, depthVal) {
            if (firebaseReady && db) {
                try {
                    await db.collection(SCORES_COLLECTION).add({
                        name: name,
                        score: scoreVal,
                        depth: depthVal,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    return true;
                } catch (e) {
                    console.error('Failed to save score to Firebase:', e);
                    // Fallback to localStorage
                    return saveLocalScore(name, scoreVal, depthVal);
                }
            } else {
                return saveLocalScore(name, scoreVal, depthVal);
            }
        }
        
        async function getScores() {
            if (firebaseReady && db) {
                try {
                    const snapshot = await db.collection(SCORES_COLLECTION)
                        .orderBy('score', 'desc')
                        .limit(50)
                        .get();
                    
                    return snapshot.docs.map(doc => ({
                        name: doc.data().name,
                        score: doc.data().score,
                        depth: doc.data().depth || 0
                    }));
                } catch (e) {
                    console.error('Failed to fetch Firebase scores:', e);
                    return getLocalScores();
                }
            } else {
                return getLocalScores();
            }
        }
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            const scores = await getScores();
            
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet.<br><br>Start digging!</div>';
                return;
            }
            
            leaderboardList.innerHTML = scores.slice(0, 20).map((e, i) => {
                const rankClass = i < 3 ? `top-3` : '';
                const rankColorClass = i < 3 ? `leaderboard-rank-${i + 1}` : '';
                return `<div class="leaderboard-row ${rankClass}">
                    <span class="leaderboard-rank ${rankColorClass}">#${i + 1}</span>
                    <span class="leaderboard-name">${e.name}</span>
                    <span class="leaderboard-score">${e.score}</span>
                    <span class="leaderboard-depth">${e.depth}m</span>
                </div>`;
            }).join('');
        }
        
        // ==================== INPUT HANDLING ====================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
            
            // DEBUG: Press B to teleport to surface
            if ((e.key === 'b' || e.key === 'B') && gameRunning && !bossArenaActive) {
                debugTeleportToDepth(0);
            }
            // DEBUG: Press N to teleport to 45m, M for 95m
            if ((e.key === 'n' || e.key === 'N') && gameRunning && !bossArenaActive) {
                debugTeleportToDepth(45);
            }
            if ((e.key === 'm' || e.key === 'M') && gameRunning && !bossArenaActive) {
                debugTeleportToDepth(95);
            }
        });
        
        // DEBUG: Teleport player to specific depth
        function debugTeleportToDepth(targetDepth) {
            // Extend world to target depth if needed
            while (world.length < targetDepth + 20) {
                extendWorld();
            }
            
            // Calculate target row (depth + 2 for surface offset)
            const targetRow = targetDepth + 2;
            const targetTx = Math.floor(WORLD_WIDTH / 2);
            
            // Clear a small area for player to spawn in
            for (let dy = -1; dy <= 1; dy++) {
                const row = targetRow + dy;
                if (row >= 0 && row < world.length) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const col = targetTx + dx;
                        if (col >= 1 && col < WORLD_WIDTH - 1) {
                            const tile = world[row][col];
                            if (tile !== TILE.BEDROCK && tile !== TILE.PORTAL && tile !== TILE.PORTAL_PART && tile !== TILE.GATE) {
                                world[row][col] = TILE.AIR;
                            }
                        }
                    }
                }
            }
            
            // Teleport player
            player.x = targetTx * TILE_SIZE + TILE_SIZE / 2 - player.width / 2;
            player.y = targetRow * TILE_SIZE;
            cameraY = player.y - BASE_HEIGHT / 2;
            
            // Reset movement state
            player.vy = 0;
            player.digging = false;
            player.digTarget = null;
            slideAnimation.active = false;
            hoverMode = false;
            
            createFloatingText(`Teleported to ${targetDepth}m`, player.x + player.width/2, player.y - 20, '#00ffff');
        }
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
        });
        
        // Virtual joystick elements
        const joystickBase = document.getElementById('joystickBase');
        const joystickThumb = document.getElementById('joystickThumb');
        const touchTutorial = document.getElementById('touchTutorial');
        
        let touchStartX = 0, touchStartY = 0;
        let touchActive = false;
        
        // Show/update joystick visual
        function showJoystick(x, y) {
            joystickBase.style.left = x + 'px';
            joystickBase.style.top = y + 'px';
            joystickBase.classList.add('active');
        }
        
        function updateJoystick(touchX, touchY) {
            const dx = touchX - touchStartX;
            const dy = touchY - touchStartY;
            
            // Clamp thumb movement to joystick radius
            const maxDist = 35;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let thumbX = dx;
            let thumbY = dy;
            
            if (dist > maxDist) {
                thumbX = (dx / dist) * maxDist;
                thumbY = (dy / dist) * maxDist;
            }
            
            joystickThumb.style.transform = `translate(calc(-50% + ${thumbX}px), calc(-50% + ${thumbY}px))`;
        }
        
        function hideJoystick() {
            joystickBase.classList.remove('active');
            joystickThumb.style.transform = 'translate(-50%, -50%)';
        }
        
        function updateTouchKeys(touchX, touchY) {
            const dx = touchX - touchStartX;
            const dy = touchY - touchStartY;
            
            // Use smaller threshold for more responsive controls
            const threshold = 12;
            
            // Allow diagonal movement by checking each axis independently
            keys.left = dx < -threshold;
            keys.right = dx > threshold;
            keys.up = dy < -threshold;
            keys.down = dy > threshold;
            
            // Update joystick visual
            updateJoystick(touchX, touchY);
        }
        
        function clearTouchKeys() {
            keys.left = keys.right = keys.up = keys.down = false;
            touchActive = false;
            hideJoystick();
        }
        
        controlZone.addEventListener('touchstart', (e) => {
            if (upgradeSelectionActive) return;
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchActive = true;
            showJoystick(touchStartX, touchStartY);
        }, { passive: false });
        
        controlZone.addEventListener('touchmove', (e) => {
            if (upgradeSelectionActive || !touchActive) return;
            e.preventDefault();
            updateTouchKeys(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        
        controlZone.addEventListener('touchend', (e) => {
            e.preventDefault();
            clearTouchKeys();
        }, { passive: false });
        
        controlZone.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            clearTouchKeys();
        }, { passive: false });
        
        // Also clear if touch leaves the control zone
        controlZone.addEventListener('touchleave', (e) => {
            clearTouchKeys();
        });
        
        // Canvas touch handling for iPad/tablet fullscreen mode
        // (control-zone may be hidden in fullscreen, so enable canvas touch too)
        let canvasTouchStartX = 0, canvasTouchStartY = 0;
        let canvasTouchActive = false;
        
        function updateCanvasTouchKeys(touchX, touchY) {
            const dx = touchX - canvasTouchStartX;
            const dy = touchY - canvasTouchStartY;
            
            // Use slightly larger threshold for canvas (more space to move)
            const threshold = 20;
            
            keys.left = dx < -threshold;
            keys.right = dx > threshold;
            keys.up = dy < -threshold;
            keys.down = dy > threshold;
            
            // Update joystick visual (reuse the joystick positioned at canvas touch start)
            const maxDist = 35;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let thumbX = dx;
            let thumbY = dy;
            if (dist > maxDist) {
                thumbX = (dx / dist) * maxDist;
                thumbY = (dy / dist) * maxDist;
            }
            joystickThumb.style.transform = `translate(calc(-50% + ${thumbX}px), calc(-50% + ${thumbY}px))`;
        }
        
        canvas.addEventListener('touchstart', (e) => {
            if (upgradeSelectionActive || !gameRunning) return;
            e.preventDefault();
            canvasTouchStartX = e.touches[0].clientX;
            canvasTouchStartY = e.touches[0].clientY;
            canvasTouchActive = true;
            showJoystick(canvasTouchStartX, canvasTouchStartY);
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            if (upgradeSelectionActive || !gameRunning || !canvasTouchActive) return;
            e.preventDefault();
            updateCanvasTouchKeys(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            if (canvasTouchActive) {
                e.preventDefault();
                keys.left = keys.right = keys.up = keys.down = false;
                canvasTouchActive = false;
                hideJoystick();
            }
        }, { passive: false });
        
        canvas.addEventListener('touchcancel', (e) => {
            if (canvasTouchActive) {
                e.preventDefault();
                keys.left = keys.right = keys.up = keys.down = false;
                canvasTouchActive = false;
                hideJoystick();
            }
        }, { passive: false });
        
        // Game container touch handling - allows swiping anywhere in the game area
        gameContainer.addEventListener('touchstart', (e) => {
            if (upgradeSelectionActive || !gameRunning) return;
            // Don't interfere with control zone or canvas handling
            if (e.target === controlZone || controlZone.contains(e.target)) return;
            if (e.target === canvas) return;
            e.preventDefault();
            canvasTouchStartX = e.touches[0].clientX;
            canvasTouchStartY = e.touches[0].clientY;
            canvasTouchActive = true;
            showJoystick(canvasTouchStartX, canvasTouchStartY);
        }, { passive: false });
        
        gameContainer.addEventListener('touchmove', (e) => {
            if (upgradeSelectionActive || !gameRunning || !canvasTouchActive) return;
            if (e.target === controlZone || controlZone.contains(e.target)) return;
            if (e.target === canvas) return;
            e.preventDefault();
            updateCanvasTouchKeys(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        
        gameContainer.addEventListener('touchend', (e) => {
            if (canvasTouchActive) {
                e.preventDefault();
                keys.left = keys.right = keys.up = keys.down = false;
                canvasTouchActive = false;
                hideJoystick();
            }
        }, { passive: false });
        
        // Document-level touch handling - ensures touch works anywhere in iframe
        document.addEventListener('touchstart', (e) => {
            if (upgradeSelectionActive || !gameRunning) return;
            // Skip if interacting with specific UI elements
            if (e.target.closest('.menu-overlay') || e.target.closest('.upgrade-overlay') || 
                e.target.closest('.leaderboard-overlay') || e.target.closest('.score-modal') ||
                e.target.closest('.surface-upgrade-btn') || e.target.closest('.shop-overlay') ||
                e.target.closest('.touch-tutorial')) return;
            
            canvasTouchStartX = e.touches[0].clientX;
            canvasTouchStartY = e.touches[0].clientY;
            canvasTouchActive = true;
            showJoystick(canvasTouchStartX, canvasTouchStartY);
        }, { passive: true });
        
        document.addEventListener('touchmove', (e) => {
            if (upgradeSelectionActive || !gameRunning || !canvasTouchActive) return;
            updateCanvasTouchKeys(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: true });
        
        document.addEventListener('touchend', (e) => {
            if (canvasTouchActive && gameRunning) {
                keys.left = keys.right = keys.up = keys.down = false;
                canvasTouchActive = false;
                hideJoystick();
            }
        }, { passive: true });
        
        // Touch tutorial functions
        function showTouchTutorial() {
            if (!isTouchDevice) return;
            touchTutorial.classList.add('active');
            
            // After 3 seconds, start fade out
            setTimeout(() => {
                touchTutorial.classList.add('fading');
                
                // After 1 second fade, remove completely
                setTimeout(() => {
                    touchTutorial.classList.remove('active', 'fading');
                }, 1000);
            }, 3000);
        }
        
        // ==================== EVENT LISTENERS ====================
        submitScoreBtn.addEventListener('click', async () => {
            const name = usernameInput.value.trim();
            if (name.length < 2) {
                scoreError.textContent = 'Name must be at least 2 characters';
                return;
            }
            if (name.length > 12) {
                scoreError.textContent = 'Name must be 12 characters or less';
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'SAVING...';
            
            const success = await saveScore(name, score, maxDepthThisRun);
            
            if (success) {
                hideScoreModal();
            } else {
                scoreError.textContent = 'Failed to save score. Try again.';
                submitScoreBtn.disabled = false;
                submitScoreBtn.textContent = 'SAVE';
            }
        });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') submitScoreBtn.click();
            if (e.key === 'Escape') hideScoreModal();
        });
        
        usernameInput.addEventListener('input', () => {
            scoreError.textContent = '';
        });
        
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardClose.addEventListener('click', () => leaderboardOverlay.classList.remove('active'));
        
        // ==================== TUTORIAL SYSTEM ====================
        // Create dots
        for (let i = 0; i < totalTutorialSteps; i++) {
            const dot = document.createElement('div');
            dot.className = 'tutorial-dot' + (i === 0 ? ' active' : '');
            dot.addEventListener('click', () => goToTutorialStep(i));
            tutorialDots.appendChild(dot);
        }
        
        function showTutorial() {
            tutorialOverlay.classList.add('active');
            goToTutorialStep(0);
        }
        
        function hideTutorial() {
            tutorialOverlay.classList.remove('active');
        }
        
        function goToTutorialStep(step) {
            currentTutorialStep = step;
            
            // Update steps
            tutorialSteps.forEach((s, i) => {
                s.classList.toggle('active', i === step);
            });
            
            // Update dots
            const dots = tutorialDots.querySelectorAll('.tutorial-dot');
            dots.forEach((d, i) => {
                d.classList.toggle('active', i === step);
            });
            
            // Update buttons
            tutorialPrev.disabled = step === 0;
            tutorialNext.textContent = step === totalTutorialSteps - 1 ? 'Got it!' : 'Next ';
        }
        
        function nextTutorialStep() {
            if (currentTutorialStep < totalTutorialSteps - 1) {
                goToTutorialStep(currentTutorialStep + 1);
            } else {
                hideTutorial();
            }
        }
        
        function prevTutorialStep() {
            if (currentTutorialStep > 0) {
                goToTutorialStep(currentTutorialStep - 1);
            }
        }
        
        tutorialBtn.addEventListener('click', showTutorial);
        tutorialClose.addEventListener('click', hideTutorial);
        tutorialPrev.addEventListener('click', prevTutorialStep);
        tutorialNext.addEventListener('click', nextTutorialStep);
        tutorialOverlay.addEventListener('click', (e) => {
            if (e.target === tutorialOverlay) {
                hideTutorial();
            }
        });
        
        // Keyboard navigation for tutorial
        document.addEventListener('keydown', (e) => {
            if (!tutorialOverlay.classList.contains('active')) return;
            if (e.key === 'ArrowRight' || e.key === 'Enter') nextTutorialStep();
            if (e.key === 'ArrowLeft') prevTutorialStep();
            if (e.key === 'Escape') hideTutorial();
        });
        
        // ==================== GAME START ====================
        function startGame() {
            // Clear any lingering timers
            clearRollTimers();
            
            gameRunning = true;
            score = 0;
            depth = 0;
            maxDepthThisRun = 0;
            // Reset shop upgrades for new run
            initShopUpgrades();
            // Base stats start at 100 (no shop bonuses yet)
            const baseMaxFuel = 100;
            const baseMaxHull = 100;
            fuel = baseMaxFuel;
            maxFuel = baseMaxFuel;
            hull = baseMaxHull;
            maxHull = baseMaxHull;
            lastUpgradeDepth = 0;
            cameraY = -80; // Reset with sky visible
            upgradeOfferHistory = {};
            screenShake = 0;
            deathAnimationActive = false;
            deathAnimationTimer = 0;
            deathReason = '';
            depthColorShift = 0;
            globalTime = 0;
            
            // Reset combo and fever systems
            comboCount = 0;
            comboTimer = 0;
            feverMode = false;
            feverTimer = 0;
            
            // Reset drill heat
            drillHeat = 0;
            drillOverheated = false;
            drillCooldownTimer = 0;
            
            // Reset hover mode
            hoverMode = false;
            flightTimer = 0;
            groundedTimer = 0;
            blockedTimer = 0;
            blockedTimerLeft = 0;
            blockedTimerRight = 0;
            hoverUpDrillTimer = 0;
            hoverDrillMomentum = 0;
            upDigMomentum = 0;
            
            // Reset visual effects
            screenFlash = { active: false, color: '#ffffff', alpha: 0, duration: 0 };
            speedLines = [];
            unstableTiles = [];
            enemies = [];
            firstEnemySpawned = false;
            secondEnemySpawned = false;
            drillKillGracePeriod = 0;
            
            // Reset boss system
            initBossSystem();
            
            // Reset alien tip system
            alienActive = false;
            alienCooldown = 300; // Short delay before first tip
            
            // Reset upgrade overlay states
            upgradeSelectionActive = false;
            isLegendaryUpgrade = false;
            isChestUpgrade = false;
            upgradeOverlay.classList.remove('active', 'legendary', 'chest');
            
            // Reset upgrades
            Object.keys(permanentUpgrades).forEach(k => permanentUpgrades[k] = 0);
            
            // Reset dig direction
            lastDigDirection = null;
            
            player.x = BASE_WIDTH / 2 - 12;
            player.y = 60;
            player.vy = 0;  // Reset fall velocity
            player.width = 24;
            player.height = 28;
            player.digging = false;
            player.digTarget = null;
            player.digProgress = 0;
            
            // Reset slide animation
            slideAnimation.active = false;
            
            particles = [];
            floatingTexts = [];
            floatingTextQueue = [];
            floatingTextQueueTimer = 0;
            lastTextShowTime = -100;
            
            // Reset luck protection system
            resetSpawnHistory();
            
            generateWorld();
            initAmbientParticles();
            initBgStars();
            
            depthEl.textContent = '0';
            maxDepthEl.textContent = '0';
            scoreEl.textContent = '0';
            updateFuelBar();
            updateHullBar();
            updateScoreDisplay();
            updateKeysDisplay();
            updatePermanentUpgradesDisplay();
            
            menuOverlay.classList.add('hidden');
            controlInstructions.classList.add('visible');
            
            // Reset pause state and hide any lingering overlays
            gamePaused = false;
            const pauseBtnEl = document.getElementById('pauseBtn');
            const pauseOverlayEl = document.getElementById('pauseOverlay');
            const confirmOverlayEl = document.getElementById('confirmOverlay');
            if (pauseBtnEl) {
                pauseBtnEl.textContent = '';
                pauseBtnEl.classList.remove('paused');
                pauseBtnEl.classList.add('visible');
            }
            if (pauseOverlayEl) pauseOverlayEl.classList.remove('active');
            if (confirmOverlayEl) confirmOverlayEl.classList.remove('active');
            
            // Show touch tutorial on mobile
            showTouchTutorial();
        }
        
        // ==================== SHOP UI ====================
        function renderShop() {
            const availablePoints = getAvailablePoints();
            shopScoreEl.textContent = availablePoints;
            
            let html = '';
            for (const def of shopUpgradesDef) {
                const level = shopUpgrades[def.id] || 0;
                const isMaxed = level >= def.max;
                const cost = getUpgradeCost(def.id, level);
                const canAfford = availablePoints >= cost;
                
                let classes = 'shop-item';
                if (isMaxed) classes += ' maxed';
                else if (!canAfford) classes += ' cant-afford';
                
                html += `
                    <div class="${classes}" data-id="${def.id}">
                        <div class="shop-item-icon">${def.icon}</div>
                        <div class="shop-item-info">
                            <div class="shop-item-name">${def.name}</div>
                            <div class="shop-item-level">Lv ${level}/${def.max}</div>
                            <div class="shop-item-desc">${def.desc}</div>
                        </div>
                        <div class="shop-item-cost">${isMaxed ? 'MAX' : cost}</div>
                    </div>
                `;
            }
            shopGrid.innerHTML = html;
            
            // Add click handlers
            shopGrid.querySelectorAll('.shop-item:not(.maxed)').forEach(item => {
                item.addEventListener('click', () => {
                    const id = item.dataset.id;
                    if (buyShopUpgrade(id)) {
                        renderShop();
                    }
                });
            });
        }
        
        function openShop() {
            renderShop();
            shopOverlay.classList.add('active');
        }
        
        function closeShop() {
            shopOverlay.classList.remove('active');
        }
        
        surfaceUpgradeBtn.addEventListener('click', openShop);
        shopClose.addEventListener('click', closeShop);
        shopOverlay.addEventListener('click', (e) => {
            if (e.target === shopOverlay) closeShop();
        });
        
        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); }, { passive: false });
        
        // ==================== PAUSE SYSTEM ====================
        const pauseBtn = document.getElementById('pauseBtn');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const pauseLeaderboardBtn = document.getElementById('pauseLeaderboardBtn');
        const exitGameBtn = document.getElementById('exitGameBtn');
        const confirmOverlay = document.getElementById('confirmOverlay');
        const confirmYes = document.getElementById('confirmYes');
        const confirmNo = document.getElementById('confirmNo');
        
        function togglePause() {
            if (!gameRunning || upgradeSelectionActive || shopOverlay.classList.contains('active')) return;
            
            gamePaused = !gamePaused;
            pauseBtn.textContent = gamePaused ? '' : '';
            pauseBtn.classList.toggle('paused', gamePaused);
            
            if (gamePaused) {
                pauseOverlay.classList.add('active');
            } else {
                pauseOverlay.classList.remove('active');
                confirmOverlay.classList.remove('active');
            }
        }
        
        function resumeGame() {
            if (!gamePaused) return;
            gamePaused = false;
            pauseBtn.textContent = '';
            pauseBtn.classList.remove('paused');
            pauseOverlay.classList.remove('active');
            confirmOverlay.classList.remove('active');
        }
        
        function showExitConfirm() {
            confirmOverlay.classList.add('active');
        }
        
        function hideExitConfirm() {
            confirmOverlay.classList.remove('active');
        }
        
        function exitToMenu() {
            gameRunning = false;
            gamePaused = false;
            pauseOverlay.classList.remove('active');
            confirmOverlay.classList.remove('active');
            pauseBtn.textContent = '';
            pauseBtn.classList.remove('paused');
            pauseBtn.classList.remove('visible');
            menuOverlay.classList.remove('hidden');
        }
        
        // Pause button click
        pauseBtn.addEventListener('click', togglePause);
        pauseBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            togglePause();
        });
        
        // Resume button
        resumeBtn.addEventListener('click', resumeGame);
        resumeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            resumeGame();
        });
        
        // Leaderboard button in pause menu
        pauseLeaderboardBtn.addEventListener('click', () => {
            pauseOverlay.classList.remove('active');
            showLeaderboard();
        });
        pauseLeaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            pauseOverlay.classList.remove('active');
            showLeaderboard();
        });
        
        // Exit game button
        exitGameBtn.addEventListener('click', showExitConfirm);
        exitGameBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            showExitConfirm();
        });
        
        // Confirmation buttons
        confirmYes.addEventListener('click', exitToMenu);
        confirmYes.addEventListener('touchend', (e) => {
            e.preventDefault();
            exitToMenu();
        });
        
        confirmNo.addEventListener('click', hideExitConfirm);
        confirmNo.addEventListener('touchend', (e) => {
            e.preventDefault();
            hideExitConfirm();
        });
        
        // P key to pause
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        
        // ==================== GAME LOOP ====================
        function gameLoop(timestamp) {
            if (lastFrameTime === 0) lastFrameTime = timestamp;
            const delta = timestamp - lastFrameTime;
            deltaMultiplier = Math.min(delta / TARGET_FRAME_TIME, 3);
            lastFrameTime = timestamp;
            
            update();
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== RESPONSIVE SCALING ====================
        // Fullscreen pixel density scaling
        let currentScale = 1;
        const isDesktop = !('ontouchstart' in window) && window.innerWidth > 768;
        
        function getViewportSize() {
            // Use visualViewport for more accurate sizing in iframes
            if (window.visualViewport) {
                return {
                    width: window.visualViewport.width,
                    height: window.visualViewport.height
                };
            }
            return {
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        
        function handleResize() {
            const viewport = getViewportSize();
            const viewportWidth = viewport.width;
            const viewportHeight = viewport.height;
            
            const isInIframe = window.self !== window.top;
            
            const hud = document.querySelector('.hud');
            const hudHeight = hud ? hud.offsetHeight : 50;
            
            const gameContainer = document.querySelector('.game-container');
            const isFullscreen = isInIframe || viewportWidth > BASE_WIDTH * 1.05 || viewportHeight > BASE_HEIGHT * 1.05;
            
            const gameAspect = BASE_WIDTH / BASE_HEIGHT;
            
            if (isFullscreen) {
                gameContainer.classList.add('fullscreen-mode');
                document.body.classList.add('fullscreen-active');
                
                // No letterboxing - use full available space
                const borderWidth = 0;
                const safetyPadding = 0;
                const totalMargin = 0;
                
                const availWidth = viewportWidth;
                const availHeight = viewportHeight - hudHeight;
                
                // Use full available dimensions - no aspect ratio constraint
                let cssWidth = Math.floor(availWidth);
                let cssHeight = Math.floor(availHeight);
                
                // Determine buffer scale
                let bufferScale;
                if (isTablet || isIPad) {
                    bufferScale = 2;
                } else if (viewportWidth >= 2560 || viewportHeight >= 1440) {
                    bufferScale = 2.5;
                } else {
                    bufferScale = 2;
                }
                
                // iOS canvas memory safety check
                let bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                let bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    bufferScale *= scaleFactor;
                    bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                    bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = cssWidth + 'px';
                canvas.style.height = cssHeight + 'px';
                
                renderScale = bufferScale;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(bufferScale, bufferScale);
                
                WORLD_WIDTH = Math.floor(BASE_WIDTH / TILE_SIZE);
                
                // Debug overlay
                GameDebug.show({
                    viewport: `${viewportWidth}${viewportHeight}`,
                    avail: `${Math.round(availWidth)}${Math.round(availHeight)}`,
                    css: `${cssWidth}${cssHeight}`,
                    buffer: `${bufferWidth}${bufferHeight}`,
                    iframe: isInIframe ? 'YES' : 'NO',
                    device: isTablet ? 'tablet' : (isIPad ? 'iPad' : 'desktop')
                });
            } else {
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
                
                // Scale internal resolution based on display size
                if (viewportWidth >= 2560 || viewportHeight >= 1440) {
                    renderScale = 2.5;
                } else if (viewportWidth >= 800) {
                    renderScale = 2;
                } else {
                    renderScale = 1;
                }
                
                // iOS canvas memory safety check
                let bufferWidth = BASE_WIDTH * renderScale;
                let bufferHeight = BASE_HEIGHT * renderScale;
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    renderScale *= scaleFactor;
                    bufferWidth = BASE_WIDTH * renderScale;
                    bufferHeight = BASE_HEIGHT * renderScale;
                }
                
                canvas.width = Math.round(bufferWidth);
                canvas.height = Math.round(bufferHeight);
                
                ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);
                
                // Use full viewport - no letterboxing
                const availableWidth = viewportWidth;
                const availableHeight = viewportHeight - hudHeight;
                
                canvas.style.width = availableWidth + 'px';
                canvas.style.height = availableHeight + 'px';
                
                WORLD_WIDTH = Math.floor(BASE_WIDTH / TILE_SIZE);
                
                GameDebug.hide();
            }
        }
        
        function handleFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
            
            // Just call resize - it handles both fullscreen and normal
            handleResize();
            
            if (!gameRunning) {
                draw();
            }
        }
        
        // Initialize scaling
        handleResize();
        window.addEventListener('resize', handleResize);
        
        // Use visualViewport resize event if available (better for iframes)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', handleResize);
            window.visualViewport.addEventListener('scroll', handleResize);
        }
        
        // Handle fullscreen changes
        document.addEventListener('fullscreenchange', () => {
            setTimeout(handleFullscreenChange, 50);
            setTimeout(handleResize, 150);
            setTimeout(handleResize, 500);
        });
        document.addEventListener('webkitfullscreenchange', () => {
            setTimeout(handleFullscreenChange, 50);
            setTimeout(handleResize, 150);
            setTimeout(handleResize, 500);
        });
        
        // Handle orientation changes on mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(handleResize, 100);
            setTimeout(handleResize, 300);
        });
        
        // Clear stuck keys when page loses focus or visibility changes
        // This prevents keys from staying stuck if user switches apps or tabs
        function clearAllKeys() {
            keys.left = keys.right = keys.up = keys.down = false;
            touchActive = false;
            canvasTouchActive = false;
        }
        
        window.addEventListener('blur', clearAllKeys);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                clearAllKeys();
            }
        });
        
        // Re-check size after delays for iframe loading
        setTimeout(handleResize, 100);
        setTimeout(handleResize, 300);
        setTimeout(handleResize, 500);
        
        // ==================== INITIALIZATION ====================
        createScanlinePattern();
        initBossSystem();
        generateWorld();
        initAmbientParticles();
        initBgStars();
        draw();
        
        requestAnimationFrame(gameLoop);
    })();
    </script>
</body>
</html>
