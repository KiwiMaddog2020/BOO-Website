<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=overlays-content">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>BOO Survivors</title>
    <script>
        // Immediate iframe detection - runs before CSS layout
        if (window.self !== window.top) {
            document.documentElement.classList.add('in-iframe');
        }
        window.onerror=function(){return true};window.onunhandledrejection=function(e){if(e&&e.preventDefault)e.preventDefault();return true};
    </script>
    <style>
        :root {
            --scale: 1;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: calc(4px * var(--scale, 1));
            padding: calc(6px * var(--scale, 1));
            width: fit-content;
            height: fit-content;
            max-width: 100%;
            transform: translateZ(0);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
            overflow: visible;
            border: 3px solid #0ff;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            border-radius: 12px;
            background: #0a0a0a;
        }

        /* Fullscreen/iframe mode: fill entire viewport */
        .game-container.fullscreen-mode {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            padding: 0;
            gap: 0;
            border-radius: 0;
            border: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        /* Subtle cyan border around canvas in fullscreen */
        .game-container.fullscreen-mode #gameCanvas {
            border: 2px solid rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
            border-radius: 0;
            border-bottom: none;
            flex-shrink: 0;
        }
        
        /* Subtle cyan border around trackpad in fullscreen */
        .game-container.fullscreen-mode .trackpad-zone {
            border: 2px solid rgba(0, 255, 255, 0.15);
            border-top: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
            overflow: visible;
            flex-shrink: 0;
            flex-grow: 0;
        }
        
        /* Fullscreen body centering - JS adds this class */
        body.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            overflow: hidden !important;
        }
        
        /* Force fullscreen layout when in iframe (CSS kicks in immediately) */
        /* Center vertically to ensure game is fully visible */
        html.in-iframe body {
            align-items: center;
        }
        
        html.in-iframe .game-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            padding: 0;
            gap: 0;
            border-radius: 0;
            border: none;
            overflow: hidden;
        }
        
        html.in-iframe #gameCanvas {
            border-radius: 0;
        }

        #gameCanvas {
            border-radius: 3px;
            max-width: 100%;
            display: block;
            touch-action: none;
        }

        /* Pause button */
        .pause-btn {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 36px;
            height: 36px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 6px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(0, 255, 255, 0.9);
            transition: all 0.15s;
            opacity: 0.7;
        }
        
        .pause-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.9);
            border-color: #0ff;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.5);
        }
        
        .pause-btn.paused {
            opacity: 1;
            background: rgba(0, 255, 255, 0.2);
            border-color: #0ff;
        }
        
        /* Pause Menu Overlay */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 550;
        }
        
        .pause-overlay.active {
            display: flex;
        }
        
        .pause-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 30px #39ff14, 0 0 60px #39ff14;
            margin-bottom: 40px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }
        
        .pause-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .pause-menu-btn {
            padding: 10px 20px;
            width: 160px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .pause-menu-btn:hover {
            transform: scale(1.05);
        }
        
        .pause-menu-btn:active {
            transform: scale(0.98);
        }
        
        .pause-menu-btn.btn-resume {
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 8px #0ff;
        }
        
        .pause-menu-btn.btn-resume:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        .pause-menu-btn.btn-exit {
            border-color: #ff3366;
            color: #ff3366;
            box-shadow: 0 0 8px #ff3366;
        }
        
        .pause-menu-btn.btn-exit:hover {
            background: #ff3366;
            color: #000;
            box-shadow: 0 0 20px #ff3366;
        }
        
        .pause-menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }
        
        .pause-menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
            box-shadow: 0 0 20px #ffcc00;
        }
        
        /* Confirmation Dialog */
        .confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 560;
        }
        
        .confirm-overlay.active {
            display: flex;
        }
        
        .confirm-box {
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        
        .confirm-text {
            font-size: 22px;
            color: #fff;
            margin-bottom: 25px;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        
        .confirm-btn {
            padding: 12px 35px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        
        .confirm-btn:hover {
            transform: scale(1.05);
        }
        
        .confirm-btn.btn-yes {
            background: rgba(200, 50, 50, 0.8);
            border: 2px solid #ff4444;
            color: #fff;
        }
        
        .confirm-btn.btn-no {
            background: rgba(80, 80, 100, 0.8);
            border: 2px solid #888;
            color: #fff;
        }

        /* HUD Overlay - Centered, symmetrical layout */
        .hud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: #fff;
            font-size: 12px;
            text-shadow: 0 0 10px #0ff;
            z-index: 100;
            pointer-events: none;
        }

        .hud-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .hud span {
            color: #0ff;
        }

        .hud .hp-bar {
            width: 200px;
            height: 10px;
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid #39ff9f;
            border-radius: 3px;
            overflow: hidden;
        }

        .hud .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #39ff9f, #00ff66);
            box-shadow: 0 0 10px #39ff9f;
            transition: width 0.2s;
        }

        .hud .xp-bar {
            width: 140px;
            height: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            border-radius: 3px;
            overflow: hidden;
        }

        .hud .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffcc, #0ff);
            box-shadow: 0 0 6px #0ff;
            transition: width 0.15s;
        }

        /* Top-Left HUD Overlay */
        /* Weapons bar - between offense panel and minimap */
        .weapons-bar {
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            gap: calc(4px * var(--scale, 1));
            justify-content: flex-start;
            align-items: center;
            align-content: center;
            padding: calc(4px * var(--scale, 1));
            pointer-events: auto;
            width: calc(70px * var(--scale, 1));
            max-height: calc(158px * var(--scale, 1));
            align-self: flex-start;
            flex-shrink: 0;
            /* Center horizontally between stat panel and minimap */
            margin: 0 auto;
        }
        
        /* Tomes bar - between minimap and defense panel */
        .tomes-bar {
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            gap: calc(4px * var(--scale, 1));
            justify-content: flex-start;
            align-items: center;
            align-content: center;
            padding: calc(4px * var(--scale, 1));
            pointer-events: auto;
            width: calc(70px * var(--scale, 1));
            max-height: calc(158px * var(--scale, 1));
            align-self: flex-start;
            flex-shrink: 0;
            /* Center horizontally between minimap and stat panel */
            margin: 0 auto;
        }
        
        /* Weapon/Tome Tooltips */
        .weapon-icon, .tome-icon {
            position: relative;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .item-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #0ff;
            border-radius: 6px;
            padding: 8px 12px;
            min-width: 140px;
            max-width: 180px;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            pointer-events: none;
            margin-top: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .weapon-icon:hover .item-tooltip,
        .tome-icon:hover .item-tooltip {
            opacity: 1;
            visibility: visible;
        }
        
        .item-tooltip-name {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 4px;
            text-align: center;
        }
        
        .item-tooltip-desc {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            line-height: 1.3;
        }
        
        .item-tooltip-level {
            font-size: 10px;
            color: #0ff;
            text-align: center;
            margin-top: 4px;
        }
        
        /* Hide tooltips on touch devices */
        @media (hover: none) {
            .item-tooltip {
                display: none;
            }
        }
        
        .tome-icon {
            width: calc(28px * var(--scale, 1));
            height: calc(28px * var(--scale, 1));
            border: calc(2px * var(--scale, 1)) solid;
            border-radius: calc(5px * var(--scale, 1));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(16px * var(--scale, 1));
            background: rgba(0, 0, 0, 0.7);
            position: relative;
        }
        
        .tome-icon .tome-base {
            position: absolute;
            font-size: calc(20px * var(--scale, 1));
            opacity: 0.6;
        }
        
        .tome-icon .tome-effect {
            position: relative;
            font-size: calc(12px * var(--scale, 1));
            z-index: 1;
            filter: drop-shadow(0 0 2px #000);
        }

        .tome-level {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: calc(9px * var(--scale, 1));
            background: #000;
            padding: 1px 3px;
            border-radius: 3px;
            color: #fff;
        }
        
        /* Main row containing minimap and weapons bar */
        .trackpad-main-row {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            justify-content: space-between;
            gap: calc(6px * var(--scale, 1));
            width: 100%;
            margin: calc(1px * var(--scale, 1)) 0 0 0;
            max-width: 100%;
            box-sizing: border-box;
            flex-grow: 1;
            max-height: 100%;
        }
        
        /* Left zone for offense panel + weapons */
        .stat-zone-left {
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: stretch;
            gap: 0;
            flex: 1 1 0;
            min-width: 0;
        }
        
        /* Right zone for tomes + defense panel */
        .stat-zone-right {
            display: flex;
            flex-direction: row;
            justify-content: flex-end;
            align-items: stretch;
            gap: 0;
            flex: 1 1 0;
            min-width: 0;
        }
        
        /* Center content wrapper - just minimap now */
        .center-content {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            justify-content: center;
            flex-shrink: 0;
        }
        
        /* Stat panels on either side of minimap */
        .stat-panel {
            display: flex;
            flex-direction: column;
            gap: calc(4px * var(--scale, 1));
            padding: calc(6px * var(--scale, 1)) calc(10px * var(--scale, 1)) calc(8px * var(--scale, 1)) calc(10px * var(--scale, 1));
            background: rgba(0, 0, 0, 0.7);
            border: calc(2px * var(--scale, 1)) solid rgba(0, 255, 255, 0.3);
            border-radius: calc(8px * var(--scale, 1));
            width: calc(170px * var(--scale, 1));
            height: 100%;
            pointer-events: none;
            flex-shrink: 0;
            justify-content: space-between;
            box-sizing: border-box;
        }
        
        .stat-panel-left {
            border-color: rgba(255, 100, 100, 0.5);
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.15);
        }
        
        .stat-panel-right {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.15);
        }
        
        .stat-panel-title {
            font-size: calc(12px * var(--scale, 1));
            font-weight: bold;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 2px;
            padding-bottom: calc(3px * var(--scale, 1));
            margin-bottom: calc(1px * var(--scale, 1));
            margin-top: calc(-1px * var(--scale, 1));
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-panel-left .stat-panel-title {
            color: rgba(255, 150, 150, 1);
            text-shadow: 0 0 8px rgba(255, 100, 100, 0.5);
        }
        
        .stat-panel-right .stat-panel-title {
            color: rgba(150, 200, 255, 1);
            text-shadow: 0 0 8px rgba(100, 200, 255, 0.5);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: calc(12px * var(--scale, 1));
            line-height: 1.3;
            padding: calc(1px * var(--scale, 1)) 0;
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.6);
            font-weight: normal;
            font-size: calc(11px * var(--scale, 1));
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            color: #0ff;
            font-weight: bold;
            font-size: calc(13px * var(--scale, 1));
            text-shadow: 0 0 6px rgba(0, 255, 255, 0.5);
        }
        
        .stat-panel-left .stat-value {
            color: #ff9977;
            text-shadow: 0 0 6px rgba(255, 136, 102, 0.5);
        }
        
        .stat-panel-right .stat-value {
            color: #77ccff;
            text-shadow: 0 0 6px rgba(102, 204, 255, 0.5);
        }
        
        /* Highlight when stat is boosted */
        .stat-value.boosted {
            color: #ffff00;
            text-shadow: 0 0 8px rgba(255, 255, 0, 0.7);
        }
        
        .trackpad-left-spacer {
            flex: 1;
        }
        
        .hud-stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 140px;
            margin-bottom: 6px;
        }
        
        .hud-stat {
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 6px #0ff;
            white-space: nowrap;
        }
        
        .hud-stat span {
            color: #0ff;
            font-weight: bold;
        }
        
        #goldDisplay {
            color: #ffd700;
            text-shadow: 0 0 6px #ffd700;
        }
        
        #goldDisplay span {
            color: #ffd700;
        }
        
        .hud-hp-bar {
            width: 140px;
            height: 12px;
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid #39ff9f;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .hud-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #39ff9f, #00ff66);
            box-shadow: 0 0 6px #39ff9f;
            transition: width 0.2s;
        }

        /* Weapon icons display - grows right to left */
        .weapons-display {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 160px;
            justify-content: flex-start;
        }

        .weapon-icon {
            width: calc(28px * var(--scale, 1));
            height: calc(28px * var(--scale, 1));
            border: calc(2px * var(--scale, 1)) solid;
            border-radius: calc(5px * var(--scale, 1));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(16px * var(--scale, 1));
            background: rgba(0, 0, 0, 0.7);
            position: relative;
        }

        .weapon-level {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: calc(9px * var(--scale, 1));
            background: #000;
            padding: 1px 3px;
            border-radius: 3px;
            color: #fff;
        }

        /* Weapon Select Overlay */
        .weapon-select-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
            box-sizing: border-box;
            padding: 5px;
            overflow: hidden;
        }
        
        .weapon-select-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px 0 15px 0;
            touch-action: pan-y;
            -webkit-overflow-scrolling: touch;
        }
        
        .weapon-select-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }
        
        .weapon-select-title {
            font-size: 22px;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            margin-bottom: 4px;
            letter-spacing: 3px;
            text-transform: uppercase;
            flex-shrink: 0;
        }
        
        .weapon-select-subtitle {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        
        .weapon-select-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            max-width: 460px;
            padding: 0 10px;
            flex-shrink: 0;
        }
        
        @media (max-height: 700px) {
            .weapon-select-content {
                padding: 5px 0;
            }
            .weapon-select-title {
                font-size: 20px;
                margin-bottom: 4px;
            }
            .weapon-select-subtitle {
                font-size: 11px;
                margin-bottom: 10px;
            }
            .weapon-select-grid {
                gap: 6px;
            }
            .weapon-select-card {
                width: 78px !important;
                padding: 7px 5px !important;
            }
            .weapon-select-card .weapon-icon {
                font-size: 22px !important;
            }
            .weapon-select-card .weapon-name {
                font-size: 7px !important;
            }
            .color-selector {
                margin-top: 12px !important;
            }
        }
        
        @media (max-height: 550px) {
            .weapon-select-title {
                font-size: 16px;
            }
            .weapon-select-subtitle {
                font-size: 10px;
                margin-bottom: 8px;
            }
            .weapon-select-grid {
                gap: 4px;
            }
            .weapon-select-card {
                width: 68px !important;
                padding: 6px 4px !important;
            }
            .weapon-select-card .weapon-icon {
                font-size: 18px !important;
            }
            .weapon-select-card .weapon-name {
                font-size: 6px !important;
            }
            .color-selector {
                margin-top: 8px !important;
            }
            .color-option {
                width: 22px !important;
                height: 22px !important;
            }
        }
        
        @media (max-height: 450px) {
            .weapon-select-title {
                font-size: 14px;
                margin-bottom: 2px;
            }
            .weapon-select-subtitle {
                font-size: 9px;
                margin-bottom: 6px;
            }
            .weapon-select-grid {
                gap: 3px;
            }
            .weapon-select-card {
                width: 58px !important;
                padding: 5px 3px !important;
            }
            .weapon-select-card .weapon-icon {
                font-size: 15px !important;
            }
            .weapon-select-card .weapon-name {
                font-size: 5px !important;
            }
            .weapon-select-card .weapon-desc {
                display: none !important;
            }
            .color-selector {
                margin-top: 6px !important;
            }
            .color-selector-title {
                font-size: 13px !important;
                margin-bottom: 4px !important;
            }
            .color-option {
                width: 18px !important;
                height: 18px !important;
            }
            .weapon-select-desc {
                font-size: 11px !important;
                min-height: 20px !important;
                margin-top: 6px !important;
            }
            .weapon-select-buttons {
                gap: 20px !important;
                margin-top: 10px !important;
            }
            .weapon-select-btn {
                padding: 8px 16px !important;
                width: 110px !important;
                font-size: 11px !important;
            }
        }
        
        @media (max-width: 600px) {
            .weapon-select-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 4px;
                max-width: 380px;
            }
            
            .weapon-select-card {
                width: 68px !important;
                padding: 6px 4px !important;
            }
            
            .weapon-select-card .weapon-icon {
                font-size: 20px !important;
            }
            
            .weapon-select-card .weapon-name {
                font-size: 6px !important;
            }
            
            .weapon-select-desc {
                font-size: 12px !important;
                padding: 4px 10px !important;
            }
            
            .weapon-select-btn {
                padding: 9px 18px !important;
                width: 120px !important;
                font-size: 12px !important;
            }
        }
        
        @media (max-width: 380px) {
            .weapon-select-title {
                font-size: 16px;
            }
            .weapon-select-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 3px;
                max-width: 260px;
                padding: 0 5px;
            }
            
            .weapon-select-card {
                width: 58px !important;
                padding: 5px 3px !important;
            }
            
            .weapon-select-card .weapon-icon {
                font-size: 16px !important;
            }
            
            .weapon-select-card .weapon-name {
                font-size: 5px !important;
            }
            
            .color-option {
                width: 20px !important;
                height: 20px !important;
            }
            
            .weapon-select-desc {
                font-size: 10px !important;
            }
            
            .weapon-select-btn {
                padding: 8px 14px !important;
                width: 100px !important;
                font-size: 10px !important;
            }
        }
        
        .weapon-select-card {
            width: 82px;
            padding: 7px 5px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            user-select: none;
        }
        
        .weapon-select-card:hover {
            transform: scale(1.05);
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }
        
        .weapon-select-card:active {
            transform: scale(0.98);
        }
        
        .weapon-select-card .weapon-icon {
            font-size: 22px;
        }
        
        .weapon-select-card .weapon-name {
            font-size: 8px;
            color: #fff;
            text-align: center;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .weapon-select-card .weapon-desc {
            font-size: 7px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            line-height: 1.2;
            display: none;
        }
        
        .weapon-select-card.selected {
            border-color: #0ff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            background: rgba(0, 255, 255, 0.15);
            outline: 2px solid #fff;
            outline-offset: 2px;
        }
        
        .weapon-select-card.disabled-weapon {
            opacity: 0.4;
            border-color: #666 !important;
        }
        
        .weapon-select-card.disabled-weapon:hover {
            border-color: #888 !important;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }
        
        .weapon-select-card .weapon-toggle {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #22cc22;
            border: 2px solid #fff;
            display: none;
            font-size: 10px;
            line-height: 12px;
            text-align: center;
        }
        
        .weapon-select-card .weapon-toggle::after {
            content: '✓';
            color: #fff;
        }
        
        .weapon-select-card.disabled-weapon .weapon-toggle {
            background: #cc2222;
        }
        
        .weapon-select-card.disabled-weapon .weapon-toggle::after {
            content: '✕';
        }
        
        .edit-mode .weapon-select-card {
            position: relative;
        }
        
        .edit-mode .weapon-select-card .weapon-toggle {
            display: block;
        }
        
        .edit-pool-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #aaa;
            border-radius: 6px;
            color: #ccc;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 90px;
            text-align: center;
        }
        
        .edit-pool-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        
        .edit-pool-btn.active {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }
        
        .edit-btn-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0;
            margin-bottom: 10px;
        }
        
        .disabled-count {
            font-size: 11px;
            color: #888;
            width: 90px;
        }
        
        .disabled-count-left {
            text-align: right;
            margin-right: 10px;
        }
        
        .disabled-count-right {
            text-align: left;
            margin-left: 10px;
        }
        
        .btn-spacer {
            width: 10px;
        }
        
        .banish-button {
            margin-top: 20px;
            padding: 8px 16px;
            background: rgba(180, 30, 30, 0.8);
            border: 2px solid #cc2222;
            border-radius: 6px;
            color: #ff3333;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            user-select: none;
            min-width: 120px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .banish-button:hover {
            background: rgba(200, 40, 40, 0.9);
            border-color: #ff3333;
            color: #ff5555;
            transform: scale(1.05);
        }
        
        .banish-button.active {
            background: rgba(220, 50, 50, 0.9);
            box-shadow: 0 0 25px rgba(255, 30, 30, 0.6);
            animation: banish-pulse 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes banish-pulse {
            from { box-shadow: 0 0 15px rgba(255, 30, 30, 0.4); }
            to { box-shadow: 0 0 30px rgba(255, 30, 30, 0.7); }
        }
        
        .upgrade-card.banish-target {
            border-color: #ff3333 !important;
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.6) !important;
        }
        
        .upgrade-card.banish-target:hover {
            transform: scale(1.08);
        }
        
        /* Tome Editor Overlay */
        .tome-editor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10002;
            flex-direction: column;
        }
        
        .tome-editor-overlay.active {
            display: flex;
        }
        
        .tome-editor-content {
            text-align: center;
            max-width: 600px;
            padding: 20px;
        }
        
        .tome-editor-title {
            font-size: 22px;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            margin-bottom: 4px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        .tome-editor-subtitle {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 10px;
        }
        
        .tome-editor-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .tome-select-card {
            width: 100px;
            padding: 12px 8px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            user-select: none;
            position: relative;
        }
        
        .tome-select-card:hover {
            transform: scale(1.05);
            border-color: #64c8ff;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
        }
        
        .tome-select-card.info-selected {
            outline: 2px solid #fff;
            outline-offset: 2px;
        }
        
        .tome-select-card.disabled-tome {
            opacity: 0.4;
            border-color: #666 !important;
        }
        
        .tome-select-card.disabled-tome:hover {
            border-color: #888 !important;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }
        
        .tome-select-card .tome-toggle {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #22cc22;
            border: 2px solid #fff;
            font-size: 10px;
            line-height: 12px;
            text-align: center;
            display: none;
        }
        
        .tome-editor-grid.edit-mode .tome-select-card .tome-toggle {
            display: block;
        }
        
        .tome-select-card .tome-toggle::after {
            content: '✓';
            color: #fff;
        }
        
        .tome-select-card.disabled-tome .tome-toggle {
            background: #cc2222;
        }
        
        .tome-select-card.disabled-tome .tome-toggle::after {
            content: '✕';
        }
        
        .tome-select-card .tome-icon-wrapper {
            font-size: 28px;
            position: relative;
        }
        
        .tome-select-card .tome-name {
            font-size: 9px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }
        
        .tome-select-card .tome-desc {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }
        
        .edit-tomes-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #aaa;
            border-radius: 6px;
            color: #ccc;
            font-size: 10px;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s;
            min-width: 90px;
            text-align: center;
        }
        
        .edit-tomes-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        
        .tome-editor-desc {
            height: 28px;
            min-height: 28px;
            margin: 15px 0;
            padding: 6px 15px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            max-width: 400px;
            line-height: 1.3;
        }
        
        .tome-editor-close {
            padding: 8px 16px;
            width: 120px;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tome-editor-close:hover {
            background: #0ff;
            color: #000;
        }
        
        .tome-disabled-count {
            font-size: 12px;
            color: #888;
            margin-left: 15px;
        }
        
        .tome-mode-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .tome-mode-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #aaa;
            border-radius: 6px;
            color: #ccc;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 90px;
            text-align: center;
        }
        
        .tome-mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        
        .tome-mode-btn.active {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #aaa;
            color: #ccc;
        }
        
        @media (max-width: 500px) {
            .tome-editor-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            .tome-select-card {
                width: 85px;
                padding: 8px 6px;
            }
            .tome-select-card .tome-icon-wrapper {
                font-size: 22px;
            }
            .tome-select-card .tome-name {
                font-size: 8px;
            }
        }
        
        .weapon-select-desc {
            height: 28px;
            min-height: 28px;
            margin-top: 10px;
            padding: 6px 15px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            max-width: 400px;
            line-height: 1.3;
            overflow: hidden;
        }
        
        .weapon-select-buttons {
            display: flex;
            justify-content: center;
            gap: 30px;
            pointer-events: auto;
            margin-top: 15px;
            flex-shrink: 0;
        }
        
        .weapon-select-btn {
            padding: 8px 16px;
            width: 120px;
            font-size: 12px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #f0f;
            border-radius: 6px;
            color: #f0f;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #f0f;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .weapon-select-btn:hover {
            background: #f0f;
            color: #000;
        }
        
        .weapon-select-btn.btn-confirm {
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 8px #0ff;
        }
        
        .weapon-select-btn.btn-confirm:hover {
            background: #0ff;
            color: #000;
        }
        
        .weapon-select-btn.btn-confirm.disabled {
            opacity: 0.4;
            pointer-events: none;
        }
        
        /* Player Color Selector */
        .color-selector {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .color-selector-title {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .color-selector-grid {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 280px;
        }
        
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s;
        }
        
        .color-option:hover {
            transform: scale(1.15);
            border-color: #fff;
        }
        
        .color-option.selected {
            border-color: #fff;
            box-shadow: 0 0 12px currentColor;
            transform: scale(1.1);
        }
        
        @media (max-width: 600px) {
            .color-selector {
                margin-top: 15px;
            }
            
            .color-option {
                width: 24px;
                height: 24px;
            }
        }

        /* Upgrade Selection Overlay */
        .upgrade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .upgrade-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }
        
        /* GPU-accelerated flash overlay */
        .upgrade-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 255, 0.4);
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        .upgrade-overlay.active::before {
            animation: flashFadeOut 0.5s ease-out forwards;
        }
        
        @keyframes flashFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .upgrade-overlay .upgrade-title {
            opacity: 0;
            transform: scale(0.5) translateY(-30px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .upgrade-overlay.active .upgrade-title {
            animation: upgradeTitleEnter 0.6s ease-out 0.1s forwards;
        }
        
        @keyframes upgradeTitleEnter {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-30px) translateZ(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(0) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0) translateZ(0);
            }
        }
        
        .upgrade-overlay .upgrade-subtitle {
            opacity: 0;
            transform: translateY(-10px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .upgrade-overlay.active .upgrade-subtitle {
            animation: upgradeSubtitleEnter 0.4s ease-out 0.3s forwards;
        }
        
        @keyframes upgradeSubtitleEnter {
            0% { opacity: 0; transform: translateY(-10px) translateZ(0); }
            100% { opacity: 0.6; transform: translateY(0) translateZ(0); }
        }
        
        .upgrade-overlay .upgrade-card {
            opacity: 0;
            transform: translateY(30px) scale(0.9) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .upgrade-overlay.active .upgrade-card:nth-child(1) {
            animation: upgradeCardEnter 0.4s ease-out 0.2s forwards;
        }
        .upgrade-overlay.active .upgrade-card:nth-child(2) {
            animation: upgradeCardEnter 0.4s ease-out 0.3s forwards;
        }
        .upgrade-overlay.active .upgrade-card:nth-child(3) {
            animation: upgradeCardEnter 0.4s ease-out 0.4s forwards;
        }
        
        @keyframes upgradeCardEnter {
            0% {
                opacity: 0;
                transform: translateY(30px) scale(0.9) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) translateZ(0);
            }
        }

        .upgrade-title {
            font-size: 32px;
            color: #0ff;
            text-shadow: 0 0 25px #0ff;
            margin-bottom: 15px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .upgrade-subtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 30px;
        }

        .upgrade-slot-machine {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }

        .upgrade-slot-machine .slot-reel {
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .upgrade-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .upgrade-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            touch-action: manipulation;
            z-index: 10;
            position: relative;
        }

        .upgrade-card.revealed {
            opacity: 1;
            transform: scale(1);
        }

        .upgrade-card:hover {
            transform: scale(1.08);
        }

        .upgrade-card .icon {
            font-size: 36px;
        }

        .upgrade-card .name {
            font-size: 14px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .upgrade-card .desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
        }
        
        /* Reroll Button */
        .reroll-button {
            margin-top: 20px;
            padding: 8px 16px;
            background: rgba(80, 80, 100, 0.8);
            border: 2px solid #777;
            border-radius: 6px;
            color: #bbb;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            user-select: none;
            min-width: 120px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .reroll-button:hover {
            background: rgba(100, 100, 130, 0.9);
            border-color: #999;
            color: #fff;
            transform: scale(1.05);
        }
        
        .reroll-button:active {
            transform: scale(0.95);
        }

        /* Shrine Power-up Overlay */
        .shrine-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }
        
        /* GPU-accelerated flash overlay */
        .shrine-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(224, 64, 255, 0.5);
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        .shrine-overlay.active::before {
            animation: flashFadeOut 0.6s ease-out forwards;
        }

        .shrine-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }
        
        .shrine-overlay .shrine-title {
            opacity: 0;
            transform: scale(0.5) translateY(-30px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .shrine-overlay.active .shrine-title {
            animation: shrineTitleEnter 0.8s ease-out 0.2s forwards;
        }
        
        @keyframes shrineTitleEnter {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-30px) translateZ(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(0) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0) translateZ(0);
            }
        }
        
        .shrine-overlay .shrine-subtitle {
            opacity: 0;
            transform: translateY(-10px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .shrine-overlay.active .shrine-subtitle {
            animation: shrineSubtitleEnter 0.5s ease-out 0.5s forwards;
        }
        
        @keyframes shrineSubtitleEnter {
            0% {
                opacity: 0;
                transform: translateY(-10px) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: translateY(0) translateZ(0);
            }
        }
        
        .shrine-overlay .shrine-card {
            opacity: 0;
            transform: translateY(40px) scale(0.9) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .shrine-overlay .shrine-card.revealed {
            animation: shrineCardEnter 0.5s ease-out forwards;
        }
        
        .shrine-overlay .shrine-card:nth-child(1).revealed {
            animation-delay: 0.6s;
        }
        .shrine-overlay .shrine-card:nth-child(2).revealed {
            animation-delay: 0.75s;
        }
        .shrine-overlay .shrine-card:nth-child(3).revealed {
            animation-delay: 0.9s;
        }
        
        @keyframes shrineCardEnter {
            0% {
                opacity: 0;
                transform: translateY(40px) scale(0.9) translateZ(0);
            }
            60% {
                opacity: 1;
                transform: translateY(-5px) scale(1.02) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) translateZ(0);
            }
        }
        
        /* Shrine flash effect on screen */
        .shrine-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(224, 64, 255, 0.8) 0%, rgba(224, 64, 255, 0) 70%);
            pointer-events: none;
            z-index: 499;
            will-change: transform, opacity;
            backface-visibility: hidden;
            animation: shrineFlash 0.6s ease-out forwards;
        }
        
        @keyframes shrineFlash {
            0% {
                opacity: 1;
                transform: scale(0.5) translateZ(0);
            }
            100% {
                opacity: 0;
                transform: scale(2) translateZ(0);
            }
        }
        
        .shrine-overlay.closing {
            animation: shrineOverlayFadeOut 0.4s ease-in forwards;
        }
        
        .shrine-overlay.closing .shrine-title,
        .shrine-overlay.closing .shrine-subtitle {
            animation: shrineElementFadeOut 0.3s ease-in forwards;
        }
        
        @keyframes shrineOverlayFadeOut {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        @keyframes shrineElementFadeOut {
            0% {
                opacity: 1;
                transform: scale(1) translateZ(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.9) translateZ(0);
            }
        }

        /* Chest overlay */
        /* ===== CHEST OVERLAY - REBUILT FROM SCRATCH ===== */
        #chestModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999999;
            pointer-events: auto;
            touch-action: auto !important;
            -webkit-touch-callout: default !important;
        }
        
        /* GPU-accelerated flash overlay */
        #chestModal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 215, 0, 0.4);
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        #chestModal.visible::before {
            animation: flashFadeOut 0.5s ease-out forwards;
        }
        
        #chestModal.visible {
            display: flex;
            pointer-events: auto;
            touch-action: auto !important;
        }
        
        #chestModal.visible * {
            pointer-events: auto;
            touch-action: auto !important;
        }
        
        #chestModal .modal-btn {
            touch-action: auto !important;
            -webkit-touch-callout: default !important;
            cursor: pointer;
        }
        
        /* Disable trackpad when modal is visible */
        #chestModal.visible ~ .game-container .trackpad-zone,
        body:has(#chestModal.visible) .trackpad-zone {
            pointer-events: none !important;
        }
        
        #chestModal .modal-title {
            font-size: 28px;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            margin-bottom: 10px;
            letter-spacing: 3px;
            opacity: 0;
            transform: scale(0.5) translateY(-30px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        #chestModal.visible .modal-title {
            animation: chestTitleEnter 0.6s ease-out 0.1s forwards;
        }
        
        @keyframes chestTitleEnter {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-30px) translateZ(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(0) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0) translateZ(0);
            }
        }
        
        #chestModal .modal-cost {
            font-size: 18px;
            color: #ffd700;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(-10px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        #chestModal.visible .modal-cost {
            animation: chestCostEnter 0.4s ease-out 0.25s forwards;
        }
        
        @keyframes chestCostEnter {
            0% { opacity: 0; transform: translateY(-10px) translateZ(0); }
            100% { opacity: 1; transform: translateY(0) translateZ(0); }
        }
        
        #chestModal .modal-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd700;
            border-radius: 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 10px;
            opacity: 0;
            transform: translateY(30px) scale(0.9) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        #chestModal.visible .modal-card {
            animation: chestCardEnter 0.4s ease-out 0.3s forwards;
        }
        
        @keyframes chestCardEnter {
            0% {
                opacity: 0;
                transform: translateY(30px) scale(0.9) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) translateZ(0);
            }
        }
        
        #chestModal .modal-buttons {
            opacity: 0;
            transform: translateY(20px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        #chestModal.visible .modal-buttons {
            animation: chestButtonsEnter 0.4s ease-out 0.4s forwards;
        }
        
        @keyframes chestButtonsEnter {
            0% { opacity: 0; transform: translateY(20px) translateZ(0); }
            100% { opacity: 1; transform: translateY(0) translateZ(0); }
        }
        
        #chestModal .modal-card.legendary {
            border: 3px solid #ffa500;
            background: linear-gradient(135deg, rgba(50, 30, 0, 0.95), rgba(80, 50, 0, 0.95));
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.6);
        }
        
        #chestModal.visible .modal-card.legendary {
            animation: chestCardEnter 0.4s ease-out 0.3s forwards, legendaryShine 2s ease-in-out 0.7s infinite;
        }
        
        #chestModal .modal-card.legendary .card-name {
            font-size: 16px;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }
        
        #chestModal .modal-card.legendary .card-icon {
            animation: legendaryIconPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes legendaryShine {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 165, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.3);
            }
            50% { 
                box-shadow: 0 0 35px rgba(255, 165, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.5);
            }
        }
        
        @keyframes legendaryIconPulse {
            0%, 100% { transform: scale(1) translateZ(0); }
            50% { transform: scale(1.15) translateZ(0); }
        }
        
        #chestModal .modal-card .card-icon {
            font-size: 36px;
        }
        
        #chestModal .modal-card .card-name {
            font-size: 14px;
            font-weight: bold;
            color: #ffd700;
        }
        
        #chestModal .modal-card .card-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        #chestModal .modal-buttons {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        #chestModal .modal-btn {
            padding: 14px 32px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.2s, box-shadow 0.2s;
            user-select: none;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #chestModal .modal-btn:hover {
            transform: scale(1.08);
        }
        
        #chestModal .modal-btn:active {
            transform: scale(0.95);
        }
        
        #chestModal .btn-take {
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            border: 2px solid #00cc00;
            box-shadow: 0 0 15px rgba(0, 204, 0, 0.4);
        }
        
        #chestModal .btn-take:hover {
            box-shadow: 0 0 25px rgba(0, 204, 0, 0.6);
        }
        
        #chestModal .btn-take.disabled {
            background: rgba(0, 0, 0, 0.8) !important;
            border-color: #555 !important;
            color: #888 !important;
            cursor: not-allowed;
            box-shadow: 0 0 8px rgba(100, 100, 100, 0.3) !important;
        }
        
        #chestModal .btn-take.disabled:hover {
            transform: scale(1) !important;
            box-shadow: 0 0 8px rgba(100, 100, 100, 0.3) !important;
        }
        
        #chestModal .btn-leave {
            background: rgba(0, 0, 0, 0.8);
            color: #ff3366;
            border: 2px solid #ff3366;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #chestModal .btn-leave:hover {
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.4);
        }
        
        /* Chest Slot Reel */
        .chest-slot-reel {
            width: 160px;
            height: 120px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ffd700;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
            margin-bottom: 15px;
            display: none;
        }
        
        .chest-slot-reel.spinning {
            display: block;
        }
        
        .chest-slot-reel.spinning .slot-content {
            animation: chestSlotSpin 0.08s linear infinite;
        }
        
        .chest-slot-reel.stopped {
            display: block;
        }
        
        @keyframes chestSlotSpin {
            0% { transform: translateY(0); opacity: 0.7; }
            50% { transform: translateY(-30px); opacity: 0.3; }
            100% { transform: translateY(-60px); opacity: 0.7; }
        }
        
        .chest-slot-reel .slot-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 10px;
            gap: 8px;
        }
        
        .chest-slot-reel .slot-icon {
            font-size: 42px;
        }
        
        .chest-slot-reel .slot-name {
            font-size: 14px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        /* Tombstone Modal */
        #tombstoneModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 10, 30, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 15%;
            z-index: 999999;
            pointer-events: auto;
            touch-action: auto !important;
        }
        
        /* GPU-accelerated flash overlay */
        #tombstoneModal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(170, 136, 204, 0.5);
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        #tombstoneModal.visible::before {
            animation: flashFadeOut 0.6s ease-out forwards;
        }
        
        #tombstoneModal.visible {
            display: flex;
        }
        
        .tombstone-title {
            font-size: 28px;
            color: #aa88cc;
            text-shadow: 0 0 20px #8866aa;
            margin-bottom: 15px;
            letter-spacing: 3px;
            opacity: 0;
            transform: scale(0.5) translateY(-30px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        #tombstoneModal.visible .tombstone-title {
            animation: tombstoneTitleEnter 0.7s ease-out 0.1s forwards;
        }
        
        @keyframes tombstoneTitleEnter {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-30px) translateZ(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(0) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0) translateZ(0);
            }
        }
        
        .tombstone-name {
            font-size: 36px;
            color: #ffffff;
            text-shadow: 0 0 15px #aabbff;
            margin-bottom: 20px;
            font-weight: bold;
            opacity: 0;
            transform: translateY(-15px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        #tombstoneModal.visible .tombstone-name {
            animation: tombstoneNameEnter 0.5s ease-out 0.3s forwards;
        }
        
        @keyframes tombstoneNameEnter {
            0% { opacity: 0; transform: translateY(-15px) translateZ(0); }
            100% { opacity: 1; transform: translateY(0) translateZ(0); }
        }
        
        .tombstone-desc {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            line-height: 1.6;
            margin-bottom: 15px;
            opacity: 0;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        #tombstoneModal.visible .tombstone-desc {
            animation: tombstoneDescEnter 0.4s ease-out 0.4s forwards;
        }
        
        @keyframes tombstoneDescEnter {
            0% { opacity: 0; }
            100% { opacity: 0.8; }
        }
        
        .tombstone-warning {
            font-size: 14px;
            color: #ff6666;
            text-shadow: 0 0 10px #ff4444;
            margin-bottom: 25px;
            opacity: 0;
            transform: translateY(10px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        #tombstoneModal.visible .tombstone-warning {
            animation: tombstoneWarningEnter 0.4s ease-out 0.5s forwards;
        }
        
        @keyframes tombstoneWarningEnter {
            0% { opacity: 0; transform: translateY(10px) translateZ(0); }
            100% { opacity: 1; transform: translateY(0) translateZ(0); }
        }
        
        .tombstone-btn {
            padding: 14px 32px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.2s, box-shadow 0.2s;
            user-select: none;
            opacity: 0;
            transform: translateY(20px) scale(0.9) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #tombstoneModal.visible .tombstone-btn {
            animation: tombstoneBtnEnter 0.4s ease-out 0.6s forwards;
        }
        
        @keyframes tombstoneBtnEnter {
            0% { opacity: 0; transform: translateY(20px) scale(0.9) translateZ(0); }
            100% { opacity: 1; transform: translateY(0) scale(1) translateZ(0); }
        }
        
        .tombstone-btn:hover {
            transform: scale(1.08) translateZ(0);
        }
        
        .tombstone-accept {
            background: rgba(0, 0, 0, 0.8);
            color: #aa88cc;
            border: 2px solid #aa66dd;
            box-shadow: 0 0 15px rgba(170, 102, 221, 0.4);
        }
        
        .tombstone-accept:hover {
            box-shadow: 0 0 25px rgba(170, 102, 221, 0.6);
        }
        
        .tombstone-decline {
            background: rgba(0, 0, 0, 0.8);
            color: #888;
            border: 2px solid #555;
            box-shadow: 0 0 10px rgba(100, 100, 100, 0.3);
        }
        
        .tombstone-decline:hover {
            box-shadow: 0 0 15px rgba(100, 100, 100, 0.4);
        }
        
        /* Tombstone modal buttons container */
        #tombstoneModal .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 20px;
        }

        /* Skull Statue Modal */
        #skullStatueModal {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(20, 10, 30, 0.98);
            border: 3px solid #880088;
            border-radius: 15px;
            padding: 25px 35px;
            z-index: 1000;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 40px rgba(136, 0, 136, 0.6), inset 0 0 30px rgba(136, 0, 136, 0.2);
        }
        
        #skullStatueModal.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .statue-title {
            font-size: 28px;
            color: #cc44cc;
            text-shadow: 0 0 20px #880088;
            margin-bottom: 10px;
            letter-spacing: 3px;
        }
        
        .statue-level {
            font-size: 16px;
            color: #ff6666;
            margin-bottom: 15px;
        }
        
        .statue-desc {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 15px;
        }
        
        .statue-effects {
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .statue-bad {
            font-size: 13px;
            color: #ff6666;
            margin-bottom: 8px;
        }
        
        .statue-good {
            font-size: 13px;
            color: #66ff66;
        }
        
        .statue-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 28px;
            margin: 0 8px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .statue-accept {
            background: rgba(0, 0, 0, 0.8);
            color: #cc44cc;
            border: 2px solid #aa00aa;
            box-shadow: 0 0 15px rgba(170, 0, 170, 0.4);
        }
        
        .statue-accept:hover {
            transform: scale(1.08);
            box-shadow: 0 0 25px rgba(170, 0, 170, 0.6);
        }
        
        .statue-decline {
            background: rgba(0, 0, 0, 0.8);
            color: #888;
            border: 2px solid #555;
            box-shadow: 0 0 10px rgba(100, 100, 100, 0.3);
        }
        
        .statue-decline:hover {
            transform: scale(1.08);
            box-shadow: 0 0 15px rgba(100, 100, 100, 0.4);
        }
        
        /* Statue modal buttons container */
        #skullStatueModal .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 20px;
        }

        .shrine-title {
            font-size: 32px;
            color: #e040ff;
            text-shadow: 0 0 25px #e040ff;
            margin-bottom: 15px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .shrine-subtitle {
            font-size: 17px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 30px;
        }

        /* Slot machine reels - shared style */
        .slot-machine {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }

        .slot-reel {
            width: 140px;
            min-width: 140px;
            max-width: 140px;
            height: 170px;
            min-height: 170px;
            max-height: 170px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #e040ff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 20px rgba(224, 64, 255, 0.3);
            box-sizing: border-box;
        }

        .slot-reel.spinning .slot-content {
            animation: slotSpin 0.1s linear infinite;
        }

        .slot-reel.stopped {
            border-color: #e040ff;
            box-shadow: 0 0 25px rgba(224, 64, 255, 0.5);
        }

        @keyframes slotSpin {
            0% { transform: translateY(0); }
            100% { transform: translateY(-40px); }
        }

        .slot-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 15px 10px;
            gap: 6px;
            box-sizing: border-box;
            overflow: hidden;
        }

        .slot-icon {
            font-size: 36px;
            height: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slot-name {
            font-size: 12px;
            color: #fff;
            text-align: center;
            font-weight: bold;
            width: 100%;
            height: 32px;
            min-height: 32px;
            max-height: 32px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
        }

        .slot-value {
            font-size: 11px;
            color: #fff;
            text-align: center;
            height: 16px;
            min-height: 16px;
        }

        .shrine-options {
            display: flex;
            gap: 20px;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .shrine-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #e040ff;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            touch-action: manipulation;
        }

        .shrine-card.revealed {
            opacity: 1;
            transform: scale(1);
        }

        .shrine-card:hover {
            transform: scale(1.08);
            box-shadow: 0 0 25px rgba(224, 64, 255, 0.5);
            border-color: #ff66ff;
        }

        .shrine-card .icon {
            font-size: 36px;
        }

        .shrine-card .name {
            font-size: 14px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .shrine-card .value {
            font-size: 12px;
            color: #fff;
            text-align: center;
        }

        /* Legendary upgrade overlay */
        .legendary-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
        }
        
        /* GPU-accelerated flash overlay */
        .legendary-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(50, 205, 50, 0.5), rgba(255, 215, 0, 0.5));
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        .legendary-overlay.active::before {
            animation: flashFadeOut 0.6s ease-out forwards;
        }

        .legendary-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }

        .legendary-title {
            font-size: 36px;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700, 0 0 60px #32cd32;
            margin-bottom: 10px;
            letter-spacing: 4px;
            opacity: 0;
            transform: scale(0.5) translateY(-30px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .legendary-overlay.active .legendary-title {
            animation: legendaryTitleEnter 0.7s ease-out 0.1s forwards;
        }
        
        @keyframes legendaryTitleEnter {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-30px) translateZ(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.15) translateY(0) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0) translateZ(0);
            }
        }

        @keyframes legendaryPulse {
            0%, 100% { text-shadow: 0 0 30px #ffd700, 0 0 60px #32cd32; }
            50% { text-shadow: 0 0 50px #ffd700, 0 0 100px #32cd32, 0 0 150px #ffd700; }
        }

        .legendary-subtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
            opacity: 0;
            transform: translateY(-10px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .legendary-overlay.active .legendary-subtitle {
            animation: legendarySubtitleEnter 0.4s ease-out 0.35s forwards;
        }
        
        @keyframes legendarySubtitleEnter {
            0% { opacity: 0; transform: translateY(-10px) translateZ(0); }
            100% { opacity: 0.7; transform: translateY(0) translateZ(0); }
        }

        .legendary-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .legendary-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: auto;
            touch-action: manipulation;
            opacity: 0;
            transform: translateY(40px) scale(0.85) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .legendary-overlay.active .legendary-card:nth-child(1) {
            animation: legendaryCardEnter 0.5s ease-out 0.25s forwards;
        }
        .legendary-overlay.active .legendary-card:nth-child(2) {
            animation: legendaryCardEnter 0.5s ease-out 0.35s forwards;
        }
        .legendary-overlay.active .legendary-card:nth-child(3) {
            animation: legendaryCardEnter 0.5s ease-out 0.45s forwards;
        }
        
        @keyframes legendaryCardEnter {
            0% {
                opacity: 0;
                transform: translateY(40px) scale(0.85) translateZ(0);
            }
            60% {
                transform: translateY(-5px) scale(1.02) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) translateZ(0);
            }
        }

        .legendary-card:hover {
            transform: scale(1.08) translateZ(0);
        }

        .legendary-icon {
            font-size: 36px;
        }

        .legendary-name {
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        }

        .legendary-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }

        .legendary-effect {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-style: italic;
        }

        @media (max-width: 500px) {
            .legendary-title { font-size: 24px; margin-bottom: 6px; }
            .legendary-subtitle { font-size: 13px; margin-bottom: 20px; }
            .legendary-options { gap: 10px; }
            .legendary-card { width: 100px; padding: 14px 10px; gap: 6px; }
            .legendary-icon { font-size: 28px; }
            .legendary-name { font-size: 11px; }
            .legendary-desc { font-size: 9px; }
            .legendary-effect { font-size: 8px; }
            
            .chest-title { font-size: 22px; }
            .chest-cost { font-size: 14px; }
            .chest-card { width: 100px; padding: 14px 10px; gap: 6px; }
            .chest-card .icon { font-size: 28px; }
            .chest-card .name { font-size: 11px; }
            .chest-card .value { font-size: 9px; }
        }

        /* Shrine charge indicator */
        .shrine-charge-bar {
            display: none !important;
        }

        .shrine-charge-bar.active {
            display: none !important;
        }

        .shrine-charge-fill {
            display: none;
        }

        .shrine-charge-text {
            display: none;
        }

        /* Starting Bonus Overlay */
        .starting-bonus-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 650;
        }
        
        .starting-bonus-overlay.active {
            display: flex;
        }
        
        .starting-bonus-title {
            font-size: 32px;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #ff00ff;
            margin-bottom: 10px;
            letter-spacing: 3px;
            animation: startingPulse 2s ease-in-out infinite;
        }
        
        @keyframes startingPulse {
            0%, 100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #ff00ff; }
            50% { text-shadow: 0 0 40px #00ffff, 0 0 80px #ff00ff; }
        }
        
        .starting-bonus-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
        }
        
        .starting-bonus-card {
            width: 180px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #888;
            border-radius: 12px;
            text-align: center;
            transform: scale(0);
            opacity: 0;
            transition: all 0.4s ease-out;
        }
        
        .starting-bonus-card.revealed {
            transform: scale(1);
            opacity: 1;
        }
        
        .starting-bonus-card .rarity {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }
        
        .starting-bonus-card .icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .starting-bonus-card .name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 6px;
        }
        
        .starting-bonus-card .desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .starting-bonus-counter {
            font-size: 18px;
            color: #ffaa00;
            margin-top: 20px;
        }

        /* Start/Game Over Screen */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
            touch-action: manipulation;
        }

        .menu-overlay.hidden {
            display: none;
            pointer-events: none;
        }

        .game-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 30px #39ff14, 0 0 60px #39ff14;
            margin-bottom: 10px;
            letter-spacing: 4px;
        }

        .game-subtitle {
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-bottom: 40px;
        }

        .menu-btn {
            padding: 10px 20px;
            width: 160px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            touch-action: manipulation;
        }

        .menu-btn:hover {
            background: #0ff;
            color: #000;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        .menu-btn.btn-tutorial {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 8px #f0f;
        }
        
        .menu-btn.btn-tutorial:hover {
            background: #f0f;
            color: #000;
        }
        
        .menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }
        
        .menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
        }

        .final-stats {
            color: #fff;
            text-align: center;
            margin: 20px 0;
            font-size: 18px;
            line-height: 2;
        }

        .final-stats span {
            color: #39ff9f;
            font-weight: bold;
        }

        /* ========== UNIFIED TRACKPAD ZONE ========== */
        /* Contains: active buffs + spacer + instructions */
        .trackpad-zone {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            /* Height set by JavaScript in fullscreen mode */
            height: auto;
            min-height: 80px;
            flex: 0 0 auto;
            padding: 2px calc(4px * var(--scale, 1)) calc(15px * var(--scale, 1)) calc(4px * var(--scale, 1));
            box-sizing: border-box;
            /* Touch control */
            touch-action: none;
            pointer-events: auto;
            /* Visual styling */
            border-top: 1px solid rgba(0, 255, 255, 0.15);
            background: linear-gradient(to bottom, rgba(0, 255, 255, 0.06), transparent);
            border-radius: 0 0 5px 5px;
            /* Needed for joystick positioning */
            position: relative;
        }
        
        /* Active buffs display - removed, stats now in stat panels */
        .active-buffs {
            display: none;
        }
        
        /* Always show divider lines even when empty */
        .active-buffs-wrapper {
            display: none;
        }
        
        /* Power-up timer bar at top of screen */
        .power-timer-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            display: flex;
            z-index: 150;
            pointer-events: none;
        }
        
        .power-timer {
            height: 100%;
            transition: width 0.1s linear;
        }
        
        .power-timer.speed-boost {
            background: linear-gradient(90deg, #39ff14, #7fff00);
            box-shadow: 0 0 8px #39ff14;
        }
        
        .power-timer.time-stop {
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 8px #00ffff;
        }
        
        .power-timer.time-slow {
            background: linear-gradient(90deg, #ff00ff, #8800ff);
            box-shadow: 0 0 8px #ff00ff;
        }
        
        .buff-item {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 44px;
            height: 44px;
        }
        
        .buff-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 4px currentColor);
        }
        
        .buff-stack {
            position: absolute;
            bottom: 0px;
            right: -2px;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 4px #000, 0 0 4px #000;
        }
        
        /* Stats timers container - at very top */
        .stats-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding-top: 0;
        }
        
        /* Minimap wrapper in trackpad - centered in main row */
        .trackpad-minimap-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            height: 100%;
        }
        
        /* Minimap wrapper for centering */
        .minimap-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            flex-shrink: 0;
        }
        
        /* Minimap container - hidden, now in trackpad */
        .minimap-container {
            display: none;
        }
        
        /* XP bar - hidden on canvas, shown in trackpad */
        .game-xp-bar {
            display: none;
        }
        
        .game-xp-fill {
            height: 100%;
            background: #a8b8c8;
            box-shadow: 0 0 4px rgba(168, 184, 200, 0.5);
            transition: width 0.15s;
        }
        
        /* Minimap canvas in trackpad */
        .minimap-canvas {
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            flex-shrink: 0;
            aspect-ratio: 1;
            height: 100%;
            width: auto !important;
        }
        
        .stats-display span {
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            height: 17px;
            min-height: 17px;
            max-height: 17px;
            line-height: 17px;
            font-size: 15px;
            padding: 0 8px;
            background: transparent;
            border-radius: 3px;
            box-sizing: border-box;
            pointer-events: none;
            flex-shrink: 0;
        }
        
        /* Spacer - minimal space before instructions */
        .trackpad-spacer {
            flex: 0 0 auto;
            min-height: 2px;
            height: 2px;
            width: 100%;
            pointer-events: none;
        }
        
        /* Instructions at bottom of trackpad */
        .trackpad-instructions {
            position: absolute;
            bottom: calc(2px * var(--scale, 1));
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: calc(18px * var(--scale, 1));
            width: 100%;
            padding-top: calc(2px * var(--scale, 1));
            font-size: calc(11px * var(--scale, 1));
            color: rgba(0, 255, 255, 0.7);
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            pointer-events: none;
            box-sizing: border-box;
        }
        
        /* Dynamic joystick overlay */
        .joystick-overlay {
            position: absolute;
            width: calc(120px * var(--scale, 1));
            height: calc(120px * var(--scale, 1));
            border: calc(2px * var(--scale, 1)) solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
            display: none;
            z-index: 300;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .joystick-overlay.active {
            display: block;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #0ff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #0ff;
            pointer-events: none;
        }

        /* Timer display - part of bottom bar now */
        .timer {
            font-size: 16px;
            color: #fff;
            text-shadow: 0 0 12px #0ff;
            letter-spacing: 1px;
        }

        /* Kill counter - part of top bar now */
        .kills {
            font-size: 12px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }

        .kills span {
            color: #fff;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 600px) {
            /* Align game to top on mobile for faux fullscreen */
            html, body {
                align-items: flex-start;
                justify-content: flex-start;
                padding: 0;
                margin: 0;
            }
            
            /* But center when in actual fullscreen mode */
            body:has(.fullscreen-mode) {
                align-items: center !important;
                justify-content: center !important;
            }
            
            .game-container {
                margin: 0;
                padding: 3px;
                gap: 2px;
            }
            
            .hud .hp-bar { width: 160px; height: 8px; }
            .hud .xp-bar { width: 110px; height: 6px; }
            .hud { font-size: 8px; gap: 3px; }
            .timer { font-size: 12px; }
            .kills { font-size: 8px; }
            .weapon-icon { width: 24px; height: 24px; font-size: 12px; }
            .weapons-display { max-width: 100px; gap: 3px; }
            
            /* Show minimap in trackpad on mobile (smaller) */
            .trackpad-minimap-wrapper {
                display: flex !important;
                height: 100%;
            }
            
            .trackpad-minimap-wrapper .minimap-canvas {
                width: auto !important;
                height: 100% !important;
                aspect-ratio: 1;
            }
            
            /* Scale stat panels for mobile - fill available height */
            .stat-panel {
                width: 110px;
                min-width: 110px;
                max-width: 110px;
                height: 100%;
                min-height: unset;
                max-height: unset;
                padding: 6px 6px 8px 6px;
                gap: 0;
                border-width: 1px;
                border-radius: 5px;
                justify-content: space-between;
            }
            
            .stat-panel-title {
                font-size: 10px;
                letter-spacing: 1px;
                padding-bottom: 4px;
                margin-bottom: 0;
            }
            
            .stat-row {
                font-size: 10px;
                padding: 2px 0;
                line-height: 1.4;
            }
            
            /* Use abbreviated labels on mobile */
            .stat-label {
                font-size: 0;
                letter-spacing: 0;
            }
            
            .stat-label::before {
                content: attr(data-short);
                font-size: 8px;
            }
            
            .stat-value {
                font-size: 10px;
            }
            
            /* Scale weapons and tomes for mobile */
            .weapons-bar, .tomes-bar {
                max-height: 145px;
                width: 40px;
                min-width: 40px;
                max-width: 40px;
                padding: 2px;
                gap: 2px;
            }
            
            .weapon-icon, .tome-icon {
                width: 16px;
                height: 16px;
                border-width: 1px;
            }
            
            .weapon-icon span {
                font-size: 9px;
            }
            
            .tome-icon .tome-base {
                font-size: 10px;
            }
            
            .tome-icon .tome-effect {
                font-size: 6px;
            }
            
            .weapon-level, .tome-level {
                font-size: 5px;
                padding: 0 1px;
            }
            
            /* Compact trackpad zone */
            .trackpad-zone {
                min-height: 72px;
                padding: 4px 4px 4px 4px;
            }
            
            .trackpad-main-row {
                gap: 0;
                align-items: center;
            }
            
            /* Mobile zone sizing - still fill width */
            .stat-zone-left, .stat-zone-right {
                width: auto;
                flex: 1 1 0;
            }
            
            .center-content {
                width: auto;
                flex-shrink: 0;
            }
            
            .trackpad-spacer {
                min-height: 4px;
            }
            
            .trackpad-instructions {
                height: 18px;
                min-height: 18px;
                font-size: 8px;
                white-space: nowrap;
            }
            
            /* Stats display row */
            .stats-display {
                padding: 4px 8px !important;
            }
            
            /* Compact bottom bar */
            .bottom-bar {
                padding: 0 2px;
            }
            
            .bottom-hp-bar {
                width: 120px;
            }
            
            .game-level-indicator {
                font-size: 9px;
                margin-top: 3px;
            }
            
            /* Mobile title sizing */
            .game-title {
                font-size: 28px;
                letter-spacing: 4px;
                text-align: center;
                width: 100%;
                padding: 0 10px;
                box-sizing: border-box;
                line-height: 1.2;
            }
            
            .game-subtitle {
                margin-bottom: 40px;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 400px) {
            .trackpad-zone {
                min-height: 36px;
            }
            
            .bottom-hp-bar {
                width: 100px;
            }
            
            .timer { font-size: 10px; }
            .kills { font-size: 7px; }
            
            /* Even smaller stat panels - fill height */
            .stat-panel {
                width: 90px;
                min-width: 90px;
                max-width: 90px;
                height: 100%;
                min-height: unset;
                max-height: unset;
                padding: 4px 4px 6px 4px;
                gap: 0;
                justify-content: space-between;
            }
            
            .stat-panel-title {
                font-size: 8px;
            }
            
            .stat-label::before {
                font-size: 6px;
            }
            
            .stat-value {
                font-size: 8px;
            }
            
            /* Smaller minimap - fill height */
            .trackpad-minimap-wrapper .minimap-canvas {
                width: auto !important;
                height: 100% !important;
                aspect-ratio: 1;
            }
            
            /* Smaller weapons/tomes */
            .weapons-bar, .tomes-bar {
                max-height: 110px;
                width: 32px;
                min-width: 32px;
                max-width: 32px;
            }
            
            .weapon-icon, .tome-icon {
                width: 14px;
                height: 14px;
            }
            
            .weapon-icon span {
                font-size: 8px;
            }
        }
        
        /* ========== SCORE MODAL ========== */
        .score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        /* GPU-accelerated flash overlay */
        .score-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 255, 0.5);
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        .score-modal.active::before {
            animation: flashFadeOut 0.7s ease-out forwards;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-title {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 38px;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 40px #ff1493;
            text-align: center;
            margin-bottom: 0;
            opacity: 0;
            transform: scale(0.5) translateY(-30px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .score-modal.active .score-modal-title {
            animation: scoreTitleEnter 0.8s ease-out 0.2s forwards;
        }
        
        @keyframes scoreTitleEnter {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-30px) translateZ(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.15) translateY(0) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0) translateZ(0);
            }
        }
        
        .score-modal-score {
            font-size: 26px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            text-align: center;
            margin-top: -4px;
            opacity: 0;
            transform: translateY(-15px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .score-modal.active .score-modal-score {
            animation: scoreValueEnter 0.5s ease-out 0.5s forwards;
        }
        
        @keyframes scoreValueEnter {
            0% { opacity: 0; transform: translateY(-15px) translateZ(0); }
            100% { opacity: 1; transform: translateY(0) translateZ(0); }
        }
        
        .score-modal-level {
            font-size: 18px;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            text-align: center;
            margin-top: -8px;
            opacity: 0;
            transform: translateY(-15px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .score-modal.active .score-modal-level {
            animation: scoreValueEnter 0.5s ease-out 0.6s forwards;
        }
        
        .score-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
            opacity: 0;
            transform: translateY(20px) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .score-modal.active .score-input-container {
            animation: scoreInputEnter 0.5s ease-out 0.7s forwards;
        }
        
        @keyframes scoreInputEnter {
            0% { opacity: 0; transform: translateY(20px) translateZ(0); }
            100% { opacity: 1; transform: translateY(0) translateZ(0); }
        }
        
        .score-input-label {
            font-size: 14px;
            color: #fff;
            opacity: 0.9;
        }
        
        .score-input {
            width: 200px;
            padding: 10px 14px;
            font-size: 16px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }
        
        .score-input:focus {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-input.error {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.15);
            animation: inputShake 0.4s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }
        
        .score-error-msg {
            font-size: 12px;
            color: #ff3366;
            text-shadow: 0 0 8px #ff3366;
            min-height: 16px;
            text-align: center;
        }
        
        .score-buttons {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }
        
        .score-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 2px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            background: transparent;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .score-btn:active {
            transform: scale(0.98);
        }
        
        .score-btn-submit {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 255, 0.2));
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .score-btn-submit:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }
        
        .score-btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .score-btn-skip {
            background: rgba(255, 255, 255, 0.05);
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #aaa;
        }
        
        /* ========== LEADERBOARD OVERLAY ========== */
        .leaderboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        /* GPU-accelerated flash overlay */
        .leaderboard-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 170, 0, 0.4);
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        .leaderboard-overlay.active::before {
            animation: flashFadeOut 0.5s ease-out forwards;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            width: 100%;
            max-width: 450px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
            opacity: 0;
            transform: translateY(20px) scale(0.95) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .leaderboard-overlay.active .leaderboard-container {
            animation: leaderboardContainerEnter 0.5s ease-out 0.15s forwards;
        }
        
        @keyframes leaderboardContainerEnter {
            0% {
                opacity: 0;
                transform: translateY(20px) scale(0.95) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) translateZ(0);
            }
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .leaderboard-title {
            font-size: 28px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
        }
        
        .leaderboard-close {
            width: 44px;
            height: 44px;
            background: rgba(255, 51, 102, 0.1);
            border: 2px solid #ff3366;
            border-radius: 8px;
            color: #ff3366;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s, color 0.2s, background 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            box-shadow: 0 0 8px #ff3366;
        }
        
        .leaderboard-close:hover {
            background: #ff3366;
            color: #000;
            box-shadow: 0 0 20px #ff3366;
        }
        
        .leaderboard-close:active {
            transform: scale(0.95) translateZ(0);
            background: #ff3366;
            color: #000;
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 10px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 4px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .leaderboard-row.top-3 {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.15), rgba(0, 255, 255, 0.1));
            border: 1px solid rgba(255, 0, 255, 0.3);
        }
        
        .leaderboard-rank {
            width: 40px;
            font-size: 16px;
            font-weight: bold;
            color: #888;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            color: #f0f;
            text-shadow: 0 0 8px #f0f;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .leaderboard-score {
            font-size: 16px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            min-width: 70px;
            text-align: right;
        }
        
        .leaderboard-level {
            font-size: 12px;
            color: #ffaa00;
            text-shadow: 0 0 6px #ff6600;
            min-width: 45px;
            text-align: right;
            margin-left: 10px;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 16px;
        }
        
        .leaderboard-loading {
            color: #0ff;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
        
        /* Leaderboard button */
        
        
        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 700;
            padding: 20px;
            box-sizing: border-box;
        }
        
        /* GPU-accelerated flash overlay */
        .tutorial-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 255, 0.4);
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            backface-visibility: hidden;
        }
        
        .tutorial-overlay.active::before {
            animation: flashFadeOut 0.5s ease-out forwards;
        }
        
        .tutorial-overlay.active {
            display: flex;
        }
        
        .tutorial-container {
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(10, 10, 30, 0.98));
            border: 2px solid #0ff;
            border-radius: 15px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            opacity: 0;
            transform: translateY(30px) scale(0.95) translateZ(0);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        
        .tutorial-overlay.active .tutorial-container {
            animation: tutorialContainerEnter 0.5s ease-out 0.1s forwards;
        }
        
        @keyframes tutorialContainerEnter {
            0% {
                opacity: 0;
                transform: translateY(30px) scale(0.95) translateZ(0);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) translateZ(0);
            }
        }
        
        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-title {
            font-size: 24px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            letter-spacing: 2px;
        }
        
        .tutorial-close {
            background: transparent;
            border: 2px solid #ff6666;
            color: #ff6666;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s, color 0.2s;
        }
        
        .tutorial-close:hover {
            background: #ff6666;
            color: #fff;
        }
        
        .tutorial-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .tutorial-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .tutorial-content::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 3px;
        }
        
        .tutorial-step {
            display: none;
            animation: tutorialFadeIn 0.3s ease-out;
        }
        
        .tutorial-step.active {
            display: block;
        }
        
        @keyframes tutorialFadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .tutorial-step-title {
            font-size: 20px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .tutorial-step-content {
            color: #ddd;
            font-size: 14px;
            line-height: 1.7;
        }
        
        .tutorial-step-content p {
            margin-bottom: 12px;
        }
        
        .tutorial-step-content ul {
            margin: 10px 0 15px 20px;
            list-style: none;
        }
        
        .tutorial-step-content ul li {
            margin-bottom: 8px;
            position: relative;
            padding-left: 5px;
        }
        
        .tutorial-step-content ul li::before {
            content: '▸';
            color: #0ff;
            position: absolute;
            left: -15px;
        }
        
        .tutorial-step-content .key {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            color: #0ff;
        }
        
        .tutorial-step-content .highlight {
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .tutorial-step-content .highlight.weapon { background: rgba(0, 255, 255, 0.2); color: #0ff; }
        .tutorial-step-content .highlight.passive { background: rgba(0, 255, 204, 0.2); color: #00ffcc; }
        .tutorial-step-content .highlight.tome { background: rgba(255, 102, 102, 0.2); color: #ff6666; }
        .tutorial-step-content .highlight.shrine { background: rgba(224, 64, 255, 0.2); color: #e040ff; }
        .tutorial-step-content .highlight.chest { background: rgba(255, 215, 0, 0.2); color: #ffd700; }
        .tutorial-step-content .highlight.swarm { background: rgba(255, 68, 68, 0.2); color: #ff4444; }
        .tutorial-step-content .highlight.crit { background: rgba(255, 68, 102, 0.2); color: #ff4466; }
        .tutorial-step-content .highlight.xp { background: rgba(102, 255, 102, 0.2); color: #66ff66; }
        .tutorial-step-content .highlight.speed { background: rgba(102, 153, 255, 0.2); color: #6699ff; }
        .tutorial-step-content .highlight.power { background: rgba(255, 153, 51, 0.2); color: #ff9933; }
        .tutorial-step-content .highlight.haste { background: rgba(204, 102, 255, 0.2); color: #cc66ff; }
        
        .tutorial-step-content .xp-gem {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }
        
        .tutorial-step-content .gold {
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700;
        }
        
        .tutorial-step-content .tip {
            background: rgba(255, 255, 0, 0.1);
            border-left: 3px solid #ffff00;
            padding: 8px 12px;
            margin-top: 15px;
            font-style: italic;
            color: #ffff99;
        }
        
        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-nav-btn {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tutorial-nav-btn:hover {
            background: rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tutorial-dots {
            display: flex;
            gap: 8px;
        }
        
        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 1px solid #0ff;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-dot.active {
            background: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        
        .tutorial-dot:hover {
            background: rgba(0, 255, 255, 0.6);
        }
        
        @media (max-width: 500px) {
            /* Mobile: Tutorial */
            .tutorial-container {
                padding: 15px;
                max-height: 90vh;
            }
            .tutorial-title {
                font-size: 18px;
            }
            .tutorial-step-title {
                font-size: 16px;
            }
            .tutorial-step-content {
                font-size: 13px;
                line-height: 1.6;
            }
            .tutorial-step-content ul {
                margin-left: 15px;
            }
            .tutorial-nav-btn {
                padding: 8px 14px;
                font-size: 12px;
            }
            .tutorial-close {
                width: 30px;
                height: 30px;
                font-size: 16px;
            }
            
            .score-modal-title { font-size: 32px; }
            .score-modal-score { font-size: 22px; }
            .score-modal-level { font-size: 16px; }
            .score-input { width: 180px; font-size: 16px; }
            .score-btn { padding: 10px 20px; font-size: 14px; }
            .leaderboard-title { font-size: 24px; }
            .leaderboard-row { padding: 8px 10px; }
            .leaderboard-name { font-size: 13px; }
            .leaderboard-score { font-size: 14px; min-width: 60px; }
            .leaderboard-level { font-size: 11px; min-width: 40px; }
            
            /* Mobile: Weapon icons - smaller and constrained */
            .weapons-display {
                max-width: 100px;
                gap: 3px;
            }
            .weapon-icon {
                width: 22px;
                height: 22px;
                font-size: 12px;
                border-width: 1.5px;
            }
            .weapon-level {
                font-size: 7px;
                padding: 0px 2px;
                bottom: -1px;
                right: -1px;
            }
            
            /* Mobile: Tome icons - smaller and constrained */
            .tome-icon {
                width: 22px;
                height: 22px;
                font-size: 12px;
                border-width: 1.5px;
            }
            .tome-icon .tome-base {
                font-size: 16px;
            }
            .tome-icon .tome-effect {
                font-size: 9px;
            }
            .tome-level {
                font-size: 7px;
                padding: 0px 2px;
                bottom: -1px;
                right: -1px;
            }
            
            /* Mobile: Weapons bar */
            .weapons-bar {
                gap: 3px;
                width: 50px;
                min-width: 50px;
                max-width: 50px;
                max-height: 100px;
            }
            
            /* Mobile: Tomes bar */
            .tomes-bar {
                gap: 3px;
                width: 50px;
                min-width: 50px;
                max-width: 50px;
                max-height: 100px;
            }
            .weapon-icon {
                width: 24px;
                height: 24px;
            }
            .hud-stats-row {
                width: 100px;
                margin-bottom: 4px;
            }
            .hud-hp-bar {
                width: 100px;
                height: 10px;
                margin-bottom: 6px;
            }
            .hud-stat {
                font-size: 8px;
            }
            
            /* Mobile: Minimap smaller */
            .minimap-container {
                top: 14px;
                right: 4px;
            }
            .minimap-canvas {
                width: 90px !important;
                height: 90px !important;
            }
            
            /* Mobile: Upgrade overlay */
            .upgrade-title {
                font-size: 22px;
                margin-bottom: 8px;
                letter-spacing: 2px;
            }
            .upgrade-subtitle {
                font-size: 13px;
                margin-bottom: 15px;
            }
            .upgrade-slot-machine {
                gap: 8px;
                margin-bottom: 15px;
            }
            .upgrade-slot-machine .slot-reel {
                width: 50px;
                min-width: 50px;
                max-width: 50px;
                height: 50px;
                min-height: 50px;
                max-height: 50px;
                border-radius: 50%;
                border-width: 2px;
            }
            .upgrade-slot-machine .slot-content {
                padding: 0;
                gap: 0;
            }
            .upgrade-slot-machine .slot-icon {
                font-size: 24px;
                height: auto;
                min-height: auto;
            }
            .upgrade-slot-machine .slot-name,
            .upgrade-slot-machine .slot-value {
                display: none;
            }
            .upgrade-options {
                gap: 10px;
            }
            .upgrade-card {
                width: 105px;
                padding: 12px 8px;
                gap: 6px;
                border-radius: 8px;
            }
            .upgrade-card .icon {
                font-size: 28px;
            }
            .upgrade-card .name {
                font-size: 11px;
            }
            .upgrade-card .desc {
                font-size: 9px;
            }
            
            /* Mobile: Shrine overlay */
            .shrine-title {
                font-size: 22px;
                margin-bottom: 8px;
                letter-spacing: 2px;
            }
            .shrine-subtitle {
                font-size: 13px;
                margin-bottom: 15px;
            }
            .slot-machine {
                gap: 8px;
                margin-bottom: 15px;
            }
            .slot-reel {
                width: 50px;
                min-width: 50px;
                max-width: 50px;
                height: 50px;
                min-height: 50px;
                max-height: 50px;
                border-radius: 50%;
                border-width: 2px;
            }
            .slot-content {
                padding: 0;
                gap: 0;
            }
            .slot-icon {
                font-size: 24px;
                height: auto;
                min-height: auto;
            }
            .slot-name,
            .slot-value {
                display: none;
            }
            .shrine-options {
                gap: 10px;
            }
            .shrine-card {
                width: 105px;
                padding: 18px 8px;
                gap: 10px;
                border-radius: 8px;
            }
            .shrine-card .icon {
                font-size: 28px;
            }
            .shrine-card .name {
                font-size: 11px;
            }
            .shrine-card .value {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="640" height="626"></canvas>
        
        <!-- Pause button -->
        <div class="pause-btn" id="pauseBtn" title="Pause (P)">⏸</div>
        
        <!-- Power-up timer bar -->
        <div class="power-timer-bar" id="powerTimerBar">
            <div class="power-timer speed-boost" id="speedBoostTimer" style="width: 0%;"></div>
            <div class="power-timer time-stop" id="timeStopTimer" style="width: 0%;"></div>
            <div class="power-timer time-slow" id="timeSlowTimer" style="width: 0%;"></div>
        </div>
        
        <!-- Minimap - top-right of game area -->
        <div class="minimap-container">
            <canvas id="minimapCanvas" class="minimap-canvas" width="156" height="156"></canvas>
        </div>
        
        <!-- Shrine Charge Bar -->
        <div class="shrine-charge-bar" id="shrineChargeBar">
            <div class="shrine-charge-fill" id="shrineChargeFill"></div>
            <div class="shrine-charge-text">CHANNELING...</div>
        </div>
        
        <!-- Hidden stats elements for code references -->
        <div style="display:none;">
            <span id="timer">0:00</span>
            <span id="killCount">0</span>
            <span id="goldCount">0</span>
            <span id="levelDisplay">1</span>
            <div id="trackpadHpFill"></div>
        </div>
        
        <!-- XP bar at top -->
        <div class="game-xp-bar">
            <div class="game-xp-fill" id="trackpadXpFill"></div>
        </div>

        <!-- Trackpad Zone -->
        <div class="trackpad-zone" id="trackpadZone">
            <div class="stats-display" id="statsDisplay">
                <div class="xp-bar-container" style="width: calc(100% - 1px); margin: 0 auto 4px auto; height: 5px; border: 1px solid #0ff; border-radius: 3px; overflow: hidden; background: transparent;">
                    <div class="xp-bar-fill" style="height: 100%; width: 0%; background: #a8b8c8; box-shadow: 0 0 4px rgba(168, 184, 200, 0.5); transition: width 0.25s ease-out;"></div>
                </div>
                <div class="stats-row-container" style="display: flex; align-items: center; justify-content: space-evenly; width: calc(100% + 24px); margin: 0 -12px 2px -12px;">
                    <span style="color: #fff; text-shadow: 0 0 4px #0ff; padding-right: 14px;">0:00</span>
                    <span style="color: #0ff; text-shadow: 0 0 4px #0ff; padding-right: 14px;">0 Kills</span>
                    <div style="width: 300px; max-width: 50vw; height: 22px; border: 1px solid #39ff9f; border-radius: 3px; overflow: hidden; background: transparent; white-space: nowrap; font-size: 0;">
                        <div style="height: 100%; width: 100%; display: inline-block; background: rgba(255, 0, 0, 0.3); position: relative; vertical-align: top;">
                            <div style="height: 100%; width: 100%; background: linear-gradient(90deg, #39ff9f, #00ff66); box-shadow: 0 0 6px #39ff9f;"></div>
                            <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; font-weight: bold; color: #fff; text-shadow: 0 0 3px #000, 0 0 3px #000; white-space: nowrap; pointer-events: none;">120</span>
                        </div>
                    </div>
                    <span style="color: #ffd700; text-shadow: 0 0 4px #ffd700; padding-left: 14px;">🪙0</span>
                    <span style="color: #0ff; text-shadow: 0 0 4px #0ff; padding-left: 14px;">Level 1</span>
                </div>
            </div>
            <div class="trackpad-main-row">
                <div class="stat-zone-left">
                    <div class="stat-panel stat-panel-left" id="offensiveStats">
                        <div class="stat-panel-title">⚔️ OFFENSE</div>
                        <div class="stat-row"><span class="stat-label" data-short="DMG">DAMAGE</span><span class="stat-value" id="statDamage">100%</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="ATK SPD">ATTACK SPEED</span><span class="stat-value" id="statAtkSpeed">100%</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="CRIT %">CRIT CHANCE</span><span class="stat-value" id="statCritChance">5%</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="CRIT ×">CRIT DAMAGE</span><span class="stat-value" id="statCritMult">2.0×</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="PICKUP">PICKUP RANGE</span><span class="stat-value" id="statPickup">100%</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="LUCK">LUCK</span><span class="stat-value" id="statLuck">0%</span></div>
                    </div>
                    <div class="weapons-bar" id="weaponsDisplay"></div>
                </div>
                <div class="center-content">
                    <div class="trackpad-minimap-wrapper" id="trackpadMinimapWrapper"></div>
                </div>
                <div class="stat-zone-right">
                    <div class="tomes-bar" id="tomesDisplay"></div>
                    <div class="stat-panel stat-panel-right" id="defensiveStats">
                        <div class="stat-panel-title">🛡️ DEFENSE</div>
                        <div class="stat-row"><span class="stat-label" data-short="MAX HP">MAX HP</span><span class="stat-value" id="statMaxHp">120</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="REGEN">HP REGEN</span><span class="stat-value" id="statRegen">1.5/s</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="HP STL">LIFESTEAL</span><span class="stat-value" id="statLifesteal">0%</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="ARMOR">ARMOR</span><span class="stat-value" id="statArmor">0%</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="SHIELD">SHIELD</span><span class="stat-value" id="statShield">0</span></div>
                        <div class="stat-row"><span class="stat-label" data-short="SPEED">MOVE SPEED</span><span class="stat-value" id="statSpeed">100%</span></div>
                    </div>
                </div>
            </div>
            <div class="trackpad-spacer">&nbsp;</div>
            <div class="trackpad-instructions">
                ← TOUCH AND DRAG OR WASD/ARROWS TO MOVE →
            </div>
            <div class="active-buffs-wrapper">
                <div class="active-buffs" id="activeBuffsBar"></div>
            </div>
            <!-- Dynamic joystick -->
            <div class="joystick-overlay" id="joystickOverlay">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
        </div>
    </div>
    
    <!-- Upgrade Selection - OUTSIDE game-container for touch events -->
    <div class="upgrade-overlay" id="upgradeOverlay">
        <div class="upgrade-title">✨ LEVEL UP! ✨</div>
        <div class="upgrade-subtitle">Choose your upgrade</div>
        <div class="upgrade-slot-machine" id="upgradeSlotMachine"></div>
        <div class="upgrade-options" id="upgradeOptions"></div>
    </div>

    <!-- Shrine Power-up Selection - OUTSIDE game-container for touch events -->
    <div class="shrine-overlay" id="shrineOverlay">
        <div class="shrine-title">✨ SHRINE ACTIVATED ✨</div>
        <div class="shrine-subtitle">Choose your blessing</div>
        <div class="slot-machine" id="slotMachine"></div>
        <div class="shrine-options" id="shrineOptions"></div>
    </div>

    <!-- Chest Modal - Rebuilt from scratch using divs only -->
    <div id="chestModal" ontouchstart="event.stopPropagation();" ontouchmove="event.stopPropagation();" ontouchend="event.stopPropagation();">
        <div class="modal-title" id="modalTitle">📦 TREASURE FOUND! 📦</div>
        <div class="modal-cost" id="modalCost"></div>
        <div class="chest-slot-reel" id="chestSlotReel">
            <div class="slot-content">
                <div class="slot-icon">❓</div>
                <div class="slot-name">???</div>
            </div>
        </div>
        <div class="modal-card" id="modalCard">
            <div class="card-icon" id="modalIcon"></div>
            <div class="card-name" id="modalName"></div>
            <div class="card-desc" id="modalDesc"></div>
        </div>
        <div class="modal-buttons" style="touch-action: auto;">
            <div id="modalTake" class="modal-btn btn-take" onclick="window.chestTake();" ontouchstart="event.stopPropagation();" ontouchend="event.preventDefault(); event.stopPropagation(); window.chestTake();">TAKE</div>
            <div id="modalLeave" class="modal-btn btn-leave" onclick="window.leaveChest();" ontouchstart="event.stopPropagation();" ontouchend="event.preventDefault(); event.stopPropagation(); window.leaveChest();">LEAVE</div>
        </div>
    </div>

    <!-- Tombstone Modal -->
    <div id="tombstoneModal" ontouchstart="event.stopPropagation();" ontouchmove="event.stopPropagation();" ontouchend="event.stopPropagation();">
        <div class="tombstone-title">⚰️ FALLEN WARRIOR ⚰️</div>
        <div class="tombstone-name" id="tombstoneName">R.I.P.</div>
        <div class="tombstone-desc">Your friend fell in battle here.<br>Avenge them by facing more bosses?</div>
        <div class="tombstone-warning">⚠️ Extra boss will spawn with every boss wave!</div>
        <div class="modal-buttons" style="touch-action: auto;">
            <div class="tombstone-btn tombstone-accept" onclick="window.acceptTombstoneOffer();" ontouchstart="event.stopPropagation();" ontouchend="event.preventDefault(); event.stopPropagation(); window.acceptTombstoneOffer();">AVENGE</div>
            <div class="tombstone-btn tombstone-decline" onclick="window.declineTombstoneOffer();" ontouchstart="event.stopPropagation();" ontouchend="event.preventDefault(); event.stopPropagation(); window.declineTombstoneOffer();">LEAVE</div>
        </div>
    </div>

    <!-- Skull Statue Modal -->
    <div id="skullStatueModal" ontouchstart="event.stopPropagation();" ontouchmove="event.stopPropagation();" ontouchend="event.stopPropagation();">
        <div class="statue-title">CURSED STATUE</div>
        <div class="statue-level" id="statueLevel">Difficulty: +0%</div>
        <div class="statue-desc">Embrace the curse for greater rewards?</div>
        <div class="statue-effects">
            <div class="statue-bad">Enemies: +10% DMG/HP, +5% Speed</div>
            <div class="statue-good">Rewards: +10% XP & Gold per kill</div>
        </div>
        <div class="modal-buttons" style="touch-action: auto;">
            <div class="statue-btn statue-accept" onclick="window.acceptStatueOffer();" ontouchstart="event.stopPropagation();" ontouchend="event.preventDefault(); event.stopPropagation(); window.acceptStatueOffer();">ACCEPT CURSE</div>
            <div class="statue-btn statue-decline" onclick="window.declineStatueOffer();" ontouchstart="event.stopPropagation();" ontouchend="event.preventDefault(); event.stopPropagation(); window.declineStatueOffer();">LEAVE</div>
        </div>
    </div>

    <!-- Start/Game Over Menu -->
    <div class="menu-overlay" id="menuOverlay">
        <div class="game-title">BOO SURVIVORS</div>
        <div class="game-subtitle">Survive the neon horde</div>
        <div class="menu-buttons">
            <button class="menu-btn" id="startBtn">START GAME</button>
            <button class="menu-btn btn-tutorial" id="tutorialBtn">HOW TO PLAY</button>
            <button class="menu-btn btn-leaderboard" id="leaderboardBtn">LEADER BOARD</button>
        </div>
        <div class="final-stats" id="finalStats" style="display: none;"></div>
    </div>
    
    <!-- Weapon Select Overlay -->
    <div class="weapon-select-overlay" id="weaponSelectOverlay">
        <div class="weapon-select-content">
            <div class="weapon-select-title">⚔️ Choose Your Weapon ⚔️</div>
            <div class="weapon-select-subtitle">Select a starting weapon</div>
            <div class="weapon-select-grid" id="weaponSelectGrid"></div>
            <div class="weapon-select-desc" id="weaponSelectDesc"></div>
            <div class="color-selector">
                <div class="color-selector-title">Player Color</div>
                <div class="color-selector-grid" id="colorSelectorGrid"></div>
            </div>
            <div class="weapon-select-buttons">
                <div class="weapon-select-btn btn-back" id="weaponBackBtn">← BACK</div>
                <div class="weapon-select-btn btn-confirm" id="weaponConfirmBtn">CONFIRM →</div>
            </div>
        </div>
    </div>
    
    <!-- Tome Editor Overlay -->
    <div class="tome-editor-overlay" id="tomeEditorOverlay">
        <div class="tome-editor-content">
            <div class="tome-editor-title">Edit Tomes</div>
            <div class="tome-editor-subtitle">Choose which tomes will be offered as upgrades</div>
            <div class="tome-mode-toggle">
                <button class="tome-mode-btn active" id="tomeModeBtn">Edit</button>
                <span class="tome-disabled-count" id="tomeDisabledCount">(0/3 disabled)</span>
            </div>
            <div class="tome-editor-grid" id="tomeEditorGrid"></div>
            <div class="tome-editor-desc" id="tomeEditorDesc"></div>
            <button class="tome-editor-close" id="tomeEditorClose">✓ Done</button>
        </div>
    </div>
    
    <!-- Pause Menu Overlay -->
    <div class="pause-overlay" id="pauseOverlay">
        <div class="pause-title">Paused</div>
        <div class="pause-menu-buttons">
            <div class="pause-menu-btn btn-resume" id="resumeBtn">Resume</div>
            <div class="pause-menu-btn btn-leaderboard" id="pauseLeaderboardBtn">Leaderboard</div>
            <div class="pause-menu-btn btn-exit" id="exitGameBtn">Exit Game</div>
        </div>
    </div>
    
    <!-- Exit Confirmation Dialog -->
    <div class="confirm-overlay" id="confirmOverlay">
        <div class="confirm-box">
            <div class="confirm-text">Are you sure?</div>
            <div class="confirm-buttons">
                <div class="confirm-btn btn-yes" id="confirmYes">Yes</div>
                <div class="confirm-btn btn-no" id="confirmNo">No</div>
            </div>
        </div>
    </div>
    
    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-container">
            <div class="tutorial-header">
                <div class="tutorial-title">HOW TO PLAY</div>
                <button class="tutorial-close" id="tutorialClose">✕</button>
            </div>
            <div class="tutorial-content" id="tutorialContent">
                <!-- Step 1: Movement -->
                <div class="tutorial-step" data-step="1">
                    <div class="tutorial-step-title">🎮 MOVEMENT</div>
                    <div class="tutorial-step-content">
                        <p><strong>Mobile:</strong> Tap and drag anywhere in the control zone below the game to move.</p>
                        <p><strong>Desktop:</strong> Use <span class="key">WASD</span> or <span class="key">Arrow Keys</span> to move.</p>
                        <p>Your character auto-attacks nearby enemies - just focus on dodging!</p>
                    </div>
                </div>
                
                <!-- Step 2: Leveling Up -->
                <div class="tutorial-step" data-step="2">
                    <div class="tutorial-step-title">⬆️ LEVELING UP</div>
                    <div class="tutorial-step-content">
                        <p>Defeat enemies to drop <span class="xp-gem">XP gems</span>. Walk over them to collect.</p>
                        <p>When you level up, choose from <strong>3 random upgrades</strong>:</p>
                        <ul>
                            <li><span class="highlight weapon">⚡ Weapons</span> - New attacks or upgrade existing ones (max level 20)</li>
                            <li><span class="highlight passive">👟 Passives</span> - Stat boosts like speed, HP, damage (max level 20)</li>
                            <li><span class="highlight tome">📕 Tomes</span> - Target specific stats you want to build (max 4 unique, level 20 each)</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Step 3: Weapons -->
                <div class="tutorial-step" data-step="3">
                    <div class="tutorial-step-title">⚔️ WEAPONS</div>
                    <div class="tutorial-step-content">
                        <p>You choose your starting weapon before each run.</p>
                        <p>Weapons have <strong>rarities</strong>: Common, Uncommon, Rare, Epic, and Legendary.</p>
                        <p>Collect different weapon types:</p>
                        <ul>
                            <li>🛡️ Orbiting shields & boomerangs</li>
                            <li>🌀 Gravity wells that pull enemies</li>
                            <li>🔥 Flame cones & meteors</li>
                            <li>🌩️ Lightning & chain attacks</li>
                            <li>💎 Ricochet & piercing shots</li>
                        </ul>
                        <p>Upgrading a weapon increases its damage, speed, and projectile count.</p>
                    </div>
                </div>
                
                <!-- Step 4: Tomes -->
                <div class="tutorial-step" data-step="4">
                    <div class="tutorial-step-title">📚 TOMES</div>
                    <div class="tutorial-step-content">
                        <p>Tomes let you <strong>customize your build</strong> by targeting specific stats:</p>
                        <ul>
                            <li>📕 <span class="highlight crit">Precision</span> - Crit chance</li>
                            <li>📗 <span class="highlight xp">Wisdom</span> - XP gain</li>
                            <li>📘 <span class="highlight speed">Swiftness</span> - Move speed</li>
                            <li>📙 <span class="highlight power">Power</span> - Damage</li>
                            <li>📔 <span class="highlight haste">Haste</span> - Attack speed</li>
                            <li>...and more!</li>
                        </ul>
                        <p>You can only have <strong>4 different tomes</strong>, but each can level up to 20!</p>
                    </div>
                </div>
                
                <!-- Step 5: Shrines & Chests -->
                <div class="tutorial-step" data-step="5">
                    <div class="tutorial-step-title">✨ SHRINES & CHESTS</div>
                    <div class="tutorial-step-content">
                        <p><span class="highlight shrine">✨ Shrines</span> - Stand inside the glowing circle to charge it. Once full, choose a powerful blessing!</p>
                        <p><span class="highlight chest">📦 Chests</span> - Walk into chests to open them. Some are free, others cost gold.</p>
                        <p>Enemies drop <span class="gold">🪙 gold</span> when defeated. Save up for rare treasures!</p>
                    </div>
                </div>
                
                <!-- Step 6: Special Encounters -->
                <div class="tutorial-step" data-step="6">
                    <div class="tutorial-step-title">🎁 SPECIAL ENCOUNTERS</div>
                    <div class="tutorial-step-content">
                        <p><span class="highlight" style="color: #ffd700;">🤠 Cowboy Hat</span> - A rare pickup that grants +20% move speed permanently!</p>
                        <p><span class="highlight" style="color: #39ff14;">🐿️ Black Squirrel</span> - Your loyal pet that pounces on enemies.</p>
                        <p><span class="highlight" style="color: #00ff00;">🍀 Leprechaun</span> - Chase and defeat him to claim his pot of gold with free upgrades!</p>
                        <p><span class="highlight" style="color: #9933ff;">💀 Cursed Statue</span> - Accept the curse for harder enemies but better rewards.</p>
                    </div>
                </div>
                
                <!-- Step 7: Bosses -->
                <div class="tutorial-step" data-step="7">
                    <div class="tutorial-step-title">👹 BOSSES</div>
                    <div class="tutorial-step-content">
                        <p>Every <strong>2.5 minutes</strong>, a boss spawns!</p>
                        <p>Before bosses arrive, a <span class="highlight swarm">SWARM</span> of enemies attacks. Survive!</p>
                        <p>Defeating bosses grants <strong>bonus upgrade choices</strong> and lots of gold.</p>
                        <p class="tip">💡 Tip: Keep moving and don't get cornered!</p>
                    </div>
                </div>
            </div>
            <div class="tutorial-nav">
                <button class="tutorial-nav-btn" id="tutorialPrev">← PREV</button>
                <div class="tutorial-dots" id="tutorialDots"></div>
                <button class="tutorial-nav-btn" id="tutorialNext">NEXT →</button>
            </div>
        </div>
    </div>
    
    <!-- Score Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-title" id="scoreModalTitle">FALLEN WARRIOR</div>
        <div class="score-modal-score">Kills: <span id="finalKillsDisplay">0</span></div>
        <div class="score-modal-level">Time: <span id="finalTimeDisplay">0:00</span></div>
        <div class="score-input-container">
            <label class="score-input-label">Enter your name for the leaderboard:</label>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME" autocomplete="off" spellcheck="false">
            <div class="score-error-msg" id="scoreErrorMsg"></div>
        </div>
        <div class="score-buttons">
            <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title">🏆 TOP 100</div>
                <button class="leaderboard-close" id="leaderboardClose">✕</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <div class="leaderboard-loading">Loading scores...</div>
            </div>
        </div>
    </div>

    <script>
        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Base canvas dimensions
        const BASE_WIDTH = 800;
        const BASE_HEIGHT = 580;
        
        // ========== DEBUG UTILITY ==========
        const GameDebug = {
            enabled: false, // Toggle for debugging
            el: null,
            show(data) {
                if (!this.enabled) return this.hide();
                if (!this.el) {
                    this.el = document.createElement('div');
                    this.el.id = 'game-debug';
                    this.el.style.cssText = `
                        position: fixed; top: 60px; left: 10px;
                        background: rgba(255,0,0,0.9); color: #fff;
                        padding: 8px; font: 12px monospace;
                        z-index: 99999; border-radius: 4px;
                        max-width: 300px; pointer-events: none;
                    `;
                    document.body.appendChild(this.el);
                }
                this.el.innerHTML = Object.entries(data)
                    .map(([k, v]) => `${k}: ${v}`)
                    .join('<br>');
            },
            hide() {
                if (this.el) {
                    this.el.remove();
                    this.el = null;
                }
            }
        };
        
        // ========== iOS GESTURE PREVENTION ==========
        // Prevent iOS "swipe down to exit fullscreen" gesture
        (function() {
            if (!('ontouchstart' in window)) return;
            
            let touchStartY = 0;
            const EDGE_THRESHOLD = 50; // Pixels from top edge
            
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                // If touch started near top edge and is moving down, block it
                if (touchStartY < EDGE_THRESHOLD) {
                    const currentY = e.touches[0].clientY;
                    if (currentY > touchStartY + 10) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });
        })();
        
        // ========== COMPREHENSIVE PIXEL DENSITY SCALING ==========
        // Game logic uses gameWidth/gameHeight (always BASE size)
        
        // Device detection - improved for iPadOS 13+ which reports as Macintosh
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isIPad = /iPad/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
                      (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
        const isTablet = isTouchDevice && (isIPad || Math.min(window.screen.width, window.screen.height) >= 600);
        const isLaptopOrDesktop = !isTouchDevice || window.innerWidth > 1024;
        const rawDPR = window.devicePixelRatio || 1;
        
        // Detect display capabilities for pixel density scaling
        const screenWidth = window.screen.width * rawDPR;
        const screenHeight = window.screen.height * rawDPR;
        const is4K = screenWidth >= 3840 || screenHeight >= 2160;
        const isHighDPI = rawDPR >= 2;
        const isRetina3x = rawDPR >= 2.5;
        
        // iOS canvas memory limit: 16,777,216 pixels max (approx 4096x4096)
        const MAX_CANVAS_PIXELS = 16777216;
        
        // Performance-based DPR limits - tiered by device capability
        const isLowPerfDevice = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : isTouchDevice;
        const isMidPerfDevice = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 8 : false;
        
        // DPR limits by device type:
        // - Low perf mobile: 1.5x normal, 2x fullscreen
        // - Mid perf / tablets: 2x normal, 2.5x fullscreen  
        // - High perf desktop: 2x normal, 3x fullscreen (for 4K)
        let maxNormalDPR, maxFullscreenDPR;
        if (isLowPerfDevice) {
            maxNormalDPR = 1.5;
            maxFullscreenDPR = 2;
        } else if (isMidPerfDevice || isTablet) {
            maxNormalDPR = 2;
            maxFullscreenDPR = 2.5;
        } else {
            // High performance desktop - allow up to 3x for 4K displays
            maxNormalDPR = 2;
            maxFullscreenDPR = is4K ? 3 : 2.5;
        }
        
        // Scaling state
        let dprScale = 1;
        let gameWidth = BASE_WIDTH;   // Game logic coordinates (always BASE)
        let gameHeight = BASE_HEIGHT;
        let cssWidth = BASE_WIDTH;    // CSS display size
        let cssHeight = BASE_HEIGHT;
        
        // Get accurate viewport size (works better in iframes)
        function getViewportSize() {
            if (window.visualViewport) {
                return {
                    width: window.visualViewport.width,
                    height: window.visualViewport.height
                };
            }
            return {
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        
        function calculateScale() {
            const isNativeFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            const isInIframe = window.self !== window.top;
            
            const viewport = getViewportSize();
            const viewW = viewport.width;
            const viewH = viewport.height;
            
            const isPseudoFullscreen = !isNativeFullscreen && 
                                       (isInIframe || viewW > BASE_WIDTH * 1.15 || viewH > BASE_HEIGHT * 1.15);
            
            const isFullscreen = isNativeFullscreen || isPseudoFullscreen;
            const isMobileView = viewW <= 600;
            const isTouchDeviceLocal = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const gameContainer = document.querySelector('.game-container');
            
            // Game logic always uses base coordinates
            gameWidth = BASE_WIDTH;
            gameHeight = BASE_HEIGHT;
            
            const gameAspect = BASE_WIDTH / BASE_HEIGHT;
            
            if (isFullscreen) {
                gameContainer.classList.add('fullscreen-mode');
                document.body.classList.add('fullscreen-active');
                
                // Universal margin system: border + safety padding
                // Iframes have no borders so no margin needed
                const borderWidth = isInIframe ? 0 : 3;
                const safetyPadding = (isTablet || isIPad) ? 20 : 0;
                const totalMargin = (borderWidth + safetyPadding) * 2;
                
                // Trackpad takes ~29% of total height (halfway between 1/4 and 1/3)
                const TRACKPAD_MIN_HEIGHT = 80;
                
                const availWidth = viewW - totalMargin;
                const availHeight = viewH - totalMargin;
                
                // Canvas aspect ratio (game logic coordinates)
                const canvasAspect = BASE_WIDTH / BASE_HEIGHT; // 800/520 = 1.538
                
                // Trackpad = ~29% of available height (halfway between 1/4 and 1/3)
                const trackpadCalc = Math.max(TRACKPAD_MIN_HEIGHT, Math.floor(availHeight / 3.5));
                const canvasAreaHeight = availHeight - trackpadCalc;
                
                // Fit canvas to available width while maintaining aspect ratio
                // If canvas would be taller than canvasAreaHeight, scale down width too
                const canvasFromWidth = availWidth;
                const canvasHeightFromWidth = canvasFromWidth / canvasAspect;
                
                if (canvasHeightFromWidth <= canvasAreaHeight) {
                    // Width-limited: canvas fits in height
                    cssWidth = Math.floor(canvasFromWidth);
                    cssHeight = Math.floor(canvasHeightFromWidth);
                } else {
                    // Height-limited: scale canvas to fit height
                    cssHeight = Math.floor(canvasAreaHeight);
                    cssWidth = Math.floor(cssHeight * canvasAspect);
                }
                
                // Final trackpad height fills remaining space
                const finalTrackpadHeight = availHeight - cssHeight;
                
                // Determine optimal buffer scale based on device
                let bufferScale;
                const displayScale = cssWidth / BASE_WIDTH;
                
                if (isIPad) {
                    bufferScale = Math.min(rawDPR * displayScale, 2.5);
                } else if (isTablet) {
                    bufferScale = Math.min(rawDPR * displayScale * 0.85, 2.5);
                } else if (is4K) {
                    bufferScale = Math.min(displayScale * rawDPR, 3);
                } else if (isHighDPI) {
                    bufferScale = Math.min(displayScale * rawDPR, maxFullscreenDPR);
                } else {
                    bufferScale = Math.min(displayScale * rawDPR, maxFullscreenDPR);
                }
                
                // Ensure minimum quality
                bufferScale = Math.max(1, bufferScale);
                
                // iOS canvas memory safety check
                let bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                let bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactorMem = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    bufferScale *= scaleFactorMem;
                    bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                    bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = cssWidth + 'px';
                canvas.style.height = cssHeight + 'px';
                
                // Set trackpad zone dimensions to match calculated layout
                const trackpadEl = document.getElementById('trackpadZone');
                if (trackpadEl) {
                    trackpadEl.style.width = cssWidth + 'px';
                    trackpadEl.style.height = finalTrackpadHeight + 'px';
                    trackpadEl.style.minHeight = finalTrackpadHeight + 'px';
                }
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(bufferScale, bufferScale);
                dprScale = bufferScale;
                
                // Update CSS scale variable for UI elements
                const uiScale = cssWidth / BASE_WIDTH;
                document.documentElement.style.setProperty('--scale', uiScale);
            } else if (isMobileView) {
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
                const containerPadding = 8;
                const maxAvailWidth = viewW - containerPadding * 2 - 6;
                cssWidth = Math.min(BASE_WIDTH, maxAvailWidth);
                cssHeight = cssWidth / gameAspect;
                
                // Mobile DPR scaling - allow up to 2x for retina phones
                // Most phones are 2x-3x DPR, cap to prevent memory issues
                const mobileDPRCap = isRetina3x ? 2 : Math.min(rawDPR, 2);
                dprScale = mobileDPRCap * (cssWidth / BASE_WIDTH);
                
                let bufferWidth = Math.round(gameWidth * dprScale);
                let bufferHeight = Math.round(gameHeight * dprScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    dprScale *= scaleFactor;
                    bufferWidth = Math.round(gameWidth * dprScale);
                    bufferHeight = Math.round(gameHeight * dprScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = Math.round(cssWidth) + 'px';
                canvas.style.height = Math.round(cssHeight) + 'px';
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dprScale, dprScale);
                
                const uiScale = cssWidth / BASE_WIDTH;
                document.documentElement.style.setProperty('--scale', uiScale);
                
                GameDebug.hide();
            } else {
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
                cssWidth = BASE_WIDTH;
                cssHeight = BASE_HEIGHT;
                
                // Desktop windowed mode - use device DPR up to limit
                // 4K monitors benefit from higher scaling even in windowed mode
                const windowedDPRCap = is4K ? 2.5 : maxNormalDPR;
                dprScale = Math.min(rawDPR, windowedDPRCap);
                
                let bufferWidth = Math.round(gameWidth * dprScale);
                let bufferHeight = Math.round(gameHeight * dprScale);
                const totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const scaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    dprScale *= scaleFactor;
                    bufferWidth = Math.round(gameWidth * dprScale);
                    bufferHeight = Math.round(gameHeight * dprScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = Math.round(cssWidth) + 'px';
                canvas.style.height = Math.round(cssHeight) + 'px';
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dprScale, dprScale);
                
                const uiScale = cssWidth / BASE_WIDTH;
                document.documentElement.style.setProperty('--scale', uiScale);
                
                GameDebug.hide();
            }
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        
        function handleFullscreenChange() {
            calculateScale();
        }
        
        function resizeCanvas() {
            calculateScale();
        }
        
        // Listen for fullscreen changes (all browser variants)
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Listen for resize/orientation changes
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));
        
        // Use visualViewport resize event if available (better for iframes)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
            window.visualViewport.addEventListener('scroll', resizeCanvas);
        }
        
        // Re-check size after delays for iframe loading
        setTimeout(resizeCanvas, 100);
        setTimeout(resizeCanvas, 300);
        
        // Initial scale calculation
        calculateScale();

        // ===== BOOMBOX ICON IMAGE =====
        const BOOMBOX_IMG = new Image();
        BOOMBOX_IMG.src = 'data:image/png;base64,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';

        // ===== NEON COLOR PALETTE =====
        const COLORS = {
            cyan: '#0ff',
            magenta: '#f0f',
            pink: '#ff1493',
            orange: '#ff6600',
            purple: '#9b30ff',
            teal: '#00ffcc',
            blue: '#00aaff',
            yellow: '#ffff00',
            white: '#ffffff',
            neonGreen: '#39ff14',
            shrine: '#e040ff',  // Bright neon purple for shrines
            gold: '#ffd700',    // Leprechaun gold
            green: '#32cd32',   // Leprechaun green
            burn: '#ff4400',    // Status: burn
            freeze: '#00bfff',  // Status: freeze
            shock: '#ffff00'    // Status: shock
        };

        // ===== BLACK SQUIRREL SPRITES =====
        const squirrelSprites = {
            breathe: [],
            attack: [],
            loaded: false
        };
        
        (function loadSquirrelSprites() {
            const breatheData = [
                'data:image/png;base64,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',
                'data:image/png;base64,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'
            ];
            const attackData = [
                'data:image/png;base64,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',
                'data:image/png;base64,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',
                'data:image/png;base64,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'
            ];
            
            let loaded = 0;
            const total = breatheData.length + attackData.length;
            
            breatheData.forEach((src, i) => {
                const img = new Image();
                img.onload = () => {
                    squirrelSprites.breathe[i] = img;
                    loaded++;
                    if (loaded === total) squirrelSprites.loaded = true;
                };
                img.src = src;
            });
            
            attackData.forEach((src, i) => {
                const img = new Image();
                img.onload = () => {
                    squirrelSprites.attack[i] = img;
                    loaded++;
                    if (loaded === total) squirrelSprites.loaded = true;
                };
                img.src = src;
            });
        })();

        // ===== WORLD & CAMERA =====
        const WORLD = {
            width: 7776,
            height: 7776
        };
        
        // Target visible world area - consistent across all devices
        // Desktop baseline: 800x600 canvas at 0.665 zoom shows ~1203x903 world units
        const TARGET_VISIBLE_WIDTH = 1144;  // 10% more zoomed out
        const TARGET_VISIBLE_HEIGHT = 858; // Maintains 4:3 aspect ratio
        const BASE_ZOOM = 0.665; // Reference zoom level
        
        // Shared targeting range for weapons (60% of half-diagonal)
        const SHARED_TARGETING_RANGE = Math.hypot(TARGET_VISIBLE_WIDTH, TARGET_VISIBLE_HEIGHT) / 2 * 0.60;
        
        const camera = {
            x: 0,
            y: 0,
            zoom: 0.665, // Will be recalculated based on canvas size
            
            // Recalculate zoom to show consistent world area
            // Uses the larger of width or height ratio to ensure player appears same size
            updateZoom() {
                // Calculate zoom needed to fit target visible area
                const zoomForWidth = gameWidth / TARGET_VISIBLE_WIDTH;
                const zoomForHeight = gameHeight / TARGET_VISIBLE_HEIGHT;
                
                // Use the LARGER zoom to keep player consistently sized
                // This means on smaller screens, you see less of the world but player is same size
                this.zoom = Math.max(zoomForWidth, zoomForHeight);
                
                // Ensure minimum zoom so things don't get too small on small screens
                // And cap maximum zoom so desktop doesn't get too zoomed in
                this.zoom = Math.max(this.zoom, 0.5);
                this.zoom = Math.min(this.zoom, 2.5);
            },
            
            update() {
                // Center camera on player (accounting for zoom)
                this.x = player.x - (gameWidth / this.zoom) / 2;
                this.y = player.y - (gameHeight / this.zoom) / 2;
                
                // Clamp to world bounds
                this.x = Math.max(0, Math.min(WORLD.width - gameWidth / this.zoom, this.x));
                this.y = Math.max(0, Math.min(WORLD.height - gameHeight / this.zoom, this.y));
            },
            
            // Convert world coords to screen coords
            screenX(worldX) { return (worldX - this.x) * this.zoom; },
            screenY(worldY) { return (worldY - this.y) * this.zoom; },
            
            // Scale a size value for zoom
            scale(size) { return size * this.zoom; },
            
            // Check if world position is visible
            isVisible(x, y, margin = 50) {
                return x > this.x - margin && 
                       x < this.x + gameWidth / this.zoom + margin &&
                       y > this.y - margin && 
                       y < this.y + gameHeight / this.zoom + margin;
            }
        };
        
        // Initialize camera zoom and update on resize
        camera.updateZoom();
        window.addEventListener('resize', () => camera.updateZoom());
        
        // Helper: Check if a position is within player's visible screen area
        function isInPlayerView(x, y, margin = 50) {
            // Calculate camera bounds (what the player can see)
            const viewLeft = camera.x - margin;
            const viewRight = camera.x + gameWidth / camera.zoom + margin;
            const viewTop = camera.y - margin;
            const viewBottom = camera.y + gameHeight / camera.zoom + margin;
            
            return x > viewLeft && x < viewRight && y > viewTop && y < viewBottom;
        }

        // ===== GAME STATE =====
        let gameRunning = false;
        let gamePaused = false;
        let gameTime = 0;
        let frameCount = 0; // For optimization - skip updates on some frames
        let kills = 0;
        let player = null;
        let enemies = [];
        let projectiles = [];
        let xpGems = [];
        let damageNumbers = [];
        let particles = [];
        let explosions = []; // AOE explosion visuals
        let shrines = [];
        let magnetPulseActive = false; // Is magnet pulse currently active
        
        // Startup message
        let startupMessageStart = 0;
        let startupMessageActive = false;
        
        // Fog of War system - tracks explored areas
        const FOG_CELL_SIZE = 100; // Each cell is 100x100 world units
        const FOG_GRID_SIZE = Math.ceil(WORLD.width / FOG_CELL_SIZE);
        let fogGrid = []; // 2D array: true = explored, false = unexplored
        
        function initFogGrid() {
            fogGrid = [];
            for (let y = 0; y < FOG_GRID_SIZE; y++) {
                fogGrid[y] = [];
                for (let x = 0; x < FOG_GRID_SIZE; x++) {
                    fogGrid[y][x] = false;
                }
            }
        }
        
        function updateFogOfWar() {
            if (!player) return;
            
            // Calculate visible range (based on camera view)
            const viewRadius = Math.max(gameWidth, gameHeight) / camera.zoom / 2 + 100;
            
            // Mark cells within view as explored
            const minCellX = Math.max(0, Math.floor((player.x - viewRadius) / FOG_CELL_SIZE));
            const maxCellX = Math.min(FOG_GRID_SIZE - 1, Math.floor((player.x + viewRadius) / FOG_CELL_SIZE));
            const minCellY = Math.max(0, Math.floor((player.y - viewRadius) / FOG_CELL_SIZE));
            const maxCellY = Math.min(FOG_GRID_SIZE - 1, Math.floor((player.y + viewRadius) / FOG_CELL_SIZE));
            
            for (let cy = minCellY; cy <= maxCellY; cy++) {
                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    // Check if cell center is within circular view
                    const cellCenterX = (cx + 0.5) * FOG_CELL_SIZE;
                    const cellCenterY = (cy + 0.5) * FOG_CELL_SIZE;
                    const dist = Math.hypot(cellCenterX - player.x, cellCenterY - player.y);
                    if (dist < viewRadius) {
                        fogGrid[cy][cx] = true;
                    }
                }
            }
        }
        
        function isExplored(worldX, worldY) {
            const cellX = Math.floor(worldX / FOG_CELL_SIZE);
            const cellY = Math.floor(worldY / FOG_CELL_SIZE);
            if (cellX < 0 || cellX >= FOG_GRID_SIZE || cellY < 0 || cellY >= FOG_GRID_SIZE) {
                return false;
            }
            return fogGrid[cellY][cellX];
        }
        
        // Leprechaun system
        let leprechauns = [];
        let rainbows = [];
        let leprechaunSpawnTimer = 0;
        let leprechaunSpawnInterval = 90000; // First spawn at 90s, then every 2 minutes
        let nextLeprechaunSpawn = 90000;
        
        // Player legendary elemental effects
        let legendaryEffects = {
            burn: { chance: 0, damage: 0 },
            freeze: { chance: 0, slowAmount: 0 },
            shock: { chance: 0, damage: 0 },
            timeSlow: { active: false, cooldownEnd: 0, isSlowed: false, effectEnd: 0, regenBoostEnd: 0 },
            holyBook: { active: false, maxHpBonus: 0, regenBonus: 0 },
            stillness: { active: false, lifestealBonus: 0 },
            xpMagnet: { active: false, lastPulse: 0, interval: 30000 },
            ghostStrike: { active: false }
        };
        
        // Ghost entities for Vengeful Spirits
        let ghosts = [];
        
        // Treasure chests
        let chests = [];
        let legendaryCount = 0; // Track legendaries acquired this run
        const MAX_LEGENDARIES = 4;
        let lastLegendaryTime = 0; // When player last got a legendary
        let guaranteedLegendaryNext = false; // Bad luck protection flag
        
        // Gold currency
        let playerGold = 0;
        let nextChestCost = 5; // First paid chest costs 5, doubles each time
        let pendingChest = null; // Currently open chest offer
        
        // Skull statue difficulty system
        let skullStatues = [];
        let pendingStatue = null;
        let difficultyLevel = 0; // Each activation adds +1
        let enemyDamageBonus = 1; // Multiplier for enemy damage
        let enemyHealthBonus = 1; // Multiplier for enemy HP
        let enemySpeedBonus = 1; // Multiplier for enemy speed
        let killRewardBonus = 1; // Multiplier for XP/gold from kills
        
        // Time slow effect multiplier (1 = normal, 0.4 = 60% slower)
        let timeSlowMultiplier = 1;
        
        // Boss system
        let bosses = [];
        let nextBossTime = 150; // First boss at 2.5 mins (150s)
        let bossCount = 0; // Track how many bosses spawned
        
        // Swarm system (1 min before boss, lasts 30s)
        let swarmActive = false;
        let swarmEndTime = 0;
        let swarmTriggeredForBoss = 0; // Which boss # triggered the current swarm
        
        // Cowboy hat pickup
        let cowboyHat = null;
        let playerHasCowboyHat = false;
        
        // Shield pickups (4 total, one per quadrant)
        let shieldPickups = [];
        let playerLastCombatTime = 0; // Track when player last took/dealt damage
        
        // Power drops (heart, shoe, hourglass) from enemy kills
        let powerDrops = [];
        let powerDropCount = 0; // Track total drops for diminishing returns
        let timeStopActive = false;
        let timeStopEndTime = 0;
        let speedBoostActive = false;
        let speedBoostEndTime = 0;
        let speedBoostMultiplier = 1;
        
        // Death animation
        let deathAnimationActive = false;
        let deathAnimationStart = 0;
        let deathAnimationX = 0;
        let deathAnimationY = 0;
        
        // Upgrade variety tracking - reduce chance of seeing same offers repeatedly
        let offerHistory = {}; // Tracks how many times each upgrade was offered
        let rerollsRemaining = 3; // Player gets 3 rerolls per game
        let banishesRemaining = 2; // Player gets 2 banishes per game

        // Entity limits for performance
        const LIMITS = {
            particles: 100,
            damageNumbers: 40,
            projectiles: 100,
            enemies: 120,
            xpGems: 300 // Limit XP gems to prevent late-game lag
        };

        // ===== RARITY SYSTEM =====
        const RARITIES = {
            common:    { name: 'Common',    color: '#aaaaaa', weight: 80 },
            uncommon:  { name: 'Uncommon',  color: '#55ff55', weight: 12 },
            rare:      { name: 'Rare',      color: '#00aaff', weight: 5 },
            epic:      { name: 'Epic',      color: '#4b0082', weight: 2 },
            legendary: { name: 'Legendary', color: '#ffaa00', weight: 1 }
        };
        
        // Weapon rarities
        const WEAPON_RARITIES = {
            energyBolt: 'common',
            plasmaOrbit: 'common',
            boomBox: 'uncommon',
            laserBeam: 'uncommon',
            starField: 'uncommon',
            voidDaggers: 'rare',
            flameThrower: 'rare',
            blackSquirrel: 'epic',
            thunderStrike: 'rare',
            toxicAura: 'uncommon',
            iceShard: 'uncommon',
            meteorStrike: 'epic',
            spiritOrbs: 'rare',
            boomerang: 'common',
            chainLightning: 'epic',
            spectralArrows: 'uncommon',
            gravityWell: 'epic',
            ricochetDisc: 'rare',
            pulseMine: 'rare',
            shotgun: 'epic'
        };
        
        // Tome rarities
        const TOME_RARITIES = {
            critTome: 'uncommon',
            xpTome: 'common',
            speedTome: 'common',
            powerTome: 'uncommon',
            luckTome: 'rare',
            attackSpeedTome: 'uncommon',
            vitalityTome: 'common',
            regenTome: 'common',
            lifestealTome: 'rare',
            critDamageTome: 'rare',
            armorTome: 'uncommon',
            shieldTome: 'epic'
        };

        // Calculate rarity based on luck
        function rollRarity(luckBonus = 0) {
            const luck = (player ? player.luck : 0) + luckBonus;
            
            // Luck shifts weights toward rarer items
            // At 0 luck: base weights
            // At 100% luck: significantly better odds
            const weights = {
                common:    Math.max(5, RARITIES.common.weight - luck * 40),
                uncommon:  RARITIES.uncommon.weight + luck * 10,
                rare:      RARITIES.rare.weight + luck * 15,
                epic:      RARITIES.epic.weight + luck * 10,
                legendary: RARITIES.legendary.weight + luck * 5
            };
            
            const total = Object.values(weights).reduce((a, b) => a + b, 0);
            let roll = Math.random() * total;
            
            for (const [rarity, weight] of Object.entries(weights)) {
                roll -= weight;
                if (roll <= 0) return rarity;
            }
            return 'common';
        }
        
        // Get upgrade rarity (weapons only - tomes don't have rarity)
        function getUpgradeRarity(type, id) {
            if (type === 'weapon') return WEAPON_RARITIES[id] || 'common';
            return null; // Tomes don't have rarity
        }
        
        // Filter upgrades by minimum rarity
        function filterByRarity(upgrades, minRarity) {
            const rarityOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
            const minIndex = rarityOrder.indexOf(minRarity);
            return upgrades.filter(u => {
                const uRarity = getUpgradeRarity(u.type, u.id);
                return rarityOrder.indexOf(uRarity) >= minIndex;
            });
        }

        // ===== WEAPON DEFINITIONS =====
        // Cartoon pump-action shotgun SVG as data URI
        const SHOTGUN_ICON_SVG = `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68 32">
          <g transform="rotate(-20, 34, 16)">
            <!-- Stock (wood) -->
            <path d="M4 11 L4 17 L10 18 L10 10 Z" fill="#8B4513" stroke="#5D2E0C" stroke-width="0.8"/>
            <!-- Receiver (gray metal) -->
            <rect x="10" y="9" width="12" height="10" rx="1" fill="#666" stroke="#444" stroke-width="0.8"/>
            <!-- Barrel (top) -->
            <rect x="22" y="9" width="40" height="5" rx="1" fill="#777" stroke="#555" stroke-width="0.8"/>
            <!-- Barrel highlight -->
            <line x1="24" y1="10.5" x2="60" y2="10.5" stroke="#999" stroke-width="0.6" opacity="0.5"/>
            <!-- Magazine tube (under barrel) -->
            <rect x="22" y="14" width="32" height="4" rx="1" fill="#666" stroke="#444" stroke-width="0.6"/>
            <!-- Pump/Forend grip (wood, wraps around magazine) -->
            <rect x="32" y="8" width="14" height="12" rx="2" fill="#8B4513" stroke="#5D2E0C" stroke-width="0.8"/>
            <!-- Pump grip lines -->
            <line x1="35" y1="9" x2="35" y2="19" stroke="#5D2E0C" stroke-width="0.8"/>
            <line x1="38" y1="9" x2="38" y2="19" stroke="#5D2E0C" stroke-width="0.8"/>
            <line x1="41" y1="9" x2="41" y2="19" stroke="#5D2E0C" stroke-width="0.8"/>
            <line x1="44" y1="9" x2="44" y2="19" stroke="#5D2E0C" stroke-width="0.8"/>
            <!-- Muzzle -->
            <ellipse cx="62" cy="11.5" rx="2" ry="3.5" fill="#555" stroke="#333" stroke-width="0.5"/>
            <ellipse cx="62" cy="11.5" rx="1" ry="2" fill="#222"/>
            <!-- Trigger guard -->
            <path d="M18 19 Q18 23 14 23 L12 23 L12 19" fill="none" stroke="#555" stroke-width="1.2" stroke-linecap="round"/>
            <!-- Trigger -->
            <rect x="14" y="19" width="2" height="3" fill="#444"/>
          </g>
        </svg>`)}`;
        
        const WEAPONS = {
            energyBolt: {
                name: 'Energy Bolt',
                icon: '⚡',
                color: COLORS.white,
                desc: 'Auto-fires at nearest enemy',
                baseDamage: 8,
                baseFireRate: 720,
                baseProjectiles: 1,
                type: 'projectile'
            },
            plasmaOrbit: {
                name: 'Plasma Shield',
                icon: '🛡️',
                color: '#6688ee',
                desc: 'Rotating shield blocks hits & damages enemies',
                baseDamage: 10,
                baseOrbs: 3,
                baseCharges: 3,
                chargeRegenTime: 8000,
                knockbackForce: 80,
                burstDamage: 20,
                burstRadius: 50,
                type: 'orbit'
            },
            boomBox: {
                name: 'Boom Box',
                icon: '🎵',
                color: COLORS.teal,
                desc: 'Blasts all nearby enemies',
                baseDamage: 10,
                baseRadius: 147,
                baseFireRate: 1440,
                type: 'aoe'
            },
            laserBeam: {
                name: 'Laser Beam',
                icon: '📡',
                color: COLORS.pink,
                desc: 'Piercing laser shots',
                baseDamage: 21,
                baseFireRate: 1080,
                pierce: 4,
                type: 'laser'
            },
            starField: {
                name: 'Star Field',
                icon: '⭐',
                color: COLORS.yellow,
                desc: 'Raining stars damage nearby enemies',
                baseDamage: 2.5,
                baseRadius: 240,
                tickRate: 500,
                type: 'starfall'
            },
            // NEW WEAPONS
            voidDaggers: {
                name: 'Void Daggers',
                icon: '🗡️',
                color: '#9400d3',
                desc: 'Fast daggers in all directions',
                baseDamage: 7,
                baseFireRate: 960,
                baseDaggers: 4,
                type: 'daggers'
            },
            flameThrower: {
                name: 'Flame Thrower',
                icon: '🔥',
                color: COLORS.orange,
                desc: 'Cone of fire damage',
                baseDamage: 5,
                baseFireRate: 144,
                baseAngle: 0.7,
                baseRange: 144,
                type: 'flame'
            },
            blackSquirrel: {
                name: 'Black Squirrel',
                icon: '🐿️',
                color: '#39ff14',
                desc: 'Rabid pet squirrel shreds enemies',
                baseDamage: 18,
                walkDamage: 6,
                baseFireRate: 2100,
                baseSquirrels: 1,
                splashRadius: 45,
                type: 'squirrel'
            },
            thunderStrike: {
                name: 'Lightning Strike',
                icon: '🌩️',
                color: '#ffff00',
                desc: 'Lightning from above',
                baseDamage: 30,
                baseFireRate: 1200,
                baseStrikes: 1,
                baseRange: 240,
                type: 'thunder'
            },
            toxicAura: {
                name: 'Toxic Aura',
                icon: '☠️',
                color: '#32cd32',
                desc: 'Poison nearby enemies',
                baseDamage: 4.0,
                baseRadius: 99,
                tickRate: 1400,
                type: 'aura'
            },
            // MORE WEAPONS
            iceShard: {
                name: 'Ice Shards',
                icon: '❄️',
                color: '#88ddff',
                desc: 'Freezing projectiles that slow',
                baseDamage: 10,
                baseFireRate: 840,
                baseProjectiles: 2,
                slowAmount: 0.4,
                slowDuration: 2000,
                type: 'ice'
            },
            meteorStrike: {
                name: 'Meteor Strike',
                icon: '☄️',
                color: '#ff4400',
                desc: 'Explosive impacts from the sky',
                baseDamage: 38,
                baseFireRate: 2400,
                blastRadius: 72,
                type: 'meteor'
            },
            spiritOrbs: {
                name: 'Ghost Orbs',
                icon: '👁️',
                color: '#aa88ff',
                desc: 'Homing spirit projectiles',
                baseDamage: 25,
                baseFireRate: 1080,
                baseOrbs: 1,
                type: 'homing'
            },
            boomerang: {
                name: 'Boomerang',
                icon: '🪃',
                color: '#f0ead6',
                desc: 'Returns to you, hits twice',
                baseDamage: 19,
                baseFireRate: 1800,
                baseCount: 1,
                type: 'boomerang'
            },
            chainLightning: {
                name: 'Chain Lightning',
                icon: '⛓️',
                color: '#44ffff',
                desc: 'Lightning jumps between enemies',
                baseDamage: 17,
                baseFireRate: 1320,
                baseChains: 3,
                chainRange: 101,
                type: 'chainlightning'
            },
            // NEW WEAPONS
            spectralArrows: {
                name: 'Spectral Arrows',
                icon: '🏹',
                color: '#99ffcc',
                desc: 'Rapid arrows that leave damage trails',
                baseDamage: 6,
                baseFireRate: 360,
                baseArrows: 2,
                trailDuration: 800,
                trailDamage: 3,
                pierce: 2,
                type: 'arrows'
            },
            gravityWell: {
                name: 'Gravity Well',
                icon: '🌀',
                color: '#6600cc',
                desc: 'Black hole pulls and crushes enemies',
                baseDamage: 4,
                baseFireRate: 4200,
                pullRadius: 110,
                visualRadius: 70,
                pullStrength: 0.5,
                duration: 3000,
                tickRate: 200,
                type: 'gravity'
            },
            ricochetDisc: {
                name: 'Ricochet Disc',
                icon: '💿',
                color: '#ff66aa',
                desc: 'Disc bounces between enemies',
                baseDamage: 14,
                baseFireRate: 1600,
                baseBounces: 4,
                bounceRange: 150,
                type: 'ricochet'
            },
            pulseMine: {
                name: 'Pulse Mine',
                icon: '💣',
                color: '#ff4444',
                desc: 'Drops mines that explode on contact',
                baseDamage: 35,
                baseFireRate: 2000,
                blastRadius: 80,
                armTime: 800,
                maxMines: 5,
                mineDuration: 12000,
                type: 'mine'
            },
            shotgun: {
                name: 'Shotgun',
                icon: '🔫',
                color: '#ff8844',
                desc: 'Spread shot, deadly up close',
                baseDamage: 8,
                baseFireRate: 1485,
                pelletCount: 6,
                spreadAngle: 0.5,
                maxRange: 180,
                knockback: 60,
                type: 'shotgun'
            }
        };

        // ===== PASSIVE UPGRADES =====
        const PASSIVES = {
            speed: { name: 'Speed Boost', icon: '👟', color: COLORS.teal, desc: '+12% move speed' },
            maxHp: { name: 'Vitality', icon: '❤️', color: COLORS.pink, desc: '+25 max HP' },
            damage: { name: 'Power Up', icon: '💪', color: COLORS.orange, desc: '+12% damage' },
            pickupRange: { name: 'Magnet', icon: '🧲', color: COLORS.blue, desc: '+30% pickup range' },
            regen: { name: 'Regen', icon: '💚', color: COLORS.teal, desc: 'Heal 1.5 HP/sec' }
        };

        // ===== TOME UPGRADES (Stat-focused, max 4 unique) =====
        const TOMES = {
            critTome: { 
                name: 'Tome of Precision', 
                icon: '🎯', 
                color: '#ff4466', 
                desc: '+4% crit chance',
                stat: 'critChance',
                value: 0.04
            },
            xpTome: { 
                name: 'Tome of Wisdom', 
                icon: '🧠', 
                color: '#66ff66', 
                desc: '+10% XP gain',
                stat: 'xpBonus',
                value: 0.10
            },
            speedTome: { 
                name: 'Tome of Swiftness', 
                icon: '💨', 
                color: '#6699ff', 
                desc: '+7% movement speed',
                stat: 'speedBonus',
                value: 0.07
            },
            powerTome: { 
                name: 'Tome of Power', 
                icon: '⚔️', 
                color: '#ff9933', 
                desc: '+9% damage',
                stat: 'damageBonus',
                value: 0.09
            },
            luckTome: { 
                name: 'Tome of Fortune', 
                icon: '🍀', 
                color: '#ffcc00', 
                desc: '+6% luck (drops, legendaries)',
                stat: 'luck',
                value: 0.06
            },
            attackSpeedTome: { 
                name: 'Tome of Haste', 
                icon: '⚡', 
                color: '#cc66ff', 
                desc: '+8% attack speed',
                stat: 'attackSpeedBonus',
                value: 0.08
            },
            vitalityTome: { 
                name: 'Tome of Vitality', 
                icon: '❤️', 
                color: '#ff6699', 
                desc: '+15 max HP',
                stat: 'maxHpBonus',
                value: 15
            },
            regenTome: { 
                name: 'Tome of Recovery', 
                icon: '💚', 
                color: '#66ffcc', 
                desc: '+0.6 HP/sec regen',
                stat: 'regenBonus',
                value: 0.6
            },
            armorTome: { 
                name: 'Tome of Iron', 
                icon: '🛡️', 
                color: '#8899aa', 
                desc: '+5% armor',
                stat: 'armorBonus',
                value: 0.05
            },
            lifestealTome: { 
                name: 'Tome of Vampirism', 
                icon: '🩸', 
                color: '#cc3366', 
                desc: '+3% lifesteal',
                stat: 'lifestealBonus',
                value: 0.03
            },
            critDamageTome: { 
                name: 'Tome of Lethality', 
                icon: '💀', 
                color: '#aa44ff', 
                desc: '+11% crit damage',
                stat: 'critMultiplierBonus',
                value: 0.11
            },
            magnetTome: { 
                name: 'Tome of Attraction', 
                icon: '🧲', 
                color: '#44aaff', 
                desc: '+15% pickup range',
                stat: 'pickupBonus',
                value: 0.15
            }
        };
        const MAX_UNIQUE_TOMES = 4;
        const MAX_UNIQUE_WEAPONS = 4;

        // ===== SHRINE POWER-UPS =====
        const SHRINE_POWERUPS = {
            damage: { name: 'Power', icon: '⚔️', color: COLORS.orange, desc: '+10% Damage', stat: 'damageBonus', value: 0.10 },
            speed: { name: 'Swiftness', icon: '💨', color: COLORS.teal, desc: '+8% Speed', stat: 'speedBonus', value: 0.08 },
            attackSpeed: { name: 'Haste', icon: '⚡', color: COLORS.yellow, desc: '+10% Attack Speed', stat: 'attackSpeedBonus', value: 0.10 },
            regen: { name: 'Vitality', icon: '💚', color: COLORS.teal, desc: '+0.75 HP/sec', stat: 'regenBonus', value: 0.75 },
            lifesteal: { name: 'Vampirism', icon: '🩸', color: COLORS.pink, desc: '+4% Lifesteal', stat: 'lifesteal', value: 0.04 },
            critChance: { name: 'Precision', icon: '🎯', color: COLORS.cyan, desc: '+5% Crit Chance', stat: 'critChance', value: 0.05 },
            critMultiplier: { name: 'Lethality', icon: '💀', color: COLORS.purple, desc: '+12% Crit Damage', stat: 'critMultiplier', value: 0.12 },
            armor: { name: 'Fortitude', icon: '🛡️', color: COLORS.blue, desc: '+6% Armor', stat: 'armor', value: 0.06 }
        };

        // ===== PLAYER CLASS =====
        class Player {
            constructor() {
                this.x = WORLD.width / 2;
                this.y = WORLD.height / 2;
                this.radius = 21;
                this.baseSpeed = 2.9; // 10% faster (was 2.64)
                this.speed = this.baseSpeed;
                this.maxHp = 120;      // Buffed from 100
                this.hp = this.maxHp;
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 3;  // Easy first level
                this.weapons = {};
                this.passives = {};
                this.tomes = {};       // Track tomes (like weapons, max 4 unique)
                this.pickupRange = 50;
                this.damageMultiplier = 1;
                this.regenRate = 1.5; // Baseline regen (tripled from 0.5)
                this.invincible = 0;
                this.invincibilityDuration = 600; // Buffed from 500ms
                
                // Knockback velocity (for animated knockback)
                this.knockbackVelX = 0;
                this.knockbackVelY = 0;
                
                // New stats for shrine system
                this.critChance = 0.05;      // 5% base crit chance
                this.critMultiplier = 2.0;   // 2x base crit damage
                this.armor = 0;              // % armor (damage reduction)
                this.lifesteal = 0;          // % of damage healed
                this.attackSpeedMultiplier = 1;
                this.luck = 0;               // Luck bonus from tomes
                this.xpBonusMult = 1;        // XP multiplier from tomes
                
                // Shield system (from pickups)
                this.shieldHp = 0;           // Current shield HP
                this.maxShieldHp = 0;        // Max shield HP (25 per pickup collected)
                this.shieldRegenRate = 5;    // Shield regen per second (when out of combat)
                this.shieldRegenDelay = 3000; // 3 seconds out of combat to start regen
                
                // Tome bonuses (stacking)
                this.tomeBonuses = {
                    critChance: 0,
                    xpBonus: 0,
                    speedBonus: 0,
                    damageBonus: 0,
                    luck: 0,
                    attackSpeedBonus: 0,
                    maxHpBonus: 0,
                    regenBonus: 0,
                    armorBonus: 0,
                    lifestealBonus: 0,
                    critMultiplierBonus: 0,
                    pickupBonus: 0
                };
                
                // Shrine bonuses (stacking)
                this.shrineBonuses = {
                    damageBonus: 0,
                    speedBonus: 0,
                    attackSpeedBonus: 0,
                    regenBonus: 0,
                    lifesteal: 0,
                    critChance: 0,
                    critMultiplier: 0,
                    armor: 0
                };
                
                // Rolling animation
                this.rollAngle = 0;
                this.moveAngle = -Math.PI / 2; // Default to upward
                
                // Give starting weapon (uses selected weapon from weapon select screen)
                this.addWeapon(selectedStartingWeapon);
            }

            addWeapon(weaponId) {
                if (!this.weapons[weaponId]) {
                    this.weapons[weaponId] = {
                        level: 1,
                        lastFire: 0,
                        angle: 0  // for orbit weapons
                    };
                } else {
                    this.weapons[weaponId].level = Math.min(this.weapons[weaponId].level + 1, 20);
                }
            }

            addPassive(passiveId) {
                if (!this.passives[passiveId]) {
                    this.passives[passiveId] = 1;
                } else {
                    this.passives[passiveId]++;
                }
                this.applyPassives();
            }

            addTome(tomeId) {
                const def = TOMES[tomeId];
                if (!def) return;
                
                if (!this.tomes[tomeId]) {
                    this.tomes[tomeId] = { level: 1 };
                } else {
                    this.tomes[tomeId].level = Math.min(this.tomes[tomeId].level + 1, 20);
                }
                
                // Apply tome bonus
                if (this.tomeBonuses.hasOwnProperty(def.stat)) {
                    this.tomeBonuses[def.stat] += def.value;
                }
                this.applyPassives();
            }
            
            getUniqueTomeCount() {
                return Object.keys(this.tomes).length;
            }
            
            getUniqueWeaponCount() {
                return Object.keys(this.weapons).length;
            }

            applyPassives() {
                // Base passives from level-up (updated values)
                const baseSpeedMult = 1 + (this.passives.speed || 0) * 0.12;  // 12% per level
                const shrineSpeedMult = 1 + this.shrineBonuses.speedBonus;
                const tomeSpeedMult = 1 + this.tomeBonuses.speedBonus; // Tome speed bonus
                const hatSpeedMult = playerHasCowboyHat ? 1.2 : 1; // 20% from cowboy hat
                const dropSpeedMult = speedBoostMultiplier; // Speed boost from shoe drop
                this.speed = this.baseSpeed * baseSpeedMult * shrineSpeedMult * tomeSpeedMult * hatSpeedMult * dropSpeedMult;
                
                // Max HP from base + passives + tomes
                this.maxHp = 120 + (this.passives.maxHp || 0) * 25 + (this.tomeBonuses.maxHpBonus || 0);
                this.hp = Math.min(this.hp, this.maxHp);
                
                // Damage multiplier combines passive, shrine, and tome bonuses
                const baseDamageMult = 1 + (this.passives.damage || 0) * 0.12;  // 12% per level
                this.damageMultiplier = baseDamageMult * (1 + this.shrineBonuses.damageBonus) * (1 + this.tomeBonuses.damageBonus);
                
                // Pickup range from passives + tomes
                this.pickupRange = 50 * (1 + (this.passives.pickupRange || 0) * 0.30 + (this.tomeBonuses.pickupBonus || 0));
                
                // Regen from base + passives + shrine + tome
                this.regenRate = 1.5 + (this.passives.regen || 0) * 1.5 + this.shrineBonuses.regenBonus + (this.tomeBonuses.regenBonus || 0);
                
                // Attack speed from shrine + tome
                this.attackSpeedMultiplier = 1 + this.shrineBonuses.attackSpeedBonus + this.tomeBonuses.attackSpeedBonus;
                
                // Crit stats (base + shrine + tome)
                this.critChance = 0.05 + this.shrineBonuses.critChance + this.tomeBonuses.critChance;
                this.critMultiplier = 2.0 + this.shrineBonuses.critMultiplier + (this.tomeBonuses.critMultiplierBonus || 0);
                
                // Luck from tome (affects various RNG) - 0.5 effectiveness rate
                this.luck = (this.tomeBonuses.luck || 0) * 0.5;
                
                // XP bonus from tome
                this.xpBonusMult = 1 + (this.tomeBonuses.xpBonus || 0);
                
                // Lifesteal from shrine + tome
                this.lifesteal = this.shrineBonuses.lifesteal + (this.tomeBonuses.lifestealBonus || 0);
                
                // Armor from shrine + tome
                this.armor = this.shrineBonuses.armor + (this.tomeBonuses.armorBonus || 0);
            }
            
            addShrineBonus(stat, value) {
                if (this.shrineBonuses.hasOwnProperty(stat)) {
                    this.shrineBonuses[stat] += value;
                    this.applyPassives();
                }
            }
            
            // Calculate damage with crit
            calcDamage(baseDamage) {
                let damage = baseDamage * this.damageMultiplier;
                let isCrit = false;
                
                if (Math.random() < this.critChance) {
                    damage *= this.critMultiplier;
                    isCrit = true;
                }
                
                return { damage, isCrit };
            }
            
            // Apply lifesteal
            onDealDamage(damage) {
                // Base lifesteal from shrines
                let totalLifesteal = this.lifesteal;
                
                // Add stillness lifesteal bonus
                if (legendaryEffects.stillness.active) {
                    totalLifesteal += legendaryEffects.stillness.lifestealBonus;
                }
                
                if (totalLifesteal > 0) {
                    const healAmount = damage * totalLifesteal;
                    this.heal(healAmount);
                }
            }
            
            // Centralized healing method for holy book radiation
            heal(amount) {
                if (this.hp >= this.maxHp) return;
                
                const oldHp = this.hp;
                this.hp = Math.min(this.maxHp, this.hp + amount);
                const actualHeal = this.hp - oldHp;
                
                // Holy Book radiation - damage nearby enemies when healing
                if (legendaryEffects.holyBook.active && actualHeal > 0) {
                    const radiusRange = 120;
                    const radiationDamage = actualHeal * 0.5; // 50% of heal as damage
                    
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                        if (dist < radiusRange) {
                            enemy.takeDamage(radiationDamage, false);
                        }
                    }
                    
                    // Visual effect
                    if (Math.random() < 0.3) {
                        spawnParticles(this.x, this.y, '#ffffaa', 5);
                    }
                }
            }

            gainXP(amount) {
                // Apply XP bonus from tomes
                const bonusedAmount = amount * (this.xpBonusMult || 1);
                this.xp += bonusedAmount;
                while (this.xp >= this.xpToNext) {
                    this.xp -= this.xpToNext;
                    this.level++;
                    // Easy early levels, then normal scaling
                    if (this.level <= 2) {
                        this.xpToNext = 5;  // Level 2→3: only 5 XP
                    } else if (this.level <= 3) {
                        this.xpToNext = 8;  // Level 3→4: only 8 XP  
                    } else {
                        this.xpToNext = Math.floor(this.xpToNext * 1.3) + 5;
                    }
                    
                    showUpgradeSelection();
                }
            }

            takeDamage(amount) {
                if (this.invincible > 0) return;
                
                // Check plasma shield charges first
                if (this.weapons.plasmaOrbit) {
                    const shieldDef = WEAPONS.plasmaOrbit;
                    const shieldState = this.weapons.plasmaOrbit;
                    if (shieldState && shieldState.shieldCharges > 0) {
                        // Block the hit with plasma shield
                        this.tryShieldBlock(shieldState, shieldDef);
                        this.invincible = this.invincibilityDuration;
                        return; // Damage fully blocked
                    }
                }
                
                // Apply armor
                const reducedDamage = amount * (1 - this.armor);
                
                // Track combat time for shield regen
                playerLastCombatTime = Date.now();
                
                // Shield absorbs damage first
                if (this.shieldHp > 0) {
                    if (this.shieldHp >= reducedDamage) {
                        this.shieldHp -= reducedDamage;
                        spawnParticles(this.x, this.y, '#4488ff', 12); // Blue particles for shield hit
                    } else {
                        const overflow = reducedDamage - this.shieldHp;
                        this.shieldHp = 0;
                        this.hp -= overflow;
                        spawnParticles(this.x, this.y, '#4488ff', 8);
                        spawnParticles(this.x, this.y, COLORS.pink, 8);
                    }
                } else {
                    this.hp -= reducedDamage;
                    spawnParticles(this.x, this.y, COLORS.pink, 10);
                }
                
                this.invincible = this.invincibilityDuration;
                
                if (this.hp <= 0) {
                    startDeathAnimation(this.x, this.y);
                }
            }

            update(dt, inputObj) {
                // Movement
                let dx = 0, dy = 0;
                if (inputObj.left) dx -= 1;
                if (inputObj.right) dx += 1;
                if (inputObj.up) dy -= 1;
                if (inputObj.down) dy += 1;
                
                // Joystick input
                if (inputObj.joystickX !== 0 || inputObj.joystickY !== 0) {
                    dx = inputObj.joystickX;
                    dy = inputObj.joystickY;
                }
                
                // Normalize diagonal
                if (dx && dy) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                // Frame-rate independent movement (dt/16 normalizes to ~60fps)
                const dtScale = dt / 16;
                this.x += dx * this.speed * dtScale;
                this.y += dy * this.speed * dtScale;
                
                // Track last movement direction for caltrops
                if (dx !== 0 || dy !== 0) {
                    this.lastMoveX = dx;
                    this.lastMoveY = dy;
                }
                
                // Update roll angle based on movement (for rolling animation)
                const moveSpeed = Math.hypot(dx, dy);
                if (moveSpeed > 0) {
                    this.moveAngle = Math.atan2(dy, dx);
                    this.rollAngle += moveSpeed * this.speed * 0.0585 * dtScale;
                }
                
                // Apply knockback velocity (animated knockback)
                if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) {
                    this.x += this.knockbackVelX * (dt / 16);
                    this.y += this.knockbackVelY * (dt / 16);
                    
                    // Apply friction to slow down knockback (higher = slower decay = smoother)
                    const friction = 0.88;
                    this.knockbackVelX *= friction;
                    this.knockbackVelY *= friction;
                    
                    // Stop when very slow
                    if (Math.abs(this.knockbackVelX) < 0.05) this.knockbackVelX = 0;
                    if (Math.abs(this.knockbackVelY) < 0.05) this.knockbackVelY = 0;
                }
                
                // World bounds
                this.x = Math.max(this.radius, Math.min(WORLD.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD.height - this.radius, this.y));
                
                // Terrain collision - push player out of lakes/mountains/trees/rocks/bushes
                const terrain = isInTerrain(this.x, this.y, this.radius);
                if (terrain) {
                    if (terrain.type === 'tree' || terrain.type === 'rock' || terrain.type === 'bush') {
                        // Circular collision for trees, rocks, bushes
                        const dx2 = this.x - terrain.x;
                        const dy2 = this.y - terrain.y;
                        const dist = Math.hypot(dx2, dy2);
                        
                        if (dist > 0) {
                            const pushDist = terrain.radius + this.radius + 2;
                            this.x = terrain.x + (dx2 / dist) * pushDist;
                            this.y = terrain.y + (dy2 / dist) * pushDist;
                        }
                    } else {
                        // Ellipse collision for lakes/mountains
                        const dx2 = this.x - terrain.x;
                        const dy2 = this.y - terrain.y;
                        
                        // Normalize by ellipse radii
                        const normX = dx2 / terrain.radiusX;
                        const normY = dy2 / terrain.radiusY;
                        const dist = Math.sqrt(normX * normX + normY * normY);
                        
                        if (dist > 0) {
                            // Push to edge of terrain + player radius
                            const pushX = (normX / dist) * (terrain.radiusX + this.radius + 5);
                            const pushY = (normY / dist) * (terrain.radiusY + this.radius + 5);
                            this.x = terrain.x + pushX;
                            this.y = terrain.y + pushY;
                        }
                    }
                }
                
                // Invincibility timer
                if (this.invincible > 0) this.invincible -= dt;
                
                // Regen (uses heal() for holy book radiation)
                if (this.regenRate > 0) {
                    let regenMultiplier = 1;
                    // Temporal Shield: 150% regen boost during effect
                    if (legendaryEffects.timeSlow.active && Date.now() < legendaryEffects.timeSlow.regenBoostEnd) {
                        regenMultiplier = 2.5; // 150% bonus = 250% total
                    }
                    this.heal(this.regenRate * regenMultiplier * dt / 1000);
                }
                
                // Shield regen (much faster when out of combat)
                if (this.maxShieldHp > 0 && this.shieldHp < this.maxShieldHp) {
                    const timeSinceCombat = Date.now() - playerLastCombatTime;
                    if (timeSinceCombat > this.shieldRegenDelay) {
                        // Out of combat - fast regen
                        this.shieldHp = Math.min(this.maxShieldHp, this.shieldHp + this.shieldRegenRate * dt / 1000);
                    }
                }
                
                // Fire weapons
                this.fireWeapons(dt);
                
                // Update active meteor strikes
                const meteorState = this.weapons['meteorStrike'];
                if (meteorState) {
                    this.updateMeteors(meteorState, Date.now());
                }
            }

            fireWeapons(dt) {
                const now = Date.now();
                
                for (const [weaponId, weaponState] of Object.entries(this.weapons)) {
                    const weaponDef = WEAPONS[weaponId];
                    const level = weaponState.level;
                    
                    switch (weaponDef.type) {
                        case 'projectile':
                            this.fireProjectile(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'orbit':
                            this.updateOrbit(weaponId, weaponDef, weaponState, level, dt);
                            break;
                        case 'aoe':
                            this.fireAOE(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'laser':
                            this.fireLaser(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'chain':
                            this.fireChain(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'daggers':
                            this.fireDaggers(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'flame':
                            this.updateFlame(weaponId, weaponDef, weaponState, level, now, dt);
                            break;
                        case 'boomerang':
                            this.fireBoomerang(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'thunder':
                            this.fireThunder(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'aura':
                            this.updateAura(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'ice':
                            this.fireIceShards(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'meteor':
                            this.fireMeteor(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'homing':
                            this.fireSpiritOrbs(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'squirrel':
                            this.fireSquirrel(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'chainlightning':
                            this.fireChainLightning(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'starfall':
                            this.updateStarfall(weaponId, weaponDef, weaponState, level, now, dt);
                            break;
                        case 'arrows':
                            this.fireArrows(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'gravity':
                            this.fireGravityWell(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'ricochet':
                            this.fireRicochetDisc(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'mine':
                            this.dropMine(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'shotgun':
                            this.fireShotgun(weaponId, weaponDef, weaponState, level, now);
                            this.updateShotgunPellets(weaponState, weaponDef, level, now, dt);
                            break;
                    }
                }
            }

            fireProjectile(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const projectileCount = def.baseProjectiles + Math.floor(level / 4);
                const totalDamage = baseDamage * projectileCount;
                const sizeScale = 1 + (level - 1) * 0.03; // +3% size per level
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const pierce = 1 + Math.floor(level / 3); // +1 pierce per 3 levels
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const spread = 0.2;
                
                for (let i = 0; i < projectileCount; i++) {
                    const a = angle + (i - (projectileCount - 1) / 2) * spread;
                    projectiles.push(new Projectile(
                        this.x, this.y, a, 4.4, baseDamage, def.color, 'bolt', pierce, sizeScale
                    ));
                }
            }

            updateOrbit(id, def, state, level, dt) {
                const orbCount = def.baseOrbs + Math.floor(level / 4);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const radius = 70 + level * 5;
                
                // Initialize shield charges (one per orb)
                const maxCharges = def.baseCharges ? def.baseCharges + Math.floor(level / 3) : orbCount;
                if (state.shieldCharges === undefined) {
                    state.shieldCharges = maxCharges;
                    state.maxShieldCharges = maxCharges;
                    state.chargeRegenTimers = [];
                }
                state.maxShieldCharges = maxCharges;
                
                // Regenerate charges over time
                const regenTime = def.chargeRegenTime || 8000;
                const now = Date.now();
                for (let i = state.chargeRegenTimers.length - 1; i >= 0; i--) {
                    if (now >= state.chargeRegenTimers[i]) {
                        state.shieldCharges = Math.min(state.maxShieldCharges, state.shieldCharges + 1);
                        state.chargeRegenTimers.splice(i, 1);
                        spawnParticles(player.x, player.y, def.color, 8);
                    }
                }
                
                // Initialize angle if needed
                if (state.angle === undefined) state.angle = 0;
                state.angle += dt * 0.00225 * player.attackSpeedMultiplier;
                
                // Active orbs based on charges
                const activeOrbs = Math.min(orbCount, state.shieldCharges);
                
                for (let i = 0; i < activeOrbs; i++) {
                    const angle = state.angle + (Math.PI * 2 / orbCount) * i;
                    const ox = player.x + Math.cos(angle) * radius;
                    const oy = player.y + Math.sin(angle) * radius;
                    
                    // Check collision with enemies
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - ox, enemy.y - oy);
                        if (dist < enemy.radius + 14 && enemy.orbHitCooldown <= 0) {
                            const { damage, isCrit } = player.calcDamage(baseDamage);
                            enemy.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                            applyStatusEffects(enemy, damage);
                            enemy.orbHitCooldown = 250;
                            
                            // Knockback (smooth)
                            if (def.knockbackForce) {
                                const knockAngle = Math.atan2(enemy.y - ox, enemy.x - ox);
                                enemy.applyKnockback(knockAngle, def.knockbackForce);
                            }
                            
                            spawnParticles(ox, oy, def.color, 6);
                        }
                    }
                    
                    // Check collision with leprechauns
                    for (const lep of leprechauns) {
                        if (lep.dead) continue;
                        const dist = Math.hypot(lep.x - ox, lep.y - oy);
                        if (dist < lep.radius + 14 && lep.orbHitCooldown <= 0) {
                            const { damage, isCrit } = player.calcDamage(baseDamage);
                            lep.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                            lep.orbHitCooldown = 250;
                            
                            // Knockback (smooth)
                            if (def.knockbackForce) {
                                const knockAngle = Math.atan2(lep.y - ox, lep.x - ox);
                                lep.applyKnockback(knockAngle, def.knockbackForce);
                            }
                            
                            spawnParticles(ox, oy, COLORS.gold, 6);
                        }
                    }
                    
                    // Check collision with bosses
                    for (const boss of bosses) {
                        if (boss.dead) continue;
                        const dist = Math.hypot(boss.x - ox, boss.y - oy);
                        if (dist < boss.radius + 14 && boss.orbHitCooldown <= 0) {
                            const { damage, isCrit } = player.calcDamage(baseDamage);
                            boss.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                            boss.orbHitCooldown = 250;
                            
                            // Knockback (reduced for bosses, smooth)
                            if (def.knockbackForce) {
                                const knockAngle = Math.atan2(boss.y - ox, boss.x - ox);
                                boss.applyKnockback(knockAngle, def.knockbackForce * 0.3);
                            }
                            
                            spawnParticles(ox, oy, boss.color, 6);
                        }
                    }
                }
                
                // Store for rendering
                state.orbCount = orbCount;
                state.activeOrbs = activeOrbs;
                state.radius = radius;
            }
            
            // Shield block helper - call this when player would take damage
            tryShieldBlock(weaponState, def) {
                if (!weaponState || weaponState.shieldCharges === undefined || weaponState.shieldCharges <= 0) {
                    return false;
                }
                
                // Consume a charge
                weaponState.shieldCharges--;
                
                // Start regen timer for this charge
                const regenTime = def.chargeRegenTime || 8000;
                weaponState.chargeRegenTimers.push(Date.now() + regenTime);
                
                // AOE burst damage
                if (def.burstDamage && def.burstRadius) {
                    const level = weaponState.level || 1;
                    const burstDmg = def.burstDamage * (1 + level * 0.05);
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                        if (dist < def.burstRadius + enemy.radius) {
                            const { damage, isCrit } = player.calcDamage(burstDmg);
                            enemy.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                            
                            // Knockback from burst (smooth)
                            const knockAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                            enemy.applyKnockback(knockAngle, def.knockbackForce || 60);
                        }
                    }
                    for (const boss of bosses) {
                        if (boss.dead) continue;
                        const dist = Math.hypot(boss.x - player.x, boss.y - player.y);
                        if (dist < def.burstRadius + boss.radius) {
                            const { damage, isCrit } = player.calcDamage(burstDmg);
                            boss.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                        }
                    }
                }
                
                // Visual feedback
                spawnParticles(player.x, player.y, def.color, 15);
                
                return true;
            }

            fireAOE(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                state.lastFire = now;
                const radius = def.baseRadius + level * 10;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                
                // Visual wave
                state.waveRadius = 0;
                state.waveMaxRadius = radius;
                state.waveActive = true;
                
                // Spawn boombox icon above player
                state.boomboxIcon = {
                    y: -35,
                    alpha: 0,
                    scale: 1,
                    phase: 'fadeIn'
                };
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue; // Skip dead enemies
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        enemy.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                        applyStatusEffects(enemy, damage);
                    }
                }
                
                // Also hit leprechauns
                for (const lep of leprechauns) {
                    if (lep.dead) continue;
                    const dist = Math.hypot(lep.x - this.x, lep.y - this.y);
                    if (dist < radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        lep.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
                
                // Also hit bosses
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist < radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        boss.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
            }

            fireLaser(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const pierce = def.pierce + Math.floor(level / 4);
                const sizeScale = 1 + (level - 1) * 0.03; // +3% size per level
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                projectiles.push(new Projectile(
                    this.x, this.y, angle, 6, baseDamage, def.color, 'laser', pierce, sizeScale
                ));
            }

            fireChain(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Filter enemies within range (135 base + 11 per level, 25% reduced)
                const chainRange = 135 + level * 11;
                const aliveEnemies = enemies.filter(e => !e.dead && Math.hypot(e.x - this.x, e.y - this.y) < chainRange);
                const aliveBosses = bosses.filter(b => !b.dead && Math.hypot(b.x - this.x, b.y - this.y) < chainRange);
                const allTargets = [...aliveEnemies, ...aliveBosses];
                if (allTargets.length === 0) return;
                
                state.lastFire = now;
                const targetCount = def.baseTargets + Math.floor(level / 4);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                
                // Efficient random sample instead of full shuffle
                const targets = randomSample(allTargets, targetCount);
                for (const target of targets) {
                    const { damage, isCrit } = this.calcDamage(baseDamage);
                    target.takeDamage(damage, isCrit);
                    this.onDealDamage(damage);
                    
                    // Visual lightning (with cleanup)
                    if (!state.chainTargets) state.chainTargets = [];
                    state.chainTargets.push({ x: target.x, y: target.y, time: now });
                    spawnParticles(target.x, target.y, def.color, 8);
                }
                
                // Clean up old chain targets (slower fade - 380ms)
                if (state.chainTargets) {
                    state.chainTargets = state.chainTargets.filter(t => now - t.time < 380);
                }
            }

            // === NEW WEAPON METHODS ===
            
            fireDaggers(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                state.lastFire = now;
                const daggerCount = def.baseDaggers + Math.floor(level / 2);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const pierce = 1 + Math.floor(level / 5); // +1 pierce per 5 levels
                const sizeScale = 1 + (level - 1) * 0.03; // +3% size per level
                
                // Fire daggers in all directions
                for (let i = 0; i < daggerCount; i++) {
                    const angle = (Math.PI * 2 / daggerCount) * i;
                    projectiles.push(new Projectile(
                        this.x, this.y, angle, 7, baseDamage, def.color, 'dagger', pierce, sizeScale
                    ));
                }
            }
            
            updateFlame(id, def, state, level, now, dt) {
                const fireRate = def.baseFireRate / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const range = def.baseRange + level * 12;
                const coneAngle = def.baseAngle + level * 0.04;
                
                // Check if any enemies are within activation range (1.5x flame range)
                const activationRange = range * 1.5;
                const allTargets = [...enemies.filter(e => !e.dead), ...bosses.filter(b => !b.dead)];
                let hasNearbyEnemy = false;
                
                for (const target of allTargets) {
                    const dist = Math.hypot(target.x - this.x, target.y - this.y);
                    if (dist <= activationRange) {
                        hasNearbyEnemy = true;
                        break;
                    }
                }
                
                // Track when we last saw an enemy for linger effect
                if (hasNearbyEnemy) {
                    state.lastEnemySeen = now;
                }
                
                // Linger for 2 seconds after enemies die/leave
                const lingerDuration = 2000;
                const timeSinceEnemy = now - (state.lastEnemySeen || 0);
                
                // Turn off flame if no enemies nearby AND linger time expired
                if (!hasNearbyEnemy && timeSinceEnemy > lingerDuration) {
                    state.flameActive = false;
                    return;
                }
                
                state.lastFire = now;
                
                // Find the direction with the most enemies (AOE targeting)
                let targetAngle = state.targetAngle || 0;
                
                if (allTargets.length > 0) {
                    // Sample 16 directions for finer targeting precision
                    let bestAngle = targetAngle;
                    let bestScore = 0;
                    
                    for (let i = 0; i < 16; i++) {
                        const testAngle = (Math.PI * 2 / 16) * i;
                        let score = 0;
                        
                        for (const target of allTargets) {
                            const dist = Math.hypot(target.x - this.x, target.y - this.y);
                            if (dist > range * 1.2) continue;
                            
                            const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                            let angleDiff = Math.abs(angleToTarget - testAngle);
                            if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                            
                            if (angleDiff < coneAngle / 2) {
                                // Weight by inverse distance and how centered the enemy is
                                const distScore = 1 + (range - dist) / range;
                                const centerScore = 1 - (angleDiff / (coneAngle / 2)) * 0.5; // Bonus for centered enemies
                                score += distScore * centerScore;
                            }
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestAngle = testAngle;
                        }
                    }
                    
                    // If best score found, refine by averaging angles to enemies in that direction
                    if (bestScore > 0) {
                        let sumX = 0, sumY = 0, count = 0;
                        for (const target of allTargets) {
                            const dist = Math.hypot(target.x - this.x, target.y - this.y);
                            if (dist > range * 1.2) continue;
                            
                            const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                            let angleDiff = Math.abs(angleToTarget - bestAngle);
                            if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                            
                            if (angleDiff < coneAngle / 2) {
                                // Weight closer enemies more in the average
                                const weight = 1 + (range - dist) / range;
                                sumX += Math.cos(angleToTarget) * weight;
                                sumY += Math.sin(angleToTarget) * weight;
                                count += weight;
                            }
                        }
                        if (count > 0) {
                            bestAngle = Math.atan2(sumY / count, sumX / count);
                        }
                    } else {
                        // Fall back to nearest enemy
                        const nearest = findNearestEnemy(this.x, this.y);
                        if (nearest) {
                            bestAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        }
                    }
                    
                    state.targetAngle = bestAngle;
                }
                
                // Smooth interpolation towards target angle (prevents jumping)
                if (state.currentAngle === undefined) state.currentAngle = targetAngle;
                
                // Calculate shortest rotation direction
                let angleDiff = state.targetAngle - state.currentAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // Smooth eased rotation - faster tracking with smooth deceleration
                // Uses lerp-style interpolation: faster when far, slows as it approaches
                const lerpSpeed = 0.28; // Higher = snappier response
                const minSpeed = 0.03; // Minimum rotation to prevent stalling
                
                if (Math.abs(angleDiff) > 0.01) {
                    // Lerp towards target with minimum speed guarantee
                    const lerpAmount = angleDiff * lerpSpeed;
                    const clampedAmount = Math.sign(lerpAmount) * Math.max(Math.abs(lerpAmount), minSpeed);
                    state.currentAngle += Math.abs(clampedAmount) > Math.abs(angleDiff) ? angleDiff : clampedAmount;
                } else {
                    state.currentAngle = state.targetAngle;
                }
                
                // Normalize current angle
                while (state.currentAngle > Math.PI) state.currentAngle -= Math.PI * 2;
                while (state.currentAngle < -Math.PI) state.currentAngle += Math.PI * 2;
                
                const facing = state.currentAngle;
                
                // Store for rendering
                state.flameAngle = facing;
                state.flameRange = range;
                state.flameCone = coneAngle;
                state.flameActive = now;
                
                // Damage enemies in cone
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist > range) continue;
                    
                    const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                    let angleDiffCheck = Math.abs(angleToEnemy - facing);
                    if (angleDiffCheck > Math.PI) angleDiffCheck = Math.PI * 2 - angleDiffCheck;
                    
                    if (angleDiffCheck < coneAngle / 2) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        enemy.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
                
                // Damage bosses in cone
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist > range) continue;
                    
                    const angleToBoss = Math.atan2(boss.y - this.y, boss.x - this.x);
                    let angleDiffCheck = Math.abs(angleToBoss - facing);
                    if (angleDiffCheck > Math.PI) angleDiffCheck = Math.PI * 2 - angleDiffCheck;
                    
                    if (angleDiffCheck < coneAngle / 2) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        boss.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
            }
            
            fireBoomerang(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const count = def.baseCount + Math.floor(level / 6);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const sizeScale = 1 + (level - 1) * 0.03; // +3% size per level
                
                for (let i = 0; i < count; i++) {
                    const angleOffset = count > 1 ? (i - (count - 1) / 2) * 0.4 : 0;
                    const angle = Math.atan2(target.y - this.y, target.x - this.x) + angleOffset;
                    
                    // Create boomerang projectile (slower speed)
                    const boom = new Projectile(this.x, this.y, angle, 3.5, baseDamage, def.color, 'boomerang', 999, sizeScale);
                    boom.startX = this.x;
                    boom.startY = this.y;
                    boom.maxDist = 250 + level * 12;
                    boom.returning = false;
                    boom.spinAngle = 0;
                    projectiles.push(boom);
                }
            }
            
            fireThunder(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Range limit for lightning strikes
                const strikeRange = def.baseRange + level * 10;
                
                // Include bosses as potential targets within range
                const aliveEnemies = enemies.filter(e => !e.dead && Math.hypot(e.x - this.x, e.y - this.y) < strikeRange);
                const aliveBosses = bosses.filter(b => !b.dead && Math.hypot(b.x - this.x, b.y - this.y) < strikeRange);
                const allTargets = [...aliveEnemies, ...aliveBosses];
                if (allTargets.length === 0) return;
                
                state.lastFire = now;
                const strikeCount = def.baseStrikes + Math.floor(level / 4);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                
                // Store strikes for rendering
                if (!state.strikes) state.strikes = [];
                
                const targets = randomSample(allTargets, strikeCount);
                for (const target of targets) {
                    const { damage, isCrit } = this.calcDamage(baseDamage);
                    target.takeDamage(damage, isCrit);
                    this.onDealDamage(damage);
                    
                    // Visual lightning strike
                    state.strikes.push({ 
                        x: target.x, 
                        y: target.y, 
                        time: now,
                        segments: generateLightning(target.x, target.y - 400, target.x, target.y)
                    });
                    spawnParticles(target.x, target.y, def.color, 12);
                }
                
                // Cleanup old strikes
                state.strikes = state.strikes.filter(s => now - s.time < 350);
            }
            
            updateAura(id, def, state, level, now) {
                const tickRate = def.tickRate / this.attackSpeedMultiplier;
                if (now - (state.lastTick || 0) < tickRate) return;
                
                state.lastTick = now;
                const radius = def.baseRadius + level * 10;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                
                // Store for rendering
                state.auraRadius = radius;
                state.auraPulse = now;
                
                // Poison regular enemies
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < radius + enemy.radius) {
                        enemy.applyPoison(baseDamage);
                    }
                }
                
                // Poison bosses
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist < radius + boss.radius) {
                        boss.applyPoison(baseDamage);
                    }
                }
                
                // Poison leprechauns
                for (const lep of leprechauns) {
                    if (lep.dead) continue;
                    const dist = Math.hypot(lep.x - this.x, lep.y - this.y);
                    if (dist < radius + lep.radius) {
                        lep.applyPoison(baseDamage);
                    }
                }
            }
            
            updateStarfall(id, def, state, level, now, dt) {
                const tickRate = def.tickRate / this.attackSpeedMultiplier;
                if (now - (state.lastTick || 0) < tickRate) return;
                
                state.lastTick = now;
                const radius = def.baseRadius + level * 15;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                
                // Initialize falling stars array
                if (!state.fallingStars) state.fallingStars = [];
                
                // Store radius for rendering
                state.starfallRadius = radius;
                
                // Spawn new falling stars (spread across the area)
                const starCount = 3 + Math.floor(level / 4);
                for (let i = 0; i < starCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    // Use sqrt for more uniform area distribution (prevents clustering near center)
                    const dist = Math.sqrt(Math.random()) * radius;
                    const targetX = this.x + Math.cos(angle) * dist;
                    const targetY = this.y + Math.sin(angle) * dist;
                    
                    state.fallingStars.push({
                        x: targetX,
                        y: targetY,
                        startY: targetY - 180 - Math.random() * 80,
                        startTime: now + Math.random() * 250,
                        duration: 350 + Math.random() * 100,
                        size: 6 + Math.random() * 5,
                        rotation: Math.random() * Math.PI * 2
                    });
                }
                
                // Damage enemies in radius
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < radius + enemy.radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        enemy.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                        applyStatusEffects(enemy, damage);
                    }
                }
                
                // Damage bosses
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist < radius + boss.radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        boss.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
                
                // Damage leprechauns
                for (const lep of leprechauns) {
                    if (lep.dead) continue;
                    const dist = Math.hypot(lep.x - this.x, lep.y - this.y);
                    if (dist < radius + lep.radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        lep.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
                
                // Cleanup old stars
                state.fallingStars = state.fallingStars.filter(s => now - s.startTime < s.duration + 200);
            }
            
            // === MORE NEW WEAPON METHODS ===
            
            fireIceShards(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const shardCount = def.baseProjectiles + Math.floor(level / 4);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const sizeScale = 1 + (level - 1) * 0.03; // +3% size per level
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const pierce = 1 + Math.floor(level / 4); // +1 pierce per 4 levels
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const spread = 0.25;
                
                for (let i = 0; i < shardCount; i++) {
                    const a = angle + (i - (shardCount - 1) / 2) * spread;
                    const proj = new Projectile(this.x, this.y, a, 5, baseDamage, def.color, 'ice', pierce, sizeScale);
                    proj.slowAmount = def.slowAmount;
                    proj.slowDuration = def.slowDuration;
                    proj.iceTarget = target; // Store initial target for homing
                    projectiles.push(proj);
                }
            }
            
            fireMeteor(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Fixed targeting range based on target visible area (consistent across all devices)
                const maxRange = Math.hypot(TARGET_VISIBLE_WIDTH, TARGET_VISIBLE_HEIGHT) / 2 * 0.45;
                
                // Find cluster of enemies or random nearby location
                let targetX, targetY;
                const nearbyEnemies = enemies.filter(e => !e.dead && Math.hypot(e.x - this.x, e.y - this.y) < maxRange);
                
                if (nearbyEnemies.length > 0) {
                    const target = nearbyEnemies[Math.floor(Math.random() * nearbyEnemies.length)];
                    targetX = target.x;
                    targetY = target.y;
                } else {
                    return; // No targets
                }
                
                state.lastFire = now;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const blastRadius = def.blastRadius + level * 5;
                const meteorCount = 1 + Math.floor(level / 5);
                
                // Initialize meteors array
                if (!state.meteors) state.meteors = [];
                
                for (let i = 0; i < meteorCount; i++) {
                    const offsetX = (Math.random() - 0.5) * 100;
                    const offsetY = (Math.random() - 0.5) * 100;
                    state.meteors.push({
                        x: targetX + offsetX,
                        y: targetY + offsetY,
                        startTime: now + i * 150,
                        damage: baseDamage,
                        radius: blastRadius,
                        impactTime: now + 500 + i * 150
                    });
                }
            }
            
            updateMeteors(state, now) {
                if (!state.meteors) return;
                
                for (let i = state.meteors.length - 1; i >= 0; i--) {
                    const meteor = state.meteors[i];
                    
                    if (now >= meteor.impactTime && !meteor.exploded) {
                        meteor.exploded = true;
                        
                        // Deal damage in blast radius
                        for (const enemy of enemies) {
                            if (enemy.dead) continue;
                            const dist = Math.hypot(enemy.x - meteor.x, enemy.y - meteor.y);
                            if (dist < meteor.radius + enemy.radius) {
                                const { damage, isCrit } = this.calcDamage(meteor.damage);
                                enemy.takeDamage(damage, isCrit);
                                this.onDealDamage(damage);
                            }
                        }
                        
                        for (const boss of bosses) {
                            if (boss.dead) continue;
                            const dist = Math.hypot(boss.x - meteor.x, boss.y - meteor.y);
                            if (dist < meteor.radius + boss.radius) {
                                const { damage, isCrit } = this.calcDamage(meteor.damage);
                                boss.takeDamage(damage, isCrit);
                                this.onDealDamage(damage);
                            }
                        }
                        
                        spawnParticles(meteor.x, meteor.y, '#ff4400', 12);
                        spawnParticles(meteor.x, meteor.y, '#ffaa00', 8);
                    }
                    
                    // Remove after explosion animation
                    if (now > meteor.impactTime + 300) {
                        state.meteors.splice(i, 1);
                    }
                }
            }
            
            fireSpiritOrbs(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                if (enemies.filter(e => !e.dead).length === 0) return;
                
                state.lastFire = now;
                const orbCount = def.baseOrbs + Math.floor(level / 4);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const sizeScale = 1 + (level - 1) * 0.03; // +3% size per level
                
                // Random base angle so orbs don't always exit from same direction
                const baseAngle = Math.random() * Math.PI * 2;
                
                for (let i = 0; i < orbCount; i++) {
                    const angle = baseAngle + (Math.PI * 2 / orbCount) * i + Math.random() * 0.5;
                    const proj = new Projectile(this.x, this.y, angle, 3, baseDamage, def.color, 'homing', 1, sizeScale);
                    proj.isHoming = true;
                    proj.homingStrength = 0.08;
                    proj.lifetime = 3000;
                    proj.spawnTime = now;
                    projectiles.push(proj);
                }
            }
            
            fireSquirrel(id, def, state, level, now) {
                // +1 squirrel at levels 2, 4, 6, 8...
                const squirrelCount = def.baseSquirrels + Math.floor(level / 2);
                const pounceDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const walkDamage = def.walkDamage * (1 + (level - 1) * 0.04);
                const sizeScale = 1 + (level - 1) * 0.025;
                const pounceCooldown = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                
                // Find existing pet squirrels
                const existingSquirrels = projectiles.filter(p => p.isPetSquirrel && !p.dead);
                
                // Spawn new squirrels if we don't have enough
                while (existingSquirrels.length < squirrelCount) {
                    const offsetAngle = Math.random() * Math.PI * 2;
                    const spawnDist = 80 + Math.random() * 40; // Spawn 80-120px away from player
                    const proj = new Projectile(
                        this.x + Math.cos(offsetAngle) * spawnDist,
                        this.y + Math.sin(offsetAngle) * spawnDist,
                        0, 2.0, walkDamage, def.color, 'squirrel', 999, sizeScale
                    );
                    proj.isPetSquirrel = true;
                    proj.isSquirrel = true;
                    proj.squirrelState = 'walking'; // walking, winding, pouncing, returning
                    proj.pounceDamage = pounceDamage;
                    proj.walkDamage = walkDamage;
                    proj.splashRadius = def.splashRadius || 45;
                    proj.lastPounce = now - pounceCooldown; // Ready to pounce immediately
                    proj.pounceCooldown = pounceCooldown;
                    proj.maxDist = 306 + level * 31; // Pounce range (+10% from 278)
                    proj.animFrame = 0;
                    proj.animTimer = 0;
                    proj.wobble = 0;
                    proj.walkHitCooldown = 0;
                    projectiles.push(proj);
                    existingSquirrels.push(proj);
                }
                
                // Check if any walking squirrels are ready to pounce
                // Stagger attacks: only one squirrel can start pouncing every 200ms
                if (!state.lastSquirrelPounceTime) state.lastSquirrelPounceTime = 0;
                if (!state.lastHighPriorityTarget) state.lastHighPriorityTarget = false; // Track if last pounce was high priority
                const squirrelStaggerDelay = 200; // 0.2 seconds between squirrel attacks
                
                for (const sq of existingSquirrels) {
                    if (sq.squirrelState !== 'walking') continue;
                    if (now - sq.lastPounce < sq.pounceCooldown) continue;
                    if (now - state.lastSquirrelPounceTime < squirrelStaggerDelay) continue; // Stagger check
                    
                    // Pounce range is based on player position, not squirrel position
                    const pounceRange = sq.maxDist * 0.85; // Must be within 85% of max pounce distance from player
                    let bestTarget = null;
                    let bestScore = -1;
                    let bestHighPriorityTarget = null;
                    let bestHighPriorityScore = -1;
                    let bestRegularTarget = null;
                    let bestRegularScore = -1;
                    
                    // Score enemies by distance from PLAYER and clustering
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const distFromPlayer = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                        if (distFromPlayer > pounceRange) continue; // Must be in pounce range from player
                        
                        const distFromSquirrel = Math.hypot(enemy.x - sq.x, enemy.y - sq.y);
                        let score = 1 + (1 - distFromPlayer / pounceRange) * 2; // Prefer closer to player
                        score += (1 - Math.min(distFromSquirrel, pounceRange) / pounceRange) * 0.5; // Small bonus for closer to squirrel
                        
                        // Bonus for clustered enemies
                        for (const other of enemies) {
                            if (other === enemy || other.dead) continue;
                            const clusterDist = Math.hypot(other.x - enemy.x, other.y - enemy.y);
                            if (clusterDist < 80) score += 0.5;
                        }
                        
                        // Bonus for higher health targets
                        score += (enemy.hp / (enemy.maxHp || 100)) * 0.5;
                        
                        if (score > bestRegularScore) {
                            bestRegularScore = score;
                            bestRegularTarget = enemy;
                        }
                    }
                    
                    // Check leprechauns (high priority)
                    for (const lep of leprechauns) {
                        if (lep.dead) continue;
                        const distFromPlayer = Math.hypot(lep.x - this.x, lep.y - this.y);
                        if (distFromPlayer > pounceRange) continue;
                        
                        const score = 8 + (1 - distFromPlayer / pounceRange) * 3; // High base priority
                        if (score > bestHighPriorityScore) {
                            bestHighPriorityScore = score;
                            bestHighPriorityTarget = lep;
                        }
                    }
                    
                    // Check bosses (high priority)
                    for (const boss of bosses) {
                        if (boss.dead) continue;
                        const distFromPlayer = Math.hypot(boss.x - this.x, boss.y - this.y);
                        if (distFromPlayer > pounceRange) continue; // Must be in pounce range from player
                        
                        let score = 6 + (1 - distFromPlayer / pounceRange) * 3;
                        // Bonus for higher health bosses
                        score += (boss.hp / (boss.maxHp || 1000)) * 2;
                        
                        if (score > bestHighPriorityScore) {
                            bestHighPriorityScore = score;
                            bestHighPriorityTarget = boss;
                        }
                    }
                    
                    // Alternating target selection: bounce between high priority and regular enemies
                    if (bestHighPriorityTarget && bestRegularTarget) {
                        // If last was high priority, go for regular (highest health), else go for high priority
                        if (state.lastHighPriorityTarget) {
                            bestTarget = bestRegularTarget;
                            state.lastHighPriorityTarget = false;
                        } else {
                            bestTarget = bestHighPriorityTarget;
                            state.lastHighPriorityTarget = true;
                        }
                    } else if (bestHighPriorityTarget) {
                        bestTarget = bestHighPriorityTarget;
                        state.lastHighPriorityTarget = true;
                    } else if (bestRegularTarget) {
                        bestTarget = bestRegularTarget;
                        state.lastHighPriorityTarget = false;
                    }
                    
                    if (bestTarget) {
                        // Start pounce! Store reference to track enemy
                        sq.squirrelState = 'winding';
                        sq.windStart = now;
                        sq.pounceTargetRef = bestTarget; // Store enemy reference
                        sq.pounceTarget = { x: bestTarget.x, y: bestTarget.y };
                        sq.startX = sq.x;
                        sq.startY = sq.y;
                        sq.damage = sq.pounceDamage; // Switch to pounce damage
                        sq.hitEnemies.clear();
                        state.lastSquirrelPounceTime = now; // Update stagger timer
                        break; // Only one squirrel starts pouncing per frame
                    }
                }
            }
            
            fireChainLightning(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const chainCount = def.baseChains + Math.floor(level / 4);
                const chainRange = def.chainRange + level * 10;
                
                // Initialize chain visualization
                if (!state.chains) state.chains = [];
                
                // Chain through enemies
                let currentTarget = target;
                let hitTargets = new Set([target]);
                let chainPoints = [{ x: this.x, y: this.y }];
                
                const { damage: firstDamage, isCrit: firstCrit } = this.calcDamage(baseDamage);
                currentTarget.takeDamage(firstDamage, firstCrit);
                this.onDealDamage(firstDamage);
                chainPoints.push({ x: currentTarget.x, y: currentTarget.y });
                spawnParticles(currentTarget.x, currentTarget.y, def.color, 6);
                
                for (let i = 0; i < chainCount; i++) {
                    // Find next target in range
                    let nextTarget = null;
                    let closestDist = chainRange;
                    
                    for (const enemy of enemies) {
                        if (enemy.dead || hitTargets.has(enemy)) continue;
                        const dist = Math.hypot(enemy.x - currentTarget.x, enemy.y - currentTarget.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            nextTarget = enemy;
                        }
                    }
                    
                    if (!nextTarget) break;
                    
                    hitTargets.add(nextTarget);
                    const { damage, isCrit } = this.calcDamage(baseDamage * 0.8); // Reduced damage per chain
                    nextTarget.takeDamage(damage, isCrit);
                    this.onDealDamage(damage);
                    chainPoints.push({ x: nextTarget.x, y: nextTarget.y });
                    spawnParticles(nextTarget.x, nextTarget.y, def.color, 4);
                    currentTarget = nextTarget;
                }
                
                state.chains.push({ points: chainPoints, time: now });
                
                // Cleanup old chains (300ms duration)
                state.chains = state.chains.filter(c => now - c.time < 300);
            }

            // === SPECTRAL ARROWS ===
            fireArrows(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const arrowCount = def.baseArrows + Math.floor(level / 5);
                const pierce = def.pierce + Math.floor(level / 4);
                
                const baseAngle = Math.atan2(target.y - this.y, target.x - this.x);
                const spread = 0.15;
                
                for (let i = 0; i < arrowCount; i++) {
                    const angle = baseAngle + (i - (arrowCount - 1) / 2) * spread;
                    const proj = new Projectile(
                        this.x, this.y, angle, 7, baseDamage, def.color, 'arrow', pierce, 1
                    );
                    proj.trailDuration = def.trailDuration;
                    proj.trailDamage = def.trailDamage * (1 + (level - 1) * 0.03);
                    proj.trailPoints = [];
                    projectiles.push(proj);
                }
            }

            // === GRAVITY WELL ===
            fireGravityWell(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Find cluster of enemies to target
                let bestPos = null;
                let bestScore = 0;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist > 500) continue;
                    
                    let score = 1;
                    for (const other of enemies) {
                        if (other.dead) continue;
                        const d = Math.hypot(other.x - enemy.x, other.y - enemy.y);
                        if (d < def.pullRadius * 1.5) score++;
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestPos = { x: enemy.x, y: enemy.y };
                    }
                }
                
                if (!bestPos) return;
                
                state.lastFire = now;
                
                // Initialize wells array
                if (!state.wells) state.wells = [];
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.05);
                const pullRadius = def.pullRadius + level * 5;
                const visualRadius = def.visualRadius + level * 3;
                const duration = def.duration + level * 200;
                
                // Create projectile toward target (speed 1.725 -> 2.24, +30%)
                const angle = Math.atan2(bestPos.y - this.y, bestPos.x - this.x);
                const proj = new Projectile(
                    this.x, this.y, angle, 2.24, 0, def.color, 'gravitywell', 999, 1.5
                );
                proj.isGravityWell = true;
                proj.targetX = bestPos.x;
                proj.targetY = bestPos.y;
                proj.wellDamage = baseDamage;
                proj.pullRadius = pullRadius;
                proj.visualRadius = visualRadius;
                proj.pullStrength = def.pullStrength;
                proj.wellDuration = duration;
                proj.tickRate = def.tickRate;
                proj.weaponState = state; // Reference to spawn well on arrival
                projectiles.push(proj);
            }

            // === RICOCHET DISC ===
            fireRicochetDisc(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const bounces = def.baseBounces + Math.floor(level / 3);
                const bounceRange = def.bounceRange + level * 10;
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const proj = new Projectile(
                    this.x, this.y, angle, 5.5, baseDamage, def.color, 'disc', 1, 1.2
                );
                proj.bouncesLeft = bounces;
                proj.bounceRange = bounceRange;
                proj.hitEnemies = new Set();
                proj.targetRef = target;
                projectiles.push(proj);
            }

            // === CALTROPS ===
            // === PULSE MINE ===
            dropMine(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.985, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Initialize mines array
                if (!state.mines) state.mines = [];
                
                // Remove expired mines
                state.mines = state.mines.filter(m => !m.exploded && now - m.startTime < m.duration);
                
                // Remove oldest mine if at max
                const maxMines = def.maxMines + Math.floor(level / 5);
                while (state.mines.length >= maxMines) {
                    state.mines.shift();
                }
                
                state.lastFire = now;
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.04);
                const blastRadius = def.blastRadius + level * 5;
                
                // Drop behind player based on movement
                const dropX = this.x - (this.lastMoveX || 0) * 40;
                const dropY = this.y - (this.lastMoveY || 0) * 40;
                
                state.mines.push({
                    x: dropX,
                    y: dropY,
                    damage: baseDamage,
                    blastRadius: blastRadius,
                    armTime: def.armTime,
                    startTime: now,
                    duration: def.mineDuration + level * 1000,
                    exploded: false,
                    armed: false
                });
            }
            
            // === SHOTGUN ===
            fireShotgun(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.97, level - 1) / this.attackSpeedMultiplier;
                if (now - (state.lastFire || 0) < fireRate) return;
                
                // Find nearest enemy to aim at
                let bestTarget = null;
                let bestDist = def.maxRange + level * 15;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestTarget = enemy;
                    }
                }
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist < bestDist * 1.2) {
                        bestDist = dist;
                        bestTarget = boss;
                    }
                }
                for (const lep of leprechauns) {
                    if (lep.dead) continue;
                    const dist = Math.hypot(lep.x - this.x, lep.y - this.y);
                    if (dist < bestDist * 1.1) {
                        bestDist = dist;
                        bestTarget = lep;
                    }
                }
                
                if (!bestTarget) return;
                
                state.lastFire = now;
                
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.06);
                const pelletCount = def.pelletCount + Math.floor(level / 3);
                const spreadAngle = def.spreadAngle + level * 0.02;
                const maxRange = def.maxRange + level * 15;
                const knockback = def.knockback + level * 5;
                
                // Base angle toward target
                const baseAngle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                
                // Initialize pellets array for rendering
                if (!state.pellets) state.pellets = [];
                
                // Store muzzle flash
                state.muzzleFlash = {
                    x: this.x,
                    y: this.y,
                    angle: baseAngle,
                    startTime: now
                };
                
                // Fire pellets in a spread pattern
                for (let i = 0; i < pelletCount; i++) {
                    // Distribute pellets across spread angle
                    const offsetAngle = (i - (pelletCount - 1) / 2) * (spreadAngle / pelletCount);
                    const pelletAngle = baseAngle + offsetAngle + (Math.random() - 0.5) * 0.1;
                    
                    const speed = 12 + Math.random() * 3;
                    state.pellets.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(pelletAngle) * speed,
                        vy: Math.sin(pelletAngle) * speed,
                        damage: baseDamage,
                        maxRange: maxRange,
                        knockback: knockback,
                        distTraveled: 0,
                        startTime: now,
                        hit: false
                    });
                }
                
                // Screen shake for shotgun feel
                if (camera.shake) camera.shake(3, 80);
            }
            
            // Update shotgun pellets (called from main update)
            updateShotgunPellets(state, def, level, now, dt) {
                if (!state.pellets) return;
                
                const maxRange = def.maxRange + level * 15;
                
                for (const pellet of state.pellets) {
                    if (pellet.hit) continue;
                    
                    // Move pellet
                    pellet.x += pellet.vx;
                    pellet.y += pellet.vy;
                    pellet.distTraveled += Math.hypot(pellet.vx, pellet.vy);
                    
                    // Check if max range reached
                    if (pellet.distTraveled > maxRange) {
                        pellet.hit = true;
                        continue;
                    }
                    
                    // Distance-based damage multiplier (2x at point blank, 0.5x at max range)
                    const distRatio = pellet.distTraveled / maxRange;
                    const damageMultiplier = 2 - distRatio * 1.5;
                    
                    // Check hits
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - pellet.x, enemy.y - pellet.y);
                        if (dist < enemy.radius + 8) {
                            const { damage, isCrit } = this.calcDamage(pellet.damage * damageMultiplier);
                            enemy.takeDamage(damage, isCrit);
                            this.onDealDamage(damage);
                            
                            // Knockback (smooth)
                            const kbAngle = Math.atan2(pellet.vy, pellet.vx);
                            enemy.applyKnockback(kbAngle, pellet.knockback * (1 - distRatio * 0.5));
                            
                            spawnParticles(pellet.x, pellet.y, def.color, 4);
                            pellet.hit = true;
                            break;
                        }
                    }
                    
                    if (!pellet.hit) {
                        for (const boss of bosses) {
                            if (boss.dead) continue;
                            const dist = Math.hypot(boss.x - pellet.x, boss.y - pellet.y);
                            if (dist < boss.radius + 8) {
                                const { damage, isCrit } = this.calcDamage(pellet.damage * damageMultiplier);
                                boss.takeDamage(damage, isCrit);
                                this.onDealDamage(damage);
                                
                                // Reduced knockback on bosses (smooth)
                                const kbAngle = Math.atan2(pellet.vy, pellet.vx);
                                boss.applyKnockback(kbAngle, pellet.knockback * 0.3 * (1 - distRatio * 0.5));
                                
                                spawnParticles(pellet.x, pellet.y, def.color, 4);
                                pellet.hit = true;
                                break;
                            }
                        }
                    }
                    
                    if (!pellet.hit) {
                        for (const lep of leprechauns) {
                            if (lep.dead) continue;
                            const dist = Math.hypot(lep.x - pellet.x, lep.y - pellet.y);
                            if (dist < lep.radius + 8) {
                                const { damage, isCrit } = this.calcDamage(pellet.damage * damageMultiplier);
                                lep.takeDamage(damage, isCrit);
                                this.onDealDamage(damage);
                                
                                // Knockback (smooth)
                                const kbAngle = Math.atan2(pellet.vy, pellet.vx);
                                lep.applyKnockback(kbAngle, pellet.knockback * 0.5 * (1 - distRatio * 0.5));
                                
                                spawnParticles(pellet.x, pellet.y, COLORS.gold, 4);
                                pellet.hit = true;
                                break;
                            }
                        }
                    }
                }
                
                // Remove old pellets
                state.pellets = state.pellets.filter(p => !p.hit && now - p.startTime < 500);
            }

            draw() {
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const time = Date.now();
                
                ctx.save();
                
                // Pulse effect based on time
                const pulse = 1 + Math.sin(time * 0.005) * 0.05;
                const isInvincible = this.invincible > 0;
                const baseColor = isInvincible ? COLORS.pink : selectedPlayerColor;
                
                // Outer glow ring (static)
                ctx.shadowBlur = 25;
                ctx.shadowColor = baseColor;
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 1.2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Ground shadow
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(sx, sy + r * 0.8, r * 0.7, r * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Main glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = baseColor;
                
                // Body with gradient for 3D effect
                const bodyGrad = ctx.createRadialGradient(
                    sx, sy, 0,
                    sx, sy, r
                );
                if (isInvincible && Math.floor(time / 50) % 2) {
                    bodyGrad.addColorStop(0, 'transparent');
                    bodyGrad.addColorStop(1, 'transparent');
                } else {
                    bodyGrad.addColorStop(0, baseColor);
                    bodyGrad.addColorStop(0.6, baseColor + 'aa');
                    bodyGrad.addColorStop(1, baseColor + '55');
                }
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner core (bright center)
                const coreGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, r * 0.5);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.6)');
                coreGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Energy ring effect (rotating)
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.4;
                const ringAngle = time * 0.002;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.55, ringAngle, ringAngle + Math.PI * 1.2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.55, ringAngle + Math.PI, ringAngle + Math.PI * 2.2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Rolling glint - moves in direction of travel across ball surface
                const traversePos = Math.sin(this.rollAngle);  // -1 to 1 position along movement axis
                const depthPos = Math.cos(this.rollAngle);     // visibility: 1=front of ball, -1=back
                
                if (depthPos > 0) {  // Only show when on visible front of ball
                    const glintX = sx + Math.cos(this.moveAngle) * r * 0.8 * traversePos;
                    const glintY = sy + Math.sin(this.moveAngle) * r * 0.8 * traversePos;
                    
                    ctx.globalAlpha = 0.2 * depthPos;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(glintX, glintY, r * 0.29, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // Draw cowboy hat if player has it
                if (playerHasCowboyHat) {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#8B4513';
                    const s = (v) => camera.scale(v * 1.265); // 26.5% larger (was 15%, +10%)
                    const hatY = sy - r * 0.7; // Nudged up
                    
                    // Brim base (flat middle)
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.ellipse(sx, hatY + s(3), s(12), s(6), 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Left brim - half pipe curve (thicker)
                    ctx.fillStyle = '#7a3a0f';
                    ctx.beginPath();
                    ctx.moveTo(sx - s(8), hatY + s(5));
                    ctx.quadraticCurveTo(sx - s(18), hatY + s(4), sx - s(24), hatY - s(3));
                    ctx.quadraticCurveTo(sx - s(28), hatY - s(10), sx - s(22), hatY - s(9));
                    ctx.quadraticCurveTo(sx - s(16), hatY - s(1), sx - s(8), hatY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Right brim - half pipe curve (thicker)
                    ctx.beginPath();
                    ctx.moveTo(sx + s(8), hatY + s(5));
                    ctx.quadraticCurveTo(sx + s(18), hatY + s(4), sx + s(24), hatY - s(3));
                    ctx.quadraticCurveTo(sx + s(28), hatY - s(10), sx + s(22), hatY - s(9));
                    ctx.quadraticCurveTo(sx + s(16), hatY - s(1), sx + s(8), hatY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Hat crown (taller)
                    ctx.fillStyle = '#A0522D';
                    ctx.beginPath();
                    ctx.moveTo(sx - s(10), hatY);
                    ctx.quadraticCurveTo(sx - s(12), hatY - s(12), sx, hatY - s(16));
                    ctx.quadraticCurveTo(sx + s(12), hatY - s(12), sx + s(10), hatY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Crown indent
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.ellipse(sx, hatY - s(14), s(5), s(2), 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Hat band
                    ctx.fillStyle = '#5a2d0a';
                    ctx.fillRect(sx - s(10), hatY - s(4), s(20), s(4));
                    
                    // Band buckle
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(sx - s(2), hatY - s(3), s(4), s(3));
                    
                    ctx.shadowBlur = 0;
                }
                
                // Draw orbit weapons
                for (const [weaponId, state] of Object.entries(this.weapons)) {
                    const def = WEAPONS[weaponId];
                    if (def.type === 'orbit' && state.orbCount) {
                        const orbitR = camera.scale(state.radius);
                        const activeOrbs = state.activeOrbs || state.orbCount;
                        
                        // Draw faint connecting ring
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(sx, sy, orbitR, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        
                        // Draw orbs (active ones are bright, inactive are dim)
                        ctx.shadowColor = def.color;
                        ctx.shadowBlur = 15;
                        for (let i = 0; i < state.orbCount; i++) {
                            const angle = state.angle + (Math.PI * 2 / state.orbCount) * i;
                            const ox = sx + Math.cos(angle) * orbitR;
                            const oy = sy + Math.sin(angle) * orbitR;
                            const isActive = i < activeOrbs;
                            
                            // Orb body
                            ctx.globalAlpha = isActive ? 1 : 0.25;
                            ctx.fillStyle = isActive ? def.color : '#444';
                            ctx.beginPath();
                            ctx.arc(ox, oy, camera.scale(12), 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Inner bright core (only on active)
                            if (isActive) {
                                ctx.fillStyle = '#fff';
                                ctx.beginPath();
                                ctx.arc(ox, oy, camera.scale(4), 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                    
                    // AOE wave visual - enhanced neon effect
                    if (def.type === 'aoe' && state.waveActive) {
                        state.waveRadius += 5; // Slower expansion
                        if (state.waveRadius >= state.waveMaxRadius) {
                            state.waveActive = false;
                        } else {
                            const progress = state.waveRadius / state.waveMaxRadius;
                            const baseAlpha = 1 - progress * 0.8; // Fade out slower
                            
                            ctx.save();
                            
                            // Draw boombox icon above player (only for boomBox weapon)
                            if (weaponId === 'boomBox') {
                                // Fast fade in (first 15%), slow fade out (remaining 85%)
                                let boomboxAlpha;
                                if (progress < 0.15) {
                                    boomboxAlpha = progress / 0.15; // 0 to 1 in first 15%
                                } else {
                                    boomboxAlpha = 1 - ((progress - 0.15) / 0.85) * 0.6; // Slow fade to 0.4
                                }
                                const boomboxY = sy - camera.scale(70); // 70px above player center
                                const boomboxSize = camera.scale(23.4); // 30% larger
                                const bounce = Math.sin(Date.now() * 0.015) * camera.scale(2);
                                
                                ctx.globalAlpha = boomboxAlpha;
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = def.color;
                                
                                // Boombox body
                                ctx.fillStyle = '#444';
                                ctx.strokeStyle = def.color;
                                ctx.lineWidth = 2;
                                const bw = boomboxSize * 2;
                                const bh = boomboxSize * 1.2;
                                ctx.fillRect(sx - bw/2, boomboxY + bounce - bh/2, bw, bh);
                                ctx.strokeRect(sx - bw/2, boomboxY + bounce - bh/2, bw, bh);
                                
                                // Handle
                                ctx.strokeStyle = '#666';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(sx - bw * 0.3, boomboxY + bounce - bh/2);
                                ctx.quadraticCurveTo(sx, boomboxY + bounce - bh/2 - boomboxSize * 0.5, sx + bw * 0.3, boomboxY + bounce - bh/2);
                                ctx.stroke();
                                
                                // Left speaker
                                ctx.fillStyle = '#222';
                                ctx.strokeStyle = def.color;
                                ctx.lineWidth = 1.5;
                                ctx.beginPath();
                                ctx.arc(sx - bw * 0.28, boomboxY + bounce, boomboxSize * 0.35, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                                // Speaker cone
                                ctx.fillStyle = def.color;
                                ctx.globalAlpha = boomboxAlpha * 0.5;
                                ctx.beginPath();
                                ctx.arc(sx - bw * 0.28, boomboxY + bounce, boomboxSize * 0.15, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = boomboxAlpha;
                                
                                // Right speaker
                                ctx.fillStyle = '#222';
                                ctx.beginPath();
                                ctx.arc(sx + bw * 0.28, boomboxY + bounce, boomboxSize * 0.35, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                                // Speaker cone
                                ctx.fillStyle = def.color;
                                ctx.globalAlpha = boomboxAlpha * 0.5;
                                ctx.beginPath();
                                ctx.arc(sx + bw * 0.28, boomboxY + bounce, boomboxSize * 0.15, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = boomboxAlpha;
                                
                                // Center cassette area
                                ctx.fillStyle = '#333';
                                ctx.fillRect(sx - boomboxSize * 0.3, boomboxY + bounce - bh * 0.2, boomboxSize * 0.6, bh * 0.4);
                            }
                            
                            // Outer glow ring (wider)
                            ctx.strokeStyle = def.color;
                            ctx.shadowBlur = 35;
                            ctx.shadowColor = def.color;
                            ctx.lineWidth = 8;
                            ctx.globalAlpha = baseAlpha * 0.35;
                            ctx.beginPath();
                            ctx.arc(sx, sy, camera.scale(state.waveRadius + 12), 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Main wave ring (thicker)
                            ctx.lineWidth = 5;
                            ctx.globalAlpha = baseAlpha * 0.9;
                            ctx.beginPath();
                            ctx.arc(sx, sy, camera.scale(state.waveRadius), 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Inner bright ring
                            ctx.strokeStyle = '#ffffff';
                            ctx.shadowColor = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = baseAlpha * 0.7;
                            ctx.beginPath();
                            ctx.arc(sx, sy, camera.scale(state.waveRadius - 5), 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Trailing secondary wave
                            if (state.waveRadius > 25) {
                                ctx.strokeStyle = def.color;
                                ctx.shadowColor = def.color;
                                ctx.lineWidth = 3;
                                ctx.globalAlpha = baseAlpha * 0.4;
                                ctx.beginPath();
                                ctx.arc(sx, sy, camera.scale(state.waveRadius * 0.65), 0, Math.PI * 2);
                                ctx.stroke();
                            }
                            
                            // Third trailing wave for extra depth
                            if (state.waveRadius > 50) {
                                ctx.lineWidth = 2;
                                ctx.globalAlpha = baseAlpha * 0.25;
                                ctx.beginPath();
                                ctx.arc(sx, sy, camera.scale(state.waveRadius * 0.35), 0, Math.PI * 2);
                                ctx.stroke();
                            }
                            
                            // Particle-like dots on the wave (more dots, rotating)
                            ctx.fillStyle = '#ffffff';
                            ctx.shadowBlur = 10;
                            ctx.globalAlpha = baseAlpha * 0.85;
                            const dotCount = 12;
                            const rotationOffset = Date.now() * 0.002;
                            for (let i = 0; i < dotCount; i++) {
                                const dotAngle = (i / dotCount) * Math.PI * 2 + rotationOffset;
                                const dotX = sx + Math.cos(dotAngle) * camera.scale(state.waveRadius);
                                const dotY = sy + Math.sin(dotAngle) * camera.scale(state.waveRadius);
                                ctx.beginPath();
                                ctx.arc(dotX, dotY, camera.scale(3.5), 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            ctx.restore();
                        }
                        
                        // Spawn musical notes throughout the wave expansion
                        if (!state.musicNotes) state.musicNotes = [];
                        
                        // Ensure minimum number of notes (spawn if below minimum or random chance)
                        const minNotes = 3;
                        const shouldSpawn = state.waveRadius > 10 && (state.musicNotes.length < minNotes || Math.random() < 0.1);
                        
                        if (shouldSpawn) {
                            // Try to find a position that's spread out from existing notes
                            const minDist = 55; // Minimum distance between notes
                            let bestX = null, bestY = null, bestMinDist = 0;
                            
                            // Try more random positions and pick the most spread out one
                            for (let attempt = 0; attempt < 10; attempt++) {
                                const angle = Math.random() * Math.PI * 2;
                                // Spawn in middle band: 35-75% of radius (not too close to player or edge)
                                const minDistPercent = 0.35;
                                const maxDistPercent = 0.75;
                                const dist = (minDistPercent + Math.random() * (maxDistPercent - minDistPercent)) * state.waveRadius;
                                const testX = this.x + Math.cos(angle) * dist;
                                const testY = this.y + Math.sin(angle) * dist;
                                
                                // Find closest existing note
                                let closestDist = Infinity;
                                for (const existing of state.musicNotes) {
                                    const d = Math.hypot(existing.x - testX, existing.y - testY);
                                    if (d < closestDist) closestDist = d;
                                }
                                
                                // Keep this position if it's more spread out
                                if (closestDist > bestMinDist) {
                                    bestMinDist = closestDist;
                                    bestX = testX;
                                    bestY = testY;
                                }
                            }
                            
                            // Spawn if below minimum (relax distance requirement) or if spread out enough
                            const belowMinimum = state.musicNotes.length < minNotes;
                            if (bestX !== null && (belowMinimum || state.musicNotes.length === 0 || bestMinDist >= minDist)) {
                                state.musicNotes.push({
                                    x: bestX,
                                    y: bestY,
                                    vx: (Math.random() - 0.5) * 0.8,
                                    vy: -1 - Math.random() * 1.2,
                                    rotation: Math.random() * 0.02 - 0.01,
                                    angle: 0,
                                    life: 1,
                                    note: '♪',
                                    size: 18 + Math.random() * 10
                                });
                            }
                        }
                    }
                    
                    // Draw and update musical notes for boom box
                    if (def.type === 'aoe' && state.musicNotes && state.musicNotes.length > 0) {
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = def.color;
                        
                        for (const note of state.musicNotes) {
                            note.x += note.vx;
                            note.y += note.vy;
                            note.vy += 0.02; // Slight gravity
                            note.angle += note.rotation;
                            note.life -= 0.015;
                            
                            if (note.life > 0) {
                                const nx = camera.screenX(note.x);
                                const ny = camera.screenY(note.y);
                                ctx.globalAlpha = note.life * 0.9;
                                ctx.fillStyle = def.color;
                                ctx.font = `bold ${camera.scale(note.size)}px Arial`;
                                ctx.save();
                                ctx.translate(nx, ny);
                                ctx.rotate(note.angle);
                                ctx.fillText(note.note, 0, 0);
                                ctx.restore();
                            }
                        }
                        
                        // Cleanup dead notes
                        state.musicNotes = state.musicNotes.filter(n => n.life > 0);
                        ctx.restore();
                    }
                    
                    // Draw boombox icon above player when firing
                    if (def.type === 'aoe' && state.boomboxIcon && (state.boomboxIcon.alpha > 0 || state.boomboxIcon.phase === 'fadeIn')) {
                        ctx.save();
                        ctx.globalAlpha = state.boomboxIcon.alpha;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = def.color;
                        
                        // Draw the boombox image
                        const imgSize = camera.scale(28 * state.boomboxIcon.scale);
                        const imgX = sx - imgSize / 2;
                        const imgY = sy + camera.scale(state.boomboxIcon.y) - imgSize / 2;
                        ctx.drawImage(BOOMBOX_IMG, imgX, imgY, imgSize, imgSize);
                        ctx.restore();
                        
                        // Animate based on phase
                        if (state.boomboxIcon.phase === 'fadeIn') {
                            // Fast fade in
                            state.boomboxIcon.alpha += 0.15;
                            if (state.boomboxIcon.alpha >= 1) {
                                state.boomboxIcon.alpha = 1;
                                state.boomboxIcon.phase = 'fadeOut';
                            }
                        } else {
                            // Slow fade out, float up and shrink
                            state.boomboxIcon.y -= 0.5;
                            state.boomboxIcon.alpha -= 0.012;
                            state.boomboxIcon.scale *= 0.997;
                        }
                    }
                    
                    // Flame thrower visual - animated flames with jagged edges
                    if (def.type === 'flame' && state.flameActive && Date.now() - state.flameActive < 200) {
                        const flameRange = camera.scale(state.flameRange);
                        const time = Date.now() * 0.005;
                        const angle = state.flameAngle;
                        const coneHalf = state.flameCone / 2;
                        
                        ctx.save();
                        
                        // Outer fire cone (red/orange)
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ff4400';
                        const outerGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, flameRange);
                        outerGrad.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                        outerGrad.addColorStop(0.4, 'rgba(255, 60, 0, 0.5)');
                        outerGrad.addColorStop(0.7, 'rgba(200, 30, 0, 0.3)');
                        outerGrad.addColorStop(1, 'rgba(100, 0, 0, 0)');
                        
                        ctx.fillStyle = outerGrad;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        // Jagged edges along the cone sides
                        const edgeSegs = 6;
                        // Left edge (jagged)
                        for (let i = 0; i <= edgeSegs; i++) {
                            const t = i / edgeSegs;
                            const edgeAngle = angle - coneHalf;
                            const jag = Math.sin(time * 4 + i * 2.5) * 0.15 + Math.sin(time * 7 + i * 1.8) * 0.1;
                            const r = flameRange * t * (0.9 + jag);
                            ctx.lineTo(sx + Math.cos(edgeAngle + jag * 0.3) * r, sy + Math.sin(edgeAngle + jag * 0.3) * r);
                        }
                        // Outer arc (wavy)
                        const arcSegs = 8;
                        for (let i = 0; i <= arcSegs; i++) {
                            const segAngle = angle - coneHalf + (coneHalf * 2 * i / arcSegs);
                            const wave = Math.sin(time * 3 + i * 1.7) * 0.12;
                            const r = flameRange * (0.88 + wave);
                            ctx.lineTo(sx + Math.cos(segAngle) * r, sy + Math.sin(segAngle) * r);
                        }
                        // Right edge (jagged)
                        for (let i = edgeSegs; i >= 0; i--) {
                            const t = i / edgeSegs;
                            const edgeAngle = angle + coneHalf;
                            const jag = Math.sin(time * 5 + i * 2.2) * 0.15 + Math.sin(time * 6 + i * 1.5) * 0.1;
                            const r = flameRange * t * (0.9 + jag);
                            ctx.lineTo(sx + Math.cos(edgeAngle - jag * 0.3) * r, sy + Math.sin(edgeAngle - jag * 0.3) * r);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Mid flame layer (orange/yellow) with wave effect
                        const midRange = flameRange * 0.85;
                        const midGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, midRange);
                        midGrad.addColorStop(0, 'rgba(255, 180, 0, 0.9)');
                        midGrad.addColorStop(0.5, 'rgba(255, 120, 0, 0.5)');
                        midGrad.addColorStop(1, 'rgba(255, 60, 0, 0)');
                        
                        ctx.fillStyle = midGrad;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        const midSegs = 10;
                        for (let i = 0; i <= midSegs; i++) {
                            const segAngle = angle - coneHalf * 0.8 + (coneHalf * 1.6 * i / midSegs);
                            const waveOffset = Math.sin(time + i * 2) * 0.1;
                            const r = midRange * (0.85 + waveOffset);
                            ctx.lineTo(sx + Math.cos(segAngle) * r, sy + Math.sin(segAngle) * r);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Inner bright core (white/yellow)
                        const innerRange = flameRange * 0.4;
                        const innerGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, innerRange);
                        innerGrad.addColorStop(0, 'rgba(255, 255, 200, 0.95)');
                        innerGrad.addColorStop(0.4, 'rgba(255, 230, 100, 0.7)');
                        innerGrad.addColorStop(1, 'rgba(255, 180, 0, 0)');
                        
                        ctx.fillStyle = innerGrad;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.arc(sx, sy, innerRange, angle - coneHalf * 0.5, angle + coneHalf * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Nozzle glow at player
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(sx + Math.cos(angle) * camera.scale(8), sy + Math.sin(angle) * camera.scale(8), camera.scale(4), 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    // Thunder strike visual
                    if (def.type === 'thunder' && state.strikes) {
                        const now = Date.now();
                        ctx.strokeStyle = def.color;
                        ctx.shadowColor = def.color;
                        ctx.shadowBlur = 20;
                        ctx.lineWidth = 4;
                        
                        for (const strike of state.strikes) {
                            const age = now - strike.time;
                            if (age > 350) continue;
                            ctx.globalAlpha = 1 - age / 350;
                            
                            // Draw jagged lightning bolt
                            for (const seg of strike.segments) {
                                ctx.beginPath();
                                ctx.moveTo(camera.screenX(seg.x1), camera.screenY(seg.y1));
                                ctx.lineTo(camera.screenX(seg.x2), camera.screenY(seg.y2));
                                ctx.stroke();
                            }
                            
                            // Impact flash
                            ctx.fillStyle = 'rgba(255, 255, 100, ' + (0.6 - age/600) + ')';
                            ctx.beginPath();
                            ctx.arc(camera.screenX(strike.x), camera.screenY(strike.y), camera.scale(30 - age/12), 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Ground sparks/particles at impact point
                            const sparkCount = 6;
                            for (let i = 0; i < sparkCount; i++) {
                                const sparkAngle = (Math.PI * 2 / sparkCount) * i + age * 0.01;
                                const sparkDist = camera.scale(15 + age * 0.08);
                                const sparkX = camera.screenX(strike.x) + Math.cos(sparkAngle) * sparkDist;
                                const sparkY = camera.screenY(strike.y) + Math.sin(sparkAngle) * sparkDist * 0.5;
                                const sparkSize = camera.scale(3) * (1 - age / 400);
                                
                                ctx.fillStyle = i % 2 === 0 ? '#ffff00' : '#ffffff';
                                ctx.beginPath();
                                ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                    
                    // Toxic aura visual
                    if (def.type === 'aura' && state.auraRadius) {
                        const auraR = camera.scale(state.auraRadius);
                        const pulseT = (Date.now() - (state.auraPulse || 0)) / 1400; // Match tick rate
                        const pulseAlpha = Math.max(0, 0.5 - pulseT * 0.5);
                        
                        // Constant outer glow
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = def.color;
                        const grad = ctx.createRadialGradient(sx, sy, auraR * 0.3, sx, sy, auraR);
                        grad.addColorStop(0, 'rgba(50, 205, 50, 0.25)');
                        grad.addColorStop(1, 'rgba(50, 205, 50, 0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(sx, sy, auraR, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Pulse ring - expands outward over tick duration
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = pulseAlpha;
                        ctx.beginPath();
                        ctx.arc(sx, sy, auraR * (0.3 + pulseT * 0.7), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                    
                    // Meteor strike visual
                    if (def.type === 'meteor' && state.meteors) {
                        const now = Date.now();
                        for (const meteor of state.meteors) {
                            const mx = camera.screenX(meteor.x);
                            const my = camera.screenY(meteor.y);
                            const mr = camera.scale(meteor.radius);
                            
                            if (!meteor.exploded) {
                                // Warning circle before impact
                                const timeToImpact = meteor.impactTime - now;
                                if (timeToImpact > 0 && timeToImpact < 600) {
                                    const pulse = 0.5 + Math.sin(now * 0.02) * 0.3;
                                    ctx.strokeStyle = `rgba(255, 68, 0, ${pulse})`;
                                    ctx.lineWidth = 2;
                                    ctx.setLineDash([5, 5]);
                                    ctx.beginPath();
                                    ctx.arc(mx, my, mr, 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.setLineDash([]);
                                    
                                    // Falling meteor visual
                                    const fallProgress = 1 - (timeToImpact / 500);
                                    const meteorY = my - (1 - fallProgress) * 150;
                                    ctx.fillStyle = '#ff4400';
                                    ctx.shadowColor = '#ff6600';
                                    ctx.shadowBlur = 20;
                                    ctx.beginPath();
                                    ctx.arc(mx, meteorY, camera.scale(12), 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.shadowBlur = 0;
                                }
                            } else {
                                // Explosion effect
                                const age = now - meteor.impactTime;
                                if (age < 300) {
                                    const explodeProgress = age / 300;
                                    ctx.globalAlpha = 1 - explodeProgress;
                                    ctx.fillStyle = '#ff6600';
                                    ctx.shadowColor = '#ff4400';
                                    ctx.shadowBlur = 30;
                                    ctx.beginPath();
                                    ctx.arc(mx, my, mr * (0.5 + explodeProgress * 1.5), 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.globalAlpha = 1;
                                    ctx.shadowBlur = 0;
                                }
                            }
                        }
                    }
                    
                    // Chain lightning weapon visual (jagged)
                    if (def.type === 'chainlightning' && state.chains) {
                        const now = Date.now();
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = def.color;
                        
                        for (const chain of state.chains) {
                            const age = now - chain.time;
                            if (age > 300) continue;
                            ctx.globalAlpha = 1 - age / 300;
                            
                            // Draw jagged lines between each chain point
                            for (let i = 0; i < chain.points.length - 1; i++) {
                                const p1 = chain.points[i];
                                const p2 = chain.points[i + 1];
                                const px1 = camera.screenX(p1.x);
                                const py1 = camera.screenY(p1.y);
                                const px2 = camera.screenX(p2.x);
                                const py2 = camera.screenY(p2.y);
                                
                                // Create jagged path between points
                                ctx.beginPath();
                                ctx.moveTo(px1, py1);
                                const segments = 5;
                                for (let j = 1; j <= segments; j++) {
                                    const t = j / segments;
                                    const jag = (j % 2 === 0 ? 1 : -1) * (Math.random() * 12 + 8);
                                    // Perpendicular offset for jag
                                    const dx = px2 - px1;
                                    const dy = py2 - py1;
                                    const len = Math.sqrt(dx * dx + dy * dy);
                                    const perpX = -dy / len * jag;
                                    const perpY = dx / len * jag;
                                    const midX = px1 + dx * t + (j < segments ? perpX : 0);
                                    const midY = py1 + dy * t + (j < segments ? perpY : 0);
                                    ctx.lineTo(midX, midY);
                                }
                                ctx.stroke();
                            }
                        }
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                    
                    // Starfall visual (raining stars AOE)
                    if (def.type === 'starfall') {
                        const now = Date.now();
                        const radius = state.starfallRadius || def.baseRadius;
                        const sr = camera.scale(radius);
                        
                        // Draw AOE zone indicator (subtle)
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.15;
                        ctx.setLineDash([8, 8]);
                        ctx.beginPath();
                        ctx.arc(sx, sy, sr, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Ambient glow in zone
                        const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, sr);
                        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.05)');
                        gradient.addColorStop(0.7, 'rgba(255, 200, 0, 0.02)');
                        gradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.arc(sx, sy, sr, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        // Draw falling stars
                        if (state.fallingStars) {
                            ctx.shadowBlur = 12;
                            ctx.shadowColor = def.color;
                            
                            for (const star of state.fallingStars) {
                                const age = now - star.startTime;
                                if (age < 0) continue; // Not yet spawned
                                
                                const progress = Math.min(1, age / star.duration);
                                const fadeOut = age > star.duration ? 1 - (age - star.duration) / 200 : 1;
                                if (fadeOut <= 0) continue;
                                
                                // Interpolate Y position (falling from above)
                                const currentY = star.startY + (star.y - star.startY) * progress;
                                const starX = camera.screenX(star.x);
                                const starY = camera.screenY(currentY);
                                const size = camera.scale(star.size) * fadeOut;
                                
                                ctx.globalAlpha = fadeOut * 0.9;
                                ctx.fillStyle = def.color;
                                
                                // Draw 4-pointed star
                                ctx.save();
                                ctx.translate(starX, starY);
                                ctx.rotate(star.rotation + progress * 2);
                                ctx.beginPath();
                                for (let i = 0; i < 8; i++) {
                                    const angle = (Math.PI / 4) * i;
                                    const dist = i % 2 === 0 ? size : size * 0.35;
                                    const px = Math.cos(angle) * dist;
                                    const py = Math.sin(angle) * dist;
                                    if (i === 0) ctx.moveTo(px, py);
                                    else ctx.lineTo(px, py);
                                }
                                ctx.closePath();
                                ctx.fill();
                                ctx.restore();
                                
                                // Trailing tail
                                if (progress < 1) {
                                    ctx.strokeStyle = def.color;
                                    ctx.lineWidth = camera.scale(1.5);
                                    ctx.globalAlpha = fadeOut * 0.5;
                                    const tailLength = camera.scale(25) * (1 - progress);
                                    ctx.beginPath();
                                    ctx.moveTo(starX, starY);
                                    ctx.lineTo(starX, starY - tailLength);
                                    ctx.stroke();
                                }
                                
                                // Impact sparkle
                                if (progress >= 1 && fadeOut > 0.3) {
                                    ctx.globalAlpha = fadeOut * 0.7;
                                    const sparkSize = camera.scale(3);
                                    ctx.fillStyle = '#fff';
                                    ctx.beginPath();
                                    ctx.arc(starX, starY, sparkSize * (1 - fadeOut + 0.3), 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            ctx.globalAlpha = 1;
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // Star field visual (shooting stars) - legacy chain type
                    if (def.type === 'chain' && state.chainTargets) {
                        ctx.fillStyle = def.color;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = def.color;
                        const now = Date.now();
                        
                        for (const target of state.chainTargets) {
                            const age = now - target.time;
                            if (age > 280) continue;
                            ctx.globalAlpha = 1 - age / 280;
                            
                            // Draw star at target position
                            const tx = camera.screenX(target.x);
                            const ty = camera.screenY(target.y);
                            const starSize = camera.scale(8) * (1 - age / 400);
                            
                            // 4-pointed star
                            ctx.beginPath();
                            for (let i = 0; i < 8; i++) {
                                const angle = (Math.PI / 4) * i;
                                const dist = i % 2 === 0 ? starSize : starSize * 0.4;
                                const px = tx + Math.cos(angle) * dist;
                                const py = ty + Math.sin(angle) * dist;
                                if (i === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.closePath();
                            ctx.fill();
                            
                            // Draw trail from player to star
                            ctx.strokeStyle = def.color;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = (1 - age / 280) * 0.4;
                            ctx.setLineDash([4, 4]);
                            ctx.beginPath();
                            ctx.moveTo(sx, sy);
                            ctx.lineTo(tx, ty);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                }
                
                // Combined health + shield bar above player
                // Show when damaged OR when player has shield
                if (this.hp < this.maxHp || this.maxShieldHp > 0) {
                    ctx.shadowBlur = 0;
                    const barWidth = camera.scale(39);
                    const barHeight = camera.scale(3);
                    const hatOffset = playerHasCowboyHat ? camera.scale(8) : 0;
                    const barY = sy - r - camera.scale(15) - hatOffset;
                    const barX = sx - barWidth/2;
                    
                    // Calculate proportions of total health pool
                    const totalPool = this.maxHp + this.maxShieldHp;
                    const hpPortionWidth = barWidth * (this.maxHp / totalPool);
                    const shieldPortionWidth = barWidth * (this.maxShieldHp / totalPool);
                    
                    // HP section (left side)
                    // Background (unfilled/damaged portion)
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(barX, barY, hpPortionWidth, barHeight);
                    
                    // Fill (remaining health)
                    const hpPercent = Math.max(0, Math.min(1, this.hp / this.maxHp));
                    ctx.fillStyle = '#39ff9f';
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = '#39ff9f';
                    ctx.fillRect(barX, barY, hpPortionWidth * hpPercent, barHeight);
                    
                    // Shield section (right side) - only if player has shield capacity
                    if (this.maxShieldHp > 0) {
                        const shieldX = barX + hpPortionWidth;
                        
                        // Background (empty shield)
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = 'rgba(68, 136, 255, 0.3)';
                        ctx.fillRect(shieldX, barY, shieldPortionWidth, barHeight);
                        
                        // Fill (current shield)
                        const shieldPercent = Math.max(0, Math.min(1, this.shieldHp / this.maxShieldHp));
                        ctx.fillStyle = '#4488ff';
                        ctx.shadowBlur = 4;
                        ctx.shadowColor = '#4488ff';
                        ctx.fillRect(shieldX, barY, shieldPortionWidth * shieldPercent, barHeight);
                    }
                    
                    // Border around entire bar
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = this.maxShieldHp > 0 ? '#66aaff' : '#00ff66';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                ctx.restore();
            }
        }

        // ===== ENEMY CLASS =====
        class Enemy {
            constructor(type, x, y) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.orbHitCooldown = 0;
                this.incomingDamage = 0; // Track damage from projectiles in flight
                
                // Status effects
                this.burnDamage = 0;
                this.burnTicks = 0;
                this.burnTickTimer = 0;
                this.freezeTimer = 0;
                this.freezeSlowAmount = 0;
                this.shockTimer = 0;
                this.poisonDamage = 0;
                this.poisonTicks = 0;
                this.poisonTickTimer = 0;
                this.baseSpeed = 0; // Set after switch
                
                // Scaling factor based on game time
                // HP: +20% every 25 seconds (slowed from /20)
                const hpScale = 1 + Math.floor(gameTime / 25) * 0.20;
                // Damage: +15% every 30 seconds (slowed from /25)
                const dmgScale = 1 + Math.floor(gameTime / 30) * 0.15;
                // Speed: +5% every 50 seconds (slowed from /40)
                const speedScale = 1 + Math.floor(gameTime / 50) * 0.05;
                
                switch (type) {
                    case 'basic':
                        this.radius = 12;
                        this.speed = 1.3 * speedScale;
                        this.maxHp = Math.floor(15 * hpScale);
                        this.baseDamage = 16;
                        this.color = COLORS.magenta;
                        this.xpValue = 1;
                        break;
                    case 'fast':
                        this.radius = 10;
                        this.speed = 2.8 * speedScale;
                        this.maxHp = Math.floor(10 * hpScale);
                        this.baseDamage = 10;
                        this.color = COLORS.orange;
                        this.xpValue = 1;
                        break;
                    case 'tank':
                        this.radius = 21;
                        this.speed = 0.8 * speedScale;
                        this.maxHp = Math.floor(50 * hpScale);
                        this.baseDamage = 24;
                        this.color = COLORS.purple;
                        this.xpValue = 3;
                        break;
                    case 'swarm':
                        this.radius = 8;
                        this.speed = 2.0 * speedScale;
                        this.maxHp = Math.floor(6 * hpScale);
                        this.baseDamage = 6;
                        this.color = COLORS.neonGreen;
                        this.xpValue = 1;
                        break;
                }
                
                // Apply damage scaling with difficulty bonus
                this.damage = Math.floor(this.baseDamage * dmgScale * enemyDamageBonus);
                this.hp = Math.floor(this.maxHp * enemyHealthBonus);
                this.maxHp = this.hp;
                this.speed = this.speed * enemySpeedBonus;
                this.baseSpeed = this.speed; // Store for freeze effect
                
                // Knockback velocity (for smooth knockback)
                this.knockbackVelX = 0;
                this.knockbackVelY = 0;
                
                // XP scales slightly with time to keep leveling relevant
                const xpScale = 1 + Math.floor(gameTime / 120) * 0.5; // +50% XP every 2 min
                this.xpValue = Math.ceil(this.xpValue * xpScale * killRewardBonus);
            }
            
            // Status effect methods
            applyBurn(damage) {
                if (this.burnTicks < 3) { // Don't stack burns, but refresh
                    this.burnDamage = damage;
                    this.burnTicks = 3;
                    this.burnTickTimer = 0;
                    // Initial burn damage
                    this.takeDamage(damage, false);
                    spawnParticles(this.x, this.y, COLORS.burn, 5);
                }
            }
            
            applyFreeze(slowAmount) {
                this.freezeTimer = 6000; // 6 seconds
                this.freezeSlowAmount = slowAmount;
                spawnParticles(this.x, this.y, COLORS.freeze, 8);
            }
            
            applyShock(damage) {
                this.shockTimer = 3000; // 3 seconds
                this.takeDamage(damage, false);
                spawnParticles(this.x, this.y, COLORS.shock, 10);
            }
            
            applyPoison(damage) {
                // Refresh poison - 5 ticks over 4 seconds
                this.poisonDamage = damage;
                this.poisonTicks = 5;
                this.poisonTickTimer = 0;
                spawnParticles(this.x, this.y, '#32cd32', 4);
            }
            
            applyKnockback(angle, force) {
                // Add to knockback velocity for smooth knockback
                this.knockbackVelX += Math.cos(angle) * force * 0.15;
                this.knockbackVelY += Math.sin(angle) * force * 0.15;
            }

            update(dt) {
                // Status effect updates
                // Burn ticks
                if (this.burnTicks > 0) {
                    this.burnTickTimer += dt;
                    if (this.burnTickTimer >= 666) { // ~3 ticks over 2 seconds
                        this.burnTickTimer = 0;
                        this.burnTicks--;
                        const tickDamage = this.burnDamage * 0.5;
                        this.hp -= tickDamage;
                        spawnDamageNumber(this.x, this.y, Math.round(tickDamage), false);
                        spawnParticles(this.x, this.y, COLORS.burn, 3);
                        if (this.hp <= 0 && !this.dead) this.die();
                    }
                }
                
                // Poison ticks
                if (this.poisonTicks > 0) {
                    this.poisonTickTimer += dt;
                    if (this.poisonTickTimer >= 800) { // 5 ticks over 4 seconds
                        this.poisonTickTimer = 0;
                        this.poisonTicks--;
                        const tickDamage = this.poisonDamage;
                        this.hp -= tickDamage;
                        spawnDamageNumber(this.x, this.y, Math.round(tickDamage), false);
                        spawnParticles(this.x, this.y, '#32cd32', 2);
                        if (this.hp <= 0 && !this.dead) this.die();
                    }
                }
                
                // Freeze timer (legendary effect)
                if (this.freezeTimer > 0) {
                    this.freezeTimer -= dt;
                    if (this.freezeTimer <= 0) {
                        this.freezeTimer = 0;
                        this.freezeSlowAmount = 0;
                    }
                }
                
                // Ice slow timer (from ice shards)
                if (this.slowUntil && Date.now() < this.slowUntil) {
                    // Ice slow active
                } else {
                    this.slowMult = 1;
                    this.slowUntil = 0;
                }
                
                // Shock timer (stunned - no movement or damage)
                if (this.shockTimer > 0) {
                    this.shockTimer -= dt;
                    if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
                    return; // Skip movement and damage while shocked
                }
                
                // Calculate effective speed
                let effectiveSpeed = this.baseSpeed;
                if (this.freezeSlowAmount > 0) {
                    effectiveSpeed *= (1 - this.freezeSlowAmount);
                }
                // Apply ice slow (multiplicative)
                if (this.slowMult && this.slowMult < 1) {
                    effectiveSpeed *= this.slowMult;
                }
                
                // Frame-rate independent movement (dt/16 normalizes to ~60fps)
                const dtScale = dt / 16;
                const frameSpeed = effectiveSpeed * dtScale;
                
                // Move toward player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    const dirX = dx / dist;
                    const dirY = dy / dist;
                    let newX = this.x + dirX * frameSpeed;
                    let newY = this.y + dirY * frameSpeed;
                    
                    // Check terrain collision
                    const terrain = isInTerrain(newX, newY, this.radius);
                    if (!terrain) {
                        this.x = newX;
                        this.y = newY;
                    } else {
                        // Better pathfinding around obstacles
                        // Calculate angle to obstacle center
                        const toObsX = terrain.x - this.x;
                        const toObsY = terrain.y - this.y;
                        
                        // Calculate perpendicular directions (left and right of obstacle)
                        const perpLeft = { x: -dirY, y: dirX };
                        const perpRight = { x: dirY, y: -dirX };
                        
                        // Determine which side is better (closer to player on other side)
                        const crossProduct = dirX * toObsY - dirY * toObsX;
                        const preferredPerp = crossProduct > 0 ? perpRight : perpLeft;
                        const alternatePerp = crossProduct > 0 ? perpLeft : perpRight;
                        
                        // Try preferred perpendicular direction
                        let slideX = this.x + preferredPerp.x * frameSpeed;
                        let slideY = this.y + preferredPerp.y * frameSpeed;
                        
                        if (!isInTerrain(slideX, slideY, this.radius)) {
                            this.x = slideX;
                            this.y = slideY;
                        } else {
                            // Try alternate perpendicular
                            slideX = this.x + alternatePerp.x * frameSpeed;
                            slideY = this.y + alternatePerp.y * frameSpeed;
                            
                            if (!isInTerrain(slideX, slideY, this.radius)) {
                                this.x = slideX;
                                this.y = slideY;
                            } else {
                                // Try diagonal combinations
                                const diag1X = this.x + (dirX + preferredPerp.x) * 0.7 * frameSpeed;
                                const diag1Y = this.y + (dirY + preferredPerp.y) * 0.7 * frameSpeed;
                                const diag2X = this.x + (dirX + alternatePerp.x) * 0.7 * frameSpeed;
                                const diag2Y = this.y + (dirY + alternatePerp.y) * 0.7 * frameSpeed;
                                
                                if (!isInTerrain(diag1X, diag1Y, this.radius)) {
                                    this.x = diag1X;
                                    this.y = diag1Y;
                                } else if (!isInTerrain(diag2X, diag2Y, this.radius)) {
                                    this.x = diag2X;
                                    this.y = diag2Y;
                                }
                                // If all blocked, enemy stays in place
                            }
                        }
                    }
                }
                
                // Apply knockback velocity (smooth knockback)
                if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) {
                    const dtScale = dt / 16;
                    this.x += this.knockbackVelX * dtScale;
                    this.y += this.knockbackVelY * dtScale;
                    
                    // Apply friction (higher = slower decay = smoother)
                    const friction = 0.88;
                    this.knockbackVelX *= friction;
                    this.knockbackVelY *= friction;
                    
                    // Stop when very slow
                    if (Math.abs(this.knockbackVelX) < 0.05) this.knockbackVelX = 0;
                    if (Math.abs(this.knockbackVelY) < 0.05) this.knockbackVelY = 0;
                }
                
                // Collision with player
                if (dist < this.radius + player.radius) {
                    player.takeDamage(this.damage);
                }
                
                // Orbit cooldown
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }

            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                // Reduce tracked incoming damage (projectile has hit)
                this.incomingDamage = Math.max(0, this.incomingDamage - amount);
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                if (this.dead) return; // Prevent double death
                this.dead = true;
                kills++;
                const killEl = document.getElementById('killCount'); if (killEl) killEl.textContent = kills;
                
                // Spawn XP gem - find valid position outside terrain
                let gemX = this.x;
                let gemY = this.y;
                const terrain = isInTerrain(gemX, gemY, 10);
                if (terrain) {
                    // Push gem outside of terrain
                    if (terrain.type === 'tree' || terrain.type === 'rock' || terrain.type === 'bush') {
                        const dx = gemX - terrain.x;
                        const dy = gemY - terrain.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 0) {
                            gemX = terrain.x + (dx / dist) * (terrain.radius + 15);
                            gemY = terrain.y + (dy / dist) * (terrain.radius + 15);
                        }
                    } else {
                        const dx = gemX - terrain.x;
                        const dy = gemY - terrain.y;
                        const normX = dx / terrain.radiusX;
                        const normY = dy / terrain.radiusY;
                        const dist = Math.sqrt(normX * normX + normY * normY);
                        if (dist > 0) {
                            gemX = terrain.x + (normX / dist) * (terrain.radiusX + 15);
                            gemY = terrain.y + (normY / dist) * (terrain.radiusY + 15);
                        }
                    }
                }
                xpGems.push(new XPGem(gemX, gemY, this.xpValue));
                
                // Death particles (reduced for performance)
                spawnParticles(this.x, this.y, this.color, 6);
                
                // Vengeful Spirits - spawn ghost on kill
                if (legendaryEffects.ghostStrike.active) {
                    ghosts.push(new Ghost(this.x, this.y));
                }
                
                // Power drop chance with diminishing returns
                trySpawnPowerDrop(this.x, this.y);
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const s = r; // Size shorthand for consistency
                const time = Date.now();
                
                ctx.save();
                
                // Status effect color overlays
                let mainColor = this.color;
                if (this.shockTimer > 0) {
                    mainColor = COLORS.shock;
                } else if (this.freezeTimer > 0) {
                    mainColor = COLORS.freeze;
                } else if (this.poisonTicks > 0) {
                    mainColor = '#32cd32'; // Poison green tint
                }
                
                // Gentle floating animation
                const floatOffset = Math.sin(time / 300 + this.x * 0.01) * camera.scale(2);
                const ghostY = sy + floatOffset;
                
                // Status effect outer glow
                if (this.freezeTimer > 0 || this.shockTimer > 0 || this.poisonTicks > 0) {
                    const pulse = 0.5 + Math.sin(time / 100) * 0.3;
                    ctx.fillStyle = mainColor;
                    ctx.globalAlpha = 0.3 * pulse;
                    ctx.beginPath();
                    ctx.arc(sx, ghostY, s * 1.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // ===== GHOST BODY SHAPE =====
                ctx.fillStyle = mainColor;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 12;
                
                ctx.beginPath();
                // Dome top (semicircle from left to right)
                ctx.arc(sx, ghostY - s * 0.2, s, Math.PI, 0, false);
                
                // Wavy bottom - 3 curves for the ghostly tail
                const bottomY = ghostY + s * 0.8;
                const waveAmp = s * 0.25;
                const tailWiggle = Math.sin(time / 200 + this.x * 0.05) * s * 0.1;
                
                // Right side down
                ctx.lineTo(sx + s, bottomY - waveAmp);
                
                // First wave (right)
                ctx.quadraticCurveTo(
                    sx + s * 0.7 + tailWiggle, bottomY + waveAmp,
                    sx + s * 0.33, bottomY - waveAmp * 0.5
                );
                
                // Second wave (center)
                ctx.quadraticCurveTo(
                    sx + tailWiggle * 0.5, bottomY + waveAmp * 1.2,
                    sx - s * 0.33, bottomY - waveAmp * 0.5
                );
                
                // Third wave (left)
                ctx.quadraticCurveTo(
                    sx - s * 0.7 - tailWiggle, bottomY + waveAmp,
                    sx - s, bottomY - waveAmp
                );
                
                // Left side up to dome
                ctx.closePath();
                ctx.fill();
                
                // Ghost outline for definition
                ctx.strokeStyle = this.type === 'tank' ? 'rgba(255,255,255,0.6)' : 'rgba(255,255,255,0.4)';
                ctx.lineWidth = this.type === 'tank' ? 2 : 1.5;
                ctx.shadowBlur = 0;
                ctx.stroke();
                
                // ===== GHOST FACE =====
                const eyeY = ghostY - s * 0.25;
                const eyeSpacing = s * 0.35;
                const eyeSize = s * 0.22;
                const mouthY = ghostY + s * 0.2;
                
                if (this.type === 'tank') {
                    // Tank: Determined, flat serious expression
                    ctx.fillStyle = '#1a0033';
                    ctx.beginPath();
                    ctx.ellipse(sx - eyeSpacing, eyeY, eyeSize * 0.9, eyeSize * 0.7, 0, 0, Math.PI * 2);
                    ctx.ellipse(sx + eyeSpacing, eyeY, eyeSize * 0.9, eyeSize * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Flat determined mouth
                    ctx.strokeStyle = '#1a0033';
                    ctx.lineWidth = s * 0.08;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(sx - s * 0.15, mouthY);
                    ctx.lineTo(sx + s * 0.15, mouthY);
                    ctx.stroke();
                } else if (this.type === 'fast') {
                    // Fast: Excited/happy with blush marks
                    ctx.fillStyle = '#1a1a00';
                    ctx.beginPath();
                    ctx.ellipse(sx - eyeSpacing, eyeY, eyeSize * 0.8, eyeSize * 0.9, 0, 0, Math.PI * 2);
                    ctx.ellipse(sx + eyeSpacing, eyeY, eyeSize * 0.8, eyeSize * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Blush marks
                    ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(sx - eyeSpacing * 1.5, eyeY + s * 0.15, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
                    ctx.ellipse(sx + eyeSpacing * 1.5, eyeY + s * 0.15, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Happy open mouth
                    ctx.fillStyle = '#1a1a00';
                    ctx.beginPath();
                    ctx.ellipse(sx, mouthY, s * 0.15, s * 0.12, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'swarm') {
                    // Swarm: Tiny mischievous face
                    ctx.fillStyle = '#0a1a0a';
                    ctx.beginPath();
                    ctx.arc(sx - eyeSpacing * 0.8, eyeY, eyeSize * 0.6, 0, Math.PI * 2);
                    ctx.arc(sx + eyeSpacing * 0.8, eyeY, eyeSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    // Tiny smile
                    ctx.strokeStyle = '#0a1a0a';
                    ctx.lineWidth = s * 0.06;
                    ctx.beginPath();
                    ctx.arc(sx, mouthY - s * 0.05, s * 0.1, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else {
                    // Normal/Basic: Classic cute ghost face (like favicon)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.ellipse(sx - eyeSpacing, eyeY, eyeSize * 0.7, eyeSize * 0.85, 0, 0, Math.PI * 2);
                    ctx.ellipse(sx + eyeSpacing, eyeY, eyeSize * 0.7, eyeSize * 0.85, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Small "o" mouth (surprised/cute)
                    ctx.beginPath();
                    ctx.ellipse(sx, mouthY, s * 0.12, s * 0.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Highlight shine on ghost head
                ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
                ctx.beginPath();
                ctx.ellipse(sx - s * 0.35, ghostY - s * 0.55, s * 0.25, s * 0.2, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Burn effect - rising embers
                if (this.burnTicks > 0) {
                    ctx.fillStyle = COLORS.burn;
                    ctx.shadowColor = COLORS.burn;
                    ctx.shadowBlur = 10;
                    // Rising ember particles
                    for (let i = 0; i < 5; i++) {
                        const emberPhase = ((time * 0.004 + i * 0.2) % 1);
                        const emberX = sx + Math.sin(time * 0.006 + i * 1.2) * s * 0.6;
                        const emberY = ghostY + s * 0.3 - emberPhase * s * 2;
                        const emberSize = camera.scale(2.5) * (1 - emberPhase * 0.6);
                        const emberAlpha = (1 - emberPhase) * 0.9;
                        ctx.globalAlpha = emberAlpha;
                        // Flickering orange-yellow color
                        ctx.fillStyle = i % 2 === 0 ? '#ff4400' : '#ffaa00';
                        ctx.beginPath();
                        ctx.arc(emberX, emberY, emberSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Freeze effect - falling ice crystals
                if (this.freezeTimer > 0) {
                    ctx.fillStyle = '#aaeeff';
                    ctx.shadowColor = COLORS.freeze;
                    ctx.shadowBlur = 8;
                    // Falling snowflake particles
                    for (let i = 0; i < 4; i++) {
                        const icePhase = ((time * 0.002 + i * 0.25) % 1);
                        const iceX = sx + Math.sin(time * 0.003 + i * 1.8) * s * 0.7;
                        const iceY = ghostY - s * 0.8 + icePhase * s * 1.8;
                        const iceSize = camera.scale(3) * (0.5 + (1 - Math.abs(icePhase - 0.5) * 2) * 0.5);
                        const iceAlpha = 0.9 - Math.abs(icePhase - 0.5) * 1.2;
                        ctx.globalAlpha = Math.max(0, iceAlpha);
                        // Draw small snowflake/crystal
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        for (let j = 0; j < 6; j++) {
                            const angle = j * Math.PI / 3;
                            ctx.moveTo(iceX, iceY);
                            ctx.lineTo(iceX + Math.cos(angle) * iceSize, iceY + Math.sin(angle) * iceSize);
                        }
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Shock effect - orbiting sparks
                if (this.shockTimer > 0) {
                    ctx.fillStyle = COLORS.shock;
                    ctx.shadowColor = COLORS.shock;
                    ctx.shadowBlur = 12;
                    // Orbiting electric sparks
                    for (let i = 0; i < 4; i++) {
                        const sparkAngle = (time * 0.008 + i * Math.PI / 2);
                        const sparkDist = s * (0.8 + Math.sin(time * 0.01 + i) * 0.3);
                        const sparkX = sx + Math.cos(sparkAngle) * sparkDist;
                        const sparkY = ghostY + Math.sin(sparkAngle) * sparkDist;
                        const sparkSize = camera.scale(2 + Math.random());
                        ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                        ctx.fill();
                        // Small lightning bolt from spark
                        if (Math.random() > 0.7) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(sparkX, sparkY);
                            const boltLen = camera.scale(8);
                            const boltAngle = Math.random() * Math.PI * 2;
                            ctx.lineTo(sparkX + Math.cos(boltAngle) * boltLen, sparkY + Math.sin(boltAngle) * boltLen);
                            ctx.stroke();
                        }
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Poison effect - rising bubbles
                if (this.poisonTicks > 0) {
                    ctx.fillStyle = '#32cd32';
                    ctx.shadowColor = '#32cd32';
                    ctx.shadowBlur = 8;
                    ctx.globalAlpha = 0.8;
                    // 4 bubbles at different phases
                    for (let i = 0; i < 4; i++) {
                        const bubblePhase = ((time * 0.003 + i * 0.25) % 1);
                        const bubbleX = sx + Math.sin(time * 0.005 + i * 1.5) * s * 0.5;
                        const bubbleY = ghostY + s * 0.5 - bubblePhase * s * 1.8;
                        const bubbleSize = camera.scale(2 + Math.sin(i) * 1) * (1 - bubblePhase * 0.5);
                        const bubbleAlpha = (1 - bubblePhase) * 0.8;
                        ctx.globalAlpha = bubbleAlpha;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // HP bar for tanks
                if (this.type === 'tank' && this.hp < this.maxHp) {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(sx - camera.scale(15), ghostY - s - camera.scale(15), camera.scale(30), camera.scale(4));
                    ctx.fillStyle = this.color;
                    ctx.fillRect(sx - camera.scale(15), ghostY - s - camera.scale(15), camera.scale(30) * (this.hp / this.maxHp), camera.scale(4));
                }
                
                ctx.restore();
            }
        }

        // ===== LEPRECHAUN CLASS =====
        class Leprechaun {
            constructor(x, y, guardX, guardY) {
                this.x = x;
                this.y = y;
                this.guardX = guardX; // Pot of gold location to guard
                this.guardY = guardY;
                this.radius = 16;
                this.incomingDamage = 0; // Track damage from projectiles in flight
                
                // Time-based scaling for leprechaun
                const timeScale = 1 + Math.floor(gameTime / 75) * 0.25; // +25% per 75s (slowed from /60)
                
                this.speed = 2.2 * (1 + Math.floor(gameTime / 110) * 0.05) * enemySpeedBonus;
                this.maxHp = Math.floor(190 * timeScale * enemyHealthBonus);
                this.hp = this.maxHp;
                this.color = COLORS.green;
                this.dead = false;
                this.orbHitCooldown = 0;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.knockbackCooldown = 0;
                this.knockbackRange = 80;
                this.aggroRange = 150; // Distance at which leprechaun reacts
                
                // Status effects
                this.poisonDamage = 0;
                this.poisonTicks = 0;
                this.poisonTickTimer = 0;
                
                // Knockback velocity (smooth knockback)
                this.knockbackVelX = 0;
                this.knockbackVelY = 0;
            }
            
            applyPoison(damage) {
                this.poisonDamage = damage;
                this.poisonTicks = 5;
                this.poisonTickTimer = 0;
                spawnParticles(this.x, this.y, '#32cd32', 4);
            }
            
            applyKnockback(angle, force) {
                this.knockbackVelX += Math.cos(angle) * force * 0.12;
                this.knockbackVelY += Math.sin(angle) * force * 0.12;
            }

            update(dt) {
                if (this.dead) return;
                
                // Poison ticks
                if (this.poisonTicks > 0) {
                    this.poisonTickTimer += dt;
                    if (this.poisonTickTimer >= 800) {
                        this.poisonTickTimer = 0;
                        this.poisonTicks--;
                        this.hp -= this.poisonDamage;
                        spawnDamageNumber(this.x, this.y, Math.round(this.poisonDamage), false);
                        spawnParticles(this.x, this.y, '#32cd32', 2);
                        if (this.hp <= 0 && !this.dead) this.die();
                    }
                }
                
                // Frame-rate independent movement
                const dtScale = dt / 16;
                
                const dxToPlayer = player.x - this.x;
                const dyToPlayer = player.y - this.y;
                const distToPlayer = Math.hypot(dxToPlayer, dyToPlayer);
                
                // Check if pot is claimed or gone - switch to chase mode
                const potClaimed = this.linkedRainbow && (this.linkedRainbow.claimed || this.linkedRainbow.dead);
                
                let moveX = 0, moveY = 0;
                
                if (potClaimed) {
                    // Pot is claimed - ENRAGE and chase player!
                    if (distToPlayer > this.radius + player.radius + 5) {
                        // Faster chase speed when enraged
                        const chaseSpeed = this.speed * 1.4;
                        moveX = (dxToPlayer / distToPlayer) * chaseSpeed * dtScale;
                        moveY = (dyToPlayer / distToPlayer) * chaseSpeed * dtScale;
                    }
                } else {
                    // Normal guarding behavior
                    const dxToPot = this.guardX - this.x;
                    const dyToPot = this.guardY - this.y;
                    const distToPot = Math.hypot(dxToPot, dyToPot);
                    
                    const playerDistToPot = Math.hypot(player.x - this.guardX, player.y - this.guardY);
                    
                    // Behavior: Stay between player and pot, push player away
                    if (playerDistToPot < this.aggroRange) {
                        // Player is close to pot - intercept!
                        if (distToPlayer > this.radius + player.radius + 10) {
                            moveX = (dxToPlayer / distToPlayer) * this.speed * 1.5 * dtScale;
                            moveY = (dyToPlayer / distToPlayer) * this.speed * 1.5 * dtScale;
                        }
                    } else if (distToPot > 50) {
                        // Return to guarding position near pot
                        moveX = (dxToPot / distToPot) * this.speed * 0.8 * dtScale;
                        moveY = (dyToPot / distToPot) * this.speed * 0.8 * dtScale;
                    }
                }
                
                // Apply movement with terrain check
                if (moveX !== 0 || moveY !== 0) {
                    const newX = this.x + moveX;
                    const newY = this.y + moveY;
                    const terrain = isInTerrain(newX, newY, this.radius);
                    
                    if (!terrain) {
                        this.x = newX;
                        this.y = newY;
                    } else {
                        // Navigate around obstacle
                        const dist = Math.hypot(moveX, moveY);
                        if (dist > 0) {
                            const dirX = moveX / dist;
                            const dirY = moveY / dist;
                            const perpLeft = { x: -dirY, y: dirX };
                            const perpRight = { x: dirY, y: -dirX };
                            const toObsX = terrain.x - this.x;
                            const toObsY = terrain.y - this.y;
                            const crossProduct = dirX * toObsY - dirY * toObsX;
                            const preferredPerp = crossProduct > 0 ? perpRight : perpLeft;
                            
                            const slideX = this.x + preferredPerp.x * this.speed * dtScale;
                            const slideY = this.y + preferredPerp.y * this.speed * dtScale;
                            
                            if (!isInTerrain(slideX, slideY, this.radius)) {
                                this.x = slideX;
                                this.y = slideY;
                            }
                        }
                    }
                }
                
                // Apply knockback velocity (smooth knockback)
                if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) {
                    const dtScale2 = dt / 16;
                    this.x += this.knockbackVelX * dtScale2;
                    this.y += this.knockbackVelY * dtScale2;
                    
                    const friction = 0.88;
                    this.knockbackVelX *= friction;
                    this.knockbackVelY *= friction;
                    
                    if (Math.abs(this.knockbackVelX) < 0.05) this.knockbackVelX = 0;
                    if (Math.abs(this.knockbackVelY) < 0.05) this.knockbackVelY = 0;
                }
                
                // Clamp to world
                this.x = Math.max(30, Math.min(WORLD.width - 30, this.x));
                this.y = Math.max(30, Math.min(WORLD.height - 30, this.y));
                
                // Knockback attack when player gets close (more aggressive when enraged)
                const knockbackCooldownTime = potClaimed ? 1200 : 2000;
                if (this.knockbackCooldown <= 0 && distToPlayer < this.knockbackRange) {
                    this.performKnockback();
                    this.knockbackCooldown = knockbackCooldownTime;
                }
                
                // Collision damage (more when enraged)
                if (distToPlayer < this.radius + player.radius) {
                    player.takeDamage(potClaimed ? 20 : 15);
                }
                
                if (this.knockbackCooldown > 0) this.knockbackCooldown -= dt;
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }
            
            performKnockback() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    // Apply knockback velocity for smooth animated push
                    const knockbackForce = 14;
                    player.knockbackVelX = (dx / dist) * knockbackForce;
                    player.knockbackVelY = (dy / dist) * knockbackForce;
                    
                    // Visual effect - more particles
                    spawnParticles(this.x, this.y, COLORS.gold, 20);
                    spawnParticles(player.x, player.y, '#ffffff', 12);
                    spawnParticles(player.x, player.y, COLORS.green, 8);
                    
                    // Small damage
                    player.takeDamage(10);
                }
            }

            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                // Reduce tracked incoming damage (projectile has hit)
                this.incomingDamage = Math.max(0, this.incomingDamage - amount);
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                spawnParticles(this.x, this.y, COLORS.green, 5);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                if (this.dead) return;
                this.dead = true;
                kills++;
                const killEl = document.getElementById('killCount'); if (killEl) killEl.textContent = kills;
                
                // Burst of particles (reduced for performance)
                spawnParticles(this.x, this.y, COLORS.green, 10);
                spawnParticles(this.x, this.y, COLORS.gold, 6);
                
                // Drop some gold
                playerGold += 25;
                updateGoldDisplay();
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const bob = Math.sin(Date.now() * 0.005 + this.bobOffset) * camera.scale(2);
                
                ctx.save();
                
                // Knockback charge indicator
                if (this.knockbackCooldown <= 0) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff6600';
                } else {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = COLORS.green;
                }
                
                // Body (green circle)
                ctx.fillStyle = COLORS.green;
                ctx.beginPath();
                ctx.arc(sx, sy + bob, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Traditional Leprechaun Hat - tall green with buckle
                const hatWidth = camera.scale(18);
                const hatHeight = camera.scale(16);
                const brimWidth = camera.scale(26);
                const brimHeight = camera.scale(4);
                const buckleSize = camera.scale(6);
                
                // Hat brim (wide, dark green)
                ctx.fillStyle = '#1a5c1a';
                ctx.shadowColor = COLORS.green;
                ctx.fillRect(sx - brimWidth/2, sy + bob - r - brimHeight, brimWidth, brimHeight);
                
                // Hat body (tall rectangle, green)
                ctx.fillStyle = '#228B22';
                ctx.fillRect(sx - hatWidth/2, sy + bob - r - hatHeight - brimHeight + 2, hatWidth, hatHeight);
                
                // Hat band (black stripe)
                ctx.fillStyle = '#000';
                ctx.fillRect(sx - hatWidth/2, sy + bob - r - brimHeight - camera.scale(5), hatWidth, camera.scale(5));
                
                // Buckle (gold square with hole)
                ctx.fillStyle = COLORS.gold;
                ctx.shadowColor = COLORS.gold;
                ctx.fillRect(sx - buckleSize/2, sy + bob - r - brimHeight - camera.scale(6), buckleSize, buckleSize);
                // Buckle hole
                ctx.fillStyle = '#000';
                ctx.fillRect(sx - buckleSize/4, sy + bob - r - brimHeight - camera.scale(5), buckleSize/2, buckleSize/2);
                
                // Angry eyes (white with red pupils when ready to knockback)
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(sx - camera.scale(5), sy + bob - camera.scale(2), camera.scale(3), 0, Math.PI * 2);
                ctx.arc(sx + camera.scale(5), sy + bob - camera.scale(2), camera.scale(3), 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = this.knockbackCooldown <= 0 ? '#ff0000' : '#000';
                ctx.beginPath();
                ctx.arc(sx - camera.scale(5), sy + bob - camera.scale(2), camera.scale(1.5), 0, Math.PI * 2);
                ctx.arc(sx + camera.scale(5), sy + bob - camera.scale(2), camera.scale(1.5), 0, Math.PI * 2);
                ctx.fill();
                
                // Frown
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy + bob + camera.scale(5), camera.scale(4), 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();
                
                // Orange beard
                ctx.fillStyle = '#ff8c00';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(sx - camera.scale(8), sy + bob + camera.scale(6));
                ctx.quadraticCurveTo(sx, sy + bob + camera.scale(16), sx + camera.scale(8), sy + bob + camera.scale(6));
                ctx.quadraticCurveTo(sx, sy + bob + camera.scale(10), sx - camera.scale(8), sy + bob + camera.scale(6));
                ctx.fill();
                
                // Poison effect - green tint and bubbles
                if (this.poisonTicks > 0) {
                    const time = Date.now();
                    // Green overlay
                    ctx.fillStyle = 'rgba(50, 205, 50, 0.3)';
                    ctx.beginPath();
                    ctx.arc(sx, sy + bob, r * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Rising bubbles
                    ctx.fillStyle = '#32cd32';
                    ctx.shadowColor = '#32cd32';
                    ctx.shadowBlur = 6;
                    for (let i = 0; i < 3; i++) {
                        const bubblePhase = ((time * 0.003 + i * 0.33) % 1);
                        const bubbleX = sx + Math.sin(time * 0.005 + i * 2) * r * 0.6;
                        const bubbleY = sy + bob + r * 0.3 - bubblePhase * r * 2;
                        const bubbleSize = camera.scale(2) * (1 - bubblePhase * 0.5);
                        ctx.globalAlpha = (1 - bubblePhase) * 0.8;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                // HP bar (positioned above taller hat)
                if (this.hp < this.maxHp) {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(sx - camera.scale(20), sy - r - camera.scale(31) + bob, camera.scale(40), camera.scale(5));
                    ctx.fillStyle = COLORS.green;
                    ctx.fillRect(sx - camera.scale(20), sy - r - camera.scale(31) + bob, camera.scale(40) * (this.hp / this.maxHp), camera.scale(5));
                }
                
                ctx.restore();
            }
        }

        // ===== RAINBOW/POT OF GOLD CLASS =====
        class Rainbow {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.potRadius = 25; // Interaction radius
                this.spawnTime = Date.now();
                this.fadeOutStart = 0;
                this.fadeDelayStart = 0; // When pot was looted
                this.fading = false;
                this.dead = false;
                this.claimed = false; // Whether reward has been claimed
                this.linkedLeprechaun = null;
            }

            startFadeOut() {
                this.fading = true;
                this.fadeOutStart = Date.now();
            }

            update() {
                if (this.fading) {
                    if (Date.now() - this.fadeOutStart > 2000) {
                        this.dead = true;
                    }
                    return;
                }
                
                // Start fade 5 seconds after pot was looted
                if (this.claimed && this.fadeDelayStart > 0) {
                    if (Date.now() - this.fadeDelayStart > 5000) {
                        this.startFadeOut();
                    }
                    return;
                }
                
                if (this.claimed) return;
                
                // Check if player touches the pot
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < this.potRadius + player.radius) {
                    this.claimReward();
                }
            }
            
            claimReward() {
                if (this.claimed) return;
                this.claimed = true;
                
                // Visual celebration (reduced for performance)
                spawnParticles(this.x, this.y, COLORS.gold, 15);
                spawnParticles(this.x, this.y, '#ffffff', 10);
                
                // Give 50 gold
                playerGold += 50;
                updateGoldDisplay();
                
                // Show pot reward sequence (3 chest offers)
                showPotOfGoldReward();
                
                // Start fading out after 5 seconds
                this.fadeDelayStart = Date.now();
            }

            draw() {
                if (!camera.isVisible(this.x, this.y, 300)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                
                // Calculate opacity
                let alpha = 1;
                if (this.fading) {
                    alpha = 1 - (Date.now() - this.fadeOutStart) / 2000;
                } else {
                    // Fade in
                    alpha = Math.min(1, (Date.now() - this.spawnTime) / 500);
                }
                
                ctx.save();
                ctx.globalAlpha = alpha * 0.7;
                
                // Pot of gold at bottom
                const potX = sx;
                const potY = sy;
                
                // Pulsing glow when unclaimed
                const pulseGlow = this.claimed ? 10 : 15 + Math.sin(Date.now() * 0.005) * 10;
                ctx.shadowBlur = pulseGlow;
                ctx.shadowColor = COLORS.gold;
                
                // Pot (dark)
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(potX, potY, camera.scale(22), camera.scale(14), 0, 0, Math.PI);
                ctx.fill();
                ctx.fillRect(potX - camera.scale(18), potY - camera.scale(10), camera.scale(36), camera.scale(10));
                
                // Gold coins on top (more coins, bigger)
                ctx.fillStyle = this.claimed ? '#888' : COLORS.gold;
                ctx.beginPath();
                ctx.arc(potX - camera.scale(8), potY - camera.scale(12), camera.scale(6), 0, Math.PI * 2);
                ctx.arc(potX + camera.scale(8), potY - camera.scale(12), camera.scale(6), 0, Math.PI * 2);
                ctx.arc(potX, potY - camera.scale(16), camera.scale(6), 0, Math.PI * 2);
                ctx.arc(potX - camera.scale(4), potY - camera.scale(20), camera.scale(5), 0, Math.PI * 2);
                ctx.arc(potX + camera.scale(4), potY - camera.scale(20), camera.scale(5), 0, Math.PI * 2);
                ctx.fill();
                
                // "LOOT" indicator if unclaimed
                if (!this.claimed && !this.fading) {
                    ctx.fillStyle = COLORS.gold;
                    ctx.font = `bold ${camera.scale(12)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10;
                    ctx.fillText('✨ LOOT ✨', potX, potY - camera.scale(35));
                }
                
                // Vertical rainbow beam shooting up from pot
                if (!this.claimed) {
                    const rainbowColors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff', '#8800ff'];
                    const beamHeight = camera.scale(150);
                    const bandWidth = camera.scale(5);
                    const totalWidth = bandWidth * rainbowColors.length;
                    
                    // Shimmer effect
                    const shimmer = Math.sin(Date.now() * 0.003) * 0.15 + 0.85;
                    ctx.globalAlpha = alpha * 0.6 * shimmer;
                    
                    for (let i = 0; i < rainbowColors.length; i++) {
                        const bandX = potX - totalWidth / 2 + i * bandWidth + bandWidth / 2;
                        
                        // Create gradient for each band
                        const grad = ctx.createLinearGradient(bandX, potY - camera.scale(20), bandX, potY - beamHeight);
                        grad.addColorStop(0, rainbowColors[i]);
                        grad.addColorStop(0.7, rainbowColors[i]);
                        grad.addColorStop(1, 'transparent');
                        
                        ctx.strokeStyle = grad;
                        ctx.lineWidth = bandWidth;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = rainbowColors[i];
                        ctx.beginPath();
                        ctx.moveTo(bandX, potY - camera.scale(20));
                        ctx.lineTo(bandX, potY - beamHeight);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
        }
        
        // Pot of Gold reward system - 3 chest offers in a row
        let potRewardQueue = [];
        let potRewardIndex = 0;
        
        function showPotOfGoldReward() {
            gamePaused = true;
            potRewardQueue = [];
            potRewardIndex = 0;
            
            // No legendaries in pot rewards - just shrine powerups
            const legendaryOfferCount = 0;
            
            // Fill all 3 slots with shrine powerups
            const powerupIds = Object.keys(SHRINE_POWERUPS);
            for (let i = 0; i < 3; i++) {
                const randomId = powerupIds[Math.floor(Math.random() * powerupIds.length)];
                const powerup = SHRINE_POWERUPS[randomId];
                potRewardQueue.push({ 
                    type: 'shrine', 
                    id: randomId,
                    icon: powerup.icon,
                    name: powerup.name,
                    desc: powerup.desc,
                    color: powerup.color
                });
            }
            
            // Shuffle the queue
            potRewardQueue.sort(() => Math.random() - 0.5);
            
            showNextPotReward();
        }
        
        function showNextPotReward() {
            if (potRewardIndex >= potRewardQueue.length) {
                // All rewards claimed - restore leave button visibility
                DOM.modalLeave.style.display = '';
                gamePaused = false;
                return;
            }
            
            const reward = potRewardQueue[potRewardIndex];
            
            // Hide slot reel, show card directly for pot rewards
            if (DOM.chestSlotReel) {
                DOM.chestSlotReel.classList.remove('spinning', 'stopped');
                DOM.chestSlotReel.style.display = 'none';
            }
            
            // For legendary rewards, skip card preview and go straight to 3-choice
            if (reward.type === 'legendary') {
                legendaryCount++;
                lastLegendaryTime = gameTime;
                guaranteedLegendaryNext = false;
                showLegendaryUpgrade();
                return;
            }
            
            DOM.modalCard.style.display = '';
            DOM.modalTake.parentElement.style.display = '';
            
            // Use new chest modal
            DOM.modalTitle.textContent = `🍀 POT OF GOLD (${potRewardIndex + 1}/3) 🍀`;
            DOM.modalTitle.style.color = '#00ff00';
            DOM.modalTitle.style.textShadow = '0 0 20px #00ff00';
            DOM.modalCost.textContent = 'FREE REWARD!';
            DOM.modalCost.style.color = '#00ff00';
            
            DOM.modalCard.style.borderColor = reward.color || COLORS.gold;
            
            DOM.modalCard.classList.remove('legendary');
            DOM.modalName.style.color = reward.color || COLORS.gold;
            
            DOM.modalIcon.textContent = reward.icon;
            DOM.modalName.textContent = reward.name;
            DOM.modalDesc.textContent = reward.desc;
            
            DOM.modalTake.classList.remove('disabled');
            DOM.modalTake.textContent = potRewardIndex < 2 ? 'TAKE & NEXT' : 'TAKE';
            
            // Hide leave button for pot rewards (forced accept)
            DOM.modalLeave.style.display = 'none';
            
            DOM.chestModal.classList.add('visible');
            
            // Override accept behavior for pot rewards
            pendingChest = { isPotReward: true, reward: reward };
        }
        
        function acceptPotReward() {
            const reward = potRewardQueue[potRewardIndex];
            
            // Legendary rewards are now handled directly in showNextPotReward
            // This should only handle shrine powerups now
            if (reward.type === 'legendary') {
                // Shouldn't reach here, but just in case
                return;
            }
            
            const powerup = SHRINE_POWERUPS[reward.id];
            player.addShrineBonus(powerup.stat, powerup.value);
            updateBuffsBar();
            
            potRewardIndex++;
            DOM.chestModal.classList.remove('visible');
            DOM.modalCard.classList.remove('legendary'); // Reset legendary styling
            
            // Small delay before next reward
            setTimeout(() => {
                showNextPotReward();
            }, 300);
        }

        // ===== GHOST CLASS (Vengeful Spirits) =====
        class Ghost {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.speed = 5;
                this.damage = 25 + player.level * 5;
                this.dead = false;
                this.alpha = 0.8;
                this.target = null;
                this.lifetime = 5000; // 5 seconds max
                this.spawnTime = Date.now();
                
                // Find nearest enemy
                this.acquireTarget();
            }
            
            acquireTarget() {
                let nearest = null;
                let minDist = Infinity;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                }
                
                this.target = nearest;
            }
            
            update(dt) {
                if (this.dead) return;
                
                // Frame-rate independent
                const dtScale = dt / 16;
                
                // Check lifetime
                if (Date.now() - this.spawnTime > this.lifetime) {
                    this.dead = true;
                    spawnParticles(this.x, this.y, '#aaccff', 8);
                    return;
                }
                
                // Re-acquire target if current is dead
                if (!this.target || this.target.dead) {
                    this.acquireTarget();
                }
                
                // Move toward target
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 0) {
                        this.x += (dx / dist) * this.speed * dtScale;
                        this.y += (dy / dist) * this.speed * dtScale;
                    }
                    
                    // Collision - kamikaze!
                    if (dist < this.radius + this.target.radius) {
                        this.target.takeDamage(this.damage, false);
                        spawnParticles(this.x, this.y, '#aaccff', 15);
                        spawnParticles(this.x, this.y, '#ffffff', 10);
                        this.dead = true;
                    }
                } else {
                    // No target - fade out
                    this.alpha -= 0.02 * dtScale;
                    if (this.alpha <= 0) {
                        this.dead = true;
                    }
                }
            }
            
            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                ctx.globalAlpha = this.alpha * (0.7 + Math.sin(Date.now() * 0.01) * 0.3);
                
                // Ghost body (translucent circle with wispy effect)
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#aaccff';
                
                // Wispy trail
                const trail = Math.sin(Date.now() * 0.008) * camera.scale(3);
                ctx.fillStyle = 'rgba(170, 204, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(sx, sy + trail, r * 1.2, r * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Main body
                ctx.fillStyle = '#aaccff';
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.8, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(sx - camera.scale(3), sy - camera.scale(2), camera.scale(2), 0, Math.PI * 2);
                ctx.arc(sx + camera.scale(3), sy - camera.scale(2), camera.scale(2), 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // ===== MINI BOSS CLASS =====
        class MiniBoss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 35;
                this.incomingDamage = 0; // Track damage from projectiles in flight
                
                // Time-based scaling for mini boss
                const timeScale = 1 + Math.floor(gameTime / 75) * 0.20; // +20% per 75s (slowed from /60)
                const speedScale = 1 + Math.floor(gameTime / 150) * 0.08; // +8% speed per 2.5 min (slowed from /120)
                
                this.speed = 1.3 * speedScale * enemySpeedBonus;
                this.maxHp = Math.floor((400 + bossCount * 100) * timeScale * enemyHealthBonus);
                this.hp = this.maxHp;
                this.damage = Math.floor(25 * timeScale * enemyDamageBonus);
                this.color = '#ff6600';
                this.dead = false;
                this.orbHitCooldown = 0;
                this.attackCooldown = 0;
                this.isBoss = true;
                this.bossType = 'mini';
                
                // Status effects
                this.poisonDamage = 0;
                this.poisonTicks = 0;
                this.poisonTickTimer = 0;
                
                // Knockback velocity (smooth knockback)
                this.knockbackVelX = 0;
                this.knockbackVelY = 0;
            }
            
            applyPoison(damage) {
                this.poisonDamage = damage;
                this.poisonTicks = 5;
                this.poisonTickTimer = 0;
                spawnParticles(this.x, this.y, '#32cd32', 4);
            }
            
            applyKnockback(angle, force) {
                // Bosses resist knockback more
                this.knockbackVelX += Math.cos(angle) * force * 0.08;
                this.knockbackVelY += Math.sin(angle) * force * 0.08;
            }
            
            update(dt) {
                if (this.dead) return;
                
                // Poison ticks
                if (this.poisonTicks > 0) {
                    this.poisonTickTimer += dt;
                    if (this.poisonTickTimer >= 800) {
                        this.poisonTickTimer = 0;
                        this.poisonTicks--;
                        this.hp -= this.poisonDamage;
                        spawnDamageNumber(this.x, this.y, Math.round(this.poisonDamage), false);
                        spawnParticles(this.x, this.y, '#32cd32', 2);
                        if (this.hp <= 0 && !this.dead) this.die();
                    }
                }
                
                // Frame-rate independent
                const dtScale = dt / 16;
                const frameSpeed = this.speed * dtScale;
                
                // Chase player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    const dirX = dx / dist;
                    const dirY = dy / dist;
                    let newX = this.x + dirX * frameSpeed;
                    let newY = this.y + dirY * frameSpeed;
                    
                    // Check terrain collision
                    const terrain = isInTerrain(newX, newY, this.radius);
                    if (!terrain) {
                        this.x = newX;
                        this.y = newY;
                    } else {
                        // Navigate around obstacle
                        const perpLeft = { x: -dirY, y: dirX };
                        const perpRight = { x: dirY, y: -dirX };
                        const toObsX = terrain.x - this.x;
                        const toObsY = terrain.y - this.y;
                        const crossProduct = dirX * toObsY - dirY * toObsX;
                        const preferredPerp = crossProduct > 0 ? perpRight : perpLeft;
                        
                        const slideX = this.x + preferredPerp.x * frameSpeed;
                        const slideY = this.y + preferredPerp.y * frameSpeed;
                        
                        if (!isInTerrain(slideX, slideY, this.radius)) {
                            this.x = slideX;
                            this.y = slideY;
                        }
                    }
                }
                
                // Apply knockback velocity (smooth knockback)
                if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) {
                    const dtScale2 = dt / 16;
                    this.x += this.knockbackVelX * dtScale2;
                    this.y += this.knockbackVelY * dtScale2;
                    
                    const friction = 0.88;
                    this.knockbackVelX *= friction;
                    this.knockbackVelY *= friction;
                    
                    if (Math.abs(this.knockbackVelX) < 0.05) this.knockbackVelX = 0;
                    if (Math.abs(this.knockbackVelY) < 0.05) this.knockbackVelY = 0;
                }
                
                // Clamp to world
                this.x = Math.max(this.radius, Math.min(WORLD.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD.height - this.radius, this.y));
                
                // Collision damage
                if (dist < this.radius + player.radius) {
                    player.takeDamage(25);
                }
                
                // Spawn minions periodically
                if (this.attackCooldown <= 0) {
                    this.spawnMinions();
                    this.attackCooldown = 5000; // Every 5 seconds
                }
                
                if (this.attackCooldown > 0) this.attackCooldown -= dt;
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }
            
            spawnMinions() {
                // Spawn 3-5 swarm enemies around boss
                const count = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const spawnX = this.x + Math.cos(angle) * 60;
                    const spawnY = this.y + Math.sin(angle) * 60;
                    enemies.push(new Enemy('swarm', spawnX, spawnY));
                }
                spawnParticles(this.x, this.y, this.color, 15);
            }
            
            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                // Reduce tracked incoming damage (projectile has hit)
                this.incomingDamage = Math.max(0, this.incomingDamage - amount);
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }
            
            die() {
                if (this.dead) return;
                this.dead = true;
                kills += 10;
                const killEl = document.getElementById('killCount'); if (killEl) killEl.textContent = kills;
                
                // Big explosion (reduced for performance)
                spawnParticles(this.x, this.y, this.color, 20);
                spawnParticles(this.x, this.y, '#ffffff', 12);
                spawnParticles(this.x, this.y, COLORS.gold, 10);
                
                // Suck up all XP gems on the map
                for (const gem of xpGems) {
                    if (!gem.dead) {
                        gem.magnetized = true;
                        gem.magnetStrength = 7; // Smoother pull to prevent lag
                    }
                }
                
                // Drop lots of gold and XP
                playerGold += 100;
                updateGoldDisplay();
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const gemX = this.x + Math.cos(angle) * 30;
                    const gemY = this.y + Math.sin(angle) * 30;
                    xpGems.push(new XPGem(gemX, gemY, 15));
                }
                
                showBossDefeatMessage('MINI BOSS');
                
                // Grant 1 level up reward
                setTimeout(() => {
                    if (gameRunning) showUpgradeSelection();
                }, 500);
            }
            
            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const s = r;
                const time = Date.now();
                
                ctx.save();
                
                // Pulsing glow
                const pulse = 0.8 + Math.sin(time * 0.005) * 0.2;
                
                // Outer fire aura ring
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.4 * pulse;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(sx, sy, s * 1.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Floating animation
                const floatOffset = Math.sin(time / 250) * camera.scale(3);
                const ghostY = sy + floatOffset;
                
                // ===== GHOST BODY SHAPE with fiery glow =====
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 30 * pulse;
                
                // Fire gradient for ghost body
                const bodyGrad = ctx.createRadialGradient(sx, ghostY, 0, sx, ghostY, s);
                bodyGrad.addColorStop(0, '#ffaa00');
                bodyGrad.addColorStop(0.6, '#ff6600');
                bodyGrad.addColorStop(1, '#cc4400');
                ctx.fillStyle = bodyGrad;
                
                ctx.beginPath();
                // Dome top
                ctx.arc(sx, ghostY - s * 0.2, s, Math.PI, 0, false);
                
                // Wavy bottom with more aggressive wave for mini boss
                const bottomY = ghostY + s * 0.8;
                const waveAmp = s * 0.3;
                const tailWiggle = Math.sin(time / 150) * s * 0.15;
                
                ctx.lineTo(sx + s, bottomY - waveAmp);
                ctx.quadraticCurveTo(sx + s * 0.7 + tailWiggle, bottomY + waveAmp * 1.2, sx + s * 0.33, bottomY - waveAmp * 0.5);
                ctx.quadraticCurveTo(sx + tailWiggle * 0.5, bottomY + waveAmp * 1.5, sx - s * 0.33, bottomY - waveAmp * 0.5);
                ctx.quadraticCurveTo(sx - s * 0.7 - tailWiggle, bottomY + waveAmp * 1.2, sx - s, bottomY - waveAmp);
                ctx.closePath();
                ctx.fill();
                
                // Fiery outline
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffaa00';
                ctx.stroke();
                
                // Inner fire pattern
                ctx.strokeStyle = '#ffcc00';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 8;
                for (let i = 0; i < 3; i++) {
                    const crackAngle = (i / 3) * Math.PI * 2 + time * 0.002;
                    ctx.beginPath();
                    ctx.moveTo(sx, ghostY);
                    ctx.lineTo(sx + Math.cos(crackAngle) * s * 0.5, ghostY + Math.sin(crackAngle) * s * 0.5);
                    ctx.stroke();
                }
                
                // ===== ANGRY GHOST FACE =====
                const eyeY = ghostY - s * 0.2;
                const eyeSpacing = s * 0.35;
                const eyeSize = s * 0.2;
                
                // Dark eye sockets
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.ellipse(sx - eyeSpacing, eyeY, eyeSize, eyeSize * 0.8, 0, 0, Math.PI * 2);
                ctx.ellipse(sx + eyeSpacing, eyeY, eyeSize, eyeSize * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Glowing red pupils
                ctx.fillStyle = '#ff0000';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#ff0000';
                const pupilPulse = 0.1 + Math.sin(time * 0.01) * 0.03;
                ctx.beginPath();
                ctx.arc(sx - eyeSpacing, eyeY, s * pupilPulse, 0, Math.PI * 2);
                ctx.arc(sx + eyeSpacing, eyeY, s * pupilPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Angry eyebrows
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ff6600';
                ctx.beginPath();
                ctx.moveTo(sx - eyeSpacing - eyeSize, eyeY - eyeSize * 1.2);
                ctx.lineTo(sx - eyeSpacing + eyeSize * 0.3, eyeY - eyeSize * 0.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(sx + eyeSpacing + eyeSize, eyeY - eyeSize * 1.2);
                ctx.lineTo(sx + eyeSpacing - eyeSize * 0.3, eyeY - eyeSize * 0.5);
                ctx.stroke();
                
                // Frowning mouth
                ctx.strokeStyle = '#330000';
                ctx.lineWidth = s * 0.08;
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(sx, ghostY + s * 0.4, s * 0.2, Math.PI + 0.3, -0.3);
                ctx.stroke();
                
                // Highlight shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.beginPath();
                ctx.ellipse(sx - s * 0.35, ghostY - s * 0.55, s * 0.2, s * 0.15, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Poison effect - green tint and bubbles
                if (this.poisonTicks > 0) {
                    // Green overlay
                    ctx.fillStyle = 'rgba(50, 205, 50, 0.25)';
                    ctx.beginPath();
                    ctx.arc(sx, ghostY, s * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Rising bubbles
                    ctx.fillStyle = '#32cd32';
                    ctx.shadowColor = '#32cd32';
                    ctx.shadowBlur = 8;
                    for (let i = 0; i < 5; i++) {
                        const bubblePhase = ((time * 0.003 + i * 0.2) % 1);
                        const bubbleX = sx + Math.sin(time * 0.004 + i * 1.3) * s * 0.7;
                        const bubbleY = ghostY + s * 0.5 - bubblePhase * s * 2.2;
                        const bubbleSize = camera.scale(3) * (1 - bubblePhase * 0.4);
                        ctx.globalAlpha = (1 - bubblePhase) * 0.85;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                // HP bar
                ctx.shadowBlur = 0;
                const barWidth = r * 2;
                ctx.fillStyle = '#333';
                ctx.fillRect(sx - barWidth/2, ghostY - s - 28, barWidth, 8);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(sx - barWidth/2, ghostY - s - 28, barWidth * (this.hp / this.maxHp), 8);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(sx - barWidth/2, ghostY - s - 28, barWidth, 8);
                
                // "MINI BOSS" label
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${camera.scale(10)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff6600';
                ctx.fillText('👻 MINI BOSS', sx, ghostY - s - 33);
                
                ctx.restore();
            }
        }
        
        // ===== MAJOR BOSS CLASS =====
        class MajorBoss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 55;
                this.incomingDamage = 0; // Track damage from projectiles in flight
                
                // Time-based scaling for major boss
                const timeScale = 1 + Math.floor(gameTime / 75) * 0.25; // +25% per 75s (slowed from /60)
                const speedScale = 1 + Math.floor(gameTime / 180) * 0.10; // +10% speed per 3 min (slowed from /150)
                
                this.baseSpeedValue = 0.9 * speedScale * enemySpeedBonus;
                this.speed = this.baseSpeedValue;
                this.maxHp = Math.floor((700 + bossCount * 140) * timeScale * enemyHealthBonus);
                this.hp = this.maxHp;
                this.damage = Math.floor(40 * timeScale * enemyDamageBonus);
                this.color = '#ff6600';
                this.dead = false;
                this.orbHitCooldown = 0;
                this.attackCooldown = 0;
                this.chargeTimer = 0;
                this.isCharging = false;
                this.chargeTarget = { x: 0, y: 0 };
                this.isBoss = true;
                this.bossType = 'major';
                this.phase = 1; // Phases at 66% and 33% HP
                this.speedScale = speedScale; // Store for phase changes
                
                // Status effects
                this.poisonDamage = 0;
                this.poisonTicks = 0;
                this.poisonTickTimer = 0;
                
                // Knockback velocity (smooth knockback)
                this.knockbackVelX = 0;
                this.knockbackVelY = 0;
            }
            
            applyPoison(damage) {
                this.poisonDamage = damage;
                this.poisonTicks = 5;
                this.poisonTickTimer = 0;
                spawnParticles(this.x, this.y, '#32cd32', 4);
            }
            
            applyKnockback(angle, force) {
                // Major bosses resist knockback even more
                this.knockbackVelX += Math.cos(angle) * force * 0.05;
                this.knockbackVelY += Math.sin(angle) * force * 0.05;
            }
            
            update(dt) {
                if (this.dead) return;
                
                // Poison ticks
                if (this.poisonTicks > 0) {
                    this.poisonTickTimer += dt;
                    if (this.poisonTickTimer >= 800) {
                        this.poisonTickTimer = 0;
                        this.poisonTicks--;
                        this.hp -= this.poisonDamage;
                        spawnDamageNumber(this.x, this.y, Math.round(this.poisonDamage), false);
                        spawnParticles(this.x, this.y, '#32cd32', 2);
                        if (this.hp <= 0 && !this.dead) this.die();
                    }
                }
                
                // Frame-rate independent
                const dtScale = dt / 16;
                
                // Phase transitions (speed scales with time)
                const hpPercent = this.hp / this.maxHp;
                if (hpPercent <= 0.33 && this.phase < 3) {
                    this.phase = 3;
                    this.speed = 1.5 * this.speedScale;
                    spawnParticles(this.x, this.y, '#ff0000', 30);
                    spawnParticles(this.x, this.y, '#ff4400', 25);
                    showBossPhaseWarning('🔥 ENRAGED! 🔥');
                } else if (hpPercent <= 0.66 && this.phase < 2) {
                    this.phase = 2;
                    this.speed = 1.2 * this.speedScale;
                    spawnParticles(this.x, this.y, '#ff6600', 20);
                    spawnParticles(this.x, this.y, '#ffaa00', 15);
                    showBossPhaseWarning('🔥 PHASE 2 🔥');
                }
                
                // Charge attack
                if (this.isCharging) {
                    const dx = this.chargeTarget.x - this.x;
                    const dy = this.chargeTarget.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 20) {
                        this.x += (dx / dist) * 8 * dtScale;
                        this.y += (dy / dist) * 8 * dtScale;
                    } else {
                        this.isCharging = false;
                        // Shockwave on landing
                        spawnParticles(this.x, this.y, this.color, 25);
                        // Damage player if close
                        const playerDist = Math.hypot(player.x - this.x, player.y - this.y);
                        if (playerDist < 100) {
                            player.takeDamage(this.damage);
                            // Knockback
                            const kbDx = player.x - this.x;
                            const kbDy = player.y - this.y;
                            const kbDist = Math.hypot(kbDx, kbDy);
                            if (kbDist > 0) {
                                player.x += (kbDx / kbDist) * 80;
                                player.y += (kbDy / kbDist) * 80;
                            }
                        }
                    }
                } else {
                    // Normal chase
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    const frameSpeed = this.speed * dtScale;
                    
                    if (dist > 0) {
                        const dirX = dx / dist;
                        const dirY = dy / dist;
                        let newX = this.x + dirX * frameSpeed;
                        let newY = this.y + dirY * frameSpeed;
                        
                        // Check terrain collision
                        const terrain = isInTerrain(newX, newY, this.radius);
                        if (!terrain) {
                            this.x = newX;
                            this.y = newY;
                        } else {
                            // Navigate around obstacle
                            const perpLeft = { x: -dirY, y: dirX };
                            const perpRight = { x: dirY, y: -dirX };
                            const toObsX = terrain.x - this.x;
                            const toObsY = terrain.y - this.y;
                            const crossProduct = dirX * toObsY - dirY * toObsX;
                            const preferredPerp = crossProduct > 0 ? perpRight : perpLeft;
                            
                            const slideX = this.x + preferredPerp.x * frameSpeed;
                            const slideY = this.y + preferredPerp.y * frameSpeed;
                            
                            if (!isInTerrain(slideX, slideY, this.radius)) {
                                this.x = slideX;
                                this.y = slideY;
                            }
                        }
                    }
                }
                
                // Apply knockback velocity (smooth knockback)
                if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) {
                    const dtScale2 = dt / 16;
                    this.x += this.knockbackVelX * dtScale2;
                    this.y += this.knockbackVelY * dtScale2;
                    
                    const friction = 0.88;
                    this.knockbackVelX *= friction;
                    this.knockbackVelY *= friction;
                    
                    if (Math.abs(this.knockbackVelX) < 0.05) this.knockbackVelX = 0;
                    if (Math.abs(this.knockbackVelY) < 0.05) this.knockbackVelY = 0;
                }
                
                // Clamp to world
                this.x = Math.max(this.radius, Math.min(WORLD.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD.height - this.radius, this.y));
                
                // Collision damage
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < this.radius + player.radius) {
                    player.takeDamage(35);
                }
                
                // Attack patterns
                if (this.attackCooldown <= 0 && !this.isCharging) {
                    const attack = Math.random();
                    if (attack < 0.3) {
                        // Charge attack
                        this.isCharging = true;
                        this.chargeTarget = { x: player.x, y: player.y };
                        spawnParticles(this.x, this.y, '#ff0000', 15);
                    } else if (attack < 0.6) {
                        // Spawn minions
                        this.spawnMinions();
                    } else {
                        // Ring of projectiles
                        this.fireRing();
                    }
                    this.attackCooldown = this.phase === 3 ? 2500 : (this.phase === 2 ? 3500 : 4500);
                }
                
                if (this.attackCooldown > 0) this.attackCooldown -= dt;
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }
            
            spawnMinions() {
                const count = 4 + this.phase * 2;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const spawnX = this.x + Math.cos(angle) * 80;
                    const spawnY = this.y + Math.sin(angle) * 80;
                    const type = Math.random() < 0.3 ? 'fast' : 'swarm';
                    enemies.push(new Enemy(type, spawnX, spawnY));
                }
                spawnParticles(this.x, this.y, COLORS.green, 20);
            }
            
            fireRing() {
                // Fire projectiles in a ring (visual effect - damages on contact)
                const count = 8 + this.phase * 4;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    // Create enemy projectile (use basic enemy that dies fast)
                    const projX = this.x + Math.cos(angle) * 40;
                    const projY = this.y + Math.sin(angle) * 40;
                    const proj = new Enemy('swarm', projX, projY);
                    proj.hp = 1;
                    proj.speed = 4;
                    // Override movement to go in straight line
                    proj.fixedAngle = angle;
                    enemies.push(proj);
                }
                spawnParticles(this.x, this.y, this.color, 20);
            }
            
            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                // Reduce tracked incoming damage (projectile has hit)
                this.incomingDamage = Math.max(0, this.incomingDamage - amount);
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }
            
            die() {
                if (this.dead) return;
                this.dead = true;
                kills += 25;
                const killEl = document.getElementById('killCount'); if (killEl) killEl.textContent = kills;
                
                // Massive explosion
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const ox = (Math.random() - 0.5) * 60;
                        const oy = (Math.random() - 0.5) * 60;
                        spawnParticles(this.x + ox, this.y + oy, this.color, 30);
                        spawnParticles(this.x + ox, this.y + oy, '#ffffff', 20);
                    }, i * 100);
                }
                spawnParticles(this.x, this.y, COLORS.gold, 40);
                
                // Suck up all XP gems on the map
                for (const gem of xpGems) {
                    if (!gem.dead) {
                        gem.magnetized = true;
                        gem.magnetStrength = 8; // Smoother pull to prevent lag
                    }
                }
                
                // Drop lots of gold and XP
                playerGold += 250;
                updateGoldDisplay();
                
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const dist = 30 + Math.random() * 40;
                    const gemX = this.x + Math.cos(angle) * dist;
                    const gemY = this.y + Math.sin(angle) * dist;
                    xpGems.push(new XPGem(gemX, gemY, 20));
                }
                
                showBossDefeatMessage('INFERNO BOSS');
                
                // Grant 2 level up rewards
                let rewardsGiven = 0;
                const giveReward = () => {
                    if (gameRunning && rewardsGiven < 2) {
                        rewardsGiven++;
                        showUpgradeSelection();
                    }
                };
                setTimeout(giveReward, 500);
                setTimeout(giveReward, 1500);
            }
            
            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const s = r;
                const time = Date.now();
                
                ctx.save();
                
                // Intense pulsing glow (faster in higher phases)
                const pulseSpeed = 0.003 + this.phase * 0.002;
                const pulse = 0.7 + Math.sin(time * pulseSpeed) * 0.3;
                
                // Animated flame aura around boss ghost
                ctx.shadowBlur = 50 * pulse;
                ctx.shadowColor = this.phase === 3 ? '#ff0000' : '#ff4400';
                
                // Floating animation (more intense for boss)
                const floatOffset = Math.sin(time / 200) * camera.scale(4);
                const ghostY = sy + floatOffset;
                
                // Outer flame tendrils emanating from ghost
                for (let i = 0; i < 8; i++) {
                    const flameAngle = (i / 8) * Math.PI * 2 + time * 0.002;
                    const flameLen = s * (0.4 + Math.sin(time * 0.008 + i) * 0.2);
                    const fx = sx + Math.cos(flameAngle) * (s + flameLen);
                    const fy = ghostY + Math.sin(flameAngle) * (s + flameLen);
                    
                    ctx.fillStyle = this.phase === 3 ? '#ff2200' : '#ff6600';
                    ctx.globalAlpha = 0.6 + Math.sin(time * 0.01 + i * 2) * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(sx + Math.cos(flameAngle) * s * 0.9, ghostY + Math.sin(flameAngle) * s * 0.9);
                    ctx.quadraticCurveTo(
                        sx + Math.cos(flameAngle + 0.2) * (s + flameLen * 0.5),
                        ghostY + Math.sin(flameAngle + 0.2) * (s + flameLen * 0.5),
                        fx, fy
                    );
                    ctx.quadraticCurveTo(
                        sx + Math.cos(flameAngle - 0.2) * (s + flameLen * 0.5),
                        ghostY + Math.sin(flameAngle - 0.2) * (s + flameLen * 0.5),
                        sx + Math.cos(flameAngle) * s * 0.9,
                        ghostY + Math.sin(flameAngle) * s * 0.9
                    );
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                
                // ===== GHOST BODY SHAPE with inferno gradient =====
                const bodyGrad = ctx.createRadialGradient(sx, ghostY, 0, sx, ghostY, s);
                if (this.phase === 3) {
                    bodyGrad.addColorStop(0, '#660000');
                    bodyGrad.addColorStop(0.5, '#aa0000');
                    bodyGrad.addColorStop(1, '#ff2200');
                } else if (this.phase === 2) {
                    bodyGrad.addColorStop(0, '#663300');
                    bodyGrad.addColorStop(0.5, '#aa4400');
                    bodyGrad.addColorStop(1, '#ff6600');
                } else {
                    bodyGrad.addColorStop(0, '#664400');
                    bodyGrad.addColorStop(0.5, '#aa5500');
                    bodyGrad.addColorStop(1, '#ff6600');
                }
                ctx.fillStyle = bodyGrad;
                
                ctx.beginPath();
                // Dome top - larger for major boss
                ctx.arc(sx, ghostY - s * 0.15, s, Math.PI, 0, false);
                
                // Wavy bottom with aggressive flame-like waves
                const bottomY = ghostY + s * 0.85;
                const waveAmp = s * 0.35;
                const tailWiggle = Math.sin(time / 120) * s * 0.2;
                
                ctx.lineTo(sx + s, bottomY - waveAmp);
                ctx.quadraticCurveTo(sx + s * 0.7 + tailWiggle, bottomY + waveAmp * 1.3, sx + s * 0.33, bottomY - waveAmp * 0.4);
                ctx.quadraticCurveTo(sx + tailWiggle * 0.5, bottomY + waveAmp * 1.5, sx - s * 0.33, bottomY - waveAmp * 0.4);
                ctx.quadraticCurveTo(sx - s * 0.7 - tailWiggle, bottomY + waveAmp * 1.3, sx - s, bottomY - waveAmp);
                ctx.closePath();
                ctx.fill();
                
                // Fiery outline
                ctx.strokeStyle = this.phase === 3 ? '#ff4400' : '#ffaa00';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.stroke();
                
                // Inner lava cracks on ghost body
                ctx.strokeStyle = this.phase === 3 ? '#ff4400' : '#ffaa00';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                for (let i = 0; i < 5; i++) {
                    const crackAngle = (i / 5) * Math.PI * 2 + time * 0.001;
                    ctx.beginPath();
                    ctx.moveTo(sx, ghostY);
                    ctx.lineTo(sx + Math.cos(crackAngle) * s * 0.6, ghostY + Math.sin(crackAngle) * s * 0.6);
                    ctx.stroke();
                }
                
                // Molten core glow
                const coreGrad = ctx.createRadialGradient(sx, ghostY - s * 0.1, 0, sx, ghostY - s * 0.1, s * 0.35);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.4, '#ffff00');
                coreGrad.addColorStop(1, '#ff6600');
                ctx.fillStyle = coreGrad;
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#ffaa00';
                ctx.beginPath();
                ctx.arc(sx, ghostY - s * 0.1, s * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                // ===== MENACING MEGABOSS GHOST FACE =====
                const eyeY = ghostY - s * 0.15;
                const eyeSpacing = s * 0.35;
                const eyeSize = s * 0.18;
                
                // Skull-like eye sockets
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                // Angular skull eye shapes
                ctx.moveTo(sx - eyeSpacing - eyeSize, eyeY - eyeSize * 0.3);
                ctx.lineTo(sx - eyeSpacing, eyeY - eyeSize);
                ctx.lineTo(sx - eyeSpacing + eyeSize, eyeY - eyeSize * 0.3);
                ctx.lineTo(sx - eyeSpacing + eyeSize * 0.5, eyeY + eyeSize);
                ctx.lineTo(sx - eyeSpacing - eyeSize * 0.5, eyeY + eyeSize);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(sx + eyeSpacing - eyeSize, eyeY - eyeSize * 0.3);
                ctx.lineTo(sx + eyeSpacing, eyeY - eyeSize);
                ctx.lineTo(sx + eyeSpacing + eyeSize, eyeY - eyeSize * 0.3);
                ctx.lineTo(sx + eyeSpacing + eyeSize * 0.5, eyeY + eyeSize);
                ctx.lineTo(sx + eyeSpacing - eyeSize * 0.5, eyeY + eyeSize);
                ctx.closePath();
                ctx.fill();
                
                // Glowing demonic pupils
                const pupilColor = this.phase === 3 ? '#ff0000' : '#ff4400';
                ctx.fillStyle = pupilColor;
                ctx.shadowBlur = 20;
                ctx.shadowColor = pupilColor;
                const pupilPulse = 0.1 + Math.sin(time * 0.012) * 0.04;
                ctx.beginPath();
                ctx.arc(sx - eyeSpacing, eyeY, s * pupilPulse, 0, Math.PI * 2);
                ctx.arc(sx + eyeSpacing, eyeY, s * pupilPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Angry flame eyebrows
                ctx.strokeStyle = this.phase === 3 ? '#ff2200' : '#ff6600';
                ctx.lineWidth = 5;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.moveTo(sx - eyeSpacing - eyeSize * 1.2, eyeY - eyeSize * 1.5);
                ctx.lineTo(sx - eyeSpacing + eyeSize * 0.3, eyeY - eyeSize * 0.7);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(sx + eyeSpacing + eyeSize * 1.2, eyeY - eyeSize * 1.5);
                ctx.lineTo(sx + eyeSpacing - eyeSize * 0.3, eyeY - eyeSize * 0.7);
                ctx.stroke();
                
                // Jagged teeth mouth
                const mouthY = ghostY + s * 0.35;
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(sx - s * 0.3, mouthY - s * 0.05);
                ctx.lineTo(sx + s * 0.3, mouthY - s * 0.05);
                ctx.lineTo(sx + s * 0.25, mouthY + s * 0.15);
                ctx.lineTo(sx - s * 0.25, mouthY + s * 0.15);
                ctx.closePath();
                ctx.fill();
                
                // Teeth
                ctx.fillStyle = '#ffccaa';
                for (let i = 0; i < 5; i++) {
                    const tx = sx - s * 0.2 + (i * s * 0.1);
                    ctx.beginPath();
                    ctx.moveTo(tx, mouthY - s * 0.03);
                    ctx.lineTo(tx + s * 0.04, mouthY + s * 0.08);
                    ctx.lineTo(tx - s * 0.04, mouthY + s * 0.08);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Highlight shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.ellipse(sx - s * 0.4, ghostY - s * 0.5, s * 0.2, s * 0.15, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Poison effect - green tint and bubbles
                if (this.poisonTicks > 0) {
                    // Green overlay
                    ctx.fillStyle = 'rgba(50, 205, 50, 0.2)';
                    ctx.beginPath();
                    ctx.arc(sx, ghostY, s * 1.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Rising bubbles (more for big boss)
                    ctx.fillStyle = '#32cd32';
                    ctx.shadowColor = '#32cd32';
                    ctx.shadowBlur = 10;
                    for (let i = 0; i < 7; i++) {
                        const bubblePhase = ((time * 0.003 + i * 0.14) % 1);
                        const bubbleX = sx + Math.sin(time * 0.004 + i * 0.9) * s * 0.8;
                        const bubbleY = ghostY + s * 0.6 - bubblePhase * s * 2.5;
                        const bubbleSize = camera.scale(4) * (1 - bubblePhase * 0.3);
                        ctx.globalAlpha = (1 - bubblePhase) * 0.85;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                // HP bar
                ctx.shadowBlur = 0;
                const barWidth = r * 2.5;
                ctx.fillStyle = '#333';
                ctx.fillRect(sx - barWidth/2, ghostY - s - 33, barWidth, 10);
                
                // HP bar color based on phase
                const hpColor = this.phase === 3 ? '#ff0000' : (this.phase === 2 ? '#ffaa00' : '#00ff00');
                ctx.fillStyle = hpColor;
                ctx.fillRect(sx - barWidth/2, ghostY - s - 33, barWidth * (this.hp / this.maxHp), 10);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx - barWidth/2, ghostY - s - 33, barWidth, 10);
                
                // "INFERNO BOSS" label with ghost emoji
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${camera.scale(14)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff4400';
                ctx.fillText('🔥 INFERNO GHOST 🔥', sx, ghostY - s - 41);
                
                ctx.restore();
            }
        }
        
        // Boss defeat message
        function showBossDefeatMessage(type) {
            const msg = document.createElement('div');
            msg.innerHTML = `<div style="font-size: 32px;">💀 ${type} DEFEATED! 💀</div>`;
            msg.style.cssText = `
                position: fixed;
                top: 10%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${COLORS.gold};
                text-shadow: 0 0 30px ${COLORS.gold}, 0 0 60px #ff00ff;
                z-index: 9999;
                pointer-events: none;
                animation: bossDefeat 2s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossDefeat {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    80% { opacity: 1; }
                    100% { opacity: 0; transform: translate(-50%, -80%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 2000);
        }
        
        // Boss phase warning
        function showBossPhaseWarning(text) {
            const msg = document.createElement('div');
            msg.innerHTML = `<div style="font-size: 26px;">⚠️ ${text} ⚠️</div>`;
            msg.style.cssText = `
                position: fixed;
                top: 10%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #ff4444;
                text-shadow: 0 0 20px #ff0000;
                z-index: 9999;
                pointer-events: none;
                animation: phaseWarn 1.5s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes phaseWarn {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    70% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 1500);
        }

        // ===== TREASURE CHEST CLASS =====
        class TreasureChest {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.opened = false;
                this.dead = false;
                this.needsPlayerToLeave = false; // Player must walk away before reopening
                this.reactivateDistance = 60; // Must walk this far away to reactivate
                this.bobOffset = Math.random() * Math.PI * 2;
                this.glowPulse = Math.random() * Math.PI * 2;
                
                // 10% chance to be free (gold), 90% costs gold (silver)
                this.isFree = Math.random() < 0.10;
                this.cost = this.isFree ? 0 : nextChestCost;
                
                // Pre-roll contents
                this.contents = this.rollContents();
            }
            
            update(dt) {
                if (this.dead) return;
                
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                
                // If player needs to leave first, check if they've walked away
                if (this.needsPlayerToLeave) {
                    if (dist > this.reactivateDistance) {
                        this.needsPlayerToLeave = false;
                        this.opened = false; // Now allow reopening
                    }
                    return;
                }
                
                if (this.opened) return;
                
                // Check if player is touching
                if (dist < this.radius + player.radius) {
                    this.showOffer();
                }
            }
            
            showOffer() {
                if (this.opened) return;
                this.opened = true;
                gamePaused = true;
                pendingChest = this;
                
                const color = this.isFree ? COLORS.gold : '#c0c0c0';
                spawnParticles(this.x, this.y, color, 15);
                
                // Set up new modal
                if (this.contents.type === 'legendary') {
                    DOM.modalTitle.textContent = '⭐ LEGENDARY FOUND! ⭐';
                    DOM.modalTitle.style.color = '#ffa500';
                    DOM.modalTitle.style.textShadow = '0 0 20px #ffa500';
                } else {
                    DOM.modalTitle.textContent = this.isFree ? '📦 FREE TREASURE! 📦' : '📦 TREASURE FOUND! 📦';
                    DOM.modalTitle.style.color = '#ffd700';
                    DOM.modalTitle.style.textShadow = '0 0 20px #ffd700';
                }
                
                if (this.isFree) {
                    DOM.modalCost.textContent = 'FREE!';
                    DOM.modalCost.style.color = '#00ff00';
                } else {
                    const canAffordNow = playerGold >= this.cost;
                    const goldColor = canAffordNow ? '#888' : '#ff3366';
                    DOM.modalCost.innerHTML = `Cost: 🪙 ${this.cost} <span style="color: ${goldColor};">(You have: ${playerGold})</span>`;
                    DOM.modalCost.style.color = canAffordNow ? '#ffd700' : '#ff6644';
                }
                
                // Hide card and buttons initially, show slot reel
                DOM.modalCard.style.display = 'none';
                DOM.modalTake.parentElement.style.display = 'none';
                
                // Set up slot reel with spinning state
                const slotReel = DOM.chestSlotReel;
                slotReel.classList.add('spinning');
                slotReel.classList.remove('stopped');
                slotReel.querySelector('.slot-icon').textContent = '❓';
                slotReel.querySelector('.slot-name').textContent = '???';
                
                // Show modal with slot spinning
                DOM.chestModal.classList.add('visible');
                
                // Store contents for reveal
                const contents = this.contents;
                const chestColor = color;
                const canAfford = this.isFree || playerGold >= this.cost;
                const isFree = this.isFree;
                const cost = this.cost;
                
                // After delay, stop spinning and reveal
                setTimeout(() => {
                    slotReel.classList.remove('spinning');
                    slotReel.classList.add('stopped');
                    
                    // Update slot content to show result
                    slotReel.querySelector('.slot-icon').textContent = contents.icon;
                    slotReel.querySelector('.slot-name').textContent = contents.name;
                    slotReel.style.borderColor = contents.color || chestColor;
                    slotReel.style.boxShadow = `0 0 30px ${contents.color || chestColor}50`;
                    
                    // After brief pause, hide slot and show card
                    setTimeout(() => {
                        slotReel.classList.remove('stopped');
                        slotReel.style.display = 'none';
                        
                        // For legendary drops, skip card preview and go straight to 3-choice
                        if (contents.type === 'legendary') {
                            legendaryCount++;
                            lastLegendaryTime = gameTime;
                            guaranteedLegendaryNext = false;
                            DOM.chestModal.classList.remove('visible');
                            // Mark chest as dead
                            const chest = pendingChest;
                            if (chest && chest.opened !== undefined) {
                                chest.dead = true;
                            }
                            pendingChest = null;
                            showLegendaryUpgrade();
                            return;
                        }
                        
                        // Set up card content
                        DOM.modalCard.style.borderColor = contents.color || chestColor;
                        
                        DOM.modalCard.classList.remove('legendary');
                        DOM.modalName.style.color = contents.color || chestColor;
                        
                        DOM.modalIcon.textContent = contents.icon;
                        DOM.modalName.textContent = contents.name;
                        DOM.modalDesc.textContent = contents.desc;
                        
                        // Update take button
                        DOM.modalTake.textContent = isFree ? 'TAKE' : (canAfford ? `BUY (${cost})` : 'NOT ENOUGH GOLD');
                        DOM.modalTake.classList.toggle('disabled', !canAfford);
                        
                        // Show card and buttons
                        DOM.modalCard.style.display = '';
                        DOM.modalTake.parentElement.style.display = '';
                        DOM.modalLeave.style.display = '';
                    }, 400);
                }, 800);
            }
            
            rollContents() {
                // Calculate legendary chance
                let legendaryChance = 0.02 + (gameTime / 60) * 0.005;
                legendaryChance = Math.min(legendaryChance, 0.15);
                
                // Bad luck protection
                if (guaranteedLegendaryNext && legendaryCount < MAX_LEGENDARIES) {
                    legendaryChance = 1.0;
                }
                
                // Good luck protection
                if (legendaryCount >= MAX_LEGENDARIES) {
                    legendaryChance = 0;
                }
                
                if (Math.random() < legendaryChance) {
                    // Pick a random legendary for preview
                    const legendaryKeys = Object.keys(LEGENDARY_UPGRADES);
                    const randomKey = legendaryKeys[Math.floor(Math.random() * legendaryKeys.length)];
                    const legendary = LEGENDARY_UPGRADES[randomKey];
                    return { 
                        type: 'legendary', 
                        id: randomKey,
                        icon: legendary.icon, 
                        name: legendary.name, 
                        desc: legendary.desc,
                        color: legendary.color 
                    };
                } else {
                    // Random shrine powerup
                    const powerupIds = Object.keys(SHRINE_POWERUPS);
                    const randomId = powerupIds[Math.floor(Math.random() * powerupIds.length)];
                    const powerup = SHRINE_POWERUPS[randomId];
                    return { 
                        type: 'shrine', 
                        id: randomId,
                        icon: powerup.icon,
                        name: powerup.name,
                        desc: powerup.desc,
                        color: powerup.color
                    };
                }
            }
            
            draw() {
                // Draw if: not opened, OR waiting for player to leave (show dimmed)
                if (!camera.isVisible(this.x, this.y)) return;
                if (this.opened && !this.needsPlayerToLeave) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const bob = Math.sin(Date.now() * 0.003 + this.bobOffset) * camera.scale(2);
                const glow = 0.6 + Math.sin(Date.now() * 0.004 + this.glowPulse) * 0.3;
                
                // Color based on free/paid
                const trimColor = this.isFree ? COLORS.gold : '#c0c0c0';
                const glowColor = this.isFree ? COLORS.gold : '#a0a0a0';
                
                ctx.save();
                
                // Dim if waiting for player to leave
                if (this.needsPlayerToLeave) {
                    ctx.globalAlpha = 0.4;
                }
                
                // Glow effect
                ctx.shadowBlur = 20 * glow;
                ctx.shadowColor = glowColor;
                
                const w = camera.scale(24);
                const h = camera.scale(13);
                const lidHeight = camera.scale(9);
                const depth = camera.scale(7); // 3D depth
                const baseColor = this.isFree ? '#8B4513' : '#4a4a4a';
                const lidColor = this.isFree ? '#A0522D' : '#606060';
                const darkShade = this.isFree ? '#5a2d0a' : '#2a2a2a';
                const lightShade = this.isFree ? '#c4713b' : '#808080';
                
                // Front face (base rectangle)
                ctx.fillStyle = baseColor;
                ctx.fillRect(sx - w/2, sy - h/2 + bob + lidHeight, w, h);
                
                // Rounded lid front (arc)
                ctx.fillStyle = lidColor;
                ctx.beginPath();
                ctx.moveTo(sx - w/2, sy - h/2 + bob + lidHeight);
                ctx.lineTo(sx - w/2, sy - h/2 + bob + lidHeight/2);
                ctx.quadraticCurveTo(sx, sy - h/2 + bob - lidHeight/2, sx + w/2, sy - h/2 + bob + lidHeight/2);
                ctx.lineTo(sx + w/2, sy - h/2 + bob + lidHeight);
                ctx.closePath();
                ctx.fill();
                
                // Lid top surface (curved 3D)
                ctx.fillStyle = lightShade;
                ctx.beginPath();
                ctx.moveTo(sx - w/2, sy - h/2 + bob + lidHeight/2);
                ctx.quadraticCurveTo(sx, sy - h/2 + bob - lidHeight/2, sx + w/2, sy - h/2 + bob + lidHeight/2);
                ctx.lineTo(sx + w/2 + depth, sy - h/2 + bob + lidHeight/2 - depth);
                ctx.quadraticCurveTo(sx + depth, sy - h/2 + bob - lidHeight/2 - depth, sx - w/2 + depth, sy - h/2 + bob + lidHeight/2 - depth);
                ctx.closePath();
                ctx.fill();
                
                // Right face (side of chest)
                ctx.fillStyle = darkShade;
                ctx.beginPath();
                ctx.moveTo(sx + w/2, sy - h/2 + bob + lidHeight);
                ctx.lineTo(sx + w/2 + depth, sy - h/2 + bob + lidHeight - depth);
                ctx.lineTo(sx + w/2 + depth, sy + h/2 + bob + lidHeight - depth);
                ctx.lineTo(sx + w/2, sy + h/2 + bob + lidHeight);
                ctx.closePath();
                ctx.fill();
                
                // Right face lid part
                ctx.beginPath();
                ctx.moveTo(sx + w/2, sy - h/2 + bob + lidHeight/2);
                ctx.lineTo(sx + w/2 + depth, sy - h/2 + bob + lidHeight/2 - depth);
                ctx.lineTo(sx + w/2 + depth, sy - h/2 + bob + lidHeight - depth);
                ctx.lineTo(sx + w/2, sy - h/2 + bob + lidHeight);
                ctx.closePath();
                ctx.fill();
                
                // Outlines
                ctx.strokeStyle = trimColor;
                ctx.lineWidth = 2;
                
                // Front base outline
                ctx.strokeRect(sx - w/2, sy - h/2 + bob + lidHeight, w, h);
                
                // Lid arc outline
                ctx.beginPath();
                ctx.moveTo(sx - w/2, sy - h/2 + bob + lidHeight);
                ctx.lineTo(sx - w/2, sy - h/2 + bob + lidHeight/2);
                ctx.quadraticCurveTo(sx, sy - h/2 + bob - lidHeight/2, sx + w/2, sy - h/2 + bob + lidHeight/2);
                ctx.lineTo(sx + w/2, sy - h/2 + bob + lidHeight);
                ctx.stroke();
                
                // Metal band across lid
                ctx.strokeStyle = trimColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(sx - w/2, sy - h/2 + bob + lidHeight);
                ctx.lineTo(sx + w/2, sy - h/2 + bob + lidHeight);
                ctx.stroke();
                
                // Lock/clasp on front
                ctx.fillStyle = trimColor;
                ctx.beginPath();
                ctx.arc(sx, sy + bob + lidHeight/2, camera.scale(4), 0, Math.PI * 2);
                ctx.fill();
                
                // Clasp keyhole
                ctx.fillStyle = darkShade;
                ctx.beginPath();
                ctx.arc(sx, sy + bob + lidHeight/2, camera.scale(1.5), 0, Math.PI * 2);
                ctx.fill();
                
                // Cost indicator above silver chests
                if (!this.isFree) {
                    const canAfford = playerGold >= this.cost;
                    ctx.font = `bold ${camera.scale(17)}px sans-serif`;
                    ctx.textAlign = 'center';
                    const costText = `🪙${this.cost}`;
                    const costY = sy - h/2 + bob - lidHeight/2 - camera.scale(10);
                    
                    if (canAfford) {
                        ctx.fillStyle = '#ffd700';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#ffd700';
                    } else {
                        // Grey text only
                        ctx.fillStyle = '#888888';
                        ctx.shadowBlur = 0;
                    }
                    ctx.fillText(costText, sx, costY);
                }
                
                // Sparkle particles
                if (Math.random() < 0.05) {
                    const sparkleX = this.x + (Math.random() - 0.5) * 30;
                    const sparkleY = this.y + (Math.random() - 0.5) * 20;
                    spawnParticles(sparkleX, sparkleY, trimColor, 1);
                }
                
                ctx.restore();
            }
        }
        
        // ===== SKULL STATUE CLASS =====
        class SkullStatue {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 28;
                this.activated = false;
                this.dead = false;
                this.needsPlayerToLeave = false;
                this.reactivateDistance = 88;
                this.glowPulse = Math.random() * Math.PI * 2;
            }
            
            update(dt) {
                if (this.dead) return;
                
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                
                // If player needs to leave first
                if (this.needsPlayerToLeave) {
                    if (dist > this.reactivateDistance) {
                        this.needsPlayerToLeave = false;
                        this.activated = false;
                    }
                    return;
                }
                
                if (this.activated) return;
                
                // Check if player is touching
                if (dist < this.radius + player.radius) {
                    this.showOffer();
                }
            }
            
            showOffer() {
                if (this.activated) return;
                this.activated = true;
                gamePaused = true;
                pendingStatue = this;
                
                spawnParticles(this.x, this.y, '#880088', 15);
                
                // Update modal level display
                const levelEl = document.getElementById('statueLevel');
                if (levelEl) {
                    levelEl.textContent = `Current Difficulty: +${difficultyLevel * 10}%`;
                }
                
                document.getElementById('skullStatueModal').classList.add('visible');
            }
            
            draw() {
                if (!camera.isVisible(this.x, this.y, 66)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const s = camera.scale.bind(camera);
                const time = Date.now();
                const glow = 0.5 + Math.sin(time * 0.003 + this.glowPulse) * 0.3;
                
                ctx.save();
                
                // Dim if waiting for player to leave
                if (this.needsPlayerToLeave) {
                    ctx.globalAlpha = 0.4;
                }
                
                // Eerie purple glow
                ctx.shadowBlur = 28 * glow;
                ctx.shadowColor = '#880088';
                
                // Stone pedestal base (10% larger)
                ctx.fillStyle = '#3a3a3a';
                ctx.beginPath();
                ctx.moveTo(sx - s(22), sy + s(16.5));
                ctx.lineTo(sx - s(16.5), sy + s(5.5));
                ctx.lineTo(sx + s(16.5), sy + s(5.5));
                ctx.lineTo(sx + s(22), sy + s(16.5));
                ctx.closePath();
                ctx.fill();
                
                // Pedestal top (10% larger)
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(sx - s(16.5), sy - s(5.5), s(33), s(11));
                
                // Skull (10% larger)
                ctx.fillStyle = '#d0d0d0';
                // Cranium
                ctx.beginPath();
                ctx.arc(sx, sy - s(19.8), s(15.4), 0, Math.PI * 2);
                ctx.fill();
                
                // Jaw
                ctx.beginPath();
                ctx.moveTo(sx - s(11), sy - s(8.8));
                ctx.quadraticCurveTo(sx, sy + s(2.2), sx + s(11), sy - s(8.8));
                ctx.fill();
                
                // Eye sockets (glowing, 10% larger)
                ctx.fillStyle = `rgba(136, 0, 136, ${glow})`;
                ctx.shadowBlur = 16.5;
                ctx.shadowColor = '#ff00ff';
                ctx.beginPath();
                ctx.ellipse(sx - s(5.5), sy - s(22), s(4.4), s(5.5), 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(sx + s(5.5), sy - s(22), s(4.4), s(5.5), 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose hole (10% larger)
                ctx.fillStyle = '#222';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(sx, sy - s(15.4));
                ctx.lineTo(sx - s(2.2), sy - s(11));
                ctx.lineTo(sx + s(2.2), sy - s(11));
                ctx.closePath();
                ctx.fill();
                
                // Teeth (10% larger)
                ctx.fillStyle = '#c0c0c0';
                for (let i = -3; i <= 3; i++) {
                    ctx.fillRect(sx + i * s(2.75) - s(1.1), sy - s(8.8), s(2.2), s(4.4));
                }
                
                // Cracks on skull for creepy effect
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(sx - s(8.8), sy - s(27.5));
                ctx.lineTo(sx - s(3.3), sy - s(19.8));
                ctx.lineTo(sx - s(6.6), sy - s(13.2));
                ctx.stroke();
                
                // Difficulty indicator above (10% larger positioning)
                if (difficultyLevel > 0) {
                    ctx.fillStyle = '#ff6666';
                    ctx.font = `bold ${s(13.2)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ff0000';
                    ctx.fillText(`+${difficultyLevel * 10}%`, sx, sy - s(42));
                }
                
                ctx.restore();
            }
        }
        
        // Skull statue functions
        function acceptStatueOffer() {
            if (!pendingStatue) return;
            
            // Increase difficulty
            difficultyLevel++;
            enemyDamageBonus = 1 + (difficultyLevel * 0.10);
            enemyHealthBonus = 1 + (difficultyLevel * 0.10);
            enemySpeedBonus = 1 + (difficultyLevel * 0.05);
            killRewardBonus = 1 + (difficultyLevel * 0.10);
            
            // Visual feedback
            spawnParticles(pendingStatue.x, pendingStatue.y, '#ff00ff', 25);
            
            // Show warning
            showStackedWarning({
                html: `<div style="font-size: 24px;">CURSE ACCEPTED</div><div style="font-size: 14px; color: #ff6666;">Difficulty +${difficultyLevel * 10}% | Rewards +${difficultyLevel * 10}%</div>`,
                color: '#880088',
                textShadow: '0 0 20px #880088',
                duration: 2500,
                priority: WARNING_PRIORITY.CURSE
            });
            
            // Remove this statue and spawn a new one in an empty quadrant
            pendingStatue.dead = true;
            
            // Ensure we maintain 2 active statues
            const activeStatues = skullStatues.filter(s => !s.dead).length;
            const statuesToSpawn = 2 - activeStatues;
            for (let i = 0; i < statuesToSpawn; i++) {
                spawnNewSkullStatue();
            }
            
            pendingStatue = null;
            document.getElementById('skullStatueModal').classList.remove('visible');
            gamePaused = false;
        }
        window.acceptStatueOffer = acceptStatueOffer;
        
        function declineStatueOffer() {
            if (!pendingStatue) return;
            
            pendingStatue.needsPlayerToLeave = true;
            pendingStatue = null;
            document.getElementById('skullStatueModal').classList.remove('visible');
            gamePaused = false;
        }
        window.declineStatueOffer = declineStatueOffer;
        
        function spawnNewSkullStatue() {
            // Find a quadrant without a statue
            const quadrants = [
                { minX: 0, maxX: WORLD.width/2, minY: 0, maxY: WORLD.height/2 },
                { minX: WORLD.width/2, maxX: WORLD.width, minY: 0, maxY: WORLD.height/2 },
                { minX: 0, maxX: WORLD.width/2, minY: WORLD.height/2, maxY: WORLD.height },
                { minX: WORLD.width/2, maxX: WORLD.width, minY: WORLD.height/2, maxY: WORLD.height }
            ];
            
            // Shuffle quadrants
            for (let i = quadrants.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [quadrants[i], quadrants[j]] = [quadrants[j], quadrants[i]];
            }
            
            // Find empty quadrant
            for (const q of quadrants) {
                let hasStatue = false;
                for (const statue of skullStatues) {
                    if (!statue.dead && statue.x >= q.minX && statue.x < q.maxX && 
                        statue.y >= q.minY && statue.y < q.maxY) {
                        hasStatue = true;
                        break;
                    }
                }
                
                if (!hasStatue) {
                    // Try to spawn in this quadrant with valid position
                    const margin = 150;
                    let attempts = 0;
                    
                    while (attempts < 30) {
                        const x = q.minX + margin + Math.random() * (q.maxX - q.minX - margin * 2);
                        const y = q.minY + margin + Math.random() * (q.maxY - q.minY - margin * 2);
                        
                        // Check not in terrain or lake
                        if (isInTerrain(x, y, 80) || isInLake(x, y, 100)) {
                            attempts++;
                            continue;
                        }
                        
                        // Check not too close to other objects
                        if (isTooCloseToObjects(x, y, MIN_OBJECT_SPACING, 'statue')) {
                            attempts++;
                            continue;
                        }
                        
                        // Don't spawn in player's visible view
                        if (isInPlayerView(x, y, 100)) {
                            attempts++;
                            continue;
                        }
                        
                        skullStatues.push(new SkullStatue(x, y));
                        return;
                    }
                    
                    // Fallback - just spawn somewhere in quadrant avoiding terrain
                    const x = q.minX + margin + Math.random() * (q.maxX - q.minX - margin * 2);
                    const y = q.minY + margin + Math.random() * (q.maxY - q.minY - margin * 2);
                    skullStatues.push(new SkullStatue(x, y));
                    return;
                }
            }
        }
        
        function spawnInitialSkullStatues() {
            skullStatues = [];
            // Spawn 2 statues in random quadrants
            for (let i = 0; i < 2; i++) {
                spawnNewSkullStatue();
            }
        }
        
        // Accept chest offer
        function acceptChestOffer() {
            if (!pendingChest) return;
            
            // Handle pot of gold rewards differently
            if (pendingChest.isPotReward) {
                acceptPotReward();
                return;
            }
            
            const chest = pendingChest;
            
            // Deduct gold if not free
            if (!chest.isFree) {
                if (playerGold < chest.cost) return;
                playerGold -= chest.cost;
                updateGoldDisplay();
                nextChestCost = nextChestCost < 1000 
                    ? nextChestCost * 2 
                    : Math.floor(nextChestCost * 1.5); // Double until 1000, then +50%
                
                // Update all existing paid chests to new cost
                for (const c of chests) {
                    if (!c.dead && !c.isFree) {
                        c.cost = nextChestCost;
                    }
                }
            }
            
            // Apply contents
            if (chest.contents.type === 'legendary') {
                legendaryCount++;
                lastLegendaryTime = gameTime;
                guaranteedLegendaryNext = false;
                DOM.chestModal.classList.remove('visible');
                DOM.modalCard.classList.remove('legendary'); // Reset legendary styling
                showLegendaryUpgrade();
            } else {
                const powerup = SHRINE_POWERUPS[chest.contents.id];
                player.addShrineBonus(powerup.stat, powerup.value);
                updateBuffsBar();
                closeChestModal();
            }
            
            // Remove chest
            chest.dead = true;
            pendingChest = null;
        }
        // Expose globally for onclick handlers
        window.acceptChestOffer = acceptChestOffer;
        
        // Skip chest offer (legacy - now using window.chestLeave)
        function skipChestOffer() {
            if (!pendingChest) {
                closeChestModal();
                return;
            }
            
            if (pendingChest.isPotReward === true) return;
            
            if (pendingChest.opened !== undefined) {
                pendingChest.opened = false;
            }
            pendingChest = null;
            closeChestModal();
        }
        window.skipChestOffer = skipChestOffer;
        
        function closeChestModal() {
            DOM.chestModal.classList.remove('visible');
            DOM.modalCard.classList.remove('legendary'); // Reset legendary styling
            DOM.modalLeave.style.display = ''; // Restore leave button
            // Reset slot reel for next chest
            if (DOM.chestSlotReel) {
                DOM.chestSlotReel.classList.remove('spinning', 'stopped');
                DOM.chestSlotReel.style.display = '';
                DOM.chestSlotReel.style.borderColor = '';
                DOM.chestSlotReel.style.boxShadow = '';
            }
            gamePaused = false;
        }
        
        // Global leave function for inline onclick
        window.leaveChest = function() {
            if (pendingChest && pendingChest.isPotReward === true) return;
            if (pendingChest) {
                // Require player to walk away before chest can reopen
                pendingChest.needsPlayerToLeave = true;
            }
            pendingChest = null;
            closeChestModal();
        };

        // Show chest reward notification
        function showChestReward(powerup) {
            const notification = document.createElement('div');
            notification.innerHTML = `<div style="font-size: 22px;">${powerup.icon} ${powerup.name}!</div><div style="font-size: 14px; opacity: 0.8;">${powerup.desc}</div>`;
            notification.style.cssText = `
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${powerup.color};
                text-shadow: 0 0 20px ${powerup.color};
                text-align: center;
                z-index: 9999;
                pointer-events: none;
                animation: chestReward 1.5s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes chestReward {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    80% { opacity: 1; }
                    100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), 1500);
        }

        // Show legendary from chest
        function showChestLegendary() {
            legendaryCount++;
            lastLegendaryTime = gameTime;
            guaranteedLegendaryNext = false;
            showLegendaryUpgrade();
        }

        // Spawn chests around the map
        // Spawn chests around the map with minimum spacing
        function spawnInitialChests() {
            const chestCount = 40 + Math.floor(Math.random() * 20); // 40-60 chests (scaled for 4x area)
            const minChestSpacing = 800; // Minimum distance between chests
            
            for (let i = 0; i < chestCount; i++) {
                let attempts = 0;
                let validPos = null;
                
                while (attempts < 30 && !validPos) {
                    const pos = getValidSpawnPosition(200, WORLD.width - 200, 200, WORLD.height - 200, 50, 300);
                    
                    // Check distance to all existing chests
                    let tooClose = false;
                    for (const chest of chests) {
                        if (Math.hypot(pos.x - chest.x, pos.y - chest.y) < minChestSpacing) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        validPos = pos;
                    }
                    attempts++;
                }
                
                if (validPos) {
                    chests.push(new TreasureChest(validPos.x, validPos.y));
                }
            }
        }

        // Respawn chests over time
        let chestRespawnTimer = 0;
        const CHEST_RESPAWN_INTERVAL = 45000; // New chest every 45 seconds

        function updateChestSpawning(dt) {
            chestRespawnTimer += dt;
            
            if (chestRespawnTimer >= CHEST_RESPAWN_INTERVAL) {
                chestRespawnTimer = 0;
                
                // Spawn new chest away from player, avoiding terrain and other chests
                const minChestSpacing = 800;
                let attempts = 0;
                
                while (attempts < 20) {
                    const pos = getValidSpawnPosition(200, WORLD.width - 200, 200, WORLD.height - 200, 50, 0);
                    
                    // Check distance to player
                    if (Math.hypot(pos.x - player.x, pos.y - player.y) < 300) {
                        attempts++;
                        continue;
                    }
                    
                    // Don't spawn in player's visible view
                    if (isInPlayerView(pos.x, pos.y, 100)) {
                        attempts++;
                        continue;
                    }
                    
                    // Check distance to other chests
                    let tooClose = false;
                    for (const chest of chests) {
                        if (Math.hypot(pos.x - chest.x, pos.y - chest.y) < minChestSpacing) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        chests.push(new TreasureChest(pos.x, pos.y));
                        break;
                    }
                    attempts++;
                }
            }
            
            // Bad luck protection check
            if (gameTime >= 600 && legendaryCount === 0 && !guaranteedLegendaryNext) {
                guaranteedLegendaryNext = true;
            }
        }
        
        // ===== COWBOY HAT PICKUP =====
        function spawnCowboyHat() {
            cowboyHat = null;
            playerHasCowboyHat = false;
            
            const minDistFromObstacles = 80;
            let attempts = 0;
            
            while (attempts < 50) {
                const x = 400 + Math.random() * (WORLD.width - 800);
                const y = 400 + Math.random() * (WORLD.height - 800);
                
                // Check not too close to center spawn
                if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 600) {
                    attempts++;
                    continue;
                }
                
                // Check not in or near terrain/lakes
                if (isInTerrain(x, y, minDistFromObstacles) || isInLake(x, y, minDistFromObstacles + 30)) {
                    attempts++;
                    continue;
                }
                
                // Check not too close to other objects
                if (isTooCloseToObjects(x, y, MIN_OBJECT_SPACING, 'hat')) {
                    attempts++;
                    continue;
                }
                
                cowboyHat = { x: x, y: y, radius: 15, bobOffset: Math.random() * Math.PI * 2 };
                break;
            }
        }
        
        function drawCowboyHat() {
            if (!cowboyHat || playerHasCowboyHat) return;
            if (!camera.isVisible(cowboyHat.x, cowboyHat.y, 50)) return;
            
            const sx = camera.screenX(cowboyHat.x);
            const baseY = camera.screenY(cowboyHat.y) - camera.scale(8); // Nudged up
            const bob = Math.sin(Date.now() * 0.003 + cowboyHat.bobOffset) * camera.scale(3);
            const sy = baseY + bob;
            const s = (v) => camera.scale(v * 1.15); // 15% larger
            
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#8B4513';
            
            // Brim base (flat middle part)
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(sx, sy + s(4), s(14), s(7), 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Left brim - half pipe curve going up (thicker)
            ctx.fillStyle = '#7a3a0f';
            ctx.beginPath();
            ctx.moveTo(sx - s(10), sy + s(8));
            ctx.quadraticCurveTo(sx - s(24), sy + s(6), sx - s(30), sy - s(4));
            ctx.quadraticCurveTo(sx - s(34), sy - s(14), sx - s(28), sy - s(12));
            ctx.quadraticCurveTo(sx - s(20), sy - s(2), sx - s(10), sy);
            ctx.closePath();
            ctx.fill();
            
            // Right brim - half pipe curve going up (thicker)
            ctx.beginPath();
            ctx.moveTo(sx + s(10), sy + s(8));
            ctx.quadraticCurveTo(sx + s(24), sy + s(6), sx + s(30), sy - s(4));
            ctx.quadraticCurveTo(sx + s(34), sy - s(14), sx + s(28), sy - s(12));
            ctx.quadraticCurveTo(sx + s(20), sy - s(2), sx + s(10), sy);
            ctx.closePath();
            ctx.fill();
            
            // Brim top highlight
            ctx.fillStyle = '#9a5a2f';
            ctx.beginPath();
            ctx.moveTo(sx - s(8), sy);
            ctx.quadraticCurveTo(sx - s(22), sy - s(1), sx - s(26), sy - s(8));
            ctx.lineTo(sx - s(24), sy - s(6));
            ctx.quadraticCurveTo(sx - s(18), sy, sx - s(8), sy + s(3));
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(sx + s(8), sy);
            ctx.quadraticCurveTo(sx + s(22), sy - s(1), sx + s(26), sy - s(8));
            ctx.lineTo(sx + s(24), sy - s(6));
            ctx.quadraticCurveTo(sx + s(18), sy, sx + s(8), sy + s(3));
            ctx.closePath();
            ctx.fill();
            
            // Hat crown (taller)
            ctx.fillStyle = '#A0522D';
            ctx.beginPath();
            ctx.moveTo(sx - s(12), sy);
            ctx.quadraticCurveTo(sx - s(14), sy - s(16), sx, sy - s(20));
            ctx.quadraticCurveTo(sx + s(14), sy - s(16), sx + s(12), sy);
            ctx.closePath();
            ctx.fill();
            
            // Crown indent on top
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(sx, sy - s(18), s(6), s(3), 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Hat band
            ctx.fillStyle = '#5a2d0a';
            ctx.fillRect(sx - s(12), sy - s(5), s(24), s(5));
            
            // Band buckle
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(sx - s(3), sy - s(4), s(6), s(4));
            ctx.fillStyle = '#5a2d0a';
            ctx.fillRect(sx - s(1), sy - s(3), s(2), s(2));
            
            // Shine effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sx - s(5), sy - s(14), s(4), s(2), -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function updateCowboyHat() {
            if (!cowboyHat || playerHasCowboyHat) return;
            
            const dist = Math.hypot(player.x - cowboyHat.x, player.y - cowboyHat.y);
            if (dist < player.radius + cowboyHat.radius) {
                // Pick up the hat!
                playerHasCowboyHat = true;
                player.applyPassives(); // Recalculate speed with hat bonus
                
                // Visual feedback
                spawnParticles(cowboyHat.x, cowboyHat.y, '#8B4513', 15);
                spawnParticles(cowboyHat.x, cowboyHat.y, '#ffd700', 10);
                
                // Show notification
                showHatPickupNotification();
            }
        }
        
        function showHatPickupNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(139, 69, 19, 0.9);
                border: 2px solid #ffd700;
                padding: 15px 30px;
                border-radius: 10px;
                color: #fff;
                font-size: 18px;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                pointer-events: none;
            `;
            notification.innerHTML = '🤠 COWBOY HAT FOUND!<br><span style="font-size: 14px; color: #ffd700;">+20% Movement Speed</span>';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }
        
        // ===== SHIELD PICKUPS =====
        function spawnShieldPickups() {
            shieldPickups = [];
            
            // Define quadrant boundaries
            const halfW = WORLD.width / 2;
            const halfH = WORLD.height / 2;
            const margin = 400; // Keep away from edges
            const centerMargin = 600; // Keep away from spawn point
            
            const quadrants = [
                { minX: margin, maxX: halfW - centerMargin/2, minY: margin, maxY: halfH - centerMargin/2 }, // Top-left
                { minX: halfW + centerMargin/2, maxX: WORLD.width - margin, minY: margin, maxY: halfH - centerMargin/2 }, // Top-right
                { minX: margin, maxX: halfW - centerMargin/2, minY: halfH + centerMargin/2, maxY: WORLD.height - margin }, // Bottom-left
                { minX: halfW + centerMargin/2, maxX: WORLD.width - margin, minY: halfH + centerMargin/2, maxY: WORLD.height - margin } // Bottom-right
            ];
            
            for (const quad of quadrants) {
                let attempts = 0;
                while (attempts < 50) {
                    const x = quad.minX + Math.random() * (quad.maxX - quad.minX);
                    const y = quad.minY + Math.random() * (quad.maxY - quad.minY);
                    
                    // Check not in or near terrain/lakes
                    if (isInTerrain(x, y, 60) || isInLake(x, y, 80)) {
                        attempts++;
                        continue;
                    }
                    
                    // Check not too close to other objects
                    if (isTooCloseToObjects(x, y, MIN_OBJECT_SPACING, 'shield')) {
                        attempts++;
                        continue;
                    }
                    
                    shieldPickups.push({
                        x: x,
                        y: y,
                        radius: 18,
                        bobOffset: Math.random() * Math.PI * 2,
                        collected: false
                    });
                    break;
                }
            }
        }
        
        function drawShieldPickups() {
            const now = Date.now();
            
            for (const shield of shieldPickups) {
                if (shield.collected) continue;
                if (!camera.isVisible(shield.x, shield.y, 50)) continue;
                
                const sx = camera.screenX(shield.x);
                const bob = Math.sin(now * 0.003 + shield.bobOffset) * camera.scale(4);
                const sy = camera.screenY(shield.y) + bob;
                const r = camera.scale(shield.radius);
                
                ctx.save();
                
                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#4488ff';
                
                // Shield shape (rounded shield/badge)
                ctx.fillStyle = '#4488ff';
                ctx.beginPath();
                ctx.moveTo(sx, sy - r);
                ctx.quadraticCurveTo(sx + r, sy - r * 0.5, sx + r * 0.8, sy + r * 0.3);
                ctx.quadraticCurveTo(sx + r * 0.4, sy + r, sx, sy + r * 1.1);
                ctx.quadraticCurveTo(sx - r * 0.4, sy + r, sx - r * 0.8, sy + r * 0.3);
                ctx.quadraticCurveTo(sx - r, sy - r * 0.5, sx, sy - r);
                ctx.closePath();
                ctx.fill();
                
                // Inner highlight
                ctx.fillStyle = '#66aaff';
                ctx.beginPath();
                ctx.moveTo(sx, sy - r * 0.6);
                ctx.quadraticCurveTo(sx + r * 0.6, sy - r * 0.3, sx + r * 0.5, sy + r * 0.1);
                ctx.quadraticCurveTo(sx + r * 0.2, sy + r * 0.5, sx, sy + r * 0.6);
                ctx.quadraticCurveTo(sx - r * 0.2, sy + r * 0.5, sx - r * 0.5, sy + r * 0.1);
                ctx.quadraticCurveTo(sx - r * 0.6, sy - r * 0.3, sx, sy - r * 0.6);
                ctx.closePath();
                ctx.fill();
                
                // Center emblem (plus/cross for health)
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = camera.scale(3);
                ctx.beginPath();
                ctx.moveTo(sx, sy - r * 0.3);
                ctx.lineTo(sx, sy + r * 0.3);
                ctx.moveTo(sx - r * 0.3, sy);
                ctx.lineTo(sx + r * 0.3, sy);
                ctx.stroke();
                
                // Pulsing ring
                const pulse = 0.5 + Math.sin(now * 0.005 + shield.bobOffset) * 0.5;
                ctx.strokeStyle = `rgba(68, 136, 255, ${0.3 + pulse * 0.4})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 1.4 + pulse * camera.scale(5), 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        function updateShieldPickups() {
            for (const shield of shieldPickups) {
                if (shield.collected) continue;
                
                const dist = Math.hypot(player.x - shield.x, player.y - shield.y);
                if (dist < player.radius + shield.radius) {
                    // Collect shield!
                    shield.collected = true;
                    player.maxShieldHp += 25;
                    player.shieldHp += 25; // Immediately grant the shield HP
                    
                    // Visual feedback
                    spawnParticles(shield.x, shield.y, '#4488ff', 20);
                    spawnParticles(shield.x, shield.y, '#ffffff', 10);
                    
                    // Show notification
                    showShieldPickupNotification();
                }
            }
        }
        
        function showShieldPickupNotification() {
            const notification = document.createElement('div');
            const gameCanvas = document.getElementById('gameCanvas');
            const canvasRect = gameCanvas.getBoundingClientRect();
            
            notification.style.cssText = `
                position: fixed;
                bottom: ${window.innerHeight - canvasRect.bottom + 15}px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(40, 80, 160, 0.9);
                border: 2px solid #4488ff;
                padding: 12px 25px;
                border-radius: 10px;
                color: #fff;
                font-size: 16px;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                pointer-events: none;
            `;
            notification.innerHTML = '🛡️ SHIELD FOUND!<br><span style="font-size: 13px; color: #4488ff;">+25 Shield HP</span>';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }

        // ===== POWER DROPS (Heart, Shoe, Hourglass) =====
        const POWER_DROP_TYPES = {
            heart: { icon: '❤️', color: '#ff4466', name: 'HEALING HEART', desc: '+30% HP' },
            shoe: { icon: '👟', color: '#ffaa00', name: 'SPEED BOOST', desc: '+30% Speed (10s)' },
            hourglass: { icon: '⏳', color: '#aa66ff', name: 'TIME STOP', desc: 'Freeze enemies (7s)' }
        };
        
        let lastPowerDropType = null;
        
        function trySpawnPowerDrop(x, y) {
            // Limit active drops on screen
            const activeDrops = powerDrops.filter(d => !d.collected).length;
            if (activeDrops >= 4) return;
            
            // Diminishing returns formula
            // Base chance 1% flat
            const baseChance = 0.01;
            const diminishFactor = 1 + powerDropCount * 0.12;
            const finalChance = baseChance / diminishFactor;
            
            if (Math.random() > finalChance) return;
            
            // Pick random drop type, avoiding same type in a row
            const types = ['heart', 'shoe', 'hourglass'];
            let availableTypes = types;
            
            // 70% chance to avoid spawning same type as last
            if (lastPowerDropType && Math.random() < 0.7) {
                availableTypes = types.filter(t => t !== lastPowerDropType);
            }
            
            // Also check if same type is nearby (within 300 units)
            const nearbyDrops = powerDrops.filter(d => !d.collected && Math.hypot(d.x - x, d.y - y) < 300);
            if (nearbyDrops.length > 0) {
                const nearbyTypes = nearbyDrops.map(d => d.type);
                availableTypes = availableTypes.filter(t => !nearbyTypes.includes(t));
            }
            
            // Fallback to all types if we filtered everything out
            if (availableTypes.length === 0) {
                availableTypes = types;
            }
            
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            lastPowerDropType = type;
            
            // Spawn at bottom of visible screen area
            const visibleWidth = gameWidth / camera.zoom;
            const visibleHeight = gameHeight / camera.zoom;
            const spawnX = camera.x + visibleWidth * (0.2 + Math.random() * 0.6); // 20-80% across screen
            const spawnY = camera.y + visibleHeight * 0.85; // Near bottom
            
            powerDrops.push({
                x: spawnX,
                y: spawnY,
                type: type,
                radius: 16,
                bobOffset: Math.random() * Math.PI * 2,
                collected: false,
                spawnTime: Date.now()
            });
            
            powerDropCount++;
        }
        
        function drawPowerDrops() {
            const now = Date.now();
            
            for (const drop of powerDrops) {
                if (drop.collected) continue;
                if (!camera.isVisible(drop.x, drop.y, 50)) continue;
                
                const sx = camera.screenX(drop.x);
                const bob = Math.sin(now * 0.004 + drop.bobOffset) * camera.scale(5);
                const sy = camera.screenY(drop.y) + bob;
                const r = camera.scale(drop.radius);
                const typeInfo = POWER_DROP_TYPES[drop.type];
                
                ctx.save();
                
                // Outer glow
                ctx.shadowBlur = 25;
                ctx.shadowColor = typeInfo.color;
                
                // Background circle
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(sx, sy, r * 1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Colored ring
                ctx.strokeStyle = typeInfo.color;
                ctx.lineWidth = camera.scale(3);
                ctx.beginPath();
                ctx.arc(sx, sy, r * 1.1, 0, Math.PI * 2);
                ctx.stroke();
                
                // Icon (with offsets for proper visual centering)
                ctx.font = `${camera.scale(20)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Small horizontal offset to visually center emojis
                ctx.fillText(typeInfo.icon, sx + camera.scale(1), sy + camera.scale(1));
                
                // Pulsing outer ring
                const pulse = 0.5 + Math.sin(now * 0.006 + drop.bobOffset) * 0.5;
                ctx.strokeStyle = `${typeInfo.color}${Math.floor((0.2 + pulse * 0.4) * 255).toString(16).padStart(2, '0')}`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 1.6 + pulse * camera.scale(6), 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        function updatePowerDrops() {
            const now = Date.now();
            
            for (const drop of powerDrops) {
                if (drop.collected) continue;
                
                // Despawn after 30 seconds
                if (now - drop.spawnTime > 30000) {
                    drop.collected = true;
                    continue;
                }
                
                const dist = Math.hypot(player.x - drop.x, player.y - drop.y);
                if (dist < player.radius + drop.radius + 10) {
                    drop.collected = true;
                    const typeInfo = POWER_DROP_TYPES[drop.type];
                    
                    // Apply effect based on type
                    if (drop.type === 'heart') {
                        const healAmount = player.maxHp * 0.3;
                        player.hp = Math.min(player.maxHp, player.hp + healAmount);
                        spawnParticles(drop.x, drop.y, '#ff4466', 20);
                        showPowerDropNotification(typeInfo.icon, typeInfo.name, typeInfo.desc, typeInfo.color);
                    } else if (drop.type === 'shoe') {
                        speedBoostActive = true;
                        speedBoostEndTime = now + 10000; // 10 seconds
                        speedBoostMultiplier = 1.3;
                        player.applyPassives(); // Update speed immediately
                        spawnParticles(drop.x, drop.y, '#ffaa00', 20);
                        showPowerDropNotification(typeInfo.icon, typeInfo.name, typeInfo.desc, typeInfo.color);
                    } else if (drop.type === 'hourglass') {
                        timeStopActive = true;
                        timeStopEndTime = now + 7000; // 7 seconds
                        spawnParticles(drop.x, drop.y, '#aa66ff', 25);
                        showPowerDropNotification(typeInfo.icon, typeInfo.name, typeInfo.desc, typeInfo.color);
                    }
                }
            }
            
            // Update speed boost timer
            if (speedBoostActive && now >= speedBoostEndTime) {
                speedBoostActive = false;
                speedBoostMultiplier = 1;
                player.applyPassives(); // Update speed when boost ends
            }
            
            // Update time stop timer
            if (timeStopActive && now >= timeStopEndTime) {
                timeStopActive = false;
            }
            
            // Update power timer bar display
            const speedTimer = document.getElementById('speedBoostTimer');
            const timeStopTimerEl = document.getElementById('timeStopTimer');
            const timeSlowTimerEl = document.getElementById('timeSlowTimer');
            
            if (speedTimer) {
                if (speedBoostActive) {
                    const remaining = Math.max(0, speedBoostEndTime - now);
                    const percent = (remaining / 10000) * 100; // 10s duration
                    speedTimer.style.width = percent + '%';
                } else {
                    speedTimer.style.width = '0%';
                }
            }
            
            if (timeStopTimerEl) {
                if (timeStopActive) {
                    const remaining = Math.max(0, timeStopEndTime - now);
                    const percent = (remaining / 7000) * 100; // 7s duration
                    timeStopTimerEl.style.width = percent + '%';
                } else {
                    timeStopTimerEl.style.width = '0%';
                }
            }
            
            if (timeSlowTimerEl) {
                if (legendaryEffects.timeSlow.isSlowed) {
                    const remaining = Math.max(0, legendaryEffects.timeSlow.effectEnd - now);
                    const percent = (remaining / 8000) * 100; // 8s duration
                    timeSlowTimerEl.style.width = percent + '%';
                } else {
                    timeSlowTimerEl.style.width = '0%';
                }
            }
            
            // Clean up old collected drops
            for (let i = powerDrops.length - 1; i >= 0; i--) {
                if (powerDrops[i].collected) {
                    powerDrops.splice(i, 1);
                }
            }
        }
        
        function showPowerDropNotification(icon, name, desc, color) {
            const notification = document.createElement('div');
            const gameCanvas = document.getElementById('gameCanvas');
            const canvasRect = gameCanvas.getBoundingClientRect();
            
            notification.style.cssText = `
                position: fixed;
                bottom: ${window.innerHeight - canvasRect.bottom + 15}px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                border: 2px solid ${color};
                padding: 12px 25px;
                border-radius: 10px;
                color: #fff;
                font-size: 16px;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                pointer-events: none;
                box-shadow: 0 0 20px ${color}80;
            `;
            notification.innerHTML = `${icon} ${name}<br><span style="font-size: 13px; color: ${color};">${desc}</span>`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 1800);
        }

        // ===== HEALING FAIRY =====
        let fairy = null;
        let fairySpellActive = false;
        let fairySpellStart = 0;
        let fairySpellX = 0;
        let fairySpellY = 0;
        
        function spawnFairy() {
            fairy = null;
            
            const minDistFromObstacles = 80; // Good clearance from all obstacles
            let attempts = 0;
            
            while (attempts < 100) {
                const x = 600 + Math.random() * (WORLD.width - 1200);
                const y = 600 + Math.random() * (WORLD.height - 1200);
                
                // Check not too close to center spawn
                if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 800) {
                    attempts++;
                    continue;
                }
                
                // Check not too close to player
                if (player && Math.hypot(x - player.x, y - player.y) < 400) {
                    attempts++;
                    continue;
                }
                
                // Check not in or near any terrain (trees, rocks, bushes)
                if (isInTerrain(x, y, minDistFromObstacles)) {
                    attempts++;
                    continue;
                }
                
                // Check not in or near lakes
                if (isInLake(x, y, minDistFromObstacles + 30)) {
                    attempts++;
                    continue;
                }
                
                // Check not too close to other objects
                if (isTooCloseToObjects(x, y, MIN_OBJECT_SPACING)) {
                    attempts++;
                    continue;
                }
                
                fairy = { 
                    x: x, 
                    y: y, 
                    radius: 18, 
                    bobOffset: Math.random() * Math.PI * 2,
                    wingPhase: Math.random() * Math.PI * 2
                };
                break;
            }
        }
        
        function drawFairy() {
            if (!fairy) return;
            if (!camera.isVisible(fairy.x, fairy.y, 60)) return;
            
            const sx = camera.screenX(fairy.x);
            const sy = camera.screenY(fairy.y);
            const time = Date.now();
            const bob = Math.sin(time * 0.004 + fairy.bobOffset) * camera.scale(5);
            const wingFlap = Math.sin(time * 0.02 + fairy.wingPhase);
            const s = camera.scale.bind(camera);
            
            ctx.save();
            
            // Magical aura glow
            const auraPulse = 0.5 + Math.sin(time * 0.003) * 0.3;
            ctx.globalAlpha = auraPulse * 0.4;
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff88ff';
            ctx.fillStyle = '#ff88ff';
            ctx.beginPath();
            ctx.arc(sx, sy + bob, s(25), 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
            
            // Sparkle trail
            for (let i = 0; i < 5; i++) {
                const sparkleTime = time * 0.002 + i * 1.2;
                const sparkleX = sx + Math.sin(sparkleTime) * s(15);
                const sparkleY = sy + bob + s(10) + Math.cos(sparkleTime * 0.7) * s(8);
                const sparkleAlpha = 0.3 + Math.sin(time * 0.01 + i) * 0.3;
                ctx.globalAlpha = sparkleAlpha;
                ctx.fillStyle = '#ffff88';
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, s(2), 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
            
            // Wings (translucent, flapping)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#88ffff';
            
            // Left wing
            ctx.fillStyle = 'rgba(200, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(sx - s(12), sy + bob - s(2), s(10 + wingFlap * 3), s(14), -0.4 + wingFlap * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Right wing
            ctx.beginPath();
            ctx.ellipse(sx + s(12), sy + bob - s(2), s(10 + wingFlap * 3), s(14), 0.4 - wingFlap * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.shadowColor = '#ff88ff';
            ctx.fillStyle = '#ffccff';
            ctx.beginPath();
            ctx.ellipse(sx, sy + bob, s(6), s(10), 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Head
            ctx.fillStyle = '#ffe4e1';
            ctx.beginPath();
            ctx.arc(sx, sy + bob - s(12), s(6), 0, Math.PI * 2);
            ctx.fill();
            
            // Hair
            ctx.fillStyle = '#ffdd44';
            ctx.beginPath();
            ctx.arc(sx, sy + bob - s(14), s(5), Math.PI, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#4488ff';
            ctx.beginPath();
            ctx.arc(sx - s(2), sy + bob - s(12), s(1.5), 0, Math.PI * 2);
            ctx.arc(sx + s(2), sy + bob - s(12), s(1.5), 0, Math.PI * 2);
            ctx.fill();
            
            // Wand with star
            ctx.strokeStyle = '#dda0dd';
            ctx.lineWidth = s(2);
            ctx.beginPath();
            ctx.moveTo(sx + s(8), sy + bob);
            ctx.lineTo(sx + s(16), sy + bob - s(12));
            ctx.stroke();
            
            // Star on wand
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 10;
            ctx.font = `${s(10)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('✦', sx + s(17), sy + bob - s(14));
            
            ctx.restore();
        }
        
        function updateFairy() {
            if (!fairy) return;
            
            const dist = Math.hypot(player.x - fairy.x, player.y - fairy.y);
            if (dist < player.radius + fairy.radius) {
                // Trigger healing spell!
                fairySpellActive = true;
                fairySpellStart = Date.now();
                fairySpellX = fairy.x;
                fairySpellY = fairy.y;
                
                // Heal player to full
                player.hp = player.maxHp;
                
                // Visual feedback
                spawnParticles(fairy.x, fairy.y, '#ff88ff', 25);
                spawnParticles(fairy.x, fairy.y, '#88ffff', 20);
                spawnParticles(fairy.x, fairy.y, '#ffff88', 15);
                
                // Remove fairy and spawn a new one elsewhere
                fairy = null;
                spawnFairy();
            }
        }
        
        function drawFairySpell() {
            if (!fairySpellActive) return;
            
            const elapsed = Date.now() - fairySpellStart;
            const duration = 1200;
            
            if (elapsed > duration) {
                fairySpellActive = false;
                return;
            }
            
            const progress = elapsed / duration;
            const sx = camera.screenX(player.x);
            const sy = camera.screenY(player.y);
            const s = camera.scale.bind(camera);
            
            ctx.save();
            
            // Expanding magical rings
            for (let i = 0; i < 3; i++) {
                const ringProgress = (progress + i * 0.15) % 1;
                const ringRadius = ringProgress * s(80);
                const ringAlpha = (1 - ringProgress) * 0.6;
                
                ctx.strokeStyle = i === 0 ? '#ff88ff' : (i === 1 ? '#88ffff' : '#ffff88');
                ctx.lineWidth = s(3);
                ctx.globalAlpha = ringAlpha;
                ctx.beginPath();
                ctx.arc(sx, sy, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Rising sparkles
            ctx.globalAlpha = 1 - progress;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + progress * Math.PI;
                const dist = s(20 + progress * 40);
                const sparkX = sx + Math.cos(angle) * dist;
                const sparkY = sy + Math.sin(angle) * dist - progress * s(50);
                
                ctx.fillStyle = ['#ff88ff', '#88ffff', '#ffff88'][i % 3];
                ctx.shadowBlur = 10;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, s(3 - progress * 2), 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Healing text
            if (progress < 0.7) {
                ctx.globalAlpha = 1 - progress / 0.7;
                ctx.fillStyle = '#88ff88';
                ctx.shadowColor = '#88ff88';
                ctx.shadowBlur = 15;
                ctx.font = `bold ${s(20)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('✨ HEALED ✨', sx, sy - s(40) - progress * s(30));
            }
            
            ctx.restore();
        }

        // ===== MAGNET PICKUPS =====
        let magnetPickups = [];
        const MAGNET_COUNT = 3; // Always 3 magnets on map
        
        function spawnMagnetPickups() {
            magnetPickups = [];
            for (let i = 0; i < MAGNET_COUNT; i++) {
                spawnSingleMagnet();
            }
        }
        
        function spawnSingleMagnet() {
            const minDistFromObstacles = 80;
            const minDistFromOtherMagnets = 800;
            let attempts = 0;
            
            while (attempts < 50) {
                const x = 500 + Math.random() * (WORLD.width - 1000);
                const y = 500 + Math.random() * (WORLD.height - 1000);
                
                // Check not too close to center spawn
                if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 600) {
                    attempts++;
                    continue;
                }
                
                // Check not too close to player
                if (player && Math.hypot(x - player.x, y - player.y) < 400) {
                    attempts++;
                    continue;
                }
                
                // Check not in terrain or lakes
                if (isInTerrain(x, y, minDistFromObstacles) || isInLake(x, y, minDistFromObstacles + 30)) {
                    attempts++;
                    continue;
                }
                
                // Check not too close to other magnets
                let tooClose = false;
                for (const mag of magnetPickups) {
                    if (Math.hypot(x - mag.x, y - mag.y) < minDistFromOtherMagnets) {
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) {
                    attempts++;
                    continue;
                }
                
                // Check not too close to other objects
                if (isTooCloseToObjects(x, y, MIN_OBJECT_SPACING, 'magnet')) {
                    attempts++;
                    continue;
                }
                
                magnetPickups.push({
                    x: x,
                    y: y,
                    radius: 18,
                    bobOffset: Math.random() * Math.PI * 2,
                    pulseOffset: Math.random() * Math.PI * 2
                });
                break;
            }
        }
        
        function drawMagnetPickups() {
            for (const mag of magnetPickups) {
                if (!camera.isVisible(mag.x, mag.y, 50)) continue;
                
                const sx = camera.screenX(mag.x);
                const sy = camera.screenY(mag.y);
                const time = Date.now();
                const bob = Math.sin(time * 0.003 + mag.bobOffset) * camera.scale(4);
                const pulse = 0.8 + Math.sin(time * 0.005 + mag.pulseOffset) * 0.2;
                const s = camera.scale.bind(camera);
                
                ctx.save();
                
                // Magnetic field rings
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                const ringPulse = (time * 0.002) % 1;
                for (let i = 0; i < 3; i++) {
                    const ringProgress = (ringPulse + i * 0.33) % 1;
                    ctx.globalAlpha = 0.4 * (1 - ringProgress);
                    ctx.beginPath();
                    ctx.arc(sx, sy + bob, s(20 + ringProgress * 25), 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                
                // Magnet body glow
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = '#ff4444';
                
                // Horseshoe magnet shape
                const magY = sy + bob;
                
                // Red side (left)
                ctx.fillStyle = '#ff2222';
                ctx.beginPath();
                ctx.moveTo(sx - s(12), magY + s(8));
                ctx.lineTo(sx - s(12), magY - s(6));
                ctx.quadraticCurveTo(sx - s(12), magY - s(14), sx - s(4), magY - s(14));
                ctx.lineTo(sx - s(4), magY + s(8));
                ctx.closePath();
                ctx.fill();
                
                // Blue side (right)
                ctx.fillStyle = '#4444ff';
                ctx.shadowColor = '#4444ff';
                ctx.beginPath();
                ctx.moveTo(sx + s(12), magY + s(8));
                ctx.lineTo(sx + s(12), magY - s(6));
                ctx.quadraticCurveTo(sx + s(12), magY - s(14), sx + s(4), magY - s(14));
                ctx.lineTo(sx + s(4), magY + s(8));
                ctx.closePath();
                ctx.fill();
                
                // Connecting arc at top
                ctx.fillStyle = '#888888';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(sx, magY - s(6), s(4), 0, Math.PI, true);
                ctx.fill();
                
                // Metal tips
                ctx.fillStyle = '#cccccc';
                ctx.shadowBlur = 5;
                ctx.fillRect(sx - s(13), magY + s(6), s(10), s(5));
                ctx.fillRect(sx + s(3), magY + s(6), s(10), s(5));
                
                // "XP" label floating above
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.font = `bold ${s(10)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('XP', sx, magY - s(20));
                
                ctx.restore();
            }
        }
        
        function updateMagnetPickups() {
            for (let i = magnetPickups.length - 1; i >= 0; i--) {
                const mag = magnetPickups[i];
                const dist = Math.hypot(player.x - mag.x, player.y - mag.y);
                
                if (dist < player.radius + mag.radius) {
                    // Activate magnet - pull all XP with staggered timing
                    activateMagnetPickup(mag);
                    magnetPickups.splice(i, 1);
                    
                    // Spawn replacement magnet
                    setTimeout(() => {
                        if (gameRunning && !gamePaused) {
                            spawnSingleMagnet();
                        }
                    }, 500);
                }
            }
        }
        
        function activateMagnetPickup(mag) {
            // Visual feedback
            spawnParticles(mag.x, mag.y, '#ff4444', 20);
            spawnParticles(mag.x, mag.y, '#4444ff', 20);
            spawnParticles(mag.x, mag.y, '#00ffff', 15);
            
            // Stagger the magnetization to prevent lag
            const totalGems = xpGems.length;
            const batchSize = 20; // Magnetize in batches
            let batchIndex = 0;
            
            function magnetizeBatch() {
                const start = batchIndex * batchSize;
                const end = Math.min(start + batchSize, totalGems);
                
                for (let i = start; i < end; i++) {
                    if (xpGems[i] && !xpGems[i].dead) {
                        xpGems[i].magnetized = true;
                        xpGems[i].magnetStrength = 6; // Slower pull to prevent lag
                    }
                }
                
                batchIndex++;
                if (batchIndex * batchSize < totalGems) {
                    setTimeout(magnetizeBatch, 50); // Stagger batches
                }
            }
            
            magnetizeBatch();
            
            // Show notification
            showMagnetNotification();
        }
        
        function showMagnetNotification() {
            const notification = document.createElement('div');
            notification.innerHTML = `<div style="font-size: 22px;">🧲 XP MAGNET! 🧲</div>`;
            notification.style.cssText = `
                position: fixed;
                top: 18%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #00ffff;
                text-shadow: 0 0 20px #00ffff, 0 0 40px #ff4444;
                text-align: center;
                z-index: 9999;
                pointer-events: none;
                animation: magnetNotify 1.2s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes magnetNotify {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    80% { opacity: 1; }
                    100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 1200);
        }

        // ===== TOMBSTONES (Avenge Fallen Friends) =====
        let tombstones = [];
        let extraBossMultiplier = 0; // Extra bosses spawned with each boss
        let pendingTombstone = null;
        
        function spawnTombstones() {
            tombstones = [];
            const count = 2 + Math.floor(Math.random() * 2); // 2-3 tombstones
            
            for (let i = 0; i < count; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const x = 600 + Math.random() * (WORLD.width - 1200);
                    const y = 600 + Math.random() * (WORLD.height - 1200);
                    
                    // Check not too close to center
                    if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 800) {
                        attempts++;
                        continue;
                    }
                    
                    // Check not in terrain or lake
                    if (isInTerrain(x, y, 80) || isInLake(x, y, 100)) {
                        attempts++;
                        continue;
                    }
                    
                    // Check not too close to other tombstones
                    let tooClose = false;
                    for (const t of tombstones) {
                        if (Math.hypot(x - t.x, y - t.y) < 400) {
                            tooClose = true;
                            break;
                        }
                    }
                    if (tooClose) {
                        attempts++;
                        continue;
                    }
                    
                    tombstones.push({
                        x: x,
                        y: y,
                        radius: 22,
                        activated: false,
                        needsPlayerToLeave: true, // Start needing player to approach fresh
                        name: getRandomFallenName()
                    });
                    break;
                }
            }
        }
        
        function getRandomFallenName() {
            const names = ['ALEX', 'SAM', 'JORDAN', 'CASEY', 'RILEY', 'MORGAN', 'TAYLOR', 'AVERY', 'QUINN', 'DREW', 'SAGE', 'RIVER'];
            return names[Math.floor(Math.random() * names.length)];
        }
        
        function drawTombstones() {
            for (const tomb of tombstones) {
                if (tomb.activated) continue;
                if (!camera.isVisible(tomb.x, tomb.y, 60)) continue;
                
                const sx = camera.screenX(tomb.x);
                const sy = camera.screenY(tomb.y);
                const s = camera.scale.bind(camera);
                const time = Date.now();
                
                ctx.save();
                
                // Dirt plot at base
                ctx.fillStyle = '#3d2817';
                ctx.beginPath();
                ctx.ellipse(sx, sy + s(14), s(22), s(8), 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Dirt mound texture
                ctx.fillStyle = '#4a3020';
                ctx.beginPath();
                ctx.ellipse(sx, sy + s(12), s(18), s(5), 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Small dirt clumps
                ctx.fillStyle = '#5a3828';
                for (let i = 0; i < 4; i++) {
                    const clumpX = sx + (i - 1.5) * s(8);
                    const clumpY = sy + s(10) + Math.sin(i * 1.5) * s(3);
                    ctx.beginPath();
                    ctx.arc(clumpX, clumpY, s(3), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Eerie glow - brighter purple
                const pulse = 0.3 + Math.sin(time * 0.002) * 0.15;
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#aa66ff';
                ctx.globalAlpha = pulse + 0.5;
                
                // Tombstone base - more purple tint
                ctx.fillStyle = '#4a4460';
                ctx.beginPath();
                ctx.moveTo(sx - s(16.5), sy + s(11));
                ctx.lineTo(sx - s(16.5), sy - s(16.5));
                ctx.quadraticCurveTo(sx - s(16.5), sy - s(27.5), sx, sy - s(31));
                ctx.quadraticCurveTo(sx + s(16.5), sy - s(27.5), sx + s(16.5), sy - s(16.5));
                ctx.lineTo(sx + s(16.5), sy + s(11));
                ctx.closePath();
                ctx.fill();
                
                // Neon outline
                ctx.strokeStyle = '#bb77ff';
                ctx.lineWidth = s(2);
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#cc88ff';
                ctx.stroke();
                
                // Tombstone front face - more purple
                ctx.fillStyle = '#3a3450';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(sx - s(13.2), sy + s(9));
                ctx.lineTo(sx - s(13.2), sy - s(13.2));
                ctx.quadraticCurveTo(sx - s(13.2), sy - s(22), sx, sy - s(25.3));
                ctx.quadraticCurveTo(sx + s(13.2), sy - s(22), sx + s(13.2), sy - s(13.2));
                ctx.lineTo(sx + s(13.2), sy + s(9));
                ctx.closePath();
                ctx.fill();
                
                // Cross - purple tint
                ctx.strokeStyle = '#7766aa';
                ctx.lineWidth = s(3.3);
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#9977cc';
                ctx.beginPath();
                ctx.moveTo(sx, sy - s(19.8));
                ctx.lineTo(sx, sy - s(5.5));
                ctx.moveTo(sx - s(6.6), sy - s(14.3));
                ctx.lineTo(sx + s(6.6), sy - s(14.3));
                ctx.stroke();
                
                // R.I.P. text - purple tint
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 6;
                ctx.shadowColor = '#bb88ff';
                ctx.fillStyle = '#ccbbee';
                ctx.font = `bold ${s(9)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('R.I.P.', sx, sy + s(2));
                
                // Ghostly wisps - more purple
                for (let i = 0; i < 3; i++) {
                    const wispTime = time * 0.001 + i * 2;
                    const wispX = sx + Math.sin(wispTime) * s(10);
                    const wispY = sy - s(30) - Math.sin(wispTime * 0.5) * s(10);
                    ctx.globalAlpha = 0.3 + Math.sin(wispTime) * 0.2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#cc99ff';
                    ctx.fillStyle = '#bb99ff';
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, s(3), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        function updateTombstones() {
            for (const tomb of tombstones) {
                if (tomb.activated) continue;
                
                const dist = Math.hypot(player.x - tomb.x, player.y - tomb.y);
                
                // Need to leave first before can interact
                if (tomb.needsPlayerToLeave) {
                    if (dist > 60) {
                        tomb.needsPlayerToLeave = false;
                    }
                    continue;
                }
                
                if (dist < player.radius + tomb.radius) {
                    // Show tombstone choice modal
                    showTombstoneModal(tomb);
                    tomb.needsPlayerToLeave = true;
                }
            }
        }
        
        function showTombstoneModal(tomb) {
            pendingTombstone = tomb;
            gamePaused = true;
            
            const modal = document.getElementById('tombstoneModal');
            document.getElementById('tombstoneName').textContent = 'R.I.P.';
            modal.classList.add('visible');
        }
        
        function acceptTombstoneOffer() {
            if (!pendingTombstone) return;
            
            // Activate the curse - extra boss spawns
            extraBossMultiplier++;
            pendingTombstone.activated = true;
            
            // Visual feedback
            spawnParticles(pendingTombstone.x, pendingTombstone.y, '#8866aa', 25);
            spawnParticles(pendingTombstone.x, pendingTombstone.y, '#ff4444', 15);
            
            closeTombstoneModal();
        }
        window.acceptTombstoneOffer = acceptTombstoneOffer;
        
        function declineTombstoneOffer() {
            closeTombstoneModal();
        }
        window.declineTombstoneOffer = declineTombstoneOffer;
        
        function closeTombstoneModal() {
            const modal = document.getElementById('tombstoneModal');
            modal.classList.remove('visible');
            pendingTombstone = null;
            gamePaused = false;
        }

        // ===== GRAVITY WELL UPDATE =====
        function updateGravityWells(dt) {
            if (!player || !player.weapons.gravityWell) return;
            
            const state = player.weapons.gravityWell;
            if (!state.wells) return;
            
            const now = Date.now();
            
            for (let i = state.wells.length - 1; i >= 0; i--) {
                const well = state.wells[i];
                
                // Remove expired wells
                if (now - well.startTime > well.duration) {
                    state.wells.splice(i, 1);
                    continue;
                }
                
                // Pull and damage enemies
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - well.x, enemy.y - well.y);
                    
                    if (dist < well.pullRadius) {
                        // Pull toward center
                        const pullForce = well.pullStrength * (1 - dist / well.pullRadius);
                        const angle = Math.atan2(well.y - enemy.y, well.x - enemy.x);
                        enemy.x += Math.cos(angle) * pullForce * dt * 0.15;
                        enemy.y += Math.sin(angle) * pullForce * dt * 0.15;
                        
                        // Damage on tick
                        if (now - well.lastTick >= well.tickRate) {
                            const { damage, isCrit } = player.calcDamage(well.damage);
                            enemy.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                        }
                    }
                }
                
                // Also affect bosses
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - well.x, boss.y - well.y);
                    
                    if (dist < well.pullRadius) {
                        // Reduced pull on bosses
                        const pullForce = well.pullStrength * 0.3 * (1 - dist / well.pullRadius);
                        const angle = Math.atan2(well.y - boss.y, well.x - boss.x);
                        boss.x += Math.cos(angle) * pullForce * dt * 0.15;
                        boss.y += Math.sin(angle) * pullForce * dt * 0.15;
                        
                        if (now - well.lastTick >= well.tickRate) {
                            const { damage, isCrit } = player.calcDamage(well.damage);
                            boss.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                        }
                    }
                }
                
                // Update tick timer (do this once per well per frame)
                if (now - well.lastTick >= well.tickRate) {
                    well.lastTick = now;
                }
            }
        }
        
        // Update pulse mines
        function updateMines() {
            if (!player || !player.weapons.pulseMine) return;
            
            const state = player.weapons.pulseMine;
            const def = WEAPONS.pulseMine;
            if (!state.mines) return;
            
            const now = Date.now();
            
            for (const mine of state.mines) {
                if (mine.exploded) continue;
                
                // Check if armed
                const armed = now - mine.startTime > mine.armTime;
                mine.armed = armed;
                
                if (!armed) continue;
                
                // Check collision with enemies for explosion
                let shouldExplode = false;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - mine.x, enemy.y - mine.y);
                    if (dist < 40 + enemy.radius) {
                        shouldExplode = true;
                        break;
                    }
                }
                
                if (!shouldExplode) {
                    for (const boss of bosses) {
                        if (boss.dead) continue;
                        const dist = Math.hypot(boss.x - mine.x, boss.y - mine.y);
                        if (dist < 40 + boss.radius) {
                            shouldExplode = true;
                            break;
                        }
                    }
                }
                
                if (!shouldExplode) {
                    for (const lep of leprechauns) {
                        if (lep.dead) continue;
                        const dist = Math.hypot(lep.x - mine.x, lep.y - mine.y);
                        if (dist < 40 + lep.radius) {
                            shouldExplode = true;
                            break;
                        }
                    }
                }
                
                if (shouldExplode) {
                    mine.exploded = true;
                    
                    // AOE damage
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - mine.x, enemy.y - mine.y);
                        if (dist < mine.blastRadius + enemy.radius) {
                            const { damage, isCrit } = player.calcDamage(mine.damage);
                            enemy.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                            
                            // Knockback (smooth)
                            const knockAngle = Math.atan2(enemy.y - mine.y, enemy.x - mine.x);
                            enemy.applyKnockback(knockAngle, 60);
                        }
                    }
                    
                    for (const boss of bosses) {
                        if (boss.dead) continue;
                        const dist = Math.hypot(boss.x - mine.x, boss.y - mine.y);
                        if (dist < mine.blastRadius + boss.radius) {
                            const { damage, isCrit } = player.calcDamage(mine.damage);
                            boss.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                        }
                    }
                    
                    for (const lep of leprechauns) {
                        if (lep.dead) continue;
                        const dist = Math.hypot(lep.x - mine.x, lep.y - mine.y);
                        if (dist < mine.blastRadius + lep.radius) {
                            const { damage, isCrit } = player.calcDamage(mine.damage);
                            lep.takeDamage(damage, isCrit);
                            player.onDealDamage(damage);
                        }
                    }
                    
                    // Explosion visual
                    spawnParticles(mine.x, mine.y, def.color, 25);
                    spawnParticles(mine.x, mine.y, '#ff8844', 15);
                    
                    // AOE explosion ring effect
                    explosions.push({
                        x: mine.x,
                        y: mine.y,
                        radius: 0,
                        maxRadius: mine.blastRadius,
                        color: def.color,
                        startTime: now
                    });
                }
            }
            
            // Remove exploded mines
            state.mines = state.mines.filter(m => !m.exploded);
        }

        // ===== TERRAIN OBSTACLES (Lakes & Mountains) =====
        let terrainObstacles = [];
        let decorations = []; // Trees only
        
        // Map area: 4320 x 4320 = 18,662,400 sq units
        // Large lake: 2-3% = 373,248 - 559,872 sq units each (radius ~345-422)
        // Mountain range: 3-4% = 559,872 - 746,496 sq units each (radius ~422-487)
        
        const TERRAIN_TYPES = {
            lake: {
                draw: function(ctx, sx, sy, scale, time, obstacle) {
                    const pulse = 0.4 + Math.sin(time * 0.001 + obstacle.variant) * 0.15;
                    const colors = ['#00ffff', '#0088ff'];
                    const color = colors[obstacle.variant % colors.length];
                    const radiusX = scale(obstacle.radiusX);
                    const radiusY = scale(obstacle.radiusY);
                    
                    ctx.save();
                    ctx.globalAlpha = pulse * 0.4;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = color;
                    ctx.fillStyle = color;
                    
                    // Lake body (ellipse)
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX, radiusY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner glow rings
                    ctx.globalAlpha = pulse * 0.5;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX * 0.7, radiusY * 0.7, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.globalAlpha = pulse * 0.3;
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX * 0.4, radiusY * 0.4, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Ripple effect
                    const ripple = ((time * 0.0006 + obstacle.variant) % 2) / 2;
                    ctx.globalAlpha = (1 - ripple) * 0.3;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX * ripple, radiusY * ripple, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            },
            tree: {
                draw: function(ctx, sx, sy, scale, time, obstacle) {
                    const colors = ['#00ffaa', '#00ff66', '#88ff00'];
                    const color = colors[obstacle.variant % colors.length];
                    const sway = Math.sin(time * 0.001 + obstacle.variant) * scale(2);
                    const height = scale(60 + (obstacle.variant % 3) * 20);
                    const radius = scale(obstacle.radius);
                    
                    ctx.save();
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = color;
                    
                    // Trunk (solid line)
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = 0.5;
                    ctx.lineWidth = scale(3);
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + sway * 0.3, sy - height * 0.5);
                    ctx.stroke();
                    
                    // Canopy layers (solid filled triangles)
                    ctx.fillStyle = color;
                    const levels = 3;
                    for (let i = 0; i < levels; i++) {
                        const levelY = sy - height * 0.3 - i * height * 0.22;
                        const spread = scale(28 - i * 6);
                        const levelSway = sway * (1 + i * 0.3);
                        
                        // Filled triangle
                        ctx.globalAlpha = 0.3 - i * 0.05;
                        ctx.beginPath();
                        ctx.moveTo(sx + levelSway - spread, levelY + scale(12));
                        ctx.lineTo(sx + levelSway, levelY - scale(12));
                        ctx.lineTo(sx + levelSway + spread, levelY + scale(12));
                        ctx.closePath();
                        ctx.fill();
                        
                        // Triangle outline
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            },
            rock: {
                draw: function(ctx, sx, sy, scale, time, obstacle) {
                    const colors = ['#666666', '#888888', '#555555'];
                    const color = colors[obstacle.variant % colors.length];
                    const r = scale(obstacle.radius);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#444';
                    
                    // Rock body (irregular polygon based on size)
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    const points = 5 + (obstacle.variant % 3);
                    for (let i = 0; i < points; i++) {
                        const angle = (i / points) * Math.PI * 2 - Math.PI / 2;
                        const variance = 0.7 + ((obstacle.variant * i) % 30) / 100;
                        const px = sx + Math.cos(angle) * r * variance;
                        const py = sy + Math.sin(angle) * r * variance * 0.7; // Flatten vertically
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Highlight edge
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Top highlight
                    ctx.fillStyle = '#888';
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.ellipse(sx - r * 0.2, sy - r * 0.2, r * 0.3, r * 0.2, -0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            },
            bush: {
                draw: function(ctx, sx, sy, scale, time, obstacle) {
                    const r = scale(obstacle.radius);
                    const sway = Math.sin(time * 0.0015 + obstacle.variant) * scale(1.5);
                    
                    ctx.save();
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#22aa44';
                    
                    // Base dark shadow/ground
                    ctx.fillStyle = 'rgba(0, 40, 0, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(sx, sy + r * 0.3, r * 0.9, r * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main bush body - lumpy shape using multiple arcs
                    const darkGreen = '#1a5a1a';
                    const midGreen = '#228B22';
                    const lightGreen = '#2d9a2d';
                    
                    // Back layer (darker)
                    ctx.fillStyle = darkGreen;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    const backBumps = 5 + (obstacle.variant % 3);
                    for (let i = 0; i < backBumps; i++) {
                        const angle = (i / backBumps) * Math.PI * 2 - Math.PI / 2;
                        const bumpR = r * (0.7 + ((obstacle.variant * i) % 30) / 100);
                        const bx = sx + Math.cos(angle) * r * 0.3 + sway * 0.5;
                        const by = sy + Math.sin(angle) * r * 0.25;
                        ctx.moveTo(bx + bumpR, by);
                        ctx.arc(bx, by, bumpR, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    
                    // Middle layer
                    ctx.fillStyle = midGreen;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    const midBumps = 4 + (obstacle.variant % 2);
                    for (let i = 0; i < midBumps; i++) {
                        const angle = (i / midBumps) * Math.PI * 2;
                        const bumpR = r * (0.55 + ((obstacle.variant * i * 3) % 25) / 100);
                        const bx = sx + Math.cos(angle) * r * 0.25 + sway;
                        const by = sy + Math.sin(angle) * r * 0.2 - r * 0.1;
                        ctx.moveTo(bx + bumpR, by);
                        ctx.arc(bx, by, bumpR, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    
                    // Front highlights (lighter bumps on top)
                    ctx.fillStyle = lightGreen;
                    ctx.globalAlpha = 0.6;
                    const topBumps = 3;
                    for (let i = 0; i < topBumps; i++) {
                        const seed = obstacle.variant * 11 + i * 17;
                        const bx = sx + ((seed % 60) / 60 - 0.5) * r * 0.8 + sway;
                        const by = sy - r * 0.2 + ((seed * 2) % 40) / 40 * r * 0.3;
                        const bumpR = r * (0.25 + (seed % 15) / 100);
                        ctx.beginPath();
                        ctx.arc(bx, by, bumpR, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Small leaf highlights
                    ctx.fillStyle = '#55dd55';
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < 5; i++) {
                        const seed = obstacle.variant * 7 + i * 23;
                        const lx = sx + ((seed % 80) / 80 - 0.5) * r * 1.2 + sway;
                        const ly = sy + (((seed * 3) % 60) / 60 - 0.5) * r * 0.7;
                        ctx.beginPath();
                        ctx.arc(lx, ly, scale(1.5 + (seed % 2)), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }
        };
        
        // Check if a point is inside any terrain obstacle (including trees, rocks, bushes)
        function isInTerrain(x, y, padding = 0) {
            for (const obs of terrainObstacles) {
                if (obs.type === 'tree' || obs.type === 'rock' || obs.type === 'bush') {
                    // Trees, rocks, bushes use circular collision
                    const dist = Math.hypot(x - obs.x, y - obs.y);
                    if (dist < obs.radius + padding) {
                        return obs;
                    }
                } else {
                    // Lakes and mountains use ellipse collision
                    const dx = (x - obs.x) / (obs.radiusX + padding);
                    const dy = (y - obs.y) / (obs.radiusY + padding);
                    if (dx * dx + dy * dy < 1) {
                        return obs;
                    }
                }
            }
            return null;
        }
        
        // Check if a circular area overlaps with any lake
        function isInLake(x, y, objectRadius = 0) {
            for (const obs of terrainObstacles) {
                if (obs.type !== 'lake') continue;
                // Check if any part of the object circle overlaps with the lake ellipse
                // Use expanded ellipse radii to account for object radius
                const dx = (x - obs.x) / (obs.radiusX + objectRadius);
                const dy = (y - obs.y) / (obs.radiusY + objectRadius);
                if (dx * dx + dy * dy < 1) {
                    return true;
                }
            }
            return false;
        }
        
        // Check if position is too close to any spawned objects (shrines, chests, statues, etc.)
        const MIN_OBJECT_SPACING = 150; // Minimum pixels between objects
        
        function isTooCloseToObjects(x, y, minDist = MIN_OBJECT_SPACING, excludeType = null) {
            // Check shrines
            if (excludeType !== 'shrine') {
                for (const shrine of shrines) {
                    if (shrine.activated) continue;
                    if (Math.hypot(x - shrine.x, y - shrine.y) < minDist) return true;
                }
            }
            
            // Check chests
            if (excludeType !== 'chest') {
                for (const chest of chests) {
                    if (chest.dead || chest.opened) continue;
                    if (Math.hypot(x - chest.x, y - chest.y) < minDist) return true;
                }
            }
            
            // Check skull statues
            if (excludeType !== 'statue') {
                for (const statue of skullStatues) {
                    if (statue.dead) continue;
                    if (Math.hypot(x - statue.x, y - statue.y) < minDist) return true;
                }
            }
            
            // Check shield pickups
            if (excludeType !== 'shield') {
                for (const shield of shieldPickups) {
                    if (shield.collected) continue;
                    if (Math.hypot(x - shield.x, y - shield.y) < minDist) return true;
                }
            }
            
            // Check cowboy hat
            if (excludeType !== 'hat' && cowboyHat && !playerHasCowboyHat) {
                if (Math.hypot(x - cowboyHat.x, y - cowboyHat.y) < minDist) return true;
            }
            
            // Check magnet pickups
            if (excludeType !== 'magnet') {
                for (const mag of magnetPickups) {
                    if (mag.collected) continue;
                    if (Math.hypot(x - mag.x, y - mag.y) < minDist) return true;
                }
            }
            
            return false;
        }
        
        // Get valid spawn position avoiding terrain and other objects
        function getValidSpawnPosition(minX, maxX, minY, maxY, padding = 50, avoidCenter = 0, minObjectDist = MIN_OBJECT_SPACING) {
            let attempts = 0;
            while (attempts < 50) {
                const x = minX + Math.random() * (maxX - minX);
                const y = minY + Math.random() * (maxY - minY);
                
                // Check center avoidance
                if (avoidCenter > 0 && Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < avoidCenter) {
                    attempts++;
                    continue;
                }
                
                // Check terrain (includes lakes)
                if (isInTerrain(x, y, padding)) {
                    attempts++;
                    continue;
                }
                
                // Check lake specifically with padding
                if (isInLake(x, y, padding + 50)) {
                    attempts++;
                    continue;
                }
                
                // Check distance to other objects
                if (minObjectDist > 0 && isTooCloseToObjects(x, y, minObjectDist)) {
                    attempts++;
                    continue;
                }
                
                return { x, y };
            }
            // Fallback - return position anyway (try to at least avoid terrain)
            for (let i = 0; i < 20; i++) {
                const x = minX + Math.random() * (maxX - minX);
                const y = minY + Math.random() * (maxY - minY);
                if (!isInTerrain(x, y, padding)) {
                    return { x, y };
                }
            }
            return { x: minX + Math.random() * (maxX - minX), y: minY + Math.random() * (maxY - minY) };
        }
        
        function spawnTerrain() {
            terrainObstacles = [];
            
            // Minimum corridor width for player to pass (player radius is 12)
            const MIN_CORRIDOR = 120;
            
            // Helper to check if position overlaps existing terrain
            function overlapsExisting(x, y, radiusX, radiusY, padding = 50) {
                for (const obs of terrainObstacles) {
                    if (obs.type === 'tree' || obs.type === 'rock' || obs.type === 'bush') {
                        const dist = Math.hypot(x - obs.x, y - obs.y);
                        if (dist < Math.max(radiusX, radiusY) + obs.radius + padding) return true;
                    } else {
                        // Ellipse overlap check with padding
                        const combinedRadiusX = obs.radiusX + radiusX + padding;
                        const combinedRadiusY = obs.radiusY + radiusY + padding;
                        const dx = (x - obs.x) / combinedRadiusX;
                        const dy = (y - obs.y) / combinedRadiusY;
                        if (dx * dx + dy * dy < 1) return true;
                    }
                }
                return false;
            }
            
            // Check if obstacle blocks edge access (player must walk around perimeter)
            function blocksEdge(x, y, radiusX, radiusY) {
                const edgeBuffer = MIN_CORRIDOR + 50;
                // Check all four edges
                if (x - radiusX < edgeBuffer) return true;  // Too close to left
                if (x + radiusX > WORLD.width - edgeBuffer) return true;  // Too close to right
                if (y - radiusY < edgeBuffer) return true;  // Too close to top
                if (y + radiusY > WORLD.height - edgeBuffer) return true;  // Too close to bottom
                return false;
            }
            
            // Check if two obstacles create a blocking corridor
            function createsBlockage(x, y, radiusX, radiusY) {
                for (const obs of terrainObstacles) {
                    if (obs.type !== 'lake') continue;
                    
                    // Check horizontal gap (for vertical corridors)
                    const horizontalGap = Math.abs(x - obs.x) - radiusX - obs.radiusX;
                    const verticalOverlap = Math.abs(y - obs.y) < radiusY + obs.radiusY;
                    
                    // Check vertical gap (for horizontal corridors)
                    const verticalGap = Math.abs(y - obs.y) - radiusY - obs.radiusY;
                    const horizontalOverlap = Math.abs(x - obs.x) < radiusX + obs.radiusX;
                    
                    // If obstacles overlap in one axis and gap is too small in other
                    if (verticalOverlap && horizontalGap > 0 && horizontalGap < MIN_CORRIDOR) return true;
                    if (horizontalOverlap && verticalGap > 0 && verticalGap < MIN_CORRIDOR) return true;
                    
                    // Check if this creates a corner trap with map edge
                    // Left edge trap
                    if (x < WORLD.width * 0.3 && obs.x < WORLD.width * 0.3) {
                        if (x - radiusX < MIN_CORRIDOR * 2 || obs.x - obs.radiusX < MIN_CORRIDOR * 2) {
                            if (Math.abs(y - obs.y) < radiusY + obs.radiusY + MIN_CORRIDOR) return true;
                        }
                    }
                    // Right edge trap
                    if (x > WORLD.width * 0.7 && obs.x > WORLD.width * 0.7) {
                        if (x + radiusX > WORLD.width - MIN_CORRIDOR * 2 || obs.x + obs.radiusX > WORLD.width - MIN_CORRIDOR * 2) {
                            if (Math.abs(y - obs.y) < radiusY + obs.radiusY + MIN_CORRIDOR) return true;
                        }
                    }
                }
                return false;
            }
            
            // ===== STEP 1: Spawn 8 Lakes (spread across larger map, ensuring accessibility) =====
            // Lakes distributed across map quadrants
            const lakeZones = [
                { minX: 0.10, maxX: 0.25, minY: 0.10, maxY: 0.25 },  // Top-left corner
                { minX: 0.75, maxX: 0.90, minY: 0.75, maxY: 0.90 },  // Bottom-right corner
                { minX: 0.75, maxX: 0.90, minY: 0.10, maxY: 0.25 },  // Top-right corner
                { minX: 0.10, maxX: 0.25, minY: 0.75, maxY: 0.90 },  // Bottom-left corner
                { minX: 0.35, maxX: 0.50, minY: 0.10, maxY: 0.25 },  // Top-center-left
                { minX: 0.50, maxX: 0.65, minY: 0.75, maxY: 0.90 },  // Bottom-center-right
                { minX: 0.10, maxX: 0.25, minY: 0.40, maxY: 0.55 },  // Left-center
                { minX: 0.75, maxX: 0.90, minY: 0.45, maxY: 0.60 }   // Right-center
            ];
            
            for (let i = 0; i < 8; i++) {
                // Slightly smaller lakes to ensure corridors
                const baseRadius = 700 + Math.random() * 200;
                const radiusX = baseRadius * (0.9 + Math.random() * 0.2);
                const radiusY = baseRadius * (0.7 + Math.random() * 0.2);
                
                let x, y, attempts = 0;
                let placed = false;
                
                const zone = lakeZones[i];
                
                do {
                    // Random position within assigned zone
                    x = WORLD.width * (zone.minX + Math.random() * (zone.maxX - zone.minX));
                    y = WORLD.height * (zone.minY + Math.random() * (zone.maxY - zone.minY));
                    
                    attempts++;
                    
                    // Check edge access is maintained
                    if (blocksEdge(x, y, radiusX, radiusY)) continue;
                    
                    // Keep away from center spawn area
                    const centerDist = Math.hypot(x - WORLD.width/2, y - WORLD.height/2);
                    if (centerDist < 800 + Math.max(radiusX, radiusY)) continue;
                    
                    // Check no overlap with existing lakes (increased spacing)
                    if (overlapsExisting(x, y, radiusX, radiusY, MIN_CORRIDOR + 200)) continue;
                    
                    // Check this doesn't create blocking corridors
                    if (createsBlockage(x, y, radiusX, radiusY)) continue;
                    
                    placed = true;
                    break;
                } while (attempts < 40);
                
                if (placed) {
                    terrainObstacles.push({
                        type: 'lake',
                        x: x,
                        y: y,
                        radiusX: radiusX,
                        radiusY: radiusY,
                        variant: i
                    });
                }
            }
            
            // ===== STEP 2: Spawn Trees (avoiding lakes, edges, and blocking paths) =====
            const treeCount = 90 + Math.floor(Math.random() * 20); // 90-110 trees (tighter range)
            const minTreeSpacing = 120; // Increased spacing for larger map
            const edgeBuffer = 300; // Keep trees away from edges
            
            for (let i = 0; i < treeCount; i++) {
                let x, y, attempts = 0;
                const treeRadius = 20 + Math.random() * 10;
                
                do {
                    x = edgeBuffer + Math.random() * (WORLD.width - edgeBuffer * 2);
                    y = edgeBuffer + Math.random() * (WORLD.height - edgeBuffer * 2);
                    attempts++;
                    
                    // Check not in center spawn area (scaled for larger map)
                    if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 600) continue;
                    
                    // Check not overlapping lakes (with padding)
                    let overlaps = false;
                    for (const obs of terrainObstacles) {
                        if (obs.type === 'lake') {
                            const dx = (x - obs.x) / (obs.radiusX + treeRadius + 80);
                            const dy = (y - obs.y) / (obs.radiusY + treeRadius + 80);
                            if (dx * dx + dy * dy < 1) {
                                overlaps = true;
                                break;
                            }
                        } else if (obs.type === 'tree') {
                            // Check spacing between trees
                            const dist = Math.hypot(x - obs.x, y - obs.y);
                            if (dist < minTreeSpacing) {
                                overlaps = true;
                                break;
                            }
                        }
                    }
                    if (!overlaps) break;
                } while (attempts < 50);
                
                if (attempts < 50) {
                    terrainObstacles.push({
                        type: 'tree',
                        x: x,
                        y: y,
                        radius: treeRadius,
                        variant: i
                    });
                }
            }
            
            // ===== STEP 3: Spawn Rocks (avoiding other objects) =====
            const rockCount = 45 + Math.floor(Math.random() * 10); // 45-55 rocks (tighter range)
            const minRockSpacing = 120; // Minimum spacing between rocks
            
            for (let i = 0; i < rockCount; i++) {
                let x, y, attempts = 0;
                const rockRadius = 25 + Math.random() * 35; // Varying sizes 25-60
                
                do {
                    x = edgeBuffer + Math.random() * (WORLD.width - edgeBuffer * 2);
                    y = edgeBuffer + Math.random() * (WORLD.height - edgeBuffer * 2);
                    attempts++;
                    
                    // Check not in center spawn area
                    if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 500) continue;
                    
                    // Check not overlapping any terrain
                    let overlaps = false;
                    for (const obs of terrainObstacles) {
                        if (obs.type === 'lake') {
                            const dx = (x - obs.x) / (obs.radiusX + rockRadius + 50);
                            const dy = (y - obs.y) / (obs.radiusY + rockRadius + 50);
                            if (dx * dx + dy * dy < 1) {
                                overlaps = true;
                                break;
                            }
                        } else {
                            // Check spacing to trees, other rocks
                            const dist = Math.hypot(x - obs.x, y - obs.y);
                            const minDist = obs.type === 'rock' ? minRockSpacing : (obs.radius + rockRadius + 40);
                            if (dist < minDist) {
                                overlaps = true;
                                break;
                            }
                        }
                    }
                    if (!overlaps) break;
                } while (attempts < 40);
                
                if (attempts < 40) {
                    terrainObstacles.push({
                        type: 'rock',
                        x: x,
                        y: y,
                        radius: rockRadius,
                        variant: i
                    });
                }
            }
            
            // ===== STEP 4: Spawn Bushes (avoiding other objects) =====
            const bushCount = 58 + Math.floor(Math.random() * 14); // 58-72 bushes (tighter range)
            const minBushSpacing = 60; // Minimum spacing between bushes
            
            for (let i = 0; i < bushCount; i++) {
                let x, y, attempts = 0;
                const bushRadius = 14 + Math.random() * 14; // Varying sizes 14-28
                
                do {
                    x = edgeBuffer + Math.random() * (WORLD.width - edgeBuffer * 2);
                    y = edgeBuffer + Math.random() * (WORLD.height - edgeBuffer * 2);
                    attempts++;
                    
                    // Check not in center spawn area
                    if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 400) continue;
                    
                    // Check not overlapping any terrain
                    let overlaps = false;
                    for (const obs of terrainObstacles) {
                        if (obs.type === 'lake') {
                            const dx = (x - obs.x) / (obs.radiusX + bushRadius + 40);
                            const dy = (y - obs.y) / (obs.radiusY + bushRadius + 40);
                            if (dx * dx + dy * dy < 1) {
                                overlaps = true;
                                break;
                            }
                        } else {
                            // Check spacing to all other objects
                            const dist = Math.hypot(x - obs.x, y - obs.y);
                            const minDist = obs.type === 'bush' ? minBushSpacing : (obs.radius + bushRadius + 30);
                            if (dist < minDist) {
                                overlaps = true;
                                break;
                            }
                        }
                    }
                    if (!overlaps) break;
                } while (attempts < 40);
                
                if (attempts < 40) {
                    terrainObstacles.push({
                        type: 'bush',
                        x: x,
                        y: y,
                        radius: bushRadius,
                        variant: i
                    });
                }
            }
        }
        
        function spawnDecorations() {
            // Trees are now part of terrain, this is kept for compatibility
            decorations = [];
        }
        
        function drawTerrain() {
            // Draw only lakes (background layer - player walks over these)
            const time = Date.now();
            
            for (const obs of terrainObstacles) {
                if (obs.type !== 'lake') continue; // Only lakes in background
                
                const visMargin = Math.max(obs.radiusX || 0, obs.radiusY || 0) + 150;
                if (!camera.isVisible(obs.x, obs.y, visMargin)) continue;
                
                const sx = camera.screenX(obs.x);
                const sy = camera.screenY(obs.y);
                const scaleFn = (val) => camera.scale(val);
                
                const terrainType = TERRAIN_TYPES[obs.type];
                if (terrainType && terrainType.draw) {
                    terrainType.draw(ctx, sx, sy, scaleFn, time, obs);
                }
            }
        }
        
        function drawTrees() {
            // Trees are now drawn in drawObstaclesAndPlayer for proper Y-sorting
        }
        
        // Draw trees, rocks, bushes and player sorted by Y position for proper depth
        function drawTreesAndPlayer() {
            const time = Date.now();
            
            // Collect visible solid obstacles (trees, rocks, bushes)
            const visibleObstacles = [];
            for (const obs of terrainObstacles) {
                if (obs.type !== 'tree' && obs.type !== 'rock' && obs.type !== 'bush') continue;
                if (!camera.isVisible(obs.x, obs.y, 100)) continue;
                visibleObstacles.push(obs);
            }
            
            // Draw obstacles behind player (obstacle Y < player Y)
            for (const obs of visibleObstacles) {
                if (obs.y < player.y) {
                    drawSingleObstacle(obs, time);
                }
            }
            
            // Draw player
            player.draw();
            
            // Draw obstacles in front of player (obstacle Y >= player Y)
            for (const obs of visibleObstacles) {
                if (obs.y >= player.y) {
                    drawSingleObstacle(obs, time);
                }
            }
        }
        
        function drawSingleObstacle(obs, time) {
            const sx = camera.screenX(obs.x);
            const sy = camera.screenY(obs.y);
            const scaleFn = (val) => camera.scale(val);
            
            const terrainType = TERRAIN_TYPES[obs.type];
            if (terrainType && terrainType.draw) {
                terrainType.draw(ctx, sx, sy, scaleFn, time, obs);
            }
        }
        
        // Keep old function name for compatibility
        function drawSingleTree(obs, time) {
            drawSingleObstacle(obs, time);
        }
        
        function drawDecorations() {
            // Trees are now drawn as terrain, keeping for compatibility
        }

        // ===== LEGENDARY UPGRADE SYSTEM =====
        const LEGENDARY_UPGRADES = {
            burn: {
                name: 'Inferno Touch',
                icon: '🔥',
                color: COLORS.burn,
                desc: 'Attacks have 15% chance to burn enemies',
                effect: 'Burn: Initial damage + 3 ticks over 2s'
            },
            freeze: {
                name: 'Frostbite',
                icon: '❄️',
                color: COLORS.freeze,
                desc: 'Attacks have 12% chance to freeze enemies',
                effect: 'Freeze: Slows enemy 50% for 6 seconds'
            },
            shock: {
                name: 'Overcharged',
                icon: '⚡',
                color: COLORS.shock,
                desc: 'Attacks have 10% chance to shock enemies',
                effect: 'Shock: Stuns for 3s, moderate damage'
            },
            timeSlow: {
                name: 'Temporal Shield',
                icon: '⏳',
                color: '#9966ff',
                desc: 'Below 30% HP: Slows time 60% for 8s',
                effect: '+150% HP Regen during effect. 1 min cooldown'
            },
            holyBook: {
                name: 'Sacred Tome',
                icon: '📖',
                color: '#ffffaa',
                desc: '+25 Max HP, +2 HP/s Regen',
                effect: 'Healing radiates damage to nearby enemies'
            },
            stillness: {
                name: 'Inner Peace',
                icon: '🧘',
                color: '#88ffaa',
                desc: 'Heal 5 HP/s while standing still',
                effect: '+20% Lifesteal on all attacks'
            },
            xpMagnet: {
                name: 'Soul Harvest',
                icon: '💎',
                color: '#ffd700',
                desc: 'Absorb ALL XP on map every 30s',
                effect: 'Automatic collection pulse'
            },
            ghostStrike: {
                name: 'Vengeful Spirits',
                icon: '👻',
                color: '#aaccff',
                desc: 'Killing enemies spawns a ghost',
                effect: 'Ghost kamikazes nearest enemy'
            }
        };

        function showLegendaryUpgrade() {
            gamePaused = true;
            
            // Create overlay
            let overlay = document.getElementById('legendaryOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'legendaryOverlay';
                overlay.className = 'legendary-overlay';
                document.body.appendChild(overlay);
            }
            
            // Randomly select 3 upgrade options
            const allOptions = Object.keys(LEGENDARY_UPGRADES);
            const shuffled = allOptions.sort(() => Math.random() - 0.5);
            const options = shuffled.slice(0, 3);
            
            // Check if player already has an upgrade
            function hasUpgrade(id) {
                const eff = legendaryEffects[id];
                if (!eff) return false;
                if (eff.chance !== undefined) return eff.chance > 0;
                if (eff.active !== undefined) return eff.active;
                return false;
            }
            
            overlay.innerHTML = `
                <div class="legendary-title">🍀 LEGENDARY LOOT! 🍀</div>
                <div class="legendary-subtitle">The leprechaun's treasure is yours!</div>
                <div class="legendary-options">
                    ${options.map(id => {
                        const upg = LEGENDARY_UPGRADES[id];
                        const hasIt = hasUpgrade(id);
                        return `
                            <div class="legendary-card" data-upgrade="${id}" style="border-color: ${upg.color}; box-shadow: 0 0 20px ${upg.color}40;">
                                <div class="legendary-icon">${upg.icon}</div>
                                <div class="legendary-name" style="color: ${upg.color}">${upg.name}${hasIt ? ' +' : ''}</div>
                                <div class="legendary-desc">${upg.desc}</div>
                                <div class="legendary-effect">${upg.effect}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            
            overlay.classList.add('active');
            
            // Add click handlers
            overlay.querySelectorAll('.legendary-card').forEach(card => {
                const handler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    selectLegendaryUpgrade(card.dataset.upgrade);
                };
                card.addEventListener('click', handler);
                card.addEventListener('touchend', handler, { passive: false });
            });
        }

        function selectLegendaryUpgrade(upgradeId) {
            const overlay = document.getElementById('legendaryOverlay');
            if (overlay) overlay.classList.remove('active');
            
            // Restore leave button visibility (in case coming from pot reward)
            DOM.modalLeave.style.display = '';
            
            // Apply the upgrade
            switch(upgradeId) {
                case 'burn':
                    legendaryEffects.burn.chance += 0.15;
                    legendaryEffects.burn.damage = 8 + player.level * 2;
                    break;
                case 'freeze':
                    legendaryEffects.freeze.chance += 0.12;
                    legendaryEffects.freeze.slowAmount = 0.5;
                    break;
                case 'shock':
                    legendaryEffects.shock.chance += 0.10;
                    legendaryEffects.shock.damage = 15 + player.level * 3;
                    break;
                case 'timeSlow':
                    legendaryEffects.timeSlow.active = true;
                    break;
                case 'holyBook':
                    legendaryEffects.holyBook.active = true;
                    legendaryEffects.holyBook.maxHpBonus += 25;
                    legendaryEffects.holyBook.regenBonus += 2;
                    // Apply immediately
                    player.maxHp += 25;
                    player.hp = Math.min(player.hp + 25, player.maxHp);
                    player.regenRate += 2;
                    break;
                case 'stillness':
                    legendaryEffects.stillness.active = true;
                    legendaryEffects.stillness.lifestealBonus = 0.20;
                    break;
                case 'xpMagnet':
                    legendaryEffects.xpMagnet.active = true;
                    legendaryEffects.xpMagnet.lastPulse = 0;
                    break;
                case 'ghostStrike':
                    legendaryEffects.ghostStrike.active = true;
                    break;
            }
            
            gamePaused = false;
        }

        // ===== STARTING BONUS SYSTEM =====
        let startingBonusIndex = 0;
        let startingBonusUpgrades = [];
        
        function showStartingBonus() {
            gamePaused = true;
            startingBonusIndex = 0;
            startingBonusUpgrades = [];
            
            // Generate 3 random upgrades (no luck bonus, base rarity)
            const available = [];
            
            // Add all weapons
            for (const [id, def] of Object.entries(WEAPONS)) {
                // Skip starting weapon
                if (id === selectedStartingWeapon) continue;
                
                const rarity = WEAPON_RARITIES[id] || 'common';
                available.push({
                    ...def,
                    type: 'weapon',
                    id,
                    rarity,
                    currentLevel: 0
                });
            }
            
            // Add all tomes
            for (const [id, def] of Object.entries(TOMES)) {
                const rarity = TOME_RARITIES[id] || 'common';
                available.push({
                    ...def,
                    type: 'tome',
                    id,
                    rarity,
                    currentLevel: 0
                });
            }
            
            // Weight by rarity (no luck bonus)
            const rarityWeights = { common: 50, uncommon: 30, rare: 15, epic: 4, legendary: 1 };
            available.forEach(u => {
                u.weight = rarityWeights[u.rarity] || 50;
            });
            
            // Pick 3 random upgrades
            const shuffled = [...available].sort(() => Math.random() - 0.5);
            for (let i = 0; i < 3 && shuffled.length > 0; i++) {
                // Weighted selection
                const totalWeight = shuffled.reduce((sum, item) => sum + item.weight, 0);
                let roll = Math.random() * totalWeight;
                
                for (let j = 0; j < shuffled.length; j++) {
                    roll -= shuffled[j].weight;
                    if (roll <= 0) {
                        startingBonusUpgrades.push(shuffled[j]);
                        shuffled.splice(j, 1);
                        break;
                    }
                }
            }
            
            // Create overlay
            let overlay = document.getElementById('startingBonusOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'startingBonusOverlay';
                overlay.className = 'starting-bonus-overlay';
                document.body.appendChild(overlay);
            }
            
            overlay.innerHTML = `
                <div class="starting-bonus-title">✨ STARTING BONUS ✨</div>
                <div class="starting-bonus-subtitle">Fortune smiles upon you...</div>
                <div class="starting-bonus-card" id="startingBonusCard">
                    <div class="rarity">???</div>
                    <div class="icon">❓</div>
                    <div class="name">???</div>
                    <div class="desc">???</div>
                </div>
                <div class="starting-bonus-counter" id="startingBonusCounter">1 / 3</div>
            `;
            
            overlay.classList.add('active');
            
            // Show first upgrade after a short delay
            setTimeout(() => showNextStartingBonus(), 500);
        }
        
        function showNextStartingBonus() {
            if (startingBonusIndex >= startingBonusUpgrades.length) {
                // All bonuses granted, close overlay and start game
                const overlay = document.getElementById('startingBonusOverlay');
                if (overlay) overlay.classList.remove('active');
                gamePaused = false;
                return;
            }
            
            const upgrade = startingBonusUpgrades[startingBonusIndex];
            const rarityInfo = RARITIES[upgrade.rarity] || RARITIES.common;
            
            const card = document.getElementById('startingBonusCard');
            const counter = document.getElementById('startingBonusCounter');
            
            if (card) {
                // Reset animation
                card.classList.remove('revealed');
                
                setTimeout(() => {
                    const iconHtml = upgrade.type === 'tome' 
                        ? `<span style="position:relative;display:inline-block;"><span style="font-size:1.2em;opacity:0.6;">📖</span><span style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:0.6em;filter:drop-shadow(0 0 2px #000);">${upgrade.icon}</span></span>`
                        : upgrade.icon;
                    
                    card.innerHTML = `
                        <div class="rarity" style="color:${rarityInfo.color}">${rarityInfo.name}</div>
                        <div class="icon">${iconHtml}</div>
                        <div class="name" style="color:${upgrade.color}">${upgrade.name}</div>
                        <div class="desc">${upgrade.desc}</div>
                    `;
                    card.style.borderColor = rarityInfo.color;
                    card.style.boxShadow = `0 0 30px ${rarityInfo.color}60`;
                    card.classList.add('revealed');
                    
                    if (counter) {
                        counter.textContent = `${startingBonusIndex + 1} / 3`;
                    }
                    
                    // Apply upgrade
                    if (upgrade.type === 'weapon') {
                        player.addWeapon(upgrade.id);
                    } else if (upgrade.type === 'tome') {
                        player.addTome(upgrade.id);
                    }
                    
                    updateWeaponsDisplay();
                    updateTomesDisplay();
                    
                    // Move to next bonus after delay
                    startingBonusIndex++;
                    setTimeout(() => showNextStartingBonus(), 1500);
                }, 100);
            }
        }

        // Apply status effect to enemy when hit
        function applyStatusEffects(enemy, damage) {
            // Try burn
            if (legendaryEffects.burn.chance > 0 && Math.random() < legendaryEffects.burn.chance) {
                enemy.applyBurn(legendaryEffects.burn.damage);
            }
            // Try freeze
            if (legendaryEffects.freeze.chance > 0 && Math.random() < legendaryEffects.freeze.chance) {
                enemy.applyFreeze(legendaryEffects.freeze.slowAmount);
            }
            // Try shock
            if (legendaryEffects.shock.chance > 0 && Math.random() < legendaryEffects.shock.chance) {
                enemy.applyShock(legendaryEffects.shock.damage);
            }
        }

        // ===== PROJECTILE CLASS =====
        // Clean system: projectiles fly STRAIGHT, only Spirit Orbs home
        class Projectile {
            constructor(x, y, angle, speed, damage, color, type, pierce = 1, sizeScale = 1) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = speed;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.damage = damage;
                this.color = color;
                this.type = type;
                this.pierce = pierce;
                this.sizeScale = sizeScale;
                const baseRadius = type === 'laser' ? 6 : type === 'dagger' ? 7 : type === 'boomerang' ? 18 : 
                              type === 'bolt' ? 5 : type === 'squirrel' ? 24 : type === 'ice' ? 6 : 
                              type === 'homing' ? 8 : 8;
                this.radius = baseRadius * sizeScale;
                this.trail = [];
                this.hitEnemies = new Set();
                this.spinAngle = 0;
                this.spawnTime = Date.now();
                this.maxLifetime = type === 'boomerang' || type === 'squirrel' ? 5000 : 2500;
                this.alpha = 1;
                this.dead = false;
            }

            update(dt = 16) {
                const dtScale = dt / 16;
                
                // Lifetime check (skip for pet squirrels - they persist)
                if (!this.isPetSquirrel) {
                    const age = Date.now() - this.spawnTime;
                    if (age > this.maxLifetime) {
                        this.dead = true;
                        return;
                    }
                    
                    // Fade in last 200ms
                    const fadeStart = this.maxLifetime - 200;
                    if (age > fadeStart) {
                        this.alpha = 1 - (age - fadeStart) / 200;
                    }
                }
                
                // Trail
                this.trail.push({ x: this.x, y: this.y });
                const maxTrail = this.type === 'dagger' ? 4 : this.type === 'boomerang' ? 0 : 
                                 this.type === 'squirrel' ? 8 : this.type === 'homing' ? 10 : 
                                 this.type === 'arrow' ? 12 : this.type === 'disc' ? 0 : 
                                 this.type === 'gravitywell' ? 8 : 6;
                if (this.trail.length > maxTrail) this.trail.shift();
                
                // Arrow trail damage handling
                if (this.type === 'arrow' && this.trailPoints) {
                    const now = Date.now();
                    // Add new trail point
                    this.trailPoints.push({ x: this.x, y: this.y, time: now });
                    // Remove expired trail points
                    this.trailPoints = this.trailPoints.filter(p => now - p.time < this.trailDuration);
                    
                    // Damage enemies touching trail
                    if (!this.trailHitCooldowns) this.trailHitCooldowns = new Map();
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const lastHit = this.trailHitCooldowns.get(enemy) || 0;
                        if (now - lastHit < 200) continue; // 0.2s cooldown
                        
                        for (const point of this.trailPoints) {
                            const dist = Math.hypot(enemy.x - point.x, enemy.y - point.y);
                            if (dist < enemy.radius + 8) {
                                const { damage, isCrit } = player.calcDamage(this.trailDamage);
                                enemy.takeDamage(damage, isCrit);
                                player.onDealDamage(damage);
                                this.trailHitCooldowns.set(enemy, now);
                                break;
                            }
                        }
                    }
                }
                
                // Gravity Well projectile - arrives and spawns well
                if (this.isGravityWell) {
                    const distToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                    const distFromStart = Math.hypot(this.x - this.startX, this.y - this.startY);
                    
                    // Track lifetime
                    if (!this.spawnTime) this.spawnTime = Date.now();
                    const lifetime = Date.now() - this.spawnTime;
                    
                    // Spawn well if: close to target, traveled max distance, close to enemy, or timed out
                    let shouldSpawn = distToTarget < 50; // Increased threshold
                    
                    // Also spawn if traveled far enough (failsafe)
                    if (distFromStart > 400) shouldSpawn = true;
                    
                    // Also spawn after 2 seconds no matter what (ultimate failsafe)
                    if (lifetime > 2000) shouldSpawn = true;
                    
                    // Also spawn if close to any enemy (dynamic targeting)
                    if (!shouldSpawn) {
                        for (const enemy of enemies) {
                            if (enemy.dead) continue;
                            const distToEnemy = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (distToEnemy < 60) {
                                shouldSpawn = true;
                                break;
                            }
                        }
                    }
                    
                    // Also check bosses
                    if (!shouldSpawn) {
                        for (const boss of bosses) {
                            if (boss.dead) continue;
                            const distToBoss = Math.hypot(boss.x - this.x, boss.y - this.y);
                            if (distToBoss < 80) {
                                shouldSpawn = true;
                                break;
                            }
                        }
                    }
                    
                    if (shouldSpawn) {
                        const now = Date.now();
                        if (!this.weaponState.wells) this.weaponState.wells = [];
                        
                        this.weaponState.wells.push({
                            x: this.x,
                            y: this.y,
                            damage: this.wellDamage,
                            pullRadius: this.pullRadius,
                            visualRadius: this.visualRadius,
                            pullStrength: this.pullStrength,
                            startTime: now,
                            duration: this.wellDuration,
                            lastTick: now,
                            tickRate: this.tickRate
                        });
                        
                        // Spawn arrival particles
                        spawnParticles(this.x, this.y, '#6600cc', 10);
                        spawnParticles(this.x, this.y, '#9933ff', 6);
                        this.dead = true;
                        return;
                    }
                }
                
                // === SPECIAL WEAPONS ONLY ===
                
                // Pet Squirrel: walks around, pounces periodically
                if (this.isPetSquirrel) {
                    const now = Date.now();
                    
                    // Animate squirrel sprite (faster when walking, slow breathing when still)
                    this.animTimer += dtScale;
                    const speed = Math.hypot(this.vx, this.vy);
                    const isMoving = speed > 0.5;
                    const animSpeed = this.squirrelState === 'pouncing' ? 4 : 
                                      isMoving ? 20 : 30; // Slower walk cycle when moving
                    if (this.animTimer > animSpeed) {
                        this.animTimer = 0;
                        this.animFrame++;
                    }
                    
                    // Walking bob effect (subtle bounce when moving)
                    if (!this.walkBob) this.walkBob = 0;
                    if (isMoving && (this.squirrelState === 'walking' || this.squirrelState === 'returning')) {
                        this.walkBob += 0.125 * dtScale;
                    }
                    
                    // Gentle wobble (only noticeable when pouncing)
                    this.wobble += 0.15 * dtScale;
                    
                    // === WALKING STATE ===
                    if (this.squirrelState === 'walking') {
                        // Stay near player but seek enemies (invisible leash)
                        const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                        const leashDist = 121; // Max distance from player (+10%)
                        const idealDist = 73;  // Preferred orbit distance (+10%)
                        const seekDist = 218;  // Range to detect enemies (+10%)
                        
                        // Find nearest enemy to walk toward
                        let nearestEnemy = null;
                        let nearestDist = seekDist;
                        
                        for (const enemy of enemies) {
                            if (enemy.dead) continue;
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestEnemy = enemy;
                            }
                        }
                        for (const boss of bosses) {
                            if (boss.dead) continue;
                            const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestEnemy = boss;
                            }
                        }
                        
                        // Calculate movement direction
                        let targetX, targetY;
                        let walkSpeed = 2.5;
                        
                        // Check if player is moving
                        const playerMoving = input.left || input.right || input.up || input.down || 
                                             Math.abs(input.joystickX) > 0.1 || Math.abs(input.joystickY) > 0.1;
                        
                        if (distToPlayer > leashDist) {
                            // Too far - return to player quickly
                            targetX = player.x;
                            targetY = player.y;
                            walkSpeed = 3.5;
                        } else if (nearestEnemy && distToPlayer < leashDist * 1.5) {
                            // Enemy nearby and within leash - chase it
                            targetX = nearestEnemy.x;
                            targetY = nearestEnemy.y;
                            walkSpeed = 3.0;
                        } else if (!playerMoving) {
                            // Player standing still, no enemies - rest in place
                            targetX = this.x;
                            targetY = this.y;
                            walkSpeed = 0;
                            // Gradually slow to a stop
                            this.vx *= 0.9;
                            this.vy *= 0.9;
                        } else {
                            // Player moving, no enemy - follow player at ideal distance
                            if (!this.orbitAngle) this.orbitAngle = Math.random() * Math.PI * 2;
                            this.orbitAngle += 0.015 * dtScale; // Slower, smoother orbit
                            targetX = player.x + Math.cos(this.orbitAngle) * idealDist;
                            targetY = player.y + Math.sin(this.orbitAngle) * idealDist;
                            walkSpeed = 1.5; // Slower for smoother look
                        }
                        
                        const toTarget = Math.atan2(targetY - this.y, targetX - this.x);
                        const targetVx = Math.cos(toTarget) * walkSpeed;
                        const targetVy = Math.sin(toTarget) * walkSpeed;
                        
                        // Smooth velocity lerp for fluid movement
                        const lerpFactor = 0.08 * dtScale;
                        this.vx += (targetVx - this.vx) * lerpFactor;
                        this.vy += (targetVy - this.vy) * lerpFactor;
                        
                        // Deal contact damage while walking
                        if (this.walkHitCooldown > 0) this.walkHitCooldown -= dtScale;
                        
                        if (this.walkHitCooldown <= 0) {
                            for (const enemy of enemies) {
                                if (enemy.dead || this.hitEnemies.has(enemy)) continue;
                                const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                                if (dist < enemy.radius + 20) {
                                    const { damage, isCrit } = player.calcDamage(this.walkDamage);
                                    enemy.takeDamage(damage, isCrit);
                                    player.onDealDamage(damage);
                                    spawnParticles(this.x, this.y, '#39ff14', 3);
                                    this.walkHitCooldown = 20; // Cooldown between walk hits
                                    break;
                                }
                            }
                        }
                    }
                    
                    // === WINDING STATE (crouch before pounce) ===
                    else if (this.squirrelState === 'winding') {
                        const windDuration = 150; // Fast wind-up
                        const windProgress = (now - this.windStart) / windDuration;
                        this.pouncePhase = Math.min(1, windProgress);
                        
                        // Stay still, crouch down
                        this.vx *= 0.8;
                        this.vy *= 0.8;
                        
                        // Track enemy's current position during wind-up
                        if (this.pounceTargetRef && !this.pounceTargetRef.dead) {
                            this.pounceTarget.x = this.pounceTargetRef.x;
                            this.pounceTarget.y = this.pounceTargetRef.y;
                        }
                        
                        if (windProgress >= 1) {
                            // POUNCE! Aim at enemy's current position
                            this.squirrelState = 'pouncing';
                            const angle = Math.atan2(this.pounceTarget.y - this.y, this.pounceTarget.x - this.x);
                            this.angle = angle;
                            this.pounceSpeed = 8.0; // FAST pounce
                            this.vx = Math.cos(angle) * this.pounceSpeed;
                            this.vy = Math.sin(angle) * this.pounceSpeed;
                        }
                    }
                    
                    // === POUNCING STATE (fast attack) ===
                    else if (this.squirrelState === 'pouncing') {
                        this.pouncePhase = 2; // Full pounce visual
                        
                        const distFromStart = Math.hypot(this.x - this.startX, this.y - this.startY);
                        
                        // Track enemy's current position during pounce
                        if (this.pounceTargetRef && !this.pounceTargetRef.dead) {
                            this.pounceTarget.x = this.pounceTargetRef.x;
                            this.pounceTarget.y = this.pounceTargetRef.y;
                        }
                        
                        // Aim toward current target position
                        const toTargetAngle = Math.atan2(this.pounceTarget.y - this.y, this.pounceTarget.x - this.x);
                        this.angle = toTargetAngle;
                        this.vx = Math.cos(this.angle) * this.pounceSpeed;
                        this.vy = Math.sin(this.angle) * this.pounceSpeed;
                        
                        // Check distance to target - end pounce when we land on enemy
                        const distToTarget = Math.hypot(this.pounceTarget.x - this.x, this.pounceTarget.y - this.y);
                        
                        // Check for hits during pounce
                        for (const enemy of enemies) {
                            if (enemy.dead || this.hitEnemies.has(enemy)) continue;
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < enemy.radius + 25) {
                                this.hitEnemies.add(enemy);
                                const { damage, isCrit } = player.calcDamage(this.pounceDamage);
                                enemy.takeDamage(damage, isCrit);
                                player.onDealDamage(damage);
                                
                                // === AOE SPLASH DAMAGE ===
                                const splashX = this.x;
                                const splashY = this.y;
                                const splashRadius = this.splashRadius || 45;
                                const splashDamage = this.pounceDamage * 0.5; // 50% damage to nearby
                                
                                for (const splashEnemy of enemies) {
                                    if (splashEnemy.dead || splashEnemy === enemy || this.hitEnemies.has(splashEnemy)) continue;
                                    const splashDist = Math.hypot(splashEnemy.x - splashX, splashEnemy.y - splashY);
                                    if (splashDist < splashRadius + splashEnemy.radius) {
                                        this.hitEnemies.add(splashEnemy);
                                        const { damage: sDmg, isCrit: sCrit } = player.calcDamage(splashDamage);
                                        splashEnemy.takeDamage(sDmg, sCrit);
                                        player.onDealDamage(sDmg);
                                    }
                                }
                                
                                // Splash damage to nearby leprechauns
                                for (const lep of leprechauns) {
                                    if (lep.dead || this.hitEnemies.has(lep)) continue;
                                    const splashDist = Math.hypot(lep.x - splashX, lep.y - splashY);
                                    if (splashDist < splashRadius + lep.radius) {
                                        this.hitEnemies.add(lep);
                                        const { damage: sDmg, isCrit: sCrit } = player.calcDamage(splashDamage);
                                        lep.takeDamage(sDmg, sCrit);
                                        player.onDealDamage(sDmg);
                                    }
                                }
                                
                                // Splash damage to nearby bosses
                                for (const boss of bosses) {
                                    if (boss.dead || this.hitEnemies.has(boss)) continue;
                                    const splashDist = Math.hypot(boss.x - splashX, boss.y - splashY);
                                    if (splashDist < splashRadius + boss.radius) {
                                        this.hitEnemies.add(boss);
                                        const { damage: sDmg, isCrit: sCrit } = player.calcDamage(splashDamage);
                                        boss.takeDamage(sDmg, sCrit);
                                        player.onDealDamage(sDmg);
                                    }
                                }
                                
                                // === RED TWO-STAGE SWIPE ANIMATION (left then right) ===
                                const swipeBaseAngle = this.angle; // Direction squirrel is facing
                                
                                // SWIPE 1: Left swipe (3 claw marks sweeping left)
                                for (let i = 0; i < 3; i++) {
                                    const clawOffset = (i - 1) * 12; // -12, 0, 12 spacing
                                    const swipeAngle = swipeBaseAngle + Math.PI * 0.6; // Angled left
                                    particles.push({
                                        x: splashX + Math.cos(swipeBaseAngle + Math.PI/2) * clawOffset,
                                        y: splashY + Math.sin(swipeBaseAngle + Math.PI/2) * clawOffset,
                                        vx: Math.cos(swipeAngle) * 7,
                                        vy: Math.sin(swipeAngle) * 7,
                                        life: 0.3, maxLife: 0.3,
                                        color: '#ff3333', size: 8, isScratch: true
                                    });
                                }
                                
                                // SWIPE 2: Right swipe (3 claw marks sweeping right, slightly delayed via position offset)
                                for (let i = 0; i < 3; i++) {
                                    const clawOffset = (i - 1) * 12;
                                    const swipeAngle = swipeBaseAngle - Math.PI * 0.6; // Angled right
                                    particles.push({
                                        x: splashX + Math.cos(swipeBaseAngle - Math.PI/2) * clawOffset + Math.cos(swipeBaseAngle) * 8,
                                        y: splashY + Math.sin(swipeBaseAngle - Math.PI/2) * clawOffset + Math.sin(swipeBaseAngle) * 8,
                                        vx: Math.cos(swipeAngle) * 7,
                                        vy: Math.sin(swipeAngle) * 7,
                                        life: 0.35, maxLife: 0.35,
                                        color: '#ff4444', size: 7, isScratch: true
                                    });
                                }
                                
                                // Center impact burst
                                for (let i = 0; i < 4; i++) {
                                    const burstAngle = Math.random() * Math.PI * 2;
                                    particles.push({
                                        x: splashX,
                                        y: splashY,
                                        vx: Math.cos(burstAngle) * (4 + Math.random() * 2),
                                        vy: Math.sin(burstAngle) * (4 + Math.random() * 2),
                                        life: 0.25, maxLife: 0.25,
                                        color: '#ff6644', size: 5, isScratch: true
                                    });
                                }
                                
                                // Green scratch particles on primary target (original effect)
                                for (let i = 0; i < 5; i++) {
                                    const scratchAngle = Math.random() * Math.PI * 2;
                                    particles.push({
                                        x: this.x + Math.cos(scratchAngle) * 8,
                                        y: this.y + Math.sin(scratchAngle) * 8,
                                        vx: Math.cos(scratchAngle) * 4,
                                        vy: Math.sin(scratchAngle) * 4,
                                        life: 0.5, maxLife: 0.5,
                                        color: '#39ff14', size: 4, isScratch: true
                                    });
                                }
                            }
                        }
                        
                        // Check for hits on leprechauns during pounce
                        for (const lep of leprechauns) {
                            if (lep.dead || this.hitEnemies.has(lep)) continue;
                            const dist = Math.hypot(lep.x - this.x, lep.y - this.y);
                            if (dist < lep.radius + 25) {
                                this.hitEnemies.add(lep);
                                const { damage, isCrit } = player.calcDamage(this.pounceDamage);
                                lep.takeDamage(damage, isCrit);
                                player.onDealDamage(damage);
                                
                                // Particles
                                for (let i = 0; i < 5; i++) {
                                    const scratchAngle = Math.random() * Math.PI * 2;
                                    particles.push({
                                        x: this.x + Math.cos(scratchAngle) * 8,
                                        y: this.y + Math.sin(scratchAngle) * 8,
                                        vx: Math.cos(scratchAngle) * 4,
                                        vy: Math.sin(scratchAngle) * 4,
                                        life: 0.5, maxLife: 0.5,
                                        color: '#ffd700', size: 4, isScratch: true
                                    });
                                }
                            }
                        }
                        
                        // Check for hits on bosses during pounce
                        for (const boss of bosses) {
                            if (boss.dead || this.hitEnemies.has(boss)) continue;
                            const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                            if (dist < boss.radius + 25) {
                                this.hitEnemies.add(boss);
                                const { damage, isCrit } = player.calcDamage(this.pounceDamage);
                                boss.takeDamage(damage, isCrit);
                                player.onDealDamage(damage);
                                
                                // Particles
                                for (let i = 0; i < 5; i++) {
                                    const scratchAngle = Math.random() * Math.PI * 2;
                                    particles.push({
                                        x: this.x + Math.cos(scratchAngle) * 8,
                                        y: this.y + Math.sin(scratchAngle) * 8,
                                        vx: Math.cos(scratchAngle) * 4,
                                        vy: Math.sin(scratchAngle) * 4,
                                        life: 0.5, maxLife: 0.5,
                                        color: boss.color || '#ff0000', size: 4, isScratch: true
                                    });
                                }
                            }
                        }
                        
                        // End pounce when we reach target position OR hit max distance (safety)
                        if (distToTarget < 20 || distFromStart >= this.maxDist) {
                            // Look for next enemy to pounce
                            const seekDist = 218;
                            let nextEnemy = null;
                            let closestDist = seekDist;
                            
                            for (const enemy of enemies) {
                                if (enemy.dead) continue;
                                const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    nextEnemy = enemy;
                                }
                            }
                            // Check leprechauns (high priority)
                            for (const lep of leprechauns) {
                                if (lep.dead) continue;
                                const dist = Math.hypot(lep.x - this.x, lep.y - this.y);
                                if (dist < closestDist * 0.7) { // Prefer leprechauns
                                    closestDist = dist;
                                    nextEnemy = lep;
                                }
                            }
                            // Check bosses (high priority)
                            for (const boss of bosses) {
                                if (boss.dead) continue;
                                const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                                if (dist < closestDist * 0.8) { // Prefer bosses
                                    closestDist = dist;
                                    nextEnemy = boss;
                                }
                            }
                            
                            if (nextEnemy && (now - this.lastPounce > this.pounceCooldown * 0.3)) {
                                // Pause briefly before chain pounce
                                this.squirrelState = 'resting';
                                this.restStart = now;
                                this.restDuration = 250; // 250ms pause
                                this.nextPounceTarget = nextEnemy;
                            } else {
                                // No enemy - return to leash position
                                this.squirrelState = 'returning';
                            }
                        }
                    }
                    
                    // === RESTING STATE (brief pause before next pounce) ===
                    else if (this.squirrelState === 'resting') {
                        this.pouncePhase = 0;
                        // Stay still
                        this.vx *= 0.8;
                        this.vy *= 0.8;
                        
                        if (now - this.restStart >= this.restDuration) {
                            // Check if target still valid
                            if (this.nextPounceTarget && !this.nextPounceTarget.dead) {
                                // Chain to next enemy
                                this.squirrelState = 'winding';
                                this.windStart = now;
                                this.pounceTargetRef = this.nextPounceTarget;
                                this.pounceTarget = { x: this.nextPounceTarget.x, y: this.nextPounceTarget.y };
                                this.startX = this.x;
                                this.startY = this.y;
                                this.hitEnemies.clear();
                            } else {
                                // Target died, return to player
                                this.squirrelState = 'returning';
                            }
                            this.nextPounceTarget = null;
                        }
                    }
                    else if (this.squirrelState === 'returning') {
                        this.pouncePhase = 0;
                        const idealDist = 73;
                        const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                        
                        // Calculate target position at ideal distance from player
                        let targetX, targetY;
                        if (distToPlayer < idealDist * 0.5) {
                            // Too close to player - move away to ideal distance
                            const awayAngle = Math.atan2(this.y - player.y, this.x - player.x);
                            targetX = player.x + Math.cos(awayAngle) * idealDist;
                            targetY = player.y + Math.sin(awayAngle) * idealDist;
                        } else if (distToPlayer > idealDist * 1.5) {
                            // Too far - move toward player
                            targetX = player.x;
                            targetY = player.y;
                        } else {
                            // Within acceptable range - transition to walking
                            this.squirrelState = 'walking';
                            this.lastPounce = now;
                            this.hitEnemies.clear();
                            this.damage = this.walkDamage;
                            targetX = this.x;
                            targetY = this.y;
                        }
                        
                        const toTarget = Math.atan2(targetY - this.y, targetX - this.x);
                        const returnSpeed = 4.0;
                        this.vx = Math.cos(toTarget) * returnSpeed;
                        this.vy = Math.sin(toTarget) * returnSpeed;
                        
                        // Check if reached target
                        if (Math.hypot(targetX - this.x, targetY - this.y) < 30) {
                            this.squirrelState = 'walking';
                            this.lastPounce = now;
                            this.hitEnemies.clear();
                            this.damage = this.walkDamage;
                        }
                    }
                    
                    // Apply movement for pet squirrel (critical - was missing!)
                    this.x += this.vx * dtScale;
                    this.y += this.vy * dtScale;
                    
                    // Don't continue to regular projectile logic
                    return;
                }
                
                // Regular squirrel projectile (legacy, shouldn't occur)
                else if (this.isSquirrel && !this.isPetSquirrel) {
                    this.dead = true;
                    return;
                }
                
                // Boomerang: outward then return to player
                else if (this.type === 'boomerang') {
                    this.spinAngle += 0.3 * dtScale;
                    const distFromStart = Math.hypot(this.x - this.startX, this.y - this.startY);
                    
                    if (!this.returning && distFromStart >= this.maxDist) {
                        this.returning = true;
                        this.hitEnemies.clear();
                    }
                    
                    if (this.returning) {
                        const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                        this.vx = Math.cos(toPlayer) * this.speed * 1.3;
                        this.vy = Math.sin(toPlayer) * this.speed * 1.3;
                        
                        if (Math.hypot(player.x - this.x, player.y - this.y) < 30) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                // Spirit Orbs: smooth homing (the ONLY homing projectile)
                else if (this.isHoming) {
                    let nearestEnemy = null;
                    let nearestDist = 300;
                    
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    }
                    
                    for (const boss of bosses) {
                        if (boss.dead) continue;
                        const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = boss;
                        }
                    }
                    
                    if (nearestEnemy) {
                        const targetAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                        const currentAngle = Math.atan2(this.vy, this.vx);
                        let angleDiff = targetAngle - currentAngle;
                        
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        // Smooth, consistent turn rate
                        const turnRate = 0.08;
                        const turn = Math.max(-turnRate, Math.min(turnRate, angleDiff));
                        const newAngle = currentAngle + turn;
                        
                        this.vx = Math.cos(newAngle) * this.speed;
                        this.vy = Math.sin(newAngle) * this.speed;
                    }
                }
                
                // Ice shards: home only on initial target, then fly straight
                else if (this.type === 'ice' && this.iceTarget && !this.iceTarget.dead) {
                    const dist = Math.hypot(this.iceTarget.x - this.x, this.iceTarget.y - this.y);
                    
                    // Only home while within range of initial target
                    if (dist < 200) {
                        const targetAngle = Math.atan2(this.iceTarget.y - this.y, this.iceTarget.x - this.x);
                        const currentAngle = Math.atan2(this.vy, this.vx);
                        let angleDiff = targetAngle - currentAngle;
                        
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        // Gentle turn rate - just a nudge
                        const turnRate = 0.04;
                        const turn = Math.max(-turnRate, Math.min(turnRate, angleDiff));
                        const newAngle = currentAngle + turn;
                        
                        this.vx = Math.cos(newAngle) * this.speed;
                        this.vy = Math.sin(newAngle) * this.speed;
                    }
                }
                
                // ALL OTHER PROJECTILES: fly straight (no homing!)
                // This is intentional - clean, predictable trajectories
                
                // Movement
                this.x += this.vx * dtScale;
                this.y += this.vy * dtScale;
                
                // Check collision with enemies
                for (const enemy of enemies) {
                    if (enemy.dead || this.hitEnemies.has(enemy)) continue;
                    
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < enemy.radius + this.radius) {
                        this.hitEnemies.add(enemy);
                        
                        const { damage, isCrit } = player.calcDamage(this.damage);
                        enemy.takeDamage(damage, isCrit);
                        player.onDealDamage(damage);
                        applyStatusEffects(enemy, damage);
                        
                        // Ice slow effect
                        if (this.type === 'ice' && this.slowAmount) {
                            enemy.slowMult = this.slowAmount;
                            enemy.slowUntil = Date.now() + this.slowDuration;
                        }
                        
                        this.pierce--;
                        spawnParticles(this.x, this.y, this.color, 3);
                        
                        // Squirrel scratch effect - lime green claw marks
                        if (this.isSquirrel) {
                            for (let i = 0; i < 4; i++) {
                                const scratchAngle = Math.random() * Math.PI * 2;
                                const scratchDist = 5 + Math.random() * 10;
                                particles.push({
                                    x: this.x + Math.cos(scratchAngle) * scratchDist,
                                    y: this.y + Math.sin(scratchAngle) * scratchDist,
                                    vx: Math.cos(scratchAngle) * (2 + Math.random() * 3),
                                    vy: Math.sin(scratchAngle) * (2 + Math.random() * 3),
                                    life: 0.4 + Math.random() * 0.3,
                                    maxLife: 0.7,
                                    color: '#39ff14',
                                    size: 3 + Math.random() * 4,
                                    isScratch: true
                                });
                            }
                        }
                        
                        if (this.pierce <= 0) {
                            // Ricochet disc - bounce to next enemy instead of dying
                            if (this.type === 'disc' && this.bouncesLeft > 0) {
                                this.bouncesLeft--;
                                let nextTarget = null;
                                let closestDist = this.bounceRange;
                                
                                for (const e of enemies) {
                                    if (e.dead || this.hitEnemies.has(e)) continue;
                                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                                    if (d < closestDist) {
                                        closestDist = d;
                                        nextTarget = e;
                                    }
                                }
                                
                                // Also check bosses
                                for (const b of bosses) {
                                    if (b.dead || this.hitEnemies.has(b)) continue;
                                    const d = Math.hypot(b.x - this.x, b.y - this.y);
                                    if (d < closestDist) {
                                        closestDist = d;
                                        nextTarget = b;
                                    }
                                }
                                
                                if (nextTarget) {
                                    const angle = Math.atan2(nextTarget.y - this.y, nextTarget.x - this.x);
                                    this.vx = Math.cos(angle) * 5.5;
                                    this.vy = Math.sin(angle) * 5.5;
                                    this.angle = angle;
                                    this.pierce = 1; // Reset pierce for next hit
                                    spawnParticles(this.x, this.y, '#ff66aa', 5);
                                } else {
                                    this.dead = true;
                                    return;
                                }
                            } else {
                                this.dead = true;
                                return;
                            }
                        }
                    }
                }
                
                // Check collision with leprechauns
                for (const leprechaun of leprechauns) {
                    if (leprechaun.dead || this.hitEnemies.has(leprechaun)) continue;
                    
                    const dist = Math.hypot(leprechaun.x - this.x, leprechaun.y - this.y);
                    if (dist < leprechaun.radius + this.radius) {
                        this.hitEnemies.add(leprechaun);
                        
                        const { damage, isCrit } = player.calcDamage(this.damage);
                        leprechaun.takeDamage(damage, isCrit);
                        player.onDealDamage(damage);
                        this.pierce--;
                        spawnParticles(this.x, this.y, COLORS.gold, 3);
                        if (this.pierce <= 0) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                // Check collision with bosses
                for (const boss of bosses) {
                    if (boss.dead || this.hitEnemies.has(boss)) continue;
                    
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist < boss.radius + this.radius) {
                        this.hitEnemies.add(boss);
                        
                        const { damage, isCrit } = player.calcDamage(this.damage);
                        boss.takeDamage(damage, isCrit);
                        player.onDealDamage(damage);
                        this.pierce--;
                        spawnParticles(this.x, this.y, boss.color, 3);
                        if (this.pierce <= 0) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                // Out of bounds (world) - except boomerangs, squirrels, and gravity wells which have special handling
                if (this.type !== 'boomerang' && !this.isSquirrel && !this.isGravityWell) {
                    if (this.x < -20 || this.x > WORLD.width + 20 ||
                        this.y < -20 || this.y > WORLD.height + 20) {
                        this.dead = true;
                    }
                }
                
                // Gravity well projectile out of bounds failsafe - spawn well at edge
                if (this.isGravityWell) {
                    if (this.x < 0 || this.x > WORLD.width ||
                        this.y < 0 || this.y > WORLD.height) {
                        // Clamp to world bounds and spawn well
                        this.x = Math.max(50, Math.min(WORLD.width - 50, this.x));
                        this.y = Math.max(50, Math.min(WORLD.height - 50, this.y));
                        
                        const now = Date.now();
                        if (!this.weaponState.wells) this.weaponState.wells = [];
                        
                        this.weaponState.wells.push({
                            x: this.x,
                            y: this.y,
                            damage: this.wellDamage,
                            pullRadius: this.pullRadius,
                            visualRadius: this.visualRadius,
                            pullStrength: this.pullStrength,
                            startTime: now,
                            duration: this.wellDuration,
                            lastTick: now,
                            tickRate: this.tickRate
                        });
                        
                        spawnParticles(this.x, this.y, '#6600cc', 8);
                        this.dead = true;
                    }
                }
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                if (this.alpha <= 0) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.shadowBlur = 10 * this.alpha;
                ctx.shadowColor = this.color;
                
                // Trail (skip for boomerang and disc types, special handling for bolt)
                if (this.type === 'bolt') {
                    // Electric bolt with lightning trail
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6 * this.alpha;
                    ctx.beginPath();
                    let prevX = sx, prevY = sy;
                    for (let i = this.trail.length - 1; i >= 0; i--) {
                        const t = this.trail[i];
                        const tsx = camera.screenX(t.x);
                        const tsy = camera.screenY(t.y);
                        // Add slight zigzag for electric effect
                        const jitter = (i % 2 === 0 ? 1 : -1) * 2;
                        const midX = (prevX + tsx) / 2 + jitter;
                        const midY = (prevY + tsy) / 2 + jitter;
                        if (i === this.trail.length - 1) {
                            ctx.moveTo(sx, sy);
                        }
                        ctx.lineTo(midX, midY);
                        ctx.lineTo(tsx, tsy);
                        prevX = tsx;
                        prevY = tsy;
                    }
                    ctx.stroke();
                    ctx.globalAlpha = this.alpha;
                    
                    // Electric core glow
                    ctx.shadowBlur = 15 * this.alpha;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(sx, sy, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(sx, sy, r, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Electric sparks
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.8 * this.alpha;
                    const sparks = 4;
                    const angle = Math.atan2(this.vy, this.vx);
                    for (let i = 0; i < sparks; i++) {
                        const sparkAngle = angle + Math.PI + (Math.random() - 0.5) * 1.5;
                        const sparkLen = r * (1 + Math.random() * 1.5);
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(
                            sx + Math.cos(sparkAngle) * sparkLen,
                            sy + Math.sin(sparkAngle) * sparkLen
                        );
                        ctx.stroke();
                    }
                    ctx.globalAlpha = this.alpha;
                } else if (this.type !== 'boomerang' && this.type !== 'laser' && this.type !== 'disc' && this.type !== 'gravitywell') {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.type === 'laser' ? 3 : this.type === 'boomerang' ? 2.5 : 2;
                    ctx.globalAlpha = 0.5 * this.alpha;
                    ctx.beginPath();
                    for (let i = 0; i < this.trail.length; i++) {
                        const t = this.trail[i];
                        const tsx = camera.screenX(t.x);
                        const tsy = camera.screenY(t.y);
                        if (i === 0) ctx.moveTo(tsx, tsy);
                        else ctx.lineTo(tsx, tsy);
                    }
                    ctx.lineTo(sx, sy);
                    ctx.stroke();
                    ctx.globalAlpha = this.alpha;
                }
                
                ctx.fillStyle = this.color;
                
                // Different shapes for different projectile types
                if (this.type === 'dagger') {
                    // Diamond/dagger shape
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.translate(sx, sy);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(r * 1.5, 0);
                    ctx.lineTo(0, r * 0.5);
                    ctx.lineTo(-r * 0.5, 0);
                    ctx.lineTo(0, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'boomerang') {
                    // Classic curved boomerang shape
                    ctx.translate(sx, sy);
                    ctx.rotate(this.spinAngle);
                    ctx.beginPath();
                    // Draw a curved V-shape boomerang
                    const armLen = r * 1.6;
                    const thickness = r * 0.4;
                    // Left arm (curved)
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(-armLen * 0.3, -armLen * 0.5, -armLen * 0.7, -armLen * 0.85);
                    ctx.lineTo(-armLen * 0.55, -armLen * 0.75);
                    ctx.quadraticCurveTo(-armLen * 0.2, -armLen * 0.35, 0, -thickness);
                    // Right arm (curved)
                    ctx.quadraticCurveTo(armLen * 0.2, -armLen * 0.35, armLen * 0.55, -armLen * 0.75);
                    ctx.lineTo(armLen * 0.7, -armLen * 0.85);
                    ctx.quadraticCurveTo(armLen * 0.3, -armLen * 0.5, 0, 0);
                    ctx.closePath();
                    ctx.fill();
                    // Add a center stripe for detail
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-armLen * 0.4, -armLen * 0.5);
                    ctx.quadraticCurveTo(0, -thickness * 0.5, armLen * 0.4, -armLen * 0.5);
                    ctx.stroke();
                } else if (this.type === 'squirrel' || this.isSquirrel) {
                    // Animated pet squirrel sprite
                    ctx.translate(sx, sy);
                    
                    // Calculate facing direction with hysteresis to prevent flip-flopping
                    // Only change direction if horizontal velocity exceeds threshold
                    const horizontalThreshold = 0.3;
                    if (!this.lastFlip) this.lastFlip = -1;
                    
                    if (this.vx > horizontalThreshold) {
                        this.lastFlip = -1; // Face right
                    } else if (this.vx < -horizontalThreshold) {
                        this.lastFlip = 1; // Face left
                    }
                    // If vx is between -threshold and +threshold, keep lastFlip unchanged
                    
                    const flip = this.lastFlip;
                    
                    // Apply wobble for rabid effect (very smooth when walking, visible when pouncing)
                    const wobbleMult = this.squirrelState === 'pouncing' ? 2.0 : 
                                       this.squirrelState === 'walking' ? 0.05 : 0.15;
                    const wobbleX = Math.sin(this.wobble * 3) * 2 * wobbleMult;
                    const wobbleY = Math.cos(this.wobble * 4) * 1.5 * wobbleMult;
                    ctx.translate(wobbleX, wobbleY);
                    
                    // Walking bob (subtle bounce when moving)
                    const walkSpeed = Math.hypot(this.vx, this.vy);
                    if (this.walkBob && walkSpeed > 0.5 && (this.squirrelState === 'walking' || this.squirrelState === 'returning')) {
                        const bobY = Math.abs(Math.sin(this.walkBob * 2)) * 2.5;
                        ctx.translate(0, -bobY);
                    }
                    
                    // Size: 10% bigger than half (r * 2.8 * 1.1 = r * 3.08)
                    const baseSize = r * 3.08;
                    let scaleX = flip;
                    let scaleY = 1;
                    
                    const state = this.squirrelState || 'walking';
                    const phase = this.pouncePhase || 0;
                    
                    // Walking squish (alternating leg compression)
                    if ((state === 'walking' || state === 'returning') && walkSpeed > 0.5) {
                        const walkCycle = Math.sin(this.walkBob * 2);
                        scaleY = 1 - Math.abs(walkCycle) * 0.08;
                        scaleX = flip * (1 + Math.abs(walkCycle) * 0.05);
                    }
                    
                    if (state === 'winding') {
                        // Crouch down before pounce
                        scaleY = 1 - phase * 0.35;
                        scaleX = flip * (1 + phase * 0.25);
                        ctx.translate(0, baseSize * phase * 0.12);
                    } else if (state === 'pouncing') {
                        // Stretched for speed - dramatic pounce pose
                        scaleX = flip * 1.3;
                        scaleY = 0.75;
                    }
                    // Walking and returning states use walk cycle animation (set above)
                    
                    ctx.scale(scaleX, scaleY);
                    
                    // Neon glow effect
                    ctx.shadowColor = '#39ff14';
                    ctx.shadowBlur = state === 'pouncing' ? 25 : state === 'winding' ? 15 : 10;
                    
                    // Draw the sprite
                    if (squirrelSprites.loaded) {
                        let sprite;
                        if (state === 'pouncing') {
                            // Attack animation when pouncing
                            sprite = squirrelSprites.attack[this.animFrame % 3];
                        } else {
                            // Breathing animation for walking/winding/returning
                            sprite = squirrelSprites.breathe[this.animFrame % 2];
                        }
                        if (sprite) {
                            ctx.drawImage(sprite, -baseSize/2, -baseSize/2, baseSize, baseSize);
                        }
                    } else {
                        // Fallback
                        ctx.fillStyle = '#39ff14';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, r * 1.32, r * 0.88, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                } else if (this.type === 'ice') {
                    // Snowflake/crystal shape
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.translate(sx, sy);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI * 2 / 6) * i;
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * r * 1.2, Math.sin(a) * r * 1.2);
                    }
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'homing') {
                    // Ghostly orb with wispy trail effect
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(sx, sy, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(sx - r * 0.3, sy - r * 0.3, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (this.type === 'arrow') {
                    // Arrow shape with spectral trail
                    const angle = Math.atan2(this.vy, this.vx);
                    
                    // Draw trail effect
                    if (this.trailPoints && this.trailPoints.length > 1) {
                        ctx.globalAlpha = 0.4;
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        for (let i = 0; i < this.trailPoints.length; i++) {
                            const p = this.trailPoints[i];
                            const tsx = camera.screenX(p.x);
                            const tsy = camera.screenY(p.y);
                            if (i === 0) ctx.moveTo(tsx, tsy);
                            else ctx.lineTo(tsx, tsy);
                        }
                        ctx.lineTo(sx, sy);
                        ctx.stroke();
                        ctx.globalAlpha = this.alpha;
                    }
                    
                    // Arrow head
                    ctx.translate(sx, sy);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(r * 2, 0);
                    ctx.lineTo(-r, r * 0.6);
                    ctx.lineTo(-r * 0.3, 0);
                    ctx.lineTo(-r, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Arrow shaft
                    ctx.fillRect(-r * 1.5, -r * 0.15, r * 1.2, r * 0.3);
                } else if (this.type === 'disc') {
                    // Spinning disc
                    const spin = Date.now() * 0.01;
                    ctx.translate(sx, sy);
                    ctx.rotate(spin);
                    
                    // Outer ring
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner design
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Radial lines
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const a = (Math.PI / 2) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(a) * r * 0.5, Math.sin(a) * r * 0.5);
                        ctx.lineTo(Math.cos(a) * r * 0.9, Math.sin(a) * r * 0.9);
                        ctx.stroke();
                    }
                } else if (this.type === 'gravitywell') {
                    // Mini black hole projectile
                    const spin = Date.now() * 0.008;
                    const now = Date.now();
                    
                    // Swirling debris particles
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = '#9933ff';
                    for (let i = 0; i < 6; i++) {
                        const angle = spin + (i / 6) * Math.PI * 2;
                        const spiralR = r * (0.6 + 0.3 * Math.sin(spin * 2 + i));
                        const px = sx + Math.cos(angle) * spiralR;
                        const py = sy + Math.sin(angle) * spiralR;
                        ctx.fillStyle = `rgba(153, 51, 255, ${0.5 + Math.sin(i + spin) * 0.2})`;
                        ctx.beginPath();
                        ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Spiral arms
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#6600cc';
                    for (let arm = 0; arm < 2; arm++) {
                        const armOffset = (arm / 2) * Math.PI * 2;
                        ctx.strokeStyle = `rgba(102, 0, 204, 0.7)`;
                        ctx.beginPath();
                        for (let t = 0; t < 1; t += 0.1) {
                            const angle = spin + armOffset + t * Math.PI * 1.5;
                            const spiralR = r * 0.2 + r * 0.6 * t;
                            const px = sx + Math.cos(angle) * spiralR;
                            const py = sy + Math.sin(angle) * spiralR;
                            if (t === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                    }
                    
                    // Inner vortex
                    const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, r * 0.5);
                    grad.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
                    grad.addColorStop(0.6, 'rgba(30, 0, 60, 0.6)');
                    grad.addColorStop(1, 'rgba(102, 0, 204, 0.3)');
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(sx, sy, r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Dark center
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(sx, sy, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'bolt') {
                    // Already drawn above with electric effect
                } else {
                    // Default circle
                    ctx.beginPath();
                    ctx.arc(sx, sy, r, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // ===== XP GEM CLASS =====
        class XPGem {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.radius = 3 + value * 0.5;
                this.color = COLORS.cyan;  // Cyan color matching player
                this.pulse = 0;
                this.magnetized = false;
                this.magnetStrength = 6; // Reduced from 12 for smoother vacuum
            }

            update(dt = 16) {
                const dtScale = dt / 16;
                this.pulse += 0.1 * dtScale;
                
                // Magnet toward player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                // Individual magnetization (from boss kill or magnet pickup)
                if (this.magnetized && dist > 1) {
                    // Slower pull that scales with distance to prevent overwhelming the player
                    const pullSpeed = Math.min(this.magnetStrength, 4 + dist * 0.02);
                    this.x += (dx / dist) * pullSpeed * dtScale;
                    this.y += (dy / dist) * pullSpeed * dtScale;
                }
                // During magnet pulse, pull ALL gems rapidly
                else if (magnetPulseActive && dist > 1) {
                    const speed = 10; // Slightly reduced from 12
                    this.x += (dx / dist) * speed * dtScale;
                    this.y += (dy / dist) * speed * dtScale;
                }
                // Normal magnet behavior within pickup range
                else if (dist > 1 && dist < player.pickupRange) {
                    const speed = 5 * (1 - dist / player.pickupRange) + 1;
                    this.x += (dx / dist) * speed * dtScale;
                    this.y += (dy / dist) * speed * dtScale;
                }
                
                // Collect
                if (dist < player.radius + this.radius) {
                    player.gainXP(this.value);
                    
                    // Gold from collecting orbs (based on XP value)
                    const goldDrop = Math.max(1, Math.floor(this.value / 2));
                    playerGold += goldDrop;
                    updateGoldDisplay();
                    
                    this.dead = true;
                }
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                const glow = 10 + Math.sin(this.pulse) * 4;
                ctx.shadowBlur = glow;
                ctx.shadowColor = COLORS.cyan;
                
                // Cyan gem circle
                ctx.fillStyle = COLORS.cyan;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner shine (white core)
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(sx - r * 0.25, sy - r * 0.25, r * 0.35, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // ===== SHRINE CLASS =====
        class Shrine {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 195;      // Outer ring (15% smaller)
                this.innerRadius = 187; // Inner ring - almost same size
                this.chargeTime = 0;
                this.chargeRequired = 5000;
                this.activated = false;
                this.pulse = Math.random() * Math.PI * 2;
                this.color = COLORS.shrine; // Neon purple
            }

            update(dt) {
                if (this.activated) return;
                
                this.pulse += dt * 0.002;
                
                // Check if player is inside
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                
                if (dist < this.innerRadius) {
                    this.chargeTime += dt;
                    
                    // Update charge bar (using DOM cache)
                    DOM.shrineChargeBar.classList.add('active');
                    DOM.shrineChargeFill.style.width = `${(this.chargeTime / this.chargeRequired) * 100}%`;
                    
                    // Spawn particles while charging
                    if (Math.random() < 0.1) {
                        const angle = Math.random() * Math.PI * 2;
                        const pr = this.radius + 10;
                        spawnParticles(
                            this.x + Math.cos(angle) * pr,
                            this.y + Math.sin(angle) * pr,
                            this.color, 1
                        );
                    }
                    
                    if (this.chargeTime >= this.chargeRequired) {
                        this.activate();
                    }
                } else {
                    // Decay charge when player leaves
                    this.chargeTime = Math.max(0, this.chargeTime - dt * 0.5);
                    
                    if (this.chargeTime === 0) {
                        DOM.shrineChargeBar.classList.remove('active');
                    }
                }
            }

            activate() {
                this.activated = true;
                DOM.shrineChargeBar.classList.remove('active');
                
                // Burst particles
                spawnParticles(this.x, this.y, this.color, 30);
                spawnParticles(this.x, this.y, COLORS.cyan, 20);
                
                // Show shrine power-up selection
                showShrinePowerups();
            }

            draw() {
                if (!camera.isVisible(this.x, this.y, this.radius + 20)) return;
                if (this.activated) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const ir = camera.scale(this.innerRadius);
                
                ctx.save();
                
                // Outer glow ring
                const glowIntensity = 0.3 + Math.sin(this.pulse) * 0.15;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = glowIntensity;
                
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner ring
                ctx.lineWidth = 2;
                ctx.globalAlpha = glowIntensity * 0.7;
                ctx.beginPath();
                ctx.arc(sx, sy, ir, 0, Math.PI * 2);
                ctx.stroke();
                
                // Charge progress arc
                if (this.chargeTime > 0) {
                    const progress = this.chargeTime / this.chargeRequired;
                    ctx.strokeStyle = COLORS.cyan;
                    ctx.lineWidth = 6;
                    ctx.shadowColor = COLORS.cyan;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(sx, sy, r - camera.scale(5), -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                    ctx.stroke();
                }
                
                // Center symbol
                ctx.globalAlpha = glowIntensity;
                ctx.fillStyle = this.color;
                ctx.font = `${camera.scale(20)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('✨', sx, sy);
                
                ctx.restore();
            }
        }

        // ===== SHRINE POWER-UP SYSTEM =====
        let shrineSlotResults = [];
        
        function showShrinePowerups() {
            gamePaused = true;
            
            // Create flash effect
            const flash = document.createElement('div');
            flash.className = 'shrine-flash';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 600);
            
            DOM.shrineOverlay.classList.add('active');
            DOM.slotMachine.innerHTML = '';
            DOM.slotMachine.style.display = 'none';
            DOM.shrineOptions.innerHTML = '';
            
            // Pick 3 random powerups
            const powerupKeys = Object.keys(SHRINE_POWERUPS);
            const shuffled = powerupKeys.sort(() => Math.random() - 0.5).slice(0, 3);
            shrineSlotResults = shuffled.map(key => ({ key, ...SHRINE_POWERUPS[key] }));
            
            // Skip slot animation, show cards directly
            showShrineCards();
        }
        
        function showShrineCards() {
            // Hide slot machine completely
            DOM.slotMachine.style.display = 'none';
            DOM.slotMachine.style.visibility = 'hidden';
            DOM.slotMachine.innerHTML = '';
            
            DOM.shrineOptions.innerHTML = '';
            
            shrineSlotResults.forEach((powerup, i) => {
                const card = document.createElement('div');
                card.className = 'shrine-card revealed';
                card.style.borderColor = powerup.color;
                card.style.cursor = 'pointer';
                
                card.innerHTML = `
                    <div class="icon">${powerup.icon}</div>
                    <div class="name" style="color: ${powerup.color}; text-shadow: 0 0 8px ${powerup.color};">${powerup.name}</div>
                    <div class="value">${powerup.desc}</div>
                `;
                
                // Use onclick directly
                card.onclick = function(e) {
                    selectShrinePowerup(powerup);
                };
                
                card.ontouchend = function(e) {
                    e.preventDefault();
                    selectShrinePowerup(powerup);
                };
                
                DOM.shrineOptions.appendChild(card);
            });
        }
        
        function selectShrinePowerup(powerup) {
            player.addShrineBonus(powerup.stat, powerup.value);
            
            // Add closing animation
            DOM.shrineOverlay.classList.add('closing');
            
            // Highlight selected card
            const cards = DOM.shrineOptions.querySelectorAll('.shrine-card');
            cards.forEach(card => {
                if (card.querySelector('.name').textContent === powerup.name) {
                    card.style.transform = 'scale(1.1)';
                    card.style.boxShadow = `0 0 40px ${powerup.color}`;
                } else {
                    card.style.opacity = '0.3';
                    card.style.transform = 'scale(0.95)';
                }
            });
            
            // Delay removal for animation
            setTimeout(() => {
                DOM.shrineOverlay.classList.remove('active');
                DOM.shrineOverlay.classList.remove('closing');
                gamePaused = false;
                
                // Update buffs bar display
                updateBuffsBar();
                
                // Visual feedback
                spawnParticles(player.x, player.y, powerup.color, 20);
            }, 400);
        }
        
        // ===== SHRINE SPAWNING =====
        const SHRINE_CONFIG = {
            maxActive: 8,           // Max shrines active at once (scaled for 4x area)
            spawnInterval: 12000,   // Spawn new shrine every 12 seconds
            initialDelay: 5000,     // Wait 5 seconds before first shrine
            minDist: 900,           // Minimum distance between shrines (scaled)
            idealDist: 2000,        // Ideal distance between shrines (scaled)
            edgeBuffer: 500,        // Distance from world edges
            exceptionChance: 0.12   // 12% chance to allow closer placement
        };
        
        let shrineSpawnTimer = 0;
        let shrineInitialDelay = true;
        
        function getActiveShrineCount() {
            return shrines.filter(s => !s.activated).length;
        }
        
        function spawnSingleShrine() {
            const candidateCount = 8; // Increased to account for terrain
            let bestCandidate = null;
            let bestScore = -Infinity;
            
            // Get only active (non-activated) shrines for distance checks
            const activeShrines = shrines.filter(s => !s.activated);
            
            // Generate multiple candidate positions and pick the best one
            for (let c = 0; c < candidateCount; c++) {
                const x = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.width - SHRINE_CONFIG.edgeBuffer * 2);
                const y = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.height - SHRINE_CONFIG.edgeBuffer * 2);
                
                // Skip if in terrain (shrines need large clear area)
                if (isInTerrain(x, y, 250)) continue;
                
                // Skip if any part of shrine would be in a lake (shrine radius is 195)
                if (isInLake(x, y, 220)) continue;
                
                // Calculate score based on distances to existing active shrines
                let minDistToShrine = Infinity;
                let totalDistScore = 0;
                
                for (const shrine of activeShrines) {
                    const dist = Math.hypot(shrine.x - x, shrine.y - y);
                    minDistToShrine = Math.min(minDistToShrine, dist);
                    
                    if (dist < SHRINE_CONFIG.idealDist) {
                        totalDistScore += dist / SHRINE_CONFIG.idealDist;
                    } else {
                        totalDistScore += 1 - (dist - SHRINE_CONFIG.idealDist) / (WORLD.width * 0.5) * 0.3;
                    }
                }
                
                // Check distance from player (spawn far from player)
                const playerDist = Math.hypot(player.x - x, player.y - y);
                if (playerDist < 800) continue; // Don't spawn too close to player
                
                // Don't spawn in player's visible view
                if (isInPlayerView(x, y, 100)) continue;
                
                // Determine if this candidate is valid
                let isValid = true;
                
                if (activeShrines.length > 0) {
                    const allowException = Math.random() < SHRINE_CONFIG.exceptionChance;
                    const effectiveMinDist = allowException ? SHRINE_CONFIG.minDist * 0.5 : SHRINE_CONFIG.minDist;
                    
                    if (minDistToShrine < effectiveMinDist) {
                        isValid = false;
                    }
                }
                
                if (!isValid) continue;
                
                // Calculate final score - prefer spawning farther from player
                const nearestScore = activeShrines.length > 0 
                    ? Math.min(minDistToShrine / SHRINE_CONFIG.idealDist, 1.5) 
                    : 1;
                const avgScore = activeShrines.length > 0 
                    ? totalDistScore / activeShrines.length 
                    : 1;
                const playerDistBonus = Math.min(playerDist / 1200, 1);
                
                const randomFactor = 0.9 + Math.random() * 0.2;
                const score = (nearestScore * 0.5 + avgScore * 0.2 + playerDistBonus * 0.3) * randomFactor;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestCandidate = { x, y };
                }
            }
            
            // Fallback if no valid candidate found
            if (!bestCandidate) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const x = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.width - SHRINE_CONFIG.edgeBuffer * 2);
                    const y = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.height - SHRINE_CONFIG.edgeBuffer * 2);
                    
                    // Skip if in lake
                    if (isInLake(x, y, 220)) continue;
                    
                    let tooClose = false;
                    for (const shrine of activeShrines) {
                        if (Math.hypot(shrine.x - x, shrine.y - y) < SHRINE_CONFIG.minDist * 0.4) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    const playerDist = Math.hypot(player.x - x, player.y - y);
                    if (!tooClose && playerDist >= 300 && !isInPlayerView(x, y, 100)) {
                        bestCandidate = { x, y };
                        break;
                    }
                }
            }
            
            if (bestCandidate) {
                shrines.push(new Shrine(bestCandidate.x, bestCandidate.y));
                return true;
            }
            return false;
        }
        
        function updateShrineSpawning(dt) {
            // Handle initial delay
            if (shrineInitialDelay) {
                shrineSpawnTimer += dt;
                if (shrineSpawnTimer >= SHRINE_CONFIG.initialDelay) {
                    shrineInitialDelay = false;
                    shrineSpawnTimer = 0;
                    spawnSingleShrine(); // Spawn first shrine
                }
                return;
            }
            
            // Check if we need more shrines
            const activeCount = getActiveShrineCount();
            if (activeCount >= SHRINE_CONFIG.maxActive) {
                shrineSpawnTimer = 0; // Reset timer when at max
                return;
            }
            
            // Spawn timer
            shrineSpawnTimer += dt;
            if (shrineSpawnTimer >= SHRINE_CONFIG.spawnInterval) {
                shrineSpawnTimer = 0;
                spawnSingleShrine();
            }
        }
        
        // Legacy function for compatibility - now just resets state
        function spawnShrines() {
            shrines = [];
            shrineSpawnTimer = 0;
            shrineInitialDelay = true;
        }

        // ===== PARTICLES & EFFECTS =====
        function spawnParticles(x, y, color, count) {
            // Early exit if at particle limit
            if (particles.length >= LIMITS.particles) return;
            
            // Reduce count if approaching limit
            const available = LIMITS.particles - particles.length;
            const actualCount = Math.min(count, available);
            
            for (let i = 0; i < actualCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2.5;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color,
                    life: 0.8 + Math.random() * 0.2,
                    size: 2 + Math.random() * 2
                });
            }
        }

        function spawnDamageNumber(x, y, damage, isCrit = false) {
            damageNumbers.push({
                x: x + (Math.random() - 0.5) * 20,
                y,
                damage,
                isCrit,
                life: 1,
                vy: isCrit ? -3 : -2,
                scale: isCrit ? 1.5 : 1
            });
        }

        // ===== HELPERS =====
        // Shot counter for alternating leprechaun targeting
        let shotCounter = 0;
        
        // Simple targeting - finds nearest living enemy within range
        function findNearestEnemy(x, y) {
            let nearest = null;
            let minDist = Infinity;
            
            // Fixed targeting range based on visible area
            const maxRange = SHARED_TARGETING_RANGE;
            
            // Every 3rd shot, prioritize leprechaun
            shotCounter++;
            if (shotCounter % 3 === 0) {
                for (const lep of leprechauns) {
                    if (lep.dead) continue;
                    const dist = Math.hypot(lep.x - x, lep.y - y);
                    if (dist < maxRange && dist < minDist) {
                        minDist = dist;
                        nearest = lep;
                    }
                }
                if (nearest) return nearest;
            }
            
            // Check regular enemies
            for (const enemy of enemies) {
                if (enemy.dead) continue;
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist < maxRange && dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }
            
            // Check leprechauns
            for (const lep of leprechauns) {
                if (lep.dead) continue;
                const dist = Math.hypot(lep.x - x, lep.y - y);
                if (dist < maxRange && dist < minDist) {
                    minDist = dist;
                    nearest = lep;
                }
            }
            
            // Check bosses
            for (const boss of bosses) {
                if (boss.dead) continue;
                const dist = Math.hypot(boss.x - x, boss.y - y);
                if (dist < maxRange && dist < minDist) {
                    minDist = dist;
                    nearest = boss;
                }
            }
            
            return nearest;
        }
        
        // Efficient in-place array cleanup (swap-and-pop)
        function cleanupArray(arr, shouldRemove) {
            for (let i = arr.length - 1; i >= 0; i--) {
                if (shouldRemove(arr[i])) {
                    arr[i] = arr[arr.length - 1];
                    arr.pop();
                }
            }
        }
        
        // Random sample without full shuffle (O(k) instead of O(n))
        function randomSample(arr, count) {
            const result = [];
            const indices = new Set();
            const max = Math.min(count, arr.length);
            while (result.length < max) {
                const idx = Math.floor(Math.random() * arr.length);
                if (!indices.has(idx)) {
                    indices.add(idx);
                    result.push(arr[idx]);
                }
            }
            return result;
        }
        
        // Generate lightning bolt segments (for lightning strike visual)
        function generateLightning(x1, y1, x2, y2) {
            const segments = [];
            const steps = 5; // Fewer segments for smoother look
            let px = x1, py = y1;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                // Reduced horizontal jag, alternating direction
                const jag = (i % 2 === 0 ? 1 : -1) * (Math.random() * 25 + 15) * (1 - t * 0.5);
                const nx = x1 + (x2 - x1) * t + jag;
                const ny = y1 + (y2 - y1) * t;
                segments.push({ x1: px, y1: py, x2: nx, y2: ny });
                px = nx; py = ny;
            }
            return segments;
        }

        // ===== SPAWNING =====
        let spawnTimer = 0;
        const spawnInterval = 3696; // Base spawn interval (5% slower)

        function spawnEnemies(dt) {
            spawnTimer += dt;
            
            // Spawn rate scales down over time
            // First minute: faster scaling (0.95 per second)
            // After 1 minute: slower scaling (0.63 per second) for more gradual difficulty increase
            let timeScale;
            if (gameTime < 60) {
                timeScale = gameTime * 0.95;
            } else {
                // First 60 seconds at 0.95 rate, then slower rate for remaining time
                timeScale = 60 * 0.95 + (gameTime - 60) * 0.63;
            }
            
            let currentInterval = Math.max(700, spawnInterval - timeScale);
            
            // SWARM EVENT: 1.5x spawn rate for 30 seconds before boss
            if (swarmActive) {
                currentInterval = currentInterval / 1.5;
            }
            
            // FINAL HORDE: 30 minutes (1800s) - spawn rate doubles every minute gradually
            const finalSwarmTime = 1800; // 30 minutes
            if (gameTime >= finalSwarmTime) {
                const secondsOver30Min = gameTime - finalSwarmTime;
                // Gradual doubling: every 60 seconds, spawn rate doubles
                // Using exponential decay: interval = base * 0.5^(minutes)
                const minutesOver = secondsOver30Min / 60;
                const multiplier = Math.pow(0.5, minutesOver);
                currentInterval = Math.max(150, currentInterval * multiplier);
                
                // Show warning once
                if (!finalSwarmWarningShown) {
                    showFinalSwarmWarning();
                }
            }
            
            if (spawnTimer >= currentInterval) {
                spawnTimer = 0;
                
                // Determine enemy type based on time
                const types = ['basic'];
                if (gameTime > 30) types.push('fast');
                if (gameTime > 60) types.push('tank');
                if (gameTime > 90) types.push('swarm', 'swarm');
                
                // SWARM EVENT: More swarm-type enemies
                if (swarmActive) {
                    types.push('swarm', 'swarm', 'fast');
                }
                
                // FINAL HORDE: 30 minutes+ heavily favors swarm enemies
                if (gameTime >= finalSwarmTime) {
                    types.push('swarm', 'swarm', 'swarm', 'fast');
                }
                
                // Spawn count increases over time: every 60s
                let count = 1 + Math.floor(gameTime / 60);
                
                // SWARM EVENT: +50% enemies per wave
                if (swarmActive) {
                    count = Math.ceil(count * 1.5);
                }
                
                // FINAL HORDE: 30 minutes+ spawns more enemies per wave
                if (gameTime >= finalSwarmTime) {
                    const secondsOver30Min = gameTime - finalSwarmTime;
                    count += Math.floor(secondsOver30Min / 20); // +1 enemy per 20 seconds over 30 min
                }
                
                for (let i = 0; i < count; i++) {
                    // Enforce enemy limit (raised for final horde)
                    const maxEnemies = (gameTime >= finalSwarmTime) ? LIMITS.enemies + 50 : LIMITS.enemies;
                    if (enemies.length >= maxEnemies) break;
                    
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    // Spawn well outside visible area (accounting for zoom)
                    let x, y, spawnAttempts = 0;
                    const visibleWidth = gameWidth / camera.zoom;
                    const visibleHeight = gameHeight / camera.zoom;
                    const spawnDist = Math.max(visibleWidth, visibleHeight) / 2 + 150;
                    
                    do {
                        const angle = Math.random() * Math.PI * 2;
                        x = player.x + Math.cos(angle) * spawnDist;
                        y = player.y + Math.sin(angle) * spawnDist;
                        
                        // Clamp to world bounds
                        x = Math.max(20, Math.min(WORLD.width - 20, x));
                        y = Math.max(20, Math.min(WORLD.height - 20, y));
                        spawnAttempts++;
                    } while ((isInTerrain(x, y, 30) || isInLake(x, y, 50) || isInPlayerView(x, y, 50)) && spawnAttempts < 15);
                    
                    enemies.push(new Enemy(type, x, y));
                }
            }
        }

        // ===== LEPRECHAUN SPAWNING =====
        function spawnLeprechaun() {
            // Spawn at a distance from player, avoiding terrain
            let potX, potY, attempts = 0;
            
            do {
                const angle = Math.random() * Math.PI * 2;
                const spawnDist = 400 + Math.random() * 200;
                
                potX = player.x + Math.cos(angle) * spawnDist;
                potY = player.y + Math.sin(angle) * spawnDist;
                
                // Clamp to world bounds
                potX = Math.max(150, Math.min(WORLD.width - 150, potX));
                potY = Math.max(150, Math.min(WORLD.height - 150, potY));
                attempts++;
            } while ((isInTerrain(potX, potY, 100) || isInLake(potX, potY, 120) || isInPlayerView(potX, potY, 50)) && attempts < 25);
            
            // Create rainbow/pot at spawn location
            const rainbow = new Rainbow(potX, potY);
            rainbows.push(rainbow);
            
            // Spawn leprechaun near the pot, guarding it
            const lepX = potX + 40;
            const lepY = potY;
            const lep = new Leprechaun(lepX, lepY, potX, potY);
            lep.linkedRainbow = rainbow;
            rainbow.linkedLeprechaun = lep;
            leprechauns.push(lep);
            
            // Flash notification
            showLeprechaunWarning();
        }

        function showLeprechaunWarning() {
            showStackedWarning({
                html: `<div style="font-size: 28px;">🌈 A rainbow appeared nearby! 🌈</div>`,
                color: COLORS.gold,
                textShadow: `0 0 20px ${COLORS.gold}, 0 0 40px ${COLORS.green}`,
                duration: 2000,
                priority: WARNING_PRIORITY.LEPRECHAUN
            });
        }

        function updateLeprechaunSpawning(dt) {
            // Never spawn during active swarm
            if (swarmActive) return;
            
            leprechaunSpawnTimer += dt;
            
            if (leprechaunSpawnTimer >= nextLeprechaunSpawn) {
                // Check if we're too close to next swarm (swarm starts 60s before boss)
                // We want to spawn 30s BEFORE swarm starts, so 90s before boss
                const bossInterval = 300; // 5 minutes
                const nextBossTime = Math.ceil(gameTime / bossInterval) * bossInterval;
                const swarmStartTime = nextBossTime - 60;
                const safeSpawnWindow = swarmStartTime - 30; // 30s before swarm
                
                // Only spawn if we're not within 30s of swarm starting
                if (gameTime < safeSpawnWindow || gameTime > swarmStartTime + 30) {
                    leprechaunSpawnTimer = 0;
                    nextLeprechaunSpawn = 120000; // 2 minutes between spawns after first
                    spawnLeprechaun();
                }
            }
        }
        
        // ===== QUEUED WARNING SYSTEM =====
        // Priority levels: higher = more important, shows first
        const WARNING_PRIORITY = {
            BOSS: 100,
            FINAL_SWARM: 95,
            SWARM: 90,
            CURSE: 60,
            LEPRECHAUN: 50,
            DEFAULT: 40
        };
        
        let activeWarning = null; // Currently displayed warning
        let warningQueue = []; // Queue of pending warnings
        let warningTimeout = null;
        
        function showStackedWarning(options) {
            // Add timestamp and default priority
            options.timestamp = Date.now();
            options.priority = options.priority || WARNING_PRIORITY.DEFAULT;
            
            // If upgrade menu is open, queue the warning for later
            if (DOM.upgradeOverlay && DOM.upgradeOverlay.classList.contains('active')) {
                warningQueue.push(options);
                sortWarningQueue();
                return;
            }
            
            // If a warning is already showing, queue this one
            if (activeWarning) {
                warningQueue.push(options);
                sortWarningQueue();
                return;
            }
            
            displayWarning(options);
        }
        
        function sortWarningQueue() {
            // Sort by priority (high to low), then by timestamp (old to new)
            warningQueue.sort((a, b) => {
                if (b.priority !== a.priority) {
                    return b.priority - a.priority;
                }
                return a.timestamp - b.timestamp;
            });
        }
        
        function displayWarning(options) {
            const warning = document.createElement('div');
            warning.className = 'stacked-warning';
            warning.innerHTML = options.html;
            warning.style.cssText = `
                position: fixed;
                top: 8%;
                left: 50%;
                transform: translateX(-50%);
                color: ${options.color};
                text-shadow: ${options.textShadow};
                text-align: center;
                z-index: 9999;
                pointer-events: none;
                opacity: 0;
            `;
            
            document.body.appendChild(warning);
            activeWarning = warning;
            
            // Animate in
            requestAnimationFrame(() => {
                warning.style.opacity = '1';
                warning.style.animation = 'warningPulse 0.5s ease-out';
            });
            
            // Clear any existing timeout
            if (warningTimeout) clearTimeout(warningTimeout);
            
            // Remove after duration and show next
            warningTimeout = setTimeout(() => {
                warning.style.opacity = '0';
                warning.style.transform = 'translateX(-50%) translateY(-20px)';
                setTimeout(() => {
                    warning.remove();
                    activeWarning = null;
                    showNextWarning();
                }, 300);
            }, options.duration - 300);
        }
        
        function showNextWarning() {
            if (warningQueue.length === 0) return;
            
            // Don't show if upgrade menu is open
            if (DOM.upgradeOverlay && DOM.upgradeOverlay.classList.contains('active')) {
                return;
            }
            
            // Get the highest priority warning
            const nextWarning = warningQueue.shift();
            displayWarning(nextWarning);
        }
        
        function processWarningQueue() {
            // Called after upgrade menu closes
            if (!activeWarning && warningQueue.length > 0) {
                showNextWarning();
            }
        }
        
        // Add warning animation styles once
        (function() {
            const style = document.createElement('style');
            style.textContent = `
                @keyframes warningPulse {
                    0% { transform: translateX(-50%) scale(0.5); }
                    50% { transform: translateX(-50%) scale(1.15); }
                    100% { transform: translateX(-50%) scale(1); }
                }
                .stacked-warning {
                    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
                }
            `;
            document.head.appendChild(style);
        })();
        
        // ===== BOSS SPAWNING SYSTEM =====
        function updateBossSpawning(dt) {
            // Boss schedule: 2.5 mins, 5 mins, 7.5 mins, 10 mins, etc.
            // Mini boss at odd intervals (2.5, 7.5, 12.5...)
            // Major boss at even intervals (5, 10, 15...)
            
            // Check for swarm trigger (1 minute before next boss)
            const nextBossNumber = bossCount + 1;
            const nextBossTimeCalc = nextBossNumber * 150; // 150s = 2.5 mins
            const swarmTriggerTime = nextBossTimeCalc - 60; // 1 minute before
            
            // Start swarm if we haven't triggered it for this boss yet
            if (gameTime >= swarmTriggerTime && swarmTriggeredForBoss < nextBossNumber) {
                swarmTriggeredForBoss = nextBossNumber;
                swarmActive = true;
                swarmEndTime = gameTime + 30; // 30 seconds duration
                showSwarmWarning();
            }
            
            // End swarm after 30 seconds
            if (swarmActive && gameTime >= swarmEndTime) {
                swarmActive = false;
            }
            
            // Spawn boss at the right time
            if (gameTime >= nextBossTime) {
                bossCount++;
                nextBossTime = (bossCount + 1) * 150; // Schedule next boss
                
                // Determine boss type: odd count = mini, even count = major
                if (bossCount % 2 === 1) {
                    spawnMiniBoss();
                } else {
                    spawnMajorBoss();
                }
            }
        }
        
        function spawnMiniBoss() {
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 350;
            
            let x, y, attempts = 0;
            do {
                const a = angle + (attempts * 0.5);
                x = player.x + Math.cos(a) * spawnDist;
                y = player.y + Math.sin(a) * spawnDist;
                
                // Clamp to world bounds
                x = Math.max(100, Math.min(WORLD.width - 100, x));
                y = Math.max(100, Math.min(WORLD.height - 100, y));
                attempts++;
            } while ((isInTerrain(x, y, 60) || isInLake(x, y, 80)) && attempts < 12);
            
            bosses.push(new MiniBoss(x, y));
            showBossWarning('MINI BOSS', '#ff6600');
            
            // Spawn extra bosses from tombstone curse
            for (let i = 0; i < extraBossMultiplier; i++) {
                let ex, ey, extraAttempts = 0;
                do {
                    const extraAngle = Math.random() * Math.PI * 2;
                    ex = player.x + Math.cos(extraAngle) * (spawnDist + 100);
                    ey = player.y + Math.sin(extraAngle) * (spawnDist + 100);
                    ex = Math.max(100, Math.min(WORLD.width - 100, ex));
                    ey = Math.max(100, Math.min(WORLD.height - 100, ey));
                    extraAttempts++;
                } while ((isInTerrain(ex, ey, 60) || isInLake(ex, ey, 80)) && extraAttempts < 12);
                bosses.push(new MiniBoss(ex, ey));
            }
        }
        
        function spawnMajorBoss() {
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 400;
            
            let x, y, attempts = 0;
            do {
                const a = angle + (attempts * 0.5);
                x = player.x + Math.cos(a) * spawnDist;
                y = player.y + Math.sin(a) * spawnDist;
                
                // Clamp to world bounds
                x = Math.max(150, Math.min(WORLD.width - 150, x));
                y = Math.max(150, Math.min(WORLD.height - 150, y));
                attempts++;
            } while ((isInTerrain(x, y, 80) || isInLake(x, y, 100)) && attempts < 12);
            
            bosses.push(new MajorBoss(x, y));
            showBossWarning('🔥 INFERNO BOSS 🔥', '#ff4400');
            
            // Spawn extra bosses from tombstone curse
            for (let i = 0; i < extraBossMultiplier; i++) {
                let ex, ey, extraAttempts = 0;
                do {
                    const extraAngle = Math.random() * Math.PI * 2;
                    ex = player.x + Math.cos(extraAngle) * (spawnDist + 100);
                    ey = player.y + Math.sin(extraAngle) * (spawnDist + 100);
                    ex = Math.max(150, Math.min(WORLD.width - 150, ex));
                    ey = Math.max(150, Math.min(WORLD.height - 150, ey));
                    extraAttempts++;
                } while ((isInTerrain(ex, ey, 80) || isInLake(ex, ey, 100)) && extraAttempts < 12);
                bosses.push(new MajorBoss(ex, ey));
            }
        }
        
        function showBossWarning(text, color) {
            showStackedWarning({
                html: `<div style="font-size: 36px;">⚠️ ${text} INCOMING! ⚠️</div>`,
                color: color,
                textShadow: `0 0 30px ${color}, 0 0 60px #ffffff`,
                duration: 2500,
                priority: WARNING_PRIORITY.BOSS
            });
        }
        
        function showSwarmWarning() {
            showStackedWarning({
                html: `<div style="font-size: 28px;">🌊 ENEMY SWARM! 🌊</div><div style="font-size: 16px; margin-top: 10px;">+50% enemy spawns for 30 seconds!</div>`,
                color: '#ff4444',
                textShadow: '0 0 20px #ff0000',
                duration: 2000,
                priority: WARNING_PRIORITY.SWARM
            });
        }

        // ===== FINAL HORDE WARNING =====
        let finalSwarmWarningShown = false;
        
        function showFinalSwarmWarning() {
            if (finalSwarmWarningShown) return;
            finalSwarmWarningShown = true;
            
            // Create warning overlay
            const warning = document.createElement('div');
            warning.id = 'finalSwarmWarning';
            warning.innerHTML = `
                <div class="warning-text">⚠️ FINAL HORDE ⚠️</div>
                <div class="warning-subtext">THE FINAL SWARM APPROACHES</div>
                <div class="warning-desc">Enemy spawns will now double every minute!</div>
            `;
            warning.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(255, 0, 0, 0.15);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: warningPulse 0.5s ease-in-out 3;
                pointer-events: none;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes warningPulse {
                    0%, 100% { background: rgba(255, 0, 0, 0.1); }
                    50% { background: rgba(255, 0, 0, 0.3); }
                }
                #finalSwarmWarning .warning-text {
                    font-size: 48px;
                    font-weight: bold;
                    color: #ff3333;
                    text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000;
                    animation: warningTextPulse 0.3s ease-in-out infinite;
                    letter-spacing: 8px;
                }
                #finalSwarmWarning .warning-subtext {
                    font-size: 28px;
                    color: #ff6600;
                    text-shadow: 0 0 20px #ff6600;
                    margin-top: 15px;
                    letter-spacing: 4px;
                }
                #finalSwarmWarning .warning-desc {
                    font-size: 16px;
                    color: #fff;
                    margin-top: 20px;
                    opacity: 0.8;
                }
                @keyframes warningTextPulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.05); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(warning);
            
            // Remove warning after 2.5 seconds
            setTimeout(() => {
                warning.style.transition = 'opacity 0.5s';
                warning.style.opacity = '0';
                setTimeout(() => warning.remove(), 500);
            }, 2500);
        }

        // ===== UPGRADE SELECTION =====
        let upgradeSlotResults = [];
        
        function showUpgradeSelection() {
            gamePaused = true;
            DOM.upgradeOverlay.classList.add('active');
            DOM.upgradeSlotMachine.innerHTML = '';
            DOM.upgradeSlotMachine.style.display = 'flex';
            DOM.upgradeSlotMachine.style.visibility = 'visible';
            DOM.upgradeOptions.innerHTML = '';
            
            // Generate available upgrades with weights
            const available = [];
            
            // Add weapon upgrades (max 4 unique weapons, each can level to 20)
            const uniqueWeaponCount = player.getUniqueWeaponCount();
            for (const [id, def] of Object.entries(WEAPONS)) {
                // Skip disabled weapons (from weapon select edit mode)
                if (disabledWeapons.has(id)) continue;
                // Skip banished weapons (from current run)
                if (banishedWeapons.has(id)) continue;
                
                const level = player.weapons[id]?.level || 0;
                
                // Can only get new weapons if under 4 unique, or can upgrade existing
                if (level > 0 && level < 20) {
                    // Already have this weapon, can upgrade it
                    const offeredCount = offerHistory[`weapon_${id}`] || 0;
                    const weight = Math.max(0.25, 1.0 - offeredCount * 0.15);
                    available.push({
                        ...def,
                        type: 'weapon',
                        id,
                        currentLevel: level,
                        weight
                    });
                } else if (level === 0 && uniqueWeaponCount < MAX_UNIQUE_WEAPONS) {
                    // Don't have this weapon yet, can get it if under cap
                    const offeredCount = offerHistory[`weapon_${id}`] || 0;
                    const weight = Math.max(0.25, 1.0 - offeredCount * 0.15);
                    available.push({
                        ...def,
                        type: 'weapon',
                        id,
                        currentLevel: 0,
                        weight
                    });
                }
            }
            
            // Add tome upgrades (max 4 unique tomes, each can level to 20)
            const uniqueTomeCount = player.getUniqueTomeCount();
            for (const [id, def] of Object.entries(TOMES)) {
                // Skip disabled tomes (from tome editor)
                if (disabledTomes.has(id)) continue;
                
                const tomeData = player.tomes[id];
                const level = tomeData?.level || 0;
                
                // Can only get new tomes if under 4 unique, or can upgrade existing
                if (level > 0 && level < 20) {
                    const offeredCount = offerHistory[`tome_${id}`] || 0;
                    const weight = Math.max(0.25, 1.0 - offeredCount * 0.15);
                    available.push({
                        ...def,
                        type: 'tome',
                        id,
                        currentLevel: level,
                        weight
                    });
                } else if (level === 0 && uniqueTomeCount < MAX_UNIQUE_TOMES) {
                    const offeredCount = offerHistory[`tome_${id}`] || 0;
                    const weight = Math.max(0.25, 1.0 - offeredCount * 0.15);
                    available.push({
                        ...def,
                        type: 'tome',
                        id,
                        currentLevel: 0,
                        weight
                    });
                }
            }
            
            // Weighted random selection - pick 3 upgrades based on weights and rarity
            // Roll for minimum rarity threshold based on luck (weapons only)
            const rolledRarity = rollRarity();
            const rarityOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
            const rolledIndex = rarityOrder.indexOf(rolledRarity);
            
            // Add rarity info and adjust weights based on rarity (weapons only)
            available.forEach(u => {
                u.rarity = getUpgradeRarity(u.type, u.id);
                
                // Only apply rarity weighting to weapons
                if (u.type === 'weapon' && u.rarity) {
                    const uRarityIndex = rarityOrder.indexOf(u.rarity);
                    
                    // Boost weight for items at or above rolled rarity
                    if (uRarityIndex >= rolledIndex) {
                        u.weight *= (1 + uRarityIndex * 0.5); // Rarer = more weight when rolled
                    } else {
                        u.weight *= 0.5; // Reduce weight for items below rolled rarity
                    }
                }
                // Tomes keep their original weight (no rarity system)
            });
            
            upgradeSlotResults = weightedRandomSelect(available, 3);
            
            // Track what we offered
            for (const upgrade of upgradeSlotResults) {
                const key = `${upgrade.type}_${upgrade.id}`;
                offerHistory[key] = (offerHistory[key] || 0) + 1;
            }
            
            // Handle edge case of no upgrades available
            if (upgradeSlotResults.length === 0) {
                DOM.upgradeOverlay.classList.remove('active');
                gamePaused = false;
                return;
            }
            
            // Create slot reels
            const reelCount = upgradeSlotResults.length;
            for (let i = 0; i < reelCount; i++) {
                const reel = document.createElement('div');
                reel.className = 'slot-reel spinning';
                reel.id = `upgradeReel${i}`;
                
                const content = document.createElement('div');
                content.className = 'slot-content';
                content.innerHTML = `
                    <div class="slot-icon">❓</div>
                    <div class="slot-name">???</div>
                    <div class="slot-value">???</div>
                `;
                
                reel.appendChild(content);
                DOM.upgradeSlotMachine.appendChild(reel);
            }
            
            // Animate slot machine reveal
            upgradeSlotResults.forEach((upgrade, i) => {
                setTimeout(() => {
                    const reel = document.getElementById(`upgradeReel${i}`);
                    if (!reel) return;
                    reel.classList.remove('spinning');
                    reel.classList.add('stopped');
                    
                    const levelText = upgrade.currentLevel > 0 
                        ? `Lv ${upgrade.currentLevel} → ${upgrade.currentLevel + 1}` 
                        : '<br>NEW!';
                    
                    const content = reel.querySelector('.slot-content');
                    const iconHtml = upgrade.type === 'tome' 
                        ? `<span style="position:relative;display:inline-block;"><span style="font-size:1.2em;opacity:0.6;">📖</span><span style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:0.7em;filter:drop-shadow(0 0 2px #000);">${upgrade.icon}</span></span>`
                        : upgrade.icon;
                    
                    // Use rarity color for weapons only
                    const rarity = upgrade.rarity || getUpgradeRarity(upgrade.type, upgrade.id);
                    const rarityInfo = rarity ? RARITIES[rarity] : null;
                    const borderColor = rarityInfo ? rarityInfo.color : upgrade.color;
                    
                    // Only show rarity label for weapons
                    const rarityLabel = rarityInfo 
                        ? `<div class="slot-rarity" style="color:${rarityInfo.color};font-size:9px;text-transform:uppercase;">${rarityInfo.name}</div>`
                        : '';
                    
                    content.innerHTML = `
                        ${rarityLabel}
                        <div class="slot-icon">${iconHtml}</div>
                        <div class="slot-name">${upgrade.name}</div>
                        <div class="slot-value">${levelText}</div>
                    `;
                    content.style.color = upgrade.color;
                    reel.style.borderColor = borderColor;
                    reel.style.boxShadow = `0 0 25px ${borderColor}50`;
                    
                    // Show clickable cards after last reel
                    if (i === upgradeSlotResults.length - 1) {
                        setTimeout(() => showUpgradeCards(), 300);
                    }
                }, 400 + i * 500);
            });
        }
        
        // Weighted random selection without replacement
        function weightedRandomSelect(items, count) {
            const selected = [];
            const remaining = [...items];
            
            for (let i = 0; i < count && remaining.length > 0; i++) {
                const totalWeight = remaining.reduce((sum, item) => sum + item.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (let j = 0; j < remaining.length; j++) {
                    random -= remaining[j].weight;
                    if (random <= 0) {
                        selected.push(remaining[j]);
                        remaining.splice(j, 1);
                        break;
                    }
                }
            }
            
            return selected;
        }
        
        function showUpgradeCards() {

            // Hide slot machine completely
            DOM.upgradeSlotMachine.style.display = 'none';
            DOM.upgradeSlotMachine.style.visibility = 'hidden';
            DOM.upgradeSlotMachine.innerHTML = '';
            DOM.upgradeOptions.innerHTML = '';
            
            // Remove any existing reroll and banish buttons
            const existingReroll = DOM.upgradeOverlay.querySelector('.reroll-button');
            if (existingReroll) existingReroll.remove();
            const existingBanish = DOM.upgradeOverlay.querySelector('.banish-button');
            if (existingBanish) existingBanish.remove();
            
            // Reset banish mode
            banishMode = false;
            
            upgradeSlotResults.forEach((upgrade, i) => {

                const card = document.createElement('div');
                card.className = 'upgrade-card revealed';
                
                // Use rarity color for border if weapon (tomes don't have rarity)
                const rarity = upgrade.rarity || getUpgradeRarity(upgrade.type, upgrade.id);
                const rarityInfo = rarity ? RARITIES[rarity] : null;
                const borderColor = rarityInfo ? rarityInfo.color : upgrade.color;
                card.style.borderColor = borderColor;
                card.style.boxShadow = `0 0 20px ${borderColor}40`;
                card.style.cursor = 'pointer';
                
                const levelText = upgrade.currentLevel > 0 
                    ? ` (Lv ${upgrade.currentLevel} → ${upgrade.currentLevel + 1})` 
                    : '<br>(NEW)';
                
                // Custom boombox icon
                let upgradeIcon = upgrade.icon;
                if (upgrade.id === 'boomBox') {
                    upgradeIcon = `<svg viewBox="0 0 48 36" width="36" height="27" style="filter: drop-shadow(0 0 3px ${upgrade.color});">
                        <path d="M12 8 Q24 2 36 8" stroke="#666" stroke-width="3" fill="none" stroke-linecap="round"/>
                        <rect x="4" y="8" width="40" height="24" rx="3" fill="#444" stroke="${upgrade.color}" stroke-width="1.5"/>
                        <circle cx="14" cy="20" r="8" fill="#222" stroke="${upgrade.color}" stroke-width="1"/>
                        <circle cx="14" cy="20" r="3" fill="${upgrade.color}" opacity="0.6"/>
                        <circle cx="34" cy="20" r="8" fill="#222" stroke="${upgrade.color}" stroke-width="1"/>
                        <circle cx="34" cy="20" r="3" fill="${upgrade.color}" opacity="0.6"/>
                        <rect x="20" y="15" width="8" height="10" fill="#333" stroke="#555" stroke-width="0.5"/>
                    </svg>`;
                } else if (upgrade.id === 'shotgun') {
                    upgradeIcon = `<img src="${SHOTGUN_ICON_SVG}" width="48" height="21" style="filter: drop-shadow(0 0 3px ${upgrade.color}); object-fit: contain;">`;
                }
                
                const iconHtml = upgrade.type === 'tome' 
                    ? `<span style="position:relative;display:inline-block;"><span style="font-size:1.2em;opacity:0.6;">📖</span><span style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:0.6em;filter:drop-shadow(0 0 2px #000);">${upgrade.icon}</span></span>`
                    : upgradeIcon;
                
                // Only show rarity badge for weapons
                const rarityBadge = rarityInfo 
                    ? `<div class="rarity-badge" style="color:${rarityInfo.color};font-size:10px;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px;">${rarityInfo.name}</div>`
                    : '';
                
                card.innerHTML = `
                    ${rarityBadge}
                    <div class="icon">${iconHtml}</div>
                    <div class="name">${upgrade.name}${levelText}</div>
                    <div class="desc">${upgrade.desc}</div>
                `;
                
                // Use onclick directly for simplicity
                card.onclick = function(e) {

                    selectUpgrade(upgrade);
                };
                
                // Also handle touch
                card.ontouchend = function(e) {

                    e.preventDefault();
                    selectUpgrade(upgrade);
                };
                
                DOM.upgradeOptions.appendChild(card);

            });
            
            // Add reroll button if player has rerolls remaining
            if (rerollsRemaining > 0) {
                const rerollBtn = document.createElement('div');
                rerollBtn.className = 'reroll-button';
                rerollBtn.innerHTML = `🎲 Reroll (${rerollsRemaining})`;
                
                rerollBtn.onclick = function(e) {
                    rerollsRemaining--;
                    // Re-trigger upgrade selection
                    DOM.upgradeOverlay.classList.remove('active');
                    showUpgradeSelection();
                };
                
                rerollBtn.ontouchend = function(e) {
                    e.preventDefault();
                    rerollsRemaining--;
                    DOM.upgradeOverlay.classList.remove('active');
                    showUpgradeSelection();
                };
                
                DOM.upgradeOverlay.appendChild(rerollBtn);
            }
            
            // Add banish button (only if charges remaining)
            if (banishesRemaining > 0) {
                const banishBtn = document.createElement('div');
                banishBtn.className = 'banish-button';
                banishBtn.id = 'banishBtn';
                banishBtn.innerHTML = `🚫 Banish (${banishesRemaining})`;
                
                banishBtn.onclick = function(e) {
                    toggleBanishMode();
                };
                
                banishBtn.ontouchend = function(e) {
                    e.preventDefault();
                    toggleBanishMode();
                };
                
                DOM.upgradeOverlay.appendChild(banishBtn);
            }
        }
        
        let banishMode = false;
        
        function toggleBanishMode() {
            banishMode = !banishMode;
            const banishBtn = document.getElementById('banishBtn');
            const cards = DOM.upgradeOptions.querySelectorAll('.upgrade-card');
            
            if (banishMode) {
                banishBtn.classList.add('active');
                banishBtn.innerHTML = '✕ Cancel';
                
                // Add banish-target class to weapon cards only
                cards.forEach((card, i) => {
                    const upgrade = upgradeSlotResults[i];
                    if (upgrade && upgrade.type === 'weapon') {
                        card.classList.add('banish-target');
                        card.onclick = function(e) {
                            banishWeapon(upgrade);
                        };
                        card.ontouchend = function(e) {
                            e.preventDefault();
                            banishWeapon(upgrade);
                        };
                    }
                });
            } else {
                banishBtn.classList.remove('active');
                banishBtn.innerHTML = `🚫 Banish (${banishesRemaining})`;
                
                // Restore normal card behavior
                cards.forEach((card, i) => {
                    card.classList.remove('banish-target');
                    const upgrade = upgradeSlotResults[i];
                    if (upgrade) {
                        card.onclick = function(e) {
                            selectUpgrade(upgrade);
                        };
                        card.ontouchend = function(e) {
                            e.preventDefault();
                            selectUpgrade(upgrade);
                        };
                    }
                });
            }
        }
        
        function banishWeapon(upgrade) {
            if (upgrade.type !== 'weapon') return;
            
            // Add to banished set for this run
            banishedWeapons.add(upgrade.id);
            
            // Decrement banish charges
            banishesRemaining--;
            
            // Show notification
            const notification = document.createElement('div');
            notification.className = 'power-notification';
            notification.innerHTML = `<div style="font-size: 18px; color: #ff6666;">🚫 ${upgrade.name} BANISHED!</div><div style="font-size: 12px; opacity: 0.8;">Won't appear in upgrades this run</div>`;
            notification.style.cssText = `
                position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
                background: rgba(180, 40, 40, 0.9); padding: 15px 25px; border-radius: 10px;
                border: 2px solid #ff3333; z-index: 10001; text-align: center;
                animation: fadeInOut 2s forwards;
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2000);
            
            // Reset banish mode and refresh upgrade options
            banishMode = false;
            DOM.upgradeOverlay.classList.remove('active');
            showUpgradeSelection();
        }

        function selectUpgrade(upgrade) {
            if (upgrade.type === 'weapon') {
                player.addWeapon(upgrade.id);
            } else if (upgrade.type === 'tome') {
                player.addTome(upgrade.id);
            } else {
                player.addPassive(upgrade.id);
            }
            
            DOM.upgradeOverlay.classList.remove('active');
            gamePaused = false;
            updateWeaponsDisplay();
            updateTomesDisplay();
            
            // Process any queued warnings after a short delay
            setTimeout(processWarningQueue, 300);
        }

        function updateWeaponsDisplay() {
            DOM.weaponsDisplay.innerHTML = '';
            
            for (const [id, state] of Object.entries(player.weapons)) {
                const def = WEAPONS[id];
                const div = document.createElement('div');
                div.className = 'weapon-icon';
                div.style.borderColor = def.color;
                div.style.boxShadow = `0 0 10px ${def.color}`;
                
                // Custom boombox SVG icon for HUD
                let iconContent = def.icon;
                if (id === 'boomBox') {
                    iconContent = `<svg viewBox="0 0 48 36" width="24" height="18" style="filter: drop-shadow(0 0 2px ${def.color});">
                        <path d="M12 8 Q24 2 36 8" stroke="#666" stroke-width="3" fill="none" stroke-linecap="round"/>
                        <rect x="4" y="8" width="40" height="24" rx="3" fill="#444" stroke="${def.color}" stroke-width="1.5"/>
                        <circle cx="14" cy="20" r="8" fill="#222" stroke="${def.color}" stroke-width="1"/>
                        <circle cx="14" cy="20" r="3" fill="${def.color}" opacity="0.6"/>
                        <circle cx="34" cy="20" r="8" fill="#222" stroke="${def.color}" stroke-width="1"/>
                        <circle cx="34" cy="20" r="3" fill="${def.color}" opacity="0.6"/>
                        <rect x="20" y="15" width="8" height="10" fill="#333" stroke="#555" stroke-width="0.5"/>
                    </svg>`;
                } else if (id === 'shotgun') {
                    iconContent = `<img src="${SHOTGUN_ICON_SVG}" width="32" height="14" style="filter: drop-shadow(0 0 2px ${def.color}); object-fit: contain;">`;
                }
                
                div.innerHTML = `
                    ${iconContent}
                    <span class="weapon-level">${state.level}</span>
                    <div class="item-tooltip">
                        <div class="item-tooltip-name" style="color: ${def.color};">${def.name}</div>
                        <div class="item-tooltip-desc">${def.desc}</div>
                    </div>
                `;
                DOM.weaponsDisplay.appendChild(div);
            }
        }

        function updateTomesDisplay() {
            DOM.tomesDisplay.innerHTML = '';
            
            for (const [id, tomeData] of Object.entries(player.tomes)) {
                const def = TOMES[id];
                if (!def) continue;
                const div = document.createElement('div');
                div.className = 'tome-icon';
                div.style.borderColor = def.color;
                div.style.boxShadow = `0 0 10px ${def.color}`;
                div.innerHTML = `
                    <span class="tome-base">📖</span>
                    <span class="tome-effect">${def.icon}</span>
                    <span class="tome-level">${tomeData.level}</span>
                    <div class="item-tooltip">
                        <div class="item-tooltip-name" style="color: ${def.color};">${def.name}</div>
                        <div class="item-tooltip-desc">${def.desc}</div>
                    </div>
                `;
                DOM.tomesDisplay.appendChild(div);
            }
        }

        // ===== INPUT HANDLING =====
        const input = {
            left: false, right: false, up: false, down: false,
            joystickX: 0, joystickY: 0
        };

        document.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if (e.key === 'ArrowLeft' || key === 'a') input.left = true;
            if (e.key === 'ArrowRight' || key === 'd') input.right = true;
            if (e.key === 'ArrowUp' || key === 'w') input.up = true;
            if (e.key === 'ArrowDown' || key === 's') input.down = true;
        });

        document.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            if (e.key === 'ArrowLeft' || key === 'a') input.left = false;
            if (e.key === 'ArrowRight' || key === 'd') input.right = false;
            if (e.key === 'ArrowUp' || key === 'w') input.up = false;
            if (e.key === 'ArrowDown' || key === 's') input.down = false;
        });

        // Mobile dynamic joystick controls
        const trackpadZone = document.getElementById('trackpadZone');
        const joystickOverlay = document.getElementById('joystickOverlay');
        const joystickKnob = document.getElementById('joystickKnob');
        
        let touchActive = false;
        let joystickCenter = { x: 0, y: 0 };
        const joystickRadius = 60; // Half of overlay size
        const knobMaxDist = 40;    // Max distance knob can move
        
        function updateJoystick(touchX, touchY) {
            const dx = touchX - joystickCenter.x;
            const dy = touchY - joystickCenter.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);
            
            // Clamp distance to max
            const clampedDist = Math.min(dist, knobMaxDist);
            
            // Calculate input values (-1 to 1)
            if (dist > 5) { // Small deadzone
                input.joystickX = (clampedDist / knobMaxDist) * Math.cos(angle);
                input.joystickY = (clampedDist / knobMaxDist) * Math.sin(angle);
            } else {
                input.joystickX = 0;
                input.joystickY = 0;
            }
            
            // Move knob visually
            const knobX = Math.cos(angle) * clampedDist;
            const knobY = Math.sin(angle) * clampedDist;
            joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
        }
        
        // Simple touch handling without complex ID tracking
        trackpadZone.addEventListener('touchstart', e => {
            if (gamePaused) return;
            // Don't capture if touching inside a modal
            if (e.target.closest('#chestModal, #shrineOverlay, #legendaryOverlay, #menuOverlay')) return;
            e.preventDefault();
            
            // Tell parent page to lock scrolling
            try { parent.postMessage({ type: 'gameTouch', action: 'start' }, '*'); } catch(err) {}
            
            const touch = e.touches[0];
            touchActive = true;
            
            const rect = trackpadZone.getBoundingClientRect();
            
            // Position joystick at touch point
            joystickCenter = { 
                x: touch.clientX, 
                y: touch.clientY 
            };
            
            // Show joystick overlay at touch position
            joystickOverlay.style.left = (touch.clientX - rect.left - joystickRadius) + 'px';
            joystickOverlay.style.top = (touch.clientY - rect.top - joystickRadius) + 'px';
            joystickOverlay.classList.add('active');
            
            // Reset knob and input
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            input.joystickX = 0;
            input.joystickY = 0;
        }, { passive: false });

        // Handle touchmove on trackpad
        trackpadZone.addEventListener('touchmove', e => {
            if (!touchActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            if (touch) {
                updateJoystick(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        // Handle touchmove on entire document (for when finger leaves trackpad)
        document.addEventListener('touchmove', e => {
            if (!touchActive) return;
            
            const touch = e.touches[0];
            if (touch) {
                updateJoystick(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        // Handle touch end
        function endJoystick() {
            touchActive = false;
            input.joystickX = 0;
            input.joystickY = 0;
            joystickOverlay.classList.remove('active');
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            
            // Tell parent page to unlock scrolling
            try { parent.postMessage({ type: 'gameTouch', action: 'end' }, '*'); } catch(err) {}
        }
        
        document.addEventListener('touchend', endJoystick);
        document.addEventListener('touchcancel', endJoystick);

        // ===== GAME LOOP =====
        let lastTime = performance.now(); // Fix: Initialize properly to avoid first-frame spike

        // Cache DOM elements for performance
        const DOM = {
            trackpadHpFill: document.getElementById('trackpadHpFill'),
            trackpadXpFill: document.getElementById('trackpadXpFill'),
            levelDisplay: document.getElementById('levelDisplay'),
            timer: document.getElementById('timer'),
            killCount: document.getElementById('killCount'),
            goldCount: document.getElementById('goldCount'),
            shrineChargeBar: document.getElementById('shrineChargeBar'),
            shrineChargeFill: document.getElementById('shrineChargeFill'),
            upgradeOverlay: document.getElementById('upgradeOverlay'),
            upgradeSlotMachine: document.getElementById('upgradeSlotMachine'),
            upgradeOptions: document.getElementById('upgradeOptions'),
            shrineOverlay: document.getElementById('shrineOverlay'),
            slotMachine: document.getElementById('slotMachine'),
            shrineOptions: document.getElementById('shrineOptions'),
            // New chest modal elements
            chestModal: document.getElementById('chestModal'),
            modalTitle: document.getElementById('modalTitle'),
            modalCost: document.getElementById('modalCost'),
            chestSlotReel: document.getElementById('chestSlotReel'),
            modalCard: document.getElementById('modalCard'),
            modalIcon: document.getElementById('modalIcon'),
            modalName: document.getElementById('modalName'),
            modalDesc: document.getElementById('modalDesc'),
            modalTake: document.getElementById('modalTake'),
            modalLeave: document.getElementById('modalLeave'),
            menuOverlay: document.getElementById('menuOverlay'),
            finalStats: document.getElementById('finalStats'),
            startBtn: document.getElementById('startBtn'),
            weaponsDisplay: document.getElementById('weaponsDisplay'),
            tomesDisplay: document.getElementById('tomesDisplay'),
            activeBuffsBar: document.getElementById('activeBuffsBar'),
            statsDisplay: document.getElementById('statsDisplay'),
            pauseBtn: document.getElementById('pauseBtn'),
            weaponSelectOverlay: document.getElementById('weaponSelectOverlay'),
            weaponSelectGrid: document.getElementById('weaponSelectGrid'),
            weaponSelectDesc: document.getElementById('weaponSelectDesc'),
            weaponBackBtn: document.getElementById('weaponBackBtn'),
            weaponConfirmBtn: document.getElementById('weaponConfirmBtn'),
            colorSelectorGrid: document.getElementById('colorSelectorGrid'),
            pauseOverlay: document.getElementById('pauseOverlay'),
            resumeBtn: document.getElementById('resumeBtn'),
            pauseLeaderboardBtn: document.getElementById('pauseLeaderboardBtn'),
            exitGameBtn: document.getElementById('exitGameBtn'),
            confirmOverlay: document.getElementById('confirmOverlay'),
            confirmYes: document.getElementById('confirmYes'),
            confirmNo: document.getElementById('confirmNo'),
            tomeEditorOverlay: document.getElementById('tomeEditorOverlay'),
            tomeEditorGrid: document.getElementById('tomeEditorGrid'),
            tomeDisabledCount: document.getElementById('tomeDisabledCount'),
            tomeEditorClose: document.getElementById('tomeEditorClose'),
            tomeEditorDesc: document.getElementById('tomeEditorDesc'),
            tomeModeBtn: document.getElementById('tomeModeBtn')
        };
        
        // Global chest button functions (called from onclick in HTML)
        window.chestTake = function() {
            acceptChestOffer();
        };
        
        window.chestLeave = function() {
            if (pendingChest && pendingChest.isPotReward === true) return;
            if (pendingChest && pendingChest.opened !== undefined) {
                pendingChest.opened = false;
            }
            pendingChest = null;
            DOM.chestModal.classList.remove('visible');
            gamePaused = false;
        };
        
        // Check if we're on mobile
        function isMobile() {
            return window.innerWidth <= 600;
        }
        
        // Update HUD in trackpad zone (works for both desktop and mobile)
        function updateTrackpadHUD() {
            if (!player) return;
            
            const statsDisplay = DOM.statsDisplay;
            if (!statsDisplay) return;
            
            // Format time
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // XP progress
            const xpPercent = (player.xp / player.xpToNext) * 100;
            
            // Update XP bar separately for smooth animation
            let xpBarContainer = statsDisplay.querySelector('.xp-bar-container');
            let xpBarFill = statsDisplay.querySelector('.xp-bar-fill');
            
            if (!xpBarContainer) {
                // First time - create the structure
                statsDisplay.innerHTML = `
                    <div class="xp-bar-container" style="width: calc(100% - 1px); margin: 0 auto 4px auto; height: 5px; border: 1px solid #0ff; border-radius: 3px; overflow: hidden; background: transparent;">
                        <div class="xp-bar-fill" style="height: 100%; width: 0%; background: #a8b8c8; box-shadow: 0 0 4px rgba(168, 184, 200, 0.5); transition: width 0.25s ease-out;"></div>
                    </div>
                    <div class="stats-row-container" style="display: flex; align-items: center; justify-content: space-evenly; width: calc(100% + 24px); margin: 0 -12px 2px -12px;"></div>
                `;
                xpBarFill = statsDisplay.querySelector('.xp-bar-fill');
            }
            
            // Smoothly update XP bar width
            if (xpBarFill) {
                xpBarFill.style.width = `${xpPercent}%`;
            }
            
            // Responsive sizing
            const mobile = isMobile();
            const fontSize = mobile ? '7px' : '10px';
            const hpTextSize = mobile ? '10px' : '12px';
            const hpWidth = mobile ? 160 : 300; // pixels
            const hpHeight = mobile ? '18px' : '20px';
            
            // Calculate HP and shield portions
            const totalPool = player.maxHp + player.maxShieldHp;
            const hpPortionWidth = hpWidth * (player.maxHp / totalPool);
            const shieldPortionWidth = hpWidth * (player.maxShieldHp / totalPool);
            const hpFillPercent = Math.max(0, Math.min(100, (player.hp / player.maxHp) * 100));
            const shieldFillPercent = player.maxShieldHp > 0 ? Math.max(0, Math.min(100, (player.shieldHp / player.maxShieldHp) * 100)) : 0;
            
            // HP text: show just total when full, current/total when not, DEAD at 0
            const currentHp = Math.max(0, Math.round(player.hp));
            const maxHpVal = Math.round(player.maxHp);
            const hpText = currentHp <= 0 ? 'DEAD' : (currentHp >= maxHpVal ? `${maxHpVal}` : `${currentHp}/${maxHpVal}`);
            
            // Shield text: show only when there's enough room (> 50px wide)
            const currentShield = Math.round(player.shieldHp);
            const maxShieldVal = Math.round(player.maxShieldHp);
            const showShieldText = shieldPortionWidth > 50 && player.maxShieldHp > 0;
            const shieldText = currentShield >= maxShieldVal ? `${maxShieldVal}` : `${currentShield}/${maxShieldVal}`;
            
            // Build HP bar HTML with shield section and text overlays
            // HP text is always centered on the ENTIRE bar (not just HP portion)
            let hpBarContent = `
                <div style="height: 100%; width: ${hpPortionWidth}px; display: inline-block; background: rgba(255, 0, 0, 0.3); position: relative; vertical-align: top;">
                    <div style="height: 100%; width: ${hpFillPercent}%; background: linear-gradient(90deg, #39ff9f, #00ff66); box-shadow: 0 0 6px #39ff9f;"></div>
                </div>`;
            
            if (player.maxShieldHp > 0) {
                hpBarContent += `
                <div style="height: 100%; width: ${shieldPortionWidth}px; display: inline-block; background: rgba(68, 136, 255, 0.3); position: relative; vertical-align: top;">
                    <div style="height: 100%; width: ${shieldFillPercent}%; background: linear-gradient(90deg, #4488ff, #66aaff); box-shadow: 0 0 6px #4488ff;"></div>
                </div>`;
            }
            
            // Add centered HP text overlay spanning entire bar
            hpBarContent += `<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: ${hpTextSize}; font-weight: bold; color: #fff; text-shadow: 0 0 3px #000, 0 0 3px #000; white-space: nowrap; pointer-events: none; z-index: 1;">${hpText}</span>`;
            
            // Add shield text if there's room
            if (player.maxShieldHp > 0 && showShieldText) {
                // Position shield text in the right portion of the bar
                const shieldTextLeft = hpPortionWidth + (shieldPortionWidth / 2);
                hpBarContent += `<span style="position: absolute; top: 50%; left: ${shieldTextLeft}px; transform: translate(-50%, -50%); font-size: ${hpTextSize}; font-weight: bold; color: #fff; text-shadow: 0 0 3px #000, 0 0 3px #000; white-space: nowrap; pointer-events: none; z-index: 1;">${shieldText}</span>`;
            }
            
            // Border color changes when shield is present
            const borderColor = player.maxShieldHp > 0 ? '#66aaff' : '#39ff9f';
            
            // Calculate HP bar position centered on minimap (true center of trackpad)
            const weaponsBar = document.getElementById('weaponsDisplay');
            const tomesBar = document.getElementById('tomesDisplay');
            const minimapWrapper = document.getElementById('trackpadMinimapWrapper');
            const statsRowContainer = statsDisplay.querySelector('.stats-row-container');
            
            if (statsRowContainer && weaponsBar && tomesBar && minimapWrapper) {
                const statsRect = statsRowContainer.getBoundingClientRect();
                const weaponsRect = weaponsBar.getBoundingClientRect();
                const tomesRect = tomesBar.getBoundingClientRect();
                const minimapRect = minimapWrapper.getBoundingClientRect();
                
                // Get center X positions relative to stats container
                const weaponsCenterX = (weaponsRect.left + weaponsRect.width / 2) - statsRect.left;
                const tomesCenterX = (tomesRect.left + tomesRect.width / 2) - statsRect.left;
                const minimapCenterX = (minimapRect.left + minimapRect.width / 2) - statsRect.left;
                
                // HP bar width based on weapons-to-tomes span
                const hpBarWidth = Math.max(50, tomesCenterX - weaponsCenterX);
                
                // Center HP bar on minimap center
                const hpBarLeft = minimapCenterX - (hpBarWidth / 2);
                
                // Recalculate HP portion widths based on actual bar width
                const actualHpPortionWidth = hpBarWidth * (player.maxHp / totalPool);
                const actualShieldPortionWidth = hpBarWidth * (player.maxShieldHp / totalPool);
                
                // Rebuild HP bar content with correct widths
                let actualHpBarContent = `
                    <div style="height: 100%; width: ${actualHpPortionWidth}px; display: inline-block; background: rgba(255, 0, 0, 0.3); position: relative; vertical-align: top;">
                        <div style="height: 100%; width: ${hpFillPercent}%; background: linear-gradient(90deg, #39ff9f, #00ff66); box-shadow: 0 0 6px #39ff9f;"></div>
                    </div>`;
                
                if (player.maxShieldHp > 0) {
                    actualHpBarContent += `
                    <div style="height: 100%; width: ${actualShieldPortionWidth}px; display: inline-block; background: rgba(68, 136, 255, 0.3); position: relative; vertical-align: top;">
                        <div style="height: 100%; width: ${shieldFillPercent}%; background: linear-gradient(90deg, #4488ff, #66aaff); box-shadow: 0 0 6px #4488ff;"></div>
                    </div>`;
                }
                
                // Add centered HP text overlay
                actualHpBarContent += `<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: ${hpTextSize}; font-weight: bold; color: #fff; text-shadow: 0 0 3px #000, 0 0 3px #000; white-space: nowrap; pointer-events: none; z-index: 1;">${hpText}</span>`;
                
                // Add shield text if there's room
                if (player.maxShieldHp > 0 && actualShieldPortionWidth > 50) {
                    const shieldTextLeft = actualHpPortionWidth + (actualShieldPortionWidth / 2);
                    actualHpBarContent += `<span style="position: absolute; top: 50%; left: ${shieldTextLeft}px; transform: translate(-50%, -50%); font-size: ${hpTextSize}; font-weight: bold; color: #fff; text-shadow: 0 0 3px #000, 0 0 3px #000; white-space: nowrap; pointer-events: none; z-index: 1;">${shieldText}</span>`;
                }
                
                // Left zone: from edge to HP bar left edge
                // Right zone: from HP bar right edge to edge
                const leftZoneWidth = hpBarLeft;
                const rightZoneWidth = statsRect.width - (hpBarLeft + hpBarWidth);
                
                statsRowContainer.style.fontSize = fontSize;
                statsRowContainer.style.position = 'relative';
                statsRowContainer.style.display = 'flex';
                statsRowContainer.style.alignItems = 'center';
                statsRowContainer.style.justifyContent = 'space-between';
                statsRowContainer.innerHTML = `
                    <div style="display: flex; justify-content: space-evenly; align-items: center; width: ${leftZoneWidth}px; flex-shrink: 0; padding-right: 14px;">
                        <span style="color: #fff; text-shadow: 0 0 4px #0ff;">${timeStr}</span>
                        <span style="color: #0ff; text-shadow: 0 0 4px #0ff;">${kills} Kills</span>
                    </div>
                    <div id="hpBarAligned" style="position: absolute; left: ${hpBarLeft}px; width: ${hpBarWidth}px; height: ${hpHeight}; border: 1px solid ${borderColor}; border-radius: 3px; overflow: hidden; background: transparent; white-space: nowrap; font-size: 0; top: 50%; transform: translateY(-50%); z-index: 0;">
                        ${actualHpBarContent}
                    </div>
                    <div style="display: flex; justify-content: space-evenly; align-items: center; width: ${rightZoneWidth}px; flex-shrink: 0; padding-left: 14px;">
                        <span style="color: #ffd700; text-shadow: 0 0 4px #ffd700;">🪙${playerGold}</span>
                        <span style="color: #0ff; text-shadow: 0 0 4px #0ff;">Level ${player.level}</span>
                    </div>
                `;
            } else {
                // Fallback if elements not found
                if (statsRowContainer) {
                    statsRowContainer.style.fontSize = fontSize;
                    statsRowContainer.innerHTML = `
                        <span style="color: #fff; text-shadow: 0 0 4px #0ff;">${timeStr}</span>
                        <span style="color: #0ff; text-shadow: 0 0 4px #0ff;">${kills} Kills</span>
                        <div style="width: ${hpWidth}px; height: ${hpHeight}; border: 1px solid ${borderColor}; border-radius: 3px; overflow: hidden; background: transparent; white-space: nowrap; font-size: 0;">
                            ${hpBarContent}
                        </div>
                        <span style="color: #ffd700; text-shadow: 0 0 4px #ffd700;">🪙${playerGold}</span>
                        <span style="color: #0ff; text-shadow: 0 0 4px #0ff;">Level ${player.level}</span>
                    `;
                }
            }
            
            // Update stat panels
            updateStatPanels();
        }
        
        // Update offensive and defensive stat panels
        function updateStatPanels() {
            if (!player) return;
            
            // Offensive stats (left panel)
            const dmgPercent = Math.round(player.damageMultiplier * 100);
            const critPercent = Math.round(player.critChance * 100);
            const critMult = player.critMultiplier.toFixed(1);
            const atkSpeedPercent = Math.round(player.attackSpeedMultiplier * 100);
            const lifestealPercent = Math.round(player.lifesteal * 100);
            const luckPercent = Math.round(player.luck * 100);
            
            // Defensive stats (right panel)
            const maxHp = Math.round(player.maxHp);
            const regenRate = player.regenRate.toFixed(1);
            const armorPercent = Math.round(player.armor * 100);
            const shieldHp = Math.round(player.maxShieldHp);
            const speedPercent = Math.round((player.speed / player.baseSpeed) * 100);
            const pickupPercent = Math.round((player.pickupRange / 50) * 100);
            
            // Update offensive panel values
            const statDamage = document.getElementById('statDamage');
            const statCritChance = document.getElementById('statCritChance');
            const statCritMult = document.getElementById('statCritMult');
            const statAtkSpeed = document.getElementById('statAtkSpeed');
            const statLifesteal = document.getElementById('statLifesteal');
            const statLuck = document.getElementById('statLuck');
            
            if (statDamage) {
                statDamage.textContent = `${dmgPercent}%`;
                statDamage.classList.toggle('boosted', dmgPercent > 100);
            }
            if (statCritChance) {
                statCritChance.textContent = `${critPercent}%`;
                statCritChance.classList.toggle('boosted', critPercent > 5);
            }
            if (statCritMult) {
                statCritMult.textContent = `${critMult}×`;
                statCritMult.classList.toggle('boosted', parseFloat(critMult) > 2.0);
            }
            if (statAtkSpeed) {
                statAtkSpeed.textContent = `${atkSpeedPercent}%`;
                statAtkSpeed.classList.toggle('boosted', atkSpeedPercent > 100);
            }
            if (statLifesteal) {
                statLifesteal.textContent = `${lifestealPercent}%`;
                statLifesteal.classList.toggle('boosted', lifestealPercent > 0);
            }
            if (statLuck) {
                statLuck.textContent = `${luckPercent}%`;
                statLuck.classList.toggle('boosted', luckPercent > 0);
            }
            
            // Update defensive panel values
            const statMaxHp = document.getElementById('statMaxHp');
            const statRegen = document.getElementById('statRegen');
            const statArmor = document.getElementById('statArmor');
            const statShield = document.getElementById('statShield');
            const statSpeed = document.getElementById('statSpeed');
            const statPickup = document.getElementById('statPickup');
            
            if (statMaxHp) {
                statMaxHp.textContent = maxHp;
                statMaxHp.classList.toggle('boosted', maxHp > 120);
            }
            if (statRegen) {
                statRegen.textContent = `${regenRate}/s`;
                statRegen.classList.toggle('boosted', parseFloat(regenRate) > 1.5);
            }
            if (statArmor) {
                statArmor.textContent = `${armorPercent}%`;
                statArmor.classList.toggle('boosted', armorPercent > 0);
            }
            if (statShield) {
                statShield.textContent = shieldHp;
                statShield.classList.toggle('boosted', shieldHp > 0);
            }
            if (statSpeed) {
                statSpeed.textContent = `${speedPercent}%`;
                statSpeed.classList.toggle('boosted', speedPercent > 100);
            }
            if (statPickup) {
                statPickup.textContent = `${pickupPercent}%`;
                statPickup.classList.toggle('boosted', pickupPercent > 100);
            }
        }
        
        // Move minimap canvas to trackpad area
        function setupTrackpadMinimap() {
            const wrapper = document.getElementById('trackpadMinimapWrapper');
            const minimapCanvas = document.getElementById('minimapCanvas');
            if (wrapper && minimapCanvas && !wrapper.contains(minimapCanvas)) {
                wrapper.appendChild(minimapCanvas);
                minimapCanvas.style.display = 'block';
            }
        }
        
        // Gold display update
        function updateGoldDisplay() {
            const el = document.getElementById('goldCount');
            if (el) el.textContent = playerGold;
        }
        
        // ===== BUFFS BAR UPDATE =====
        function updateBuffsBar() {
            // Buff display removed - stats now shown in stat panels
        }

        function gameLoop(timestamp) {
            const dt = Math.min(timestamp - lastTime, 50); // Cap dt to prevent spiral of death
            lastTime = timestamp;
            frameCount++; // Increment for optimization frame skipping
            
            if (gameRunning && !gamePaused && player) {
                // Apply time slow effect (Temporal Shield)
                let effectiveDt = dt;
                if (legendaryEffects.timeSlow.active && player) {
                    const hpPercent = player.hp / player.maxHp;
                    const now = Date.now();
                    
                    // Trigger when below 30% HP and off cooldown
                    if (hpPercent < 0.3 && !legendaryEffects.timeSlow.isSlowed && now > legendaryEffects.timeSlow.cooldownEnd) {
                        legendaryEffects.timeSlow.isSlowed = true;
                        legendaryEffects.timeSlow.effectEnd = now + 8000; // 8 seconds
                        legendaryEffects.timeSlow.regenBoostEnd = now + 8000;
                        timeSlowMultiplier = 0.4; // 60% slower
                        spawnParticles(player.x, player.y, '#9966ff', 25);
                    }
                    
                    // Check if effect should end
                    if (legendaryEffects.timeSlow.isSlowed && now >= legendaryEffects.timeSlow.effectEnd) {
                        legendaryEffects.timeSlow.isSlowed = false;
                        legendaryEffects.timeSlow.cooldownEnd = now + 60000; // 1 minute cooldown
                        timeSlowMultiplier = 1;
                    }
                    
                    // Apply time slow to enemy updates
                    if (legendaryEffects.timeSlow.isSlowed) {
                        effectiveDt = dt * timeSlowMultiplier;
                    }
                }
                
                // Time stop from hourglass power drop - completely freeze enemies
                if (timeStopActive) {
                    effectiveDt = 0;
                }
                
                gameTime += dt / 1000;
                
                // Legendary XP Magnet - 30 second pulse
                if (legendaryEffects.xpMagnet.active && player) {
                    const timeSinceLastPulse = gameTime - legendaryEffects.xpMagnet.lastPulse;
                    if (timeSinceLastPulse >= 30 && xpGems.length > 0) {
                        legendaryEffects.xpMagnet.lastPulse = gameTime;
                        magnetPulseActive = true;
                        spawnParticles(player.x, player.y, '#ffd700', 25);
                        
                        setTimeout(() => {
                            magnetPulseActive = false;
                        }, 2000);
                    }
                }
                
                // Stillness healing - heal when not moving
                if (legendaryEffects.stillness.active && player) {
                    const isMoving = input.left || input.right || input.up || input.down || 
                                     Math.abs(input.joystickX) > 0.1 || Math.abs(input.joystickY) > 0.1;
                    if (!isMoving) {
                        // Standing still - heal 5 HP/s
                        const healAmount = 5 * (dt / 1000);
                        player.heal(healAmount);
                        // Occasional visual
                        if (Math.random() < 0.05) {
                            spawnParticles(player.x, player.y, '#88ffaa', 3);
                        }
                    }
                }
                
                // Update
                if (!player) return;
                player.update(dt, input);
                camera.update();
                updateFogOfWar();
                spawnEnemies(effectiveDt);
                updateShrineSpawning(dt);
                updateLeprechaunSpawning(dt);
                updateBossSpawning(dt);
                
                // Update enemies with distance-based culling for performance
                const cullDistance = 800; // Full update within this distance
                const skipDistance = 1500; // Skip updates beyond this
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                    if (dist < cullDistance) {
                        enemy.update(effectiveDt);
                    } else if (dist < skipDistance) {
                        // Reduced update rate for distant enemies (every other frame)
                        if (frameCount % 2 === 0) enemy.update(effectiveDt * 2);
                    }
                    // Very distant enemies don't update (will catch up when closer)
                }
                for (const proj of projectiles) proj.update(dt);
                
                // Batch XP gem updates - only update visible/nearby gems every frame
                const gemUpdateRadius = 600;
                for (const gem of xpGems) {
                    if (gem.magnetized) {
                        gem.update(dt); // Always update magnetized gems
                    } else {
                        const dist = Math.hypot(gem.x - player.x, gem.y - player.y);
                        if (dist < gemUpdateRadius) {
                            gem.update(dt);
                        } else if (frameCount % 3 === 0) {
                            gem.update(dt); // Distant gems update less frequently
                        }
                    }
                }
                
                for (const shrine of shrines) shrine.update(dt);
                for (const lep of leprechauns) {
                    if (!lep.dead) lep.update(effectiveDt);
                }
                for (const rainbow of rainbows) rainbow.update();
                for (const ghost of ghosts) {
                    if (!ghost.dead) ghost.update(dt);
                }
                for (const chest of chests) {
                    if (!chest.dead) chest.update(dt);
                }
                for (const statue of skullStatues) {
                    if (!statue.dead) statue.update(dt);
                }
                for (const boss of bosses) {
                    if (!boss.dead) boss.update(effectiveDt);
                }
                updateChestSpawning(dt);
                updateCowboyHat();
                updateShieldPickups();
                updatePowerDrops();
                updateFairy();
                updateMagnetPickups();
                updateTombstones();
                updateGravityWells(effectiveDt);
                updateMines();
                
                // Clean up dead entities (in-place for performance)
                cleanupArray(enemies, e => e.dead);
                cleanupArray(projectiles, p => p.dead);
                cleanupArray(xpGems, g => g.dead);
                cleanupArray(leprechauns, l => l.dead);
                cleanupArray(rainbows, r => r.dead);
                cleanupArray(ghosts, g => g.dead);
                cleanupArray(chests, c => c.dead);
                cleanupArray(skullStatues, s => s.dead);
                cleanupArray(bosses, b => b.dead);
                
                // Enforce XP gem limit - merge excess gems into larger ones
                if (xpGems.length > LIMITS.xpGems) {
                    // Sort by distance to player (keep closer ones)
                    xpGems.sort((a, b) => {
                        const distA = Math.hypot(a.x - player.x, a.y - player.y);
                        const distB = Math.hypot(b.x - player.x, b.y - player.y);
                        return distA - distB;
                    });
                    // Sum value of removed gems and add to closest gem
                    let bonusValue = 0;
                    for (let i = LIMITS.xpGems; i < xpGems.length; i++) {
                        bonusValue += xpGems[i].value;
                    }
                    xpGems.length = LIMITS.xpGems;
                    if (xpGems.length > 0 && bonusValue > 0) {
                        xpGems[0].value += bonusValue;
                    }
                }
                
                // Update particles with limit
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.03;
                    if (p.life <= 0) {
                        particles[i] = particles[particles.length - 1];
                        particles.pop();
                    }
                }
                // Enforce particle limit
                if (particles.length > LIMITS.particles) {
                    particles.length = LIMITS.particles;
                }
                
                // Update explosion effects
                const explosionDuration = 300;
                for (let i = explosions.length - 1; i >= 0; i--) {
                    const e = explosions[i];
                    const age = Date.now() - e.startTime;
                    if (age > explosionDuration) {
                        explosions.splice(i, 1);
                    } else {
                        e.radius = (age / explosionDuration) * e.maxRadius;
                    }
                }
                
                // Update damage numbers with limit
                for (let i = damageNumbers.length - 1; i >= 0; i--) {
                    const d = damageNumbers[i];
                    d.y += d.vy;
                    d.life -= 0.02;
                    if (d.life <= 0) {
                        damageNumbers[i] = damageNumbers[damageNumbers.length - 1];
                        damageNumbers.pop();
                    }
                }
                if (damageNumbers.length > LIMITS.damageNumbers) {
                    damageNumbers.length = LIMITS.damageNumbers;
                }
                
                // Update HUD (using cached DOM elements)
                DOM.trackpadHpFill.style.width = `${(player.hp / player.maxHp) * 100}%`;
                DOM.trackpadXpFill.style.width = `${(player.xp / player.xpToNext) * 100}%`;
                DOM.levelDisplay.textContent = player.level;
                
                // Timer
                const minutes = Math.floor(gameTime / 60);
                const seconds = Math.floor(gameTime % 60);
                DOM.timer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Update mobile HUD
                updateTrackpadHUD();
            }
            
            // Update death animation (runs even when paused)
            updateDeathAnimation();
            
            // Render
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // Grid background (scrolls with camera, scales with zoom)
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const worldGridSize = 60; // World units per grid cell
            const screenGridSize = worldGridSize * camera.zoom;
            
            // Calculate grid offset based on camera position in world space
            const gridOffsetX = (camera.x % worldGridSize) * camera.zoom;
            const gridOffsetY = (camera.y % worldGridSize) * camera.zoom;
            
            for (let x = -gridOffsetX; x < gameWidth + screenGridSize; x += screenGridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, gameHeight);
                ctx.stroke();
            }
            for (let y = -gridOffsetY; y < gameHeight + screenGridSize; y += screenGridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(gameWidth, y);
                ctx.stroke();
            }
            
            // World boundary indicator (dotted purple)
            ctx.strokeStyle = '#9b30ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.strokeRect(
                camera.screenX(0), 
                camera.screenY(0), 
                WORLD.width * camera.zoom, 
                WORLD.height * camera.zoom
            );
            ctx.setLineDash([]);
            
            if (!gameRunning) return;
            
            // Draw terrain obstacles (lakes/mountains - background)
            drawTerrain();
            
            // Draw environment decorations (trees)
            drawDecorations();
            
            // Draw shrines first (under everything)
            for (const shrine of shrines) shrine.draw();
            
            // Draw treasure chests
            for (const chest of chests) {
                if (!chest.dead) chest.draw();
            }
            
            // Draw skull statues
            for (const statue of skullStatues) {
                if (!statue.dead) statue.draw();
            }
            
            // Draw cowboy hat pickup
            drawCowboyHat();
            
            // Draw shield pickups
            drawShieldPickups();
            
            // Draw healing fairy
            drawFairy();
            
            // Draw magnet pickups
            drawMagnetPickups();
            
            // Draw tombstones
            drawTombstones();
            
            // Draw rainbows (behind everything else)
            for (const rainbow of rainbows) rainbow.draw();
            
            // Draw entities
            for (const gem of xpGems) gem.draw();
            
            // Draw power drops (heart, shoe, hourglass) above XP gems
            drawPowerDrops();
            
            for (const enemy of enemies) {
                if (!enemy.dead) enemy.draw();
            }
            for (const lep of leprechauns) {
                if (!lep.dead) lep.draw();
            }
            for (const ghost of ghosts) {
                if (!ghost.dead) ghost.draw();
            }
            for (const boss of bosses) {
                if (!boss.dead) boss.draw();
            }
            
            // Draw gravity wells (under player)
            if (player && player.weapons.gravityWell) {
                const state = player.weapons.gravityWell;
                if (state.wells) {
                    for (const well of state.wells) {
                        if (!camera.isVisible(well.x, well.y, well.pullRadius)) continue;
                        const sx = camera.screenX(well.x);
                        const sy = camera.screenY(well.y);
                        const vr = camera.scale(well.visualRadius || well.pullRadius * 0.65);
                        const now = Date.now();
                        const age = (now - well.startTime) / well.duration;
                        const alpha = age < 0.05 ? age * 20 : age > 0.8 ? (1 - age) * 5 : 1;
                        const spin = now * 0.005;
                        
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#9933ff';
                        for (let i = 0; i < 10; i++) {
                            const angle = spin + (i / 10) * Math.PI * 2;
                            const spiralR = vr * (0.7 + 0.25 * ((Math.sin(spin * 2 + i) + 1) / 2));
                            const px = sx + Math.cos(angle) * spiralR;
                            const py = sy + Math.sin(angle) * spiralR;
                            const size = 2 + Math.sin(now * 0.01 + i) * 1;
                            ctx.fillStyle = `rgba(153, 51, 255, ${0.5 + Math.sin(i + spin) * 0.2})`;
                            ctx.beginPath();
                            ctx.arc(px, py, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = '#6600cc';
                        for (let arm = 0; arm < 3; arm++) {
                            const armOffset = (arm / 3) * Math.PI * 2;
                            ctx.strokeStyle = `rgba(102, 0, 204, ${0.7 - arm * 0.15})`;
                            ctx.beginPath();
                            for (let t = 0; t < 1; t += 0.05) {
                                const angle = spin + armOffset + t * Math.PI * 2;
                                const spiralR = vr * 0.15 + vr * 0.8 * t;
                                const px = sx + Math.cos(angle) * spiralR;
                                const py = sy + Math.sin(angle) * spiralR;
                                if (t === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                        }
                        
                        ctx.strokeStyle = 'rgba(153, 51, 255, 0.4)';
                        ctx.lineWidth = vr * 0.12;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#9933ff';
                        ctx.beginPath();
                        ctx.arc(sx, sy, vr * 0.85, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, vr * 0.45);
                        grad.addColorStop(0, 'rgba(0, 0, 0, 0.95)');
                        grad.addColorStop(0.5, 'rgba(30, 0, 60, 0.7)');
                        grad.addColorStop(0.85, 'rgba(102, 0, 204, 0.4)');
                        grad.addColorStop(1, 'transparent');
                        ctx.fillStyle = grad;
                        ctx.shadowBlur = 0;
                        ctx.beginPath();
                        ctx.arc(sx, sy, vr * 0.45, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(sx, sy, vr * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
            }
            
            // Draw pulse mines (under player)
            if (player && player.weapons.pulseMine) {
                const state = player.weapons.pulseMine;
                const def = WEAPONS.pulseMine;
                if (state.mines) {
                    const now = Date.now();
                    for (const mine of state.mines) {
                        if (mine.exploded) continue;
                        if (!camera.isVisible(mine.x, mine.y, 30)) continue;
                        const sx = camera.screenX(mine.x);
                        const sy = camera.screenY(mine.y);
                        const r = camera.scale(18);
                        const armed = now - mine.startTime > mine.armTime;
                        
                        ctx.save();
                        
                        // Pulsing glow when armed
                        if (armed) {
                            const pulse = 0.5 + Math.sin(now * 0.01) * 0.5;
                            ctx.shadowBlur = 15 + pulse * 10;
                            ctx.shadowColor = def.color;
                            ctx.fillStyle = def.color;
                        } else {
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#666';
                            ctx.fillStyle = '#666';
                        }
                        
                        // Mine body
                        ctx.beginPath();
                        ctx.arc(sx, sy, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Inner core
                        ctx.fillStyle = armed ? '#fff' : '#888';
                        ctx.beginPath();
                        ctx.arc(sx, sy, r * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Spikes
                        ctx.fillStyle = armed ? def.color : '#555';
                        for (let i = 0; i < 4; i++) {
                            const angle = (i / 4) * Math.PI * 2 + now * 0.002;
                            ctx.beginPath();
                            ctx.moveTo(sx + Math.cos(angle) * r, sy + Math.sin(angle) * r);
                            ctx.lineTo(sx + Math.cos(angle - 0.3) * r * 0.7, sy + Math.sin(angle - 0.3) * r * 0.7);
                            ctx.lineTo(sx + Math.cos(angle + 0.3) * r * 0.7, sy + Math.sin(angle + 0.3) * r * 0.7);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                }
            }
            
            // Draw shotgun effects
            if (player && player.weapons.shotgun) {
                const state = player.weapons.shotgun;
                const def = WEAPONS.shotgun;
                const now = Date.now();
                
                // Draw muzzle flash
                if (state.muzzleFlash) {
                    const flash = state.muzzleFlash;
                    const age = now - flash.startTime;
                    if (age < 100) {
                        const progress = age / 100;
                        const flashAlpha = 1 - progress;
                        const flashSize = camera.scale(25 + progress * 30);
                        
                        const sx = camera.screenX(flash.x);
                        const sy = camera.screenY(flash.y);
                        const flashX = sx + Math.cos(flash.angle) * camera.scale(20);
                        const flashY = sy + Math.sin(flash.angle) * camera.scale(20);
                        
                        ctx.save();
                        ctx.globalAlpha = flashAlpha;
                        
                        // Outer orange glow
                        ctx.shadowBlur = 40;
                        ctx.shadowColor = def.color;
                        ctx.fillStyle = def.color;
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, flashSize * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Inner white-yellow flash
                        ctx.fillStyle = '#ffff88';
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, flashSize * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Core white
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(flashX, flashY, flashSize * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Spread lines (shotgun blast effect)
                        ctx.strokeStyle = '#ffcc44';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 8; i++) {
                            const lineAngle = flash.angle + (i - 3.5) * 0.15;
                            const lineLength = flashSize * (1.5 + Math.random() * 0.5) * (1 - progress * 0.5);
                            ctx.globalAlpha = flashAlpha * 0.8;
                            ctx.beginPath();
                            ctx.moveTo(flashX, flashY);
                            ctx.lineTo(
                                flashX + Math.cos(lineAngle) * lineLength,
                                flashY + Math.sin(lineAngle) * lineLength
                            );
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                }
                
                // Draw pellets
                if (state.pellets) {
                    for (const pellet of state.pellets) {
                        if (pellet.hit) continue;
                        if (!camera.isVisible(pellet.x, pellet.y, 10)) continue;
                        
                        const sx = camera.screenX(pellet.x);
                        const sy = camera.screenY(pellet.y);
                        const age = now - pellet.startTime;
                        const fadeAlpha = Math.max(0, 1 - age / 400);
                        
                        ctx.save();
                        ctx.globalAlpha = fadeAlpha;
                        
                        // Pellet glow
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = def.color;
                        
                        // Trail
                        const trailLength = camera.scale(12);
                        const angle = Math.atan2(pellet.vy, pellet.vx);
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = camera.scale(3);
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(
                            sx - Math.cos(angle) * trailLength,
                            sy - Math.sin(angle) * trailLength
                        );
                        ctx.stroke();
                        
                        // Pellet core
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(sx, sy, camera.scale(3), 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
            }
            
            // Draw projectiles (under player)
            for (const proj of projectiles) proj.draw();
            
            // Draw player and trees with proper Y-sorting (player appears ON TOP of weapons/projectiles)
            drawTreesAndPlayer();
            
            // Draw explosion effects
            for (const e of explosions) {
                if (!camera.isVisible(e.x, e.y, e.maxRadius)) continue;
                const sx = camera.screenX(e.x);
                const sy = camera.screenY(e.y);
                const progress = e.radius / e.maxRadius;
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Outer glow ring
                ctx.strokeStyle = e.color;
                ctx.shadowBlur = 30;
                ctx.shadowColor = e.color;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(sx, sy, camera.scale(e.radius), 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner bright ring
                ctx.strokeStyle = '#fff';
                ctx.shadowColor = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(sx, sy, camera.scale(e.radius * 0.8), 0, Math.PI * 2);
                ctx.stroke();
                
                // Core flash (early in explosion)
                if (progress < 0.3) {
                    ctx.globalAlpha = (0.3 - progress) * 3;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(sx, sy, camera.scale(e.radius * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            // Particles (batched rendering)
            ctx.save();
            for (const p of particles) {
                if (!camera.isVisible(p.x, p.y, 20)) continue;
                const sx = camera.screenX(p.x);
                const sy = camera.screenY(p.y);
                ctx.globalAlpha = p.life / (p.maxLife || 1);
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = p.color;
                
                if (p.isScratch) {
                    // Draw scratch marks as angled lines
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    const len = camera.scale(p.size * 2);
                    const angle = Math.atan2(p.vy, p.vx);
                    ctx.beginPath();
                    ctx.moveTo(sx - Math.cos(angle) * len, sy - Math.sin(angle) * len);
                    ctx.lineTo(sx + Math.cos(angle) * len, sy + Math.sin(angle) * len);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(sx, sy, camera.scale(p.size) * p.life, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
            
            // Draw fairy healing spell effect
            drawFairySpell();
            
            // Draw death animation
            drawDeathAnimation();
            
            // Draw startup message
            drawStartupMessage();
            
            // Damage numbers (batched rendering)
            ctx.save();
            for (const d of damageNumbers) {
                if (!camera.isVisible(d.x, d.y, 30)) continue;
                const sx = camera.screenX(d.x);
                const sy = camera.screenY(d.y);
                ctx.globalAlpha = d.life;
                
                if (d.isCrit) {
                    ctx.font = `bold ${camera.scale(19)}px sans-serif`;
                    ctx.fillStyle = COLORS.yellow;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = COLORS.orange;
                    ctx.fillText(d.damage + '!', sx, sy);
                } else {
                    ctx.font = `bold ${camera.scale(15)}px sans-serif`;
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = COLORS.orange;
                    ctx.fillText(d.damage, sx, sy);
                }
            }
            ctx.restore();
            
            // Time stop visual effect (purple tint when active)
            if (timeStopActive) {
                const pulse = 0.08 + Math.sin(Date.now() * 0.005) * 0.04;
                ctx.fillStyle = `rgba(170, 100, 255, ${pulse})`;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
                
                // Purple vignette edges
                const gradient = ctx.createRadialGradient(
                    gameWidth / 2, gameHeight / 2, gameHeight * 0.4,
                    gameWidth / 2, gameHeight / 2, gameHeight * 0.8
                );
                gradient.addColorStop(0, 'rgba(170, 100, 255, 0)');
                gradient.addColorStop(1, `rgba(170, 100, 255, ${pulse + 0.1})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
            }
            
            // Speed boost visual effect (subtle orange glow at edges)
            if (speedBoostActive) {
                const pulse = 0.05 + Math.sin(Date.now() * 0.008) * 0.03;
                const gradient = ctx.createRadialGradient(
                    gameWidth / 2, gameHeight / 2, gameHeight * 0.5,
                    gameWidth / 2, gameHeight / 2, gameHeight * 0.9
                );
                gradient.addColorStop(0, 'rgba(255, 170, 0, 0)');
                gradient.addColorStop(1, `rgba(255, 170, 0, ${pulse})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
            }
            
            // Low health warning flash
            if (player && player.hp / player.maxHp < 0.3) {
                const pulse = 0.15 + Math.sin(Date.now() * 0.008) * 0.1;
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
                
                // Red vignette edges
                const gradient = ctx.createRadialGradient(
                    gameWidth / 2, gameHeight / 2, gameHeight * 0.3,
                    gameWidth / 2, gameHeight / 2, gameHeight * 0.7
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(255, 0, 0, ${pulse + 0.15})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
            }
            
            // Minimap
            drawMinimap();
        }

        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const mapSize = 156; // Fixed size - CSS handles display scaling
        
        function drawMinimap() {
            const scale = mapSize / WORLD.width;
            const fogCellScale = FOG_CELL_SIZE * scale;
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, mapSize, mapSize);
            
            // Draw fog of war (unexplored = dark, explored = slightly visible)
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            minimapCtx.fillRect(0, 0, mapSize, mapSize);
            
            // Draw explored areas
            minimapCtx.fillStyle = 'rgba(20, 20, 40, 0.9)';
            for (let cy = 0; cy < FOG_GRID_SIZE; cy++) {
                for (let cx = 0; cx < FOG_GRID_SIZE; cx++) {
                    if (fogGrid[cy] && fogGrid[cy][cx]) {
                        minimapCtx.fillRect(
                            cx * fogCellScale,
                            cy * fogCellScale,
                            fogCellScale + 0.5,
                            fogCellScale + 0.5
                        );
                    }
                }
            }
            
            // Draw lakes on minimap (only in explored areas)
            minimapCtx.fillStyle = 'rgba(30, 80, 120, 0.8)';
            minimapCtx.strokeStyle = 'rgba(60, 140, 180, 0.6)';
            minimapCtx.lineWidth = 1;
            for (const obs of terrainObstacles) {
                if (obs.type !== 'lake') continue;
                
                // Check if any part of lake is explored
                const lakeExplored = isExplored(obs.x, obs.y) || 
                    isExplored(obs.x + obs.radiusX * 0.7, obs.y) ||
                    isExplored(obs.x - obs.radiusX * 0.7, obs.y) ||
                    isExplored(obs.x, obs.y + obs.radiusY * 0.7) ||
                    isExplored(obs.x, obs.y - obs.radiusY * 0.7);
                    
                if (!lakeExplored) continue;
                
                const lx = obs.x * scale;
                const ly = obs.y * scale;
                const lrx = obs.radiusX * scale;
                const lry = obs.radiusY * scale;
                
                minimapCtx.beginPath();
                minimapCtx.ellipse(lx, ly, lrx, lry, 0, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Viewport indicator (always visible)
            const viewWidth = gameWidth / camera.zoom;
            const viewHeight = gameHeight / camera.zoom;
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scale,
                camera.y * scale,
                viewWidth * scale,
                viewHeight * scale
            );
            
            // Only show entities in explored areas
            
            // Enemies (as small dots) - only in explored areas
            minimapCtx.fillStyle = COLORS.magenta;
            for (const enemy of enemies) {
                if (enemy.dead) continue;
                if (!isExplored(enemy.x, enemy.y)) continue;
                const ex = enemy.x * scale;
                const ey = enemy.y * scale;
                minimapCtx.fillRect(ex - 1, ey - 1, 2, 2);
            }
            
            // XP gems - only in explored areas
            minimapCtx.fillStyle = COLORS.cyan;
            for (const gem of xpGems) {
                if (!isExplored(gem.x, gem.y)) continue;
                const gx = gem.x * scale;
                const gy = gem.y * scale;
                minimapCtx.fillRect(gx, gy, 1, 1);
            }
            
            // Shrines - only in explored areas
            minimapCtx.fillStyle = COLORS.shrine;
            for (const shrine of shrines) {
                if (shrine.activated) continue;
                if (!isExplored(shrine.x, shrine.y)) continue;
                const shx = shrine.x * scale;
                const shy = shrine.y * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(shx, shy, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }
            
            // Treasure chests - only in explored areas
            for (const chest of chests) {
                if (chest.dead || chest.opened) continue;
                if (!isExplored(chest.x, chest.y)) continue;
                minimapCtx.fillStyle = chest.isFree ? COLORS.gold : '#c0c0c0';
                const cx = chest.x * scale;
                const cy = chest.y * scale;
                minimapCtx.fillRect(cx - 2, cy - 2, 4, 4);
            }
            
            // Skull statues - only in explored areas
            for (const statue of skullStatues) {
                if (statue.dead) continue;
                if (!isExplored(statue.x, statue.y)) continue;
                minimapCtx.fillStyle = '#880088';
                minimapCtx.strokeStyle = '#cc44cc';
                minimapCtx.lineWidth = 1;
                const stx = statue.x * scale;
                const sty = statue.y * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(stx, sty, 4, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Leprechauns - only in explored areas
            for (const lep of leprechauns) {
                if (lep.dead) continue;
                if (!isExplored(lep.x, lep.y)) continue;
                const lx = lep.x * scale;
                const ly = lep.y * scale;
                minimapCtx.fillStyle = COLORS.green;
                minimapCtx.strokeStyle = COLORS.gold;
                minimapCtx.lineWidth = 1;
                minimapCtx.beginPath();
                minimapCtx.arc(lx, ly, 4, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Bosses - only in explored areas
            for (const boss of bosses) {
                if (boss.dead) continue;
                if (!isExplored(boss.x, boss.y)) continue;
                const bx = boss.x * scale;
                const by = boss.y * scale;
                minimapCtx.fillStyle = boss.color;
                minimapCtx.strokeStyle = '#ffffff';
                minimapCtx.lineWidth = 2;
                minimapCtx.beginPath();
                minimapCtx.arc(bx, by, boss.bossType === 'major' ? 7 : 5, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Cowboy hat - only in explored areas, before picked up
            if (cowboyHat && !playerHasCowboyHat && isExplored(cowboyHat.x, cowboyHat.y)) {
                const hx = cowboyHat.x * scale;
                const hy = cowboyHat.y * scale;
                minimapCtx.fillStyle = '#8B4513';
                minimapCtx.strokeStyle = '#ffd700';
                minimapCtx.lineWidth = 1;
                minimapCtx.beginPath();
                minimapCtx.arc(hx, hy, 4, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Shield pickups - only in explored areas, before collected
            for (const shield of shieldPickups) {
                if (shield.collected) continue;
                if (!isExplored(shield.x, shield.y)) continue;
                
                const shx = shield.x * scale;
                const shy = shield.y * scale;
                minimapCtx.fillStyle = '#4488ff';
                minimapCtx.strokeStyle = '#66aaff';
                minimapCtx.lineWidth = 1;
                minimapCtx.beginPath();
                minimapCtx.arc(shx, shy, 4, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Player (always visible)
            minimapCtx.fillStyle = selectedPlayerColor;
            minimapCtx.shadowBlur = 5;
            minimapCtx.shadowColor = selectedPlayerColor;
            const px = player.x * scale;
            const py = player.y * scale;
            minimapCtx.beginPath();
            minimapCtx.arc(px, py, 4, 0, Math.PI * 2);
            minimapCtx.fill();
            minimapCtx.shadowBlur = 0;
        }

        // ===== GAME START/END =====
        
        // Selected starting weapon (default to energyBolt)
        let selectedStartingWeapon = 'energyBolt';
        
        // Disabled weapons (won't appear in upgrade pool) - persisted
        let disabledWeapons = new Set(JSON.parse(localStorage.getItem('disabledWeapons') || '[]'));
        let weaponEditMode = false;
        const MAX_DISABLED_WEAPONS = 5;
        
        // Disabled tomes (won't appear in upgrade pool) - persisted
        let disabledTomes = new Set(JSON.parse(localStorage.getItem('disabledTomes') || '[]'));
        const MAX_DISABLED_TOMES = 3;
        
        // Banished weapons (removed for current run only)
        let banishedWeapons = new Set();
        
        // Available starting weapons
        const STARTING_WEAPONS = [
            'energyBolt', 'boomBox', 'plasmaOrbit', 'blackSquirrel', 
            'laserBeam', 'voidDaggers', 'flameThrower', 'iceShard',
            'thunderStrike', 'chainLightning', 'toxicAura', 'boomerang',
            'spectralArrows', 'ricochetDisc', 'gravityWell',
            'starField', 'meteorStrike', 'spiritOrbs', 'pulseMine',
            'shotgun'
        ];
        
        // Player color options (neon palette, cold to hot)
        const PLAYER_COLORS = [
            '#4466ff', // Dark Blue (coldest)
            '#9b30ff', // Purple
            '#00ffff', // Cyan
            '#39ff14', // Neon Green
            '#ffff00', // Yellow
            '#ff6600', // Orange
            '#ff00ff'  // Magenta (hottest)
        ];
        let selectedPlayerColor = PLAYER_COLORS[2]; // Default to Cyan
        
        function showWeaponSelect() {
            DOM.menuOverlay.classList.add('hidden');
            DOM.weaponSelectOverlay.classList.add('active');
            
            // Reset selection state
            pendingWeaponSelect = null;
            weaponEditMode = false;
            DOM.weaponSelectDesc.textContent = '';
            DOM.weaponConfirmBtn.classList.add('disabled');
            
            // Remove edit mode class
            DOM.weaponSelectGrid.classList.remove('edit-mode');
            
            // Add edit pool button if not exists
            let editBtnContainer = DOM.weaponSelectOverlay.querySelector('.edit-btn-container');
            if (!editBtnContainer) {
                editBtnContainer = document.createElement('div');
                editBtnContainer.className = 'edit-btn-container';
                editBtnContainer.style.cssText = 'text-align: center; margin-bottom: 10px;';
                DOM.weaponSelectGrid.parentNode.insertBefore(editBtnContainer, DOM.weaponSelectGrid);
            }
            editBtnContainer.innerHTML = `
                <span class="disabled-count" id="disabledCount">(${disabledWeapons.size}/${MAX_DISABLED_WEAPONS} disabled)</span>
                <button class="edit-pool-btn" id="editPoolBtn">Edit Weapons</button>
                <button class="edit-tomes-btn" id="editTomesBtn">Edit Tomes</button>
                <span class="disabled-count" id="tomeCountDisplay">(${disabledTomes.size}/${MAX_DISABLED_TOMES} disabled)</span>
            `;
            
            document.getElementById('editPoolBtn').onclick = toggleEditMode;
            document.getElementById('editTomesBtn').onclick = showTomeEditor;
            
            // Populate weapon grid
            DOM.weaponSelectGrid.innerHTML = '';
            
            for (const weaponId of STARTING_WEAPONS) {
                const weapon = WEAPONS[weaponId];
                if (!weapon) continue;
                
                const card = document.createElement('div');
                card.className = 'weapon-select-card';
                if (disabledWeapons.has(weaponId)) {
                    card.classList.add('disabled-weapon');
                }
                card.dataset.weaponId = weaponId;
                card.style.borderColor = weapon.color + '66';
                
                // Custom boombox SVG icon
                let iconContent = weapon.icon;
                if (weaponId === 'boomBox') {
                    iconContent = `<svg viewBox="0 0 48 36" width="53" height="40" style="filter: drop-shadow(0 0 4px ${weapon.color});">
                        <!-- Handle -->
                        <path d="M12 8 Q24 2 36 8" stroke="#666" stroke-width="3" fill="none" stroke-linecap="round"/>
                        <!-- Body -->
                        <rect x="4" y="8" width="40" height="24" rx="3" fill="#444" stroke="${weapon.color}" stroke-width="1.5"/>
                        <!-- Left speaker -->
                        <circle cx="14" cy="20" r="8" fill="#222" stroke="${weapon.color}" stroke-width="1"/>
                        <circle cx="14" cy="20" r="3" fill="${weapon.color}" opacity="0.6"/>
                        <!-- Right speaker -->
                        <circle cx="34" cy="20" r="8" fill="#222" stroke="${weapon.color}" stroke-width="1"/>
                        <circle cx="34" cy="20" r="3" fill="${weapon.color}" opacity="0.6"/>
                        <!-- Center cassette -->
                        <rect x="20" y="15" width="8" height="10" fill="#333" stroke="#555" stroke-width="0.5"/>
                    </svg>`;
                } else if (weaponId === 'shotgun') {
                    iconContent = `<img src="${SHOTGUN_ICON_SVG}" width="43" height="19" style="filter: drop-shadow(0 0 4px ${weapon.color}); object-fit: contain; margin-left: 3px;">`;
                }
                
                card.innerHTML = `
                    <div class="weapon-toggle"></div>
                    <div class="weapon-icon">${iconContent}</div>
                    <div class="weapon-name" style="color: ${weapon.color};">${weapon.name}</div>
                    <div class="weapon-desc">${weapon.desc}</div>
                `;
                
                card.addEventListener('click', () => handleWeaponCardClick(weaponId));
                card.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleWeaponCardClick(weaponId);
                });
                
                DOM.weaponSelectGrid.appendChild(card);
            }
            
            // Populate color selector
            DOM.colorSelectorGrid.innerHTML = '';
            
            for (const color of PLAYER_COLORS) {
                const option = document.createElement('div');
                option.className = 'color-option' + (color === selectedPlayerColor ? ' selected' : '');
                option.style.backgroundColor = color;
                option.style.color = color;
                option.dataset.color = color;
                
                option.addEventListener('click', () => selectPlayerColor(color));
                option.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    selectPlayerColor(color);
                });
                
                DOM.colorSelectorGrid.appendChild(option);
            }
        }
        
        let pendingWeaponSelect = null;
        
        function toggleEditMode() {
            weaponEditMode = !weaponEditMode;
            const btn = document.getElementById('editPoolBtn');
            
            if (weaponEditMode) {
                DOM.weaponSelectGrid.classList.add('edit-mode');
                btn.classList.add('active');
                btn.textContent = '✓ Done Editing';
                DOM.weaponSelectDesc.textContent = 'Choose which weapons will be offered as upgrades';
                DOM.weaponSelectDesc.style.color = '#fff';
                DOM.weaponConfirmBtn.classList.add('disabled');
                
                // Deselect any selected weapon
                const cards = DOM.weaponSelectGrid.querySelectorAll('.weapon-select-card');
                cards.forEach(card => card.classList.remove('selected'));
                pendingWeaponSelect = null;
            } else {
                DOM.weaponSelectGrid.classList.remove('edit-mode');
                btn.classList.remove('active');
                btn.textContent = 'Edit Weapons';
                DOM.weaponSelectDesc.textContent = '';
            }
        }
        
        function handleWeaponCardClick(weaponId) {
            if (weaponEditMode) {
                toggleWeaponDisabled(weaponId);
            } else {
                highlightWeapon(weaponId);
            }
        }
        
        function toggleWeaponDisabled(weaponId) {
            const card = DOM.weaponSelectGrid.querySelector(`[data-weapon-id="${weaponId}"]`);
            
            if (disabledWeapons.has(weaponId)) {
                // Re-enable
                disabledWeapons.delete(weaponId);
                card.classList.remove('disabled-weapon');
            } else {
                // Check limit
                if (disabledWeapons.size >= MAX_DISABLED_WEAPONS) {
                    DOM.weaponSelectDesc.textContent = `Maximum ${MAX_DISABLED_WEAPONS} weapons can be disabled!`;
                    DOM.weaponSelectDesc.style.color = '#ff4444';
                    return;
                }
                // Disable
                disabledWeapons.add(weaponId);
                card.classList.add('disabled-weapon');
            }
            
            // Save to localStorage
            localStorage.setItem('disabledWeapons', JSON.stringify([...disabledWeapons]));
            
            // Update count display
            document.getElementById('disabledCount').textContent = `(${disabledWeapons.size}/${MAX_DISABLED_WEAPONS} disabled)`;
            DOM.weaponSelectDesc.textContent = 'Choose which weapons will be offered as upgrades';
            DOM.weaponSelectDesc.style.color = '#fff';
        }
        
        // ===== TOME EDITOR =====
        let tomeEditorMode = 'info'; // 'info' or 'edit'
        
        function showTomeEditor() {
            DOM.tomeEditorOverlay.classList.add('active');
            
            // Reset to info mode
            tomeEditorMode = 'info';
            DOM.tomeModeBtn.textContent = 'Edit';
            DOM.tomeModeBtn.classList.add('active');
            DOM.tomeEditorGrid.classList.remove('edit-mode');
            
            // Clear description
            DOM.tomeEditorDesc.textContent = 'Click a tome to see its description';
            
            // Populate tome grid
            DOM.tomeEditorGrid.innerHTML = '';
            
            for (const [tomeId, tome] of Object.entries(TOMES)) {
                const card = document.createElement('div');
                card.className = 'tome-select-card';
                if (disabledTomes.has(tomeId)) {
                    card.classList.add('disabled-tome');
                }
                card.dataset.tomeId = tomeId;
                card.style.borderColor = tome.color + '66';
                
                card.innerHTML = `
                    <div class="tome-toggle"></div>
                    <div class="tome-icon-wrapper">
                        <span style="opacity: 0.6;">📖</span>
                        <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.5em;">${tome.icon}</span>
                    </div>
                    <div class="tome-name" style="color: ${tome.color};">${tome.name.replace('Tome of ', '')}</div>
                    <div class="tome-desc">${tome.desc}</div>
                `;
                
                card.addEventListener('click', () => handleTomeCardClick(tomeId));
                card.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleTomeCardClick(tomeId);
                });
                
                DOM.tomeEditorGrid.appendChild(card);
            }
            
            // Set up mode button handler
            DOM.tomeModeBtn.onclick = () => toggleTomeEditorMode();
            
            // Update count display
            updateTomeDisabledCount();
        }
        
        function toggleTomeEditorMode() {
            if (tomeEditorMode === 'info') {
                setTomeEditorMode('edit');
            } else {
                setTomeEditorMode('info');
            }
        }
        
        function setTomeEditorMode(mode) {
            tomeEditorMode = mode;
            
            if (mode === 'info') {
                DOM.tomeModeBtn.textContent = 'Edit';
                DOM.tomeEditorGrid.classList.remove('edit-mode');
                DOM.tomeEditorDesc.textContent = 'Click a tome to see its description';
            } else {
                DOM.tomeModeBtn.textContent = 'Info';
                DOM.tomeEditorGrid.classList.add('edit-mode');
                DOM.tomeEditorDesc.textContent = 'Click a tome to enable/disable it';
                // Clear info selection when entering edit mode
                const cards = DOM.tomeEditorGrid.querySelectorAll('.tome-select-card');
                cards.forEach(card => card.classList.remove('info-selected'));
            }
        }
        
        function handleTomeCardClick(tomeId) {
            if (tomeEditorMode === 'info') {
                showTomeInfo(tomeId);
            } else {
                toggleTomeDisabled(tomeId);
            }
        }
        
        function showTomeInfo(tomeId) {
            const tome = TOMES[tomeId];
            DOM.tomeEditorDesc.innerHTML = `<span style="color: ${tome.color};">${tome.name}</span>: ${tome.desc}`;
            
            // Update visual selection
            const cards = DOM.tomeEditorGrid.querySelectorAll('.tome-select-card');
            cards.forEach(card => {
                card.classList.toggle('info-selected', card.dataset.tomeId === tomeId);
            });
        }
        
        function closeTomeEditor() {
            DOM.tomeEditorOverlay.classList.remove('active');
            // Update the count on the weapon select screen
            const tomeCountEl = document.getElementById('tomeCountDisplay');
            if (tomeCountEl) {
                tomeCountEl.textContent = `(${disabledTomes.size}/${MAX_DISABLED_TOMES} disabled)`;
            }
        }
        
        function toggleTomeDisabled(tomeId) {
            const card = DOM.tomeEditorGrid.querySelector(`[data-tome-id="${tomeId}"]`);
            const tome = TOMES[tomeId];
            
            // Show tome description
            DOM.tomeEditorDesc.innerHTML = `<span style="color: ${tome.color};">${tome.name}</span>: ${tome.desc}`;
            
            if (disabledTomes.has(tomeId)) {
                // Re-enable
                disabledTomes.delete(tomeId);
                card.classList.remove('disabled-tome');
            } else {
                // Check limit
                if (disabledTomes.size >= MAX_DISABLED_TOMES) {
                    // Show warning - can't disable more
                    DOM.tomeDisabledCount.textContent = `Maximum ${MAX_DISABLED_TOMES} tomes can be disabled!`;
                    DOM.tomeDisabledCount.style.color = '#ff4444';
                    setTimeout(() => {
                        updateTomeDisabledCount();
                    }, 1500);
                    return;
                }
                // Disable
                disabledTomes.add(tomeId);
                card.classList.add('disabled-tome');
            }
            
            // Save to localStorage
            localStorage.setItem('disabledTomes', JSON.stringify([...disabledTomes]));
            
            // Update count display
            updateTomeDisabledCount();
        }
        
        function updateTomeDisabledCount() {
            DOM.tomeDisabledCount.textContent = `(${disabledTomes.size}/${MAX_DISABLED_TOMES} disabled)`;
            DOM.tomeDisabledCount.style.color = '#888';
        }
        
        // Set up tome editor close button
        DOM.tomeEditorClose.onclick = closeTomeEditor;
        
        function highlightWeapon(weaponId) {
            // Cannot select disabled weapons as starter
            if (disabledWeapons.has(weaponId)) {
                DOM.weaponSelectDesc.textContent = 'This weapon is disabled';
                DOM.weaponSelectDesc.style.color = '#ff4444';
                return;
            }
            
            pendingWeaponSelect = weaponId;
            const weapon = WEAPONS[weaponId];
            
            // Update visual selection
            const cards = DOM.weaponSelectGrid.querySelectorAll('.weapon-select-card');
            cards.forEach(card => {
                card.classList.toggle('selected', card.dataset.weaponId === weaponId);
            });
            
            // Show description with colored name
            DOM.weaponSelectDesc.style.color = '#fff';
            DOM.weaponSelectDesc.innerHTML = `<span style="color: ${weapon.color};">${weapon.name}</span>: ${weapon.desc}`;
            
            // Enable confirm button
            DOM.weaponConfirmBtn.classList.remove('disabled');
        }
        
        function confirmWeaponSelect() {
            if (!pendingWeaponSelect) return;
            // Safety check - don't allow disabled weapons
            if (disabledWeapons.has(pendingWeaponSelect)) return;
            selectedStartingWeapon = pendingWeaponSelect;
            DOM.weaponSelectOverlay.classList.remove('active');
            startGame();
        }
        
        function cancelWeaponSelect() {
            DOM.weaponSelectOverlay.classList.remove('active');
            DOM.menuOverlay.classList.remove('hidden');
        }
        
        function selectPlayerColor(color) {
            selectedPlayerColor = color;
            // Update selection visual
            const options = DOM.colorSelectorGrid.querySelectorAll('.color-option');
            options.forEach(opt => {
                // Compare using data attribute instead of computed style
                const optColor = opt.dataset.color;
                opt.classList.toggle('selected', optColor === color);
            });
        }
        
        function selectWeapon(weaponId) {
            selectedStartingWeapon = weaponId;
            DOM.weaponSelectOverlay.classList.remove('active');
            startGame();
        }
        
        function startGame() {
            gameRunning = true;
            gamePaused = false;
            gameTime = 0;
            kills = 0;
            enemies = [];
            projectiles = [];
            xpGems = [];
            particles = [];
            explosions = [];
            damageNumbers = [];
            shrines = [];
            leprechauns = [];
            rainbows = [];
            ghosts = [];
            chests = [];
            leprechaunSpawnTimer = 0;
            nextLeprechaunSpawn = 90000; // First spawn at 90s
            finalSwarmWarningShown = false; // Reset for new game
            magnetPulseActive = false;
            timeSlowMultiplier = 1;
            frameCount = 0;
            
            // Reset fairy
            fairy = null;
            fairySpellActive = false;
            
            // Reset magnet pickups
            magnetPickups = [];
            
            // Reset power drops
            powerDrops = [];
            powerDropCount = 0;
            lastPowerDropType = null;
            timeStopActive = false;
            timeStopEndTime = 0;
            speedBoostActive = false;
            speedBoostEndTime = 0;
            speedBoostMultiplier = 1;
            
            // Reset death animation
            deathAnimationActive = false;
            
            // Reset tombstones
            tombstones = [];
            extraBossMultiplier = 0;
            pendingTombstone = null;
            
            // Reset boss system
            bosses = [];
            bossCount = 0;
            nextBossTime = 150; // First boss at 2.5 mins
            swarmActive = false;
            swarmEndTime = 0;
            swarmTriggeredForBoss = 0;
            
            // Clear any active warnings
            if (activeWarning) {
                activeWarning.remove();
                activeWarning = null;
            }
            if (warningTimeout) {
                clearTimeout(warningTimeout);
                warningTimeout = null;
            }
            warningQueue = [];
            
            // Reset chest/legendary tracking
            legendaryCount = 0;
            lastLegendaryTime = 0;
            guaranteedLegendaryNext = false;
            chestRespawnTimer = 0;
            
            // Reset gold currency
            playerGold = 0;
            nextChestCost = 5;
            pendingChest = null;
            updateGoldDisplay();
            
            // Reset upgrade variety tracking
            offerHistory = {};
            rerollsRemaining = 3;
            banishesRemaining = 2;
            banishedWeapons.clear();
            
            // Reset all legendary effects
            legendaryEffects = {
                burn: { chance: 0, damage: 0 },
                freeze: { chance: 0, slowAmount: 0 },
                shock: { chance: 0, damage: 0 },
                timeSlow: { active: false, cooldownEnd: 0, isSlowed: false, effectEnd: 0, regenBoostEnd: 0 },
                holyBook: { active: false, maxHpBonus: 0, regenBonus: 0 },
                stillness: { active: false, lifestealBonus: 0 },
                xpMagnet: { active: false, lastPulse: 0, interval: 30000 },
                ghostStrike: { active: false }
            };
            
            // Reset skull statue difficulty system
            skullStatues = [];
            pendingStatue = null;
            difficultyLevel = 0;
            enemyDamageBonus = 1;
            enemyHealthBonus = 1;
            enemySpeedBonus = 1;
            killRewardBonus = 1;
            
            player = new Player();
            initFogGrid();
            spawnTerrain();
            spawnShrines();
            spawnDecorations();
            spawnInitialChests();
            spawnCowboyHat();
            spawnFairy();
            spawnMagnetPickups();
            spawnTombstones();
            spawnShieldPickups();
            spawnInitialSkullStatues();
            
            // Reset combat timer for shield regen
            playerLastCombatTime = 0;
            
            DOM.menuOverlay.classList.add('hidden');
            
            // Reset pause button
            if (DOM.pauseBtn) {
                DOM.pauseBtn.textContent = '⏸';
                DOM.pauseBtn.classList.remove('paused');
            }
            
            const killEl = document.getElementById('killCount');
            if (killEl) killEl.textContent = '0';
            if (DOM.finalStats) DOM.finalStats.style.display = 'none';
            if (DOM.shrineChargeBar) DOM.shrineChargeBar.classList.remove('active');
            updateWeaponsDisplay();
            updateTomesDisplay();
            updateBuffsBar();
            
            // Start the "Upgrade and survive..." message
            startupMessageActive = true;
            startupMessageStart = Date.now();
        }

        // ===== DEATH ANIMATION =====
        function startDeathAnimation(x, y) {
            deathAnimationActive = true;
            deathAnimationStart = Date.now();
            deathAnimationX = x;
            deathAnimationY = y;
            
            // Pause the game but keep rendering
            gamePaused = true;
            
            // Initial explosion of particles
            for (let i = 0; i < 50; i++) {
                spawnParticles(x, y, selectedPlayerColor, 1);
                spawnParticles(x, y, COLORS.pink, 1);
                spawnParticles(x, y, '#ffffff', 1);
            }
        }
        
        function updateDeathAnimation() {
            if (!deathAnimationActive) return;
            
            const elapsed = Date.now() - deathAnimationStart;
            const duration = 2500; // 2.5 second animation
            
            // Spawn trailing particles during animation
            if (elapsed < 1500 && Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 50;
                spawnParticles(
                    deathAnimationX + Math.cos(angle) * dist,
                    deathAnimationY + Math.sin(angle) * dist,
                    ['#00ffff', '#ff00ff', '#ffffff', '#ffff00'][Math.floor(Math.random() * 4)],
                    3
                );
            }
            
            // End animation and show game over
            if (elapsed >= duration) {
                deathAnimationActive = false;
                gamePaused = false;
                gameOver();
            }
        }
        
        function drawStartupMessage() {
            if (!startupMessageActive) return;
            if (!player) return;
            
            const elapsed = Date.now() - startupMessageStart;
            const totalDuration = 3000; // 3 seconds total
            const solidDuration = 1500; // 1.5 seconds solid
            const fadeDuration = 1500; // 1.5 seconds fade
            
            // Check if message should end
            if (elapsed >= totalDuration) {
                startupMessageActive = false;
                return;
            }
            
            // Calculate alpha
            let alpha = 1;
            if (elapsed > solidDuration) {
                // Fading phase
                alpha = 1 - ((elapsed - solidDuration) / fadeDuration);
                alpha = Math.max(0, alpha); // Clamp to 0
            }
            
            // Position: centered horizontally, vertically between player and top
            const playerScreenY = camera.screenY(player.y);
            const centerY = playerScreenY / 2; // Halfway between top (0) and player
            const centerX = gameWidth / 2;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.font = 'bold 28px "Exo 2", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw text with glow (shadow color also needs alpha)
            const cyanAlpha = Math.floor(alpha * 255).toString(16).padStart(2, '0');
            const magentaAlpha = Math.floor(alpha * 127).toString(16).padStart(2, '0');
            
            ctx.shadowBlur = 20;
            ctx.shadowColor = `rgba(0, 255, 255, ${alpha})`;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.fillText('Upgrade and survive...', centerX, centerY);
            
            // Second layer for extra glow
            ctx.shadowBlur = 40;
            ctx.shadowColor = `rgba(255, 0, 255, ${alpha * 0.5})`;
            ctx.fillText('Upgrade and survive...', centerX, centerY);
            
            ctx.restore();
        }
        
        function drawDeathAnimation() {
            if (!deathAnimationActive) return;
            
            const elapsed = Date.now() - deathAnimationStart;
            const duration = 2500;
            const progress = Math.min(elapsed / duration, 1);
            
            const sx = camera.screenX(deathAnimationX);
            const sy = camera.screenY(deathAnimationY);
            
            ctx.save();
            
            // Screen flash (white fade in then out)
            if (progress < 0.15) {
                const flashIntensity = progress / 0.15;
                ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.6})`;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
            } else if (progress < 0.3) {
                const flashIntensity = 1 - ((progress - 0.15) / 0.15);
                ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.6})`;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
            }
            
            // Expanding shockwave rings
            for (let i = 0; i < 3; i++) {
                const ringProgress = Math.max(0, (progress - i * 0.1) * 1.5);
                if (ringProgress > 0 && ringProgress < 1) {
                    const ringRadius = ringProgress * 300;
                    const ringAlpha = (1 - ringProgress) * 0.8;
                    
                    ctx.strokeStyle = i === 0 ? COLORS.cyan : (i === 1 ? COLORS.pink : '#ffffff');
                    ctx.lineWidth = 4 - ringProgress * 3;
                    ctx.globalAlpha = ringAlpha;
                    ctx.beginPath();
                    ctx.arc(sx, sy, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Central dissolving player
            if (progress < 0.6) {
                const dissolveProgress = progress / 0.6;
                const playerRadius = camera.scale(12) * (1 - dissolveProgress * 0.5);
                
                // Flickering effect
                if (Math.random() > dissolveProgress * 0.8) {
                    ctx.globalAlpha = 1 - dissolveProgress;
                    ctx.shadowBlur = 30 - dissolveProgress * 20;
                    ctx.shadowColor = selectedPlayerColor;
                    ctx.fillStyle = selectedPlayerColor;
                    ctx.beginPath();
                    ctx.arc(sx, sy, playerRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner glow
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(sx, sy, playerRadius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Floating soul fragments
            if (progress > 0.2 && progress < 0.9) {
                const fragmentProgress = (progress - 0.2) / 0.7;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 2;
                    const dist = 20 + fragmentProgress * 100;
                    const fragX = sx + Math.cos(angle) * dist;
                    const fragY = sy + Math.sin(angle) * dist - fragmentProgress * 80;
                    
                    ctx.globalAlpha = (1 - fragmentProgress) * 0.8;
                    ctx.fillStyle = i % 2 === 0 ? selectedPlayerColor : COLORS.pink;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.beginPath();
                    ctx.arc(fragX, fragY, 5 - fragmentProgress * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // "DEFEATED" text fade in
            if (progress > 0.5) {
                const textProgress = (progress - 0.5) / 0.5;
                ctx.globalAlpha = textProgress;
                ctx.fillStyle = '#ff4444';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.font = `bold ${36 + textProgress * 10}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('DEFEATED', sx, sy - 60 - textProgress * 20);
            }
            
            // Gradual screen fade to dark at end
            if (progress > 0.7) {
                const fadeProgress = (progress - 0.7) / 0.3;
                ctx.globalAlpha = fadeProgress * 0.7;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, gameWidth, gameHeight);
            }
            
            ctx.restore();
        }

        function gameOver() {
            gameRunning = false;
            
            // Store stats for later display
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            const shrinesActivated = shrines.filter(s => s.activated).length;
            
            window.gameOverStats = {
                time: timeString,
                level: player.level,
                kills: kills,
                shrines: shrinesActivated
            };
            
            // Show score modal for leaderboard submission (pass time instead of level)
            showScoreModal(kills, timeString);
        }
        
        function showGameOverMenu() {
            DOM.menuOverlay.classList.remove('hidden');
            DOM.menuOverlay.querySelector('.game-title').textContent = 'GAME OVER';
            DOM.menuOverlay.querySelector('.game-subtitle').textContent = 'You have fallen...';
            DOM.startBtn.textContent = 'TRY AGAIN';
            
            const stats = window.gameOverStats;
            DOM.finalStats.innerHTML = `
                Survived: <span>${stats.time}</span><br>
                Level: <span>${stats.level}</span><br>
                Kills: <span>${stats.kills}</span><br>
                Shrines: <span>${stats.shrines}</span>
            `;
            DOM.finalStats.style.display = 'block';
        }

        // ===== INIT =====
        DOM.startBtn.addEventListener('click', showWeaponSelect);
        DOM.startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            showWeaponSelect();
        });
        
        // Weapon select back button
        DOM.weaponBackBtn.addEventListener('click', cancelWeaponSelect);
        DOM.weaponBackBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            cancelWeaponSelect();
        });
        
        // Weapon select confirm button
        DOM.weaponConfirmBtn.addEventListener('click', confirmWeaponSelect);
        DOM.weaponConfirmBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            confirmWeaponSelect();
        });
        
        // Pause button handler
        function togglePause() {
            if (!gameRunning || DOM.upgradeOverlay.classList.contains('active') || 
                DOM.shrineOverlay.classList.contains('active') || 
                DOM.chestModal.classList.contains('visible')) return;
            
            gamePaused = !gamePaused;
            DOM.pauseBtn.textContent = gamePaused ? '▶' : '⏸';
            DOM.pauseBtn.classList.toggle('paused', gamePaused);
            
            // Show/hide pause overlay
            if (gamePaused) {
                DOM.pauseOverlay.classList.add('active');
            } else {
                DOM.pauseOverlay.classList.remove('active');
                DOM.confirmOverlay.classList.remove('active');
            }
        }
        
        function resumeGame() {
            if (!gamePaused) return;
            gamePaused = false;
            DOM.pauseBtn.textContent = '⏸';
            DOM.pauseBtn.classList.remove('paused');
            DOM.pauseOverlay.classList.remove('active');
            DOM.confirmOverlay.classList.remove('active');
        }
        
        function showExitConfirm() {
            DOM.confirmOverlay.classList.add('active');
        }
        
        function hideExitConfirm() {
            DOM.confirmOverlay.classList.remove('active');
        }
        
        function exitToMenu() {
            gameRunning = false;
            gamePaused = false;
            DOM.pauseOverlay.classList.remove('active');
            DOM.confirmOverlay.classList.remove('active');
            DOM.pauseBtn.textContent = '⏸';
            DOM.pauseBtn.classList.remove('paused');
            DOM.menuOverlay.classList.remove('hidden');
            if (DOM.finalStats) DOM.finalStats.style.display = 'none';
        }
        
        // Pause button click
        DOM.pauseBtn.addEventListener('click', togglePause);
        DOM.pauseBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            togglePause();
        });
        
        // Resume button
        DOM.resumeBtn.addEventListener('click', resumeGame);
        DOM.resumeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            resumeGame();
        });
        
        // Leaderboard button in pause menu
        DOM.pauseLeaderboardBtn.addEventListener('click', () => {
            DOM.pauseOverlay.classList.remove('active');
            showLeaderboard();
        });
        DOM.pauseLeaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            DOM.pauseOverlay.classList.remove('active');
            showLeaderboard();
        });
        
        // Exit game button
        DOM.exitGameBtn.addEventListener('click', showExitConfirm);
        DOM.exitGameBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            showExitConfirm();
        });
        
        // Confirmation buttons
        DOM.confirmYes.addEventListener('click', exitToMenu);
        DOM.confirmYes.addEventListener('touchend', (e) => {
            e.preventDefault();
            exitToMenu();
        });
        
        DOM.confirmNo.addEventListener('click', hideExitConfirm);
        DOM.confirmNo.addEventListener('touchend', (e) => {
            e.preventDefault();
            hideExitConfirm();
        });
        
        // P key to pause
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        
        // Chest modal buttons now use onclick in HTML (div elements work, buttons don't)
        
        // Move minimap to trackpad area
        setupTrackpadMinimap();
        
        requestAnimationFrame(gameLoop);
        
        // ========== FIREBASE LEADERBOARD SYSTEM ==========
        
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Collection name for THIS game
        const COLLECTION_NAME = 'survivors_scores';
        const LOCAL_STORAGE_KEY = 'survivors_scores';
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ===== PROFANITY FILTER =====
        const blockedPatterns = [
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i, /\bc+h+i+n+k/i,
            /\bs+p+i+c+/i, /\bk+i+k+e/i, /\bg+o+o+k/i, /\bw+e+t+b+a+c+k/i, /\btr+a+n+n+y/i,
            /\bd+y+k+e/i, /\bp+a+k+i/i, /\bt+w+a+t/i, /\bw+a+n+k/i, /\bp+r+i+c+k/i,
            /\bb+o+l+l+o+c+k/i, /\ba+r+s+e/i, /\bb+u+g+g+e+r/i, /\bc+r+a+p/i, /\bd+a+m+n/i,
            /\bp+u+t+a/i, /\bm+i+e+r+d+a/i, /\bc+a+b+r+[oó]+n/i, /\bp+e+n+d+e+j+o/i,
            /\bc+h+i+n+g+a/i, /\bj+o+d+e+r/i, /\bm+a+r+i+c+[oó]+n/i,
            /\bm+e+r+d+e/i, /\bp+u+t+a+i+n/i, /\bs+a+l+o+p/i,
            /\bs+c+h+e+i+[sß]+e/i, /\bf+i+c+k/i, /\bh+u+r+e/i, /\ba+r+s+c+h/i,
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i
        ];
        
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'nip', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'anus', 'homo'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            if (blockedExact.has(normalized)) return true;
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) return true;
            }
            return false;
        }
        
        function sanitizeUsername(name) {
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ===== SCORE MODAL =====
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalKillsDisplay = document.getElementById('finalKillsDisplay');
        const finalTimeDisplay = document.getElementById('finalTimeDisplay');
        
        let pendingScore = 0;
        let pendingTime = '0:00';
        
        async function showScoreModal(finalKills, finalTime) {
            pendingScore = finalKills;
            pendingTime = finalTime;
            finalKillsDisplay.textContent = finalKills;
            finalTimeDisplay.textContent = finalTime;
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'Submit';
            
            // Check rank
            let rank = await getScoreRank(finalKills);
            
            if (rank === 1) {
                scoreModalTitle.textContent = "🏆 #1 SLAYER 🏆";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'FALLEN WARRIOR';
            }
            
            scoreModal.classList.add('active');
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        async function getScoreRank(playerScore) {
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data().score));
                } else {
                    scores = getLocalScores().map(s => s.score);
                }
                
                let rank = 1;
                for (const existingScore of scores) {
                    if (playerScore <= existingScore) rank++;
                    else break;
                }
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999;
            }
        }
        
        scoreModal.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
            showGameOverMenu();
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection(COLLECTION_NAME).add({
                        name: username,
                        score: pendingScore,
                        time: pendingTime,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } else {
                    saveLocalScore(username, pendingScore, pendingTime);
                }
                hideScoreModal();
            } catch (e) {
                console.warn('Score submission failed:', e);
                saveLocalScore(username, pendingScore, pendingTime);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        // Local storage fallback
        function saveLocalScore(name, score, time) {
            try {
                const scores = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
                scores.push({ name, score, time, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Score modal event listeners
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            submitScore();
        }, { passive: false, capture: true });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideScoreModal();
        }, { passive: false, capture: true });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); submitScore(); }
            if (e.key === 'Escape') { hideScoreModal(); }
        });
        
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ===== LEADERBOARD =====
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data()));
                } else {
                    scores = getLocalScores();
                }
                renderLeaderboard(scores);
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                renderLeaderboard(getLocalScores());
            }
        }
        
        function renderLeaderboard(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            scores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                const time = entry.time || entry.level || '?'; // Fallback for old entries
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                        <div class="leaderboard-level">${time}</div>
                    </div>
                `;
            });
            leaderboardList.innerHTML = html;
        }
        
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        // Leaderboard button listeners
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) hideLeaderboard();
        });
        
        leaderboardOverlay.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        leaderboardOverlay.addEventListener('touchend', (e) => {
            if (e.target === leaderboardOverlay) {
                e.preventDefault();
                hideLeaderboard();
            }
        }, { passive: false });
        
        // ===== TUTORIAL SYSTEM =====
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialBtn = document.getElementById('tutorialBtn');
        const tutorialClose = document.getElementById('tutorialClose');
        const tutorialPrev = document.getElementById('tutorialPrev');
        const tutorialNext = document.getElementById('tutorialNext');
        const tutorialDots = document.getElementById('tutorialDots');
        const tutorialSteps = document.querySelectorAll('.tutorial-step');
        
        let currentTutorialStep = 0;
        const totalSteps = tutorialSteps.length;
        
        function initTutorialDots() {
            tutorialDots.innerHTML = '';
            for (let i = 0; i < totalSteps; i++) {
                const dot = document.createElement('div');
                dot.className = 'tutorial-dot' + (i === 0 ? ' active' : '');
                dot.addEventListener('click', () => goToTutorialStep(i));
                tutorialDots.appendChild(dot);
            }
        }
        
        function updateTutorialStep() {
            // Update steps visibility
            tutorialSteps.forEach((step, i) => {
                step.classList.toggle('active', i === currentTutorialStep);
            });
            
            // Update dots
            const dots = tutorialDots.querySelectorAll('.tutorial-dot');
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === currentTutorialStep);
            });
            
            // Update nav buttons
            tutorialPrev.disabled = currentTutorialStep === 0;
            tutorialNext.textContent = currentTutorialStep === totalSteps - 1 ? 'DONE' : 'NEXT →';
        }
        
        function goToTutorialStep(step) {
            currentTutorialStep = Math.max(0, Math.min(totalSteps - 1, step));
            updateTutorialStep();
        }
        
        function showTutorial() {
            currentTutorialStep = 0;
            initTutorialDots();
            updateTutorialStep();
            tutorialOverlay.classList.add('active');
        }
        
        function hideTutorial() {
            tutorialOverlay.classList.remove('active');
        }
        
        // Tutorial button listeners
        tutorialBtn.addEventListener('click', showTutorial);
        tutorialBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showTutorial();
        }, { passive: false, capture: true });
        
        tutorialClose.addEventListener('click', hideTutorial);
        tutorialClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideTutorial();
        }, { passive: false, capture: true });
        
        tutorialPrev.addEventListener('click', () => goToTutorialStep(currentTutorialStep - 1));
        tutorialPrev.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            goToTutorialStep(currentTutorialStep - 1);
        }, { passive: false, capture: true });
        
        tutorialNext.addEventListener('click', () => {
            if (currentTutorialStep === totalSteps - 1) {
                hideTutorial();
            } else {
                goToTutorialStep(currentTutorialStep + 1);
            }
        });
        tutorialNext.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (currentTutorialStep === totalSteps - 1) {
                hideTutorial();
            } else {
                goToTutorialStep(currentTutorialStep + 1);
            }
        }, { passive: false, capture: true });
        
        tutorialOverlay.addEventListener('click', (e) => {
            if (e.target === tutorialOverlay) hideTutorial();
        });
        
        tutorialOverlay.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        tutorialOverlay.addEventListener('touchend', (e) => {
            if (e.target === tutorialOverlay) {
                e.preventDefault();
                hideTutorial();
            }
        }, { passive: false });
    </script>
</body>
</html>
