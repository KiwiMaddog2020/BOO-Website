<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=overlays-content">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>BOO Tower Defense</title>
    <script>
        // Immediate iframe detection - runs before CSS layout
        if (window.self !== window.top) {
            document.documentElement.classList.add('in-iframe');
        }
        window.onerror=function(){return true};window.onunhandledrejection=function(e){if(e&&e.preventDefault)e.preventDefault();return true};
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --scale: 1;
            --canvas-width: 648px;
            --canvas-height: 576px;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height for mobile */
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        .game-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 1;
            padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
            box-sizing: border-box;
        }

        .game-container {
            position: relative;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0;
            padding: 0;
            width: fit-content;
            max-width: 100%;
            border: 2px solid #0ff;
            box-shadow: 0 0 15px #0ff;
            border-radius: 0;
            background: #0a0a0a;
            overflow: hidden;
        }

        /* Fullscreen/iframe mode: fill entire viewport */
        .game-container.fullscreen-mode {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            padding: 0;
            gap: 0;
            border-radius: 0;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Fullscreen body centering - JS adds this class */
        body.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            margin: 0 !important;
            padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0) !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            overflow: hidden !important;
            border: 2px solid #0ff !important;
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.3) !important;
            box-sizing: border-box !important;
        }
        
        /* Force fullscreen layout when in iframe (CSS kicks in immediately) */
        html.in-iframe body {
            justify-content: center;
            align-items: center;
            border: 2px solid #0ff;
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.3);
            box-sizing: border-box;
        }
        
        html.in-iframe .game-wrapper {
            justify-content: center;
            align-items: center;
        }
        
        /* Tablet in iframe - center */
        @media (min-width: 769px) and (pointer: coarse) {
            html.in-iframe body {
                align-items: center;
            }
        }
        
        html.in-iframe .game-container {
            width: fit-content;
            height: fit-content;
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
            border: none;
            padding: 0;
        }
        
        html.in-iframe #gameCanvas {
            border-radius: 0;
        }

        #gameCanvas {
            border-radius: 0;
            display: block;
            touch-action: none;
        }

        /* HUD */
        .hud {
            position: absolute;
            top: calc(10px * var(--scale, 1));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: calc(20px * var(--scale, 1));
            color: #fff;
            font-size: calc(18px * var(--scale, 1));
            text-shadow: 0 0 10px #0ff;
            z-index: 100;
            pointer-events: none;
            font-weight: bold;
        }
        
        @media (max-width: 700px) {
            .hud {
                gap: calc(10px * var(--scale, 1));
                font-size: calc(15px * var(--scale, 1));
                top: calc(5px * var(--scale, 1));
            }
        }
        
        @media (max-width: 500px) {
            .hud {
                gap: calc(6px * var(--scale, 1));
                font-size: calc(13px * var(--scale, 1));
            }
        }
        
        .hide-mobile {
            display: inline;
        }
        
        @media (max-width: 600px) {
            .hide-mobile {
                display: none;
            }
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: calc(5px * var(--scale, 1));
        }

        .hud-item span {
            color: #0ff;
        }
        
        /* Speed button - positioned left of HUD */
        .speed-btn {
            position: absolute;
            top: calc(10px * var(--scale, 1));
            left: calc(50% - 175px * var(--scale, 1));
            transform: translateX(-100%);
            padding: calc(5px * var(--scale, 1)) calc(12px * var(--scale, 1));
            font-size: calc(11px * var(--scale, 1));
            font-weight: bold;
            background: rgba(0, 0, 0, 0.7);
            border: calc(2px * var(--scale, 1)) solid rgba(0, 255, 255, 0.5);
            border-radius: calc(4px * var(--scale, 1));
            color: #0ff;
            cursor: pointer;
            z-index: 101;
            transition: all 0.2s;
        }
        
        .speed-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #0ff;
        }
        
        .speed-btn.active {
            background: rgba(255, 0, 255, 0.3);
            border-color: #f0f;
            color: #f0f;
        }
        
        /* Exit button - positioned right of HUD */
        .exit-btn {
            position: absolute;
            top: calc(10px * var(--scale, 1));
            left: calc(50% + 175px * var(--scale, 1));
            padding: calc(5px * var(--scale, 1)) calc(12px * var(--scale, 1));
            font-size: calc(11px * var(--scale, 1));
            font-weight: bold;
            background: rgba(0, 0, 0, 0.7);
            border: calc(2px * var(--scale, 1)) solid rgba(255, 100, 100, 0.5);
            border-radius: calc(4px * var(--scale, 1));
            color: rgba(255, 100, 100, 0.8);
            cursor: pointer;
            z-index: 101;
            transition: all 0.2s;
        }
        
        .exit-btn:hover {
            background: rgba(255, 50, 50, 0.2);
            border-color: #f66;
            color: #f66;
        }
        
        /* Mobile: tighter padding */
        @media (max-width: 600px) {
            .speed-btn {
                top: calc(8px * var(--scale, 1));
                left: calc(50% - 155px * var(--scale, 1));
                padding: calc(3px * var(--scale, 1)) calc(6px * var(--scale, 1));
                font-size: calc(10px * var(--scale, 1));
            }
            
            .exit-btn {
                top: calc(8px * var(--scale, 1));
                left: calc(50% + 155px * var(--scale, 1));
                padding: calc(3px * var(--scale, 1)) calc(6px * var(--scale, 1));
                font-size: calc(10px * var(--scale, 1));
            }
        }
        
        /* Very small screens - tighter positioning */
        @media (max-width: 400px) {
            .speed-btn {
                left: calc(50% - 130px * var(--scale, 1));
            }
            
            .exit-btn {
                left: calc(50% + 130px * var(--scale, 1));
            }
        }
        
        /* Exit confirmation overlay */
        .exit-confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .exit-confirm-overlay.active {
            display: flex;
        }
        
        .exit-confirm-box {
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid #f66;
            border-radius: 10px;
            padding: 20px 30px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.3);
        }
        
        .exit-confirm-text {
            font-size: 16px;
            color: #fff;
            margin-bottom: 20px;
        }
        
        .exit-confirm-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .exit-confirm-btn {
            padding: 8px 20px;
            font-size: 13px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
            text-align: center;
        }
        
        .exit-confirm-btn.yes {
            background: rgba(255, 50, 50, 0.3);
            border: 2px solid #f66;
            color: #f66;
        }
        
        .exit-confirm-btn.yes:hover {
            background: rgba(255, 50, 50, 0.5);
        }
        
        .exit-confirm-btn.no {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #0ff;
            color: #0ff;
        }
        
        .exit-confirm-btn.no:hover {
            background: rgba(0, 255, 255, 0.4);
        }

        /* Tower Selection Bar */
        .tower-bar {
            position: relative;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: calc(4px * var(--scale, 1));
            padding: calc(6px * var(--scale, 1)) calc(8px * var(--scale, 1));
            background: rgba(0, 0, 0, 0.8);
            border: calc(2px * var(--scale, 1)) solid rgba(0, 255, 255, 0.4);
            border-radius: calc(6px * var(--scale, 1));
            pointer-events: auto;
        }

        .tower-btn {
            width: calc(50px * var(--scale, 1));
            height: calc(62px * var(--scale, 1));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 255, 0.1);
            border: calc(2px * var(--scale, 1)) solid rgba(0, 255, 255, 0.4);
            border-radius: calc(5px * var(--scale, 1));
            cursor: pointer;
            transition: all 0.2s;
            color: #fff;
        }

        .tower-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #0ff;
            transform: scale(1.05);
        }

        .tower-btn.selected {
            background: rgba(0, 255, 255, 0.3);
            border-color: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .tower-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tower-icon {
            font-size: calc(18px * var(--scale, 1));
        }

        .tower-cost {
            font-size: calc(10px * var(--scale, 1));
            color: #ffd700;
        }
        
        .tower-count {
            font-size: calc(8px * var(--scale, 1));
            color: rgba(255, 255, 255, 0.6);
            margin-top: calc(1px * var(--scale, 1));
        }
        
        .tower-btn.at-limit {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tower-btn.at-limit .tower-cost {
            color: #ff4444;
        }
        
        /* Locked tower styling (Campaign mode) */
        .tower-btn.locked {
            opacity: 0.25;
            cursor: not-allowed;
            filter: grayscale(70%);
        }
        
        .tower-btn.locked .tower-cost {
            color: #888;
            font-size: calc(8px * var(--scale, 1));
        }
        
        .tower-btn.locked .tower-count {
            display: none;
        }
        
        .tower-btn.locked:hover {
            transform: none;
            background: rgba(0, 255, 255, 0.1);
        }
        
        /* Champion tower buttons - special styling */
        .tower-btn.champion-btn {
            background: rgba(74, 74, 74, 0.2);
            border-color: rgba(74, 74, 74, 0.6);
        }
        
        .tower-btn.champion-btn[data-tower="caster"] {
            background: rgba(26, 10, 42, 0.3);
            border-color: rgba(170, 0, 255, 0.6);
        }
        
        .tower-btn.champion-btn:not(.locked):hover {
            background: rgba(74, 74, 74, 0.4);
            border-color: #88ff88;
        }
        
        .tower-btn.champion-btn[data-tower="caster"]:not(.locked):hover {
            background: rgba(26, 10, 42, 0.5);
            border-color: #aa00ff;
        }
        
        .tower-btn.champion-btn.selected {
            background: rgba(74, 74, 74, 0.5);
            border-color: #88ff88;
            box-shadow: 0 0 15px rgba(136, 255, 136, 0.5);
        }
        
        .tower-btn.champion-btn[data-tower="caster"].selected {
            background: rgba(26, 10, 42, 0.6);
            border-color: #aa00ff;
            box-shadow: 0 0 15px rgba(170, 0, 255, 0.6);
        }
        
        .tower-btn.champion-btn .tower-cost {
            color: #00ff88;
            font-weight: bold;
        }
        
        .tower-btn.champion-btn.placed {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tower-btn.champion-btn.placed .tower-cost {
            color: #888;
        }
        
        /* Champion focus toggle in action panel */
        .champion-focus-toggle {
            display: flex;
            align-items: center;
            gap: calc(8px * var(--scale, 1));
            margin-top: calc(8px * var(--scale, 1));
        }
        
        .focus-label {
            font-size: calc(10px * var(--scale, 1));
            color: #aaa;
        }
        
        .focus-switch {
            display: flex;
            background: rgba(0, 0, 0, 0.5);
            border: calc(2px * var(--scale, 1)) solid rgba(255, 255, 255, 0.3);
            border-radius: calc(4px * var(--scale, 1));
            overflow: hidden;
        }
        
        .focus-option {
            padding: calc(4px * var(--scale, 1)) calc(10px * var(--scale, 1));
            font-size: calc(10px * var(--scale, 1));
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            color: #888;
            background: transparent;
            border: none;
        }
        
        .focus-option.active {
            background: linear-gradient(180deg, #f0f, #a0a);
            color: #000;
        }
        
        .focus-option:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        /* Wave Start Button */
        .wave-btn {
            padding: calc(10px * var(--scale, 1)) calc(15px * var(--scale, 1));
            width: calc(125px * var(--scale, 1));
            background: linear-gradient(180deg, #f0f, #c0c);
            border: calc(2px * var(--scale, 1)) solid #f0f;
            border-radius: calc(6px * var(--scale, 1));
            color: #000;
            font-weight: bold;
            font-size: calc(12px * var(--scale, 1));
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: none;
            white-space: nowrap;
        }

        .wave-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }

        .wave-btn:disabled {
            background: #444;
            border-color: #666;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Control Bar */
        .control-bar {
            display: flex;
            gap: calc(6px * var(--scale, 1));
            align-items: stretch;
            width: var(--canvas-width, 648px);
            max-width: 100%;
            justify-content: center;
            overflow: hidden;
            padding-bottom: env(safe-area-inset-bottom, 0);
        }
        
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: calc(5px * var(--scale, 1));
            justify-content: center;
            align-items: center;
            padding: calc(6px * var(--scale, 1)) calc(8px * var(--scale, 1));
            background: rgba(0, 0, 0, 0.5);
            border: calc(2px * var(--scale, 1)) solid rgba(0, 255, 255, 0.3);
            border-radius: calc(6px * var(--scale, 1));
        }
        
        /* Placement Tooltip */
        .placement-tooltip {
            display: none;
            position: absolute;
            bottom: auto;
            left: 0;
            text-align: center;
            padding: 6px 14px;
            background: rgba(0, 0, 0, 0.92);
            border: 2px solid rgba(0, 255, 255, 0.6);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            text-shadow: 0 0 8px #0ff;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.3);
            white-space: nowrap;
            z-index: 150;
            pointer-events: none;
        }
        
        .placement-tooltip.active {
            display: block;
        }
        
        .placement-tooltip .tower-name {
            color: #0ff;
            font-weight: bold;
        }
        
        .placement-tooltip .tower-desc {
            color: #ccc;
            margin-left: 6px;
        }
        
        @media (max-width: 600px) {
            .placement-tooltip {
                font-size: 11px;
                padding: 6px 12px;
                border-width: 2px;
                border-radius: 6px;
            }
            
            .placement-tooltip .tower-desc {
                margin-left: 6px;
            }
        }
        
        /* Tower bar disabled state during wave */
        .tower-bar.wave-active .tower-btn {
            opacity: 0.4;
            pointer-events: none;
            cursor: not-allowed;
        }
        
        /* Shop Overlay */
        .shop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1100;
            pointer-events: none;
        }
        
        .shop-overlay.active {
            display: flex;
            pointer-events: auto;
        }
        
        .shop-container {
            position: relative;
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px 25px;
            width: 620px;
            max-width: 95%;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.3);
        }
        
        .shop-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .shop-title {
            font-size: 25px;
            color: #ffd700;
            text-shadow: 0 0 15px #ffd700;
        }
        
        .shop-gold {
            position: absolute;
            top: 15px;
            left: 18px;
            font-size: 23px;
            color: #ffd700;
        }
        
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .shop-item {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 10px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .shop-item:hover:not(.disabled) {
            border-color: #0ff;
            transform: scale(1.03);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }
        
        .shop-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .shop-item.maxed {
            border-color: #00ff88;
            opacity: 0.6;
        }
        
        .shop-item.locked {
            opacity: 0.35;
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .shop-item.locked .shop-item-icon {
            filter: grayscale(100%);
        }
        
        .shop-item-icon {
            font-size: 30px;
            margin-bottom: 5px;
        }
        
        .shop-item-name {
            font-size: 13px;
            color: #fff;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .shop-item-level {
            font-size: 12px;
            color: #0ff;
            margin-bottom: 5px;
        }
        
        .shop-item-effect {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
            line-height: 1.2;
        }
        
        .shop-item-cost {
            font-size: 13px;
            color: #ffd700;
            font-weight: bold;
        }
        
        .shop-continue-btn {
            padding: 12px 40px;
            font-size: 14px;
            font-weight: bold;
            background: rgba(255, 50, 50, 0.2);
            border: 2px solid #ff3333;
            border-radius: 6px;
            color: #ff3333;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .shop-continue-btn:hover {
            background: rgba(255, 50, 50, 0.4);
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.5);
        }
        
        /* Stats toggle button - matches exit button styling */
        .shop-stats-toggle {
            padding: 12px 40px;
            font-size: 14px;
            font-weight: bold;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .shop-stats-toggle:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .shop-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        /* Stats panel */
        .shop-stats-panel {
            display: none;
        }
        
        .shop-stats-panel.active {
            display: block;
        }
        
        .shop-grid.hidden {
            display: none;
        }
        
        .stats-title {
            font-size: 18px;
            color: #0ff;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #0ff;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px 15px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-name {
            font-size: 12px;
            color: #aaa;
        }
        
        .stat-value {
            font-size: 13px;
            font-weight: bold;
            color: #0ff;
        }
        
        .stat-value.zero {
            color: #666;
        }
        
        .stat-value.positive {
            color: #55ff55;
        }

        /* Upgrade Overlay */
        .upgrade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: none;
        }

        .upgrade-overlay.active {
            display: flex;
            pointer-events: auto;
        }
        
        /* Flash effect on overlay open */
        .upgrade-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 255, 0.4);
            opacity: 0;
            pointer-events: none;
        }
        
        .upgrade-overlay.active::before {
            animation: overlayFlash 0.5s ease-out forwards;
        }
        
        @keyframes overlayFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .upgrade-title {
            font-size: 28px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
            margin-bottom: 8px;
            letter-spacing: 3px;
            animation: titlePulse 1.5s ease-in-out infinite;
            opacity: 0;
            transform: scale(0.5) translateY(-20px);
        }
        
        .upgrade-overlay.active .upgrade-title {
            animation: titleEnter 0.6s ease-out forwards, titlePulse 1.5s ease-in-out 0.6s infinite;
        }
        
        @keyframes titleEnter {
            0% { opacity: 0; transform: scale(0.5) translateY(-20px); }
            60% { opacity: 1; transform: scale(1.1) translateY(0); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff; }
            50% { text-shadow: 0 0 30px #0ff, 0 0 60px #0ff, 0 0 80px #f0f; }
        }

        .upgrade-subtitle {
            font-size: 15px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 25px;
            opacity: 0;
        }
        
        .upgrade-overlay.active .upgrade-subtitle {
            animation: subtitleEnter 0.4s ease-out 0.3s forwards;
        }
        
        @keyframes subtitleEnter {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .upgrade-slots {
            display: flex;
            gap: 15px;
        }

        .upgrade-slot {
            width: 130px;
            height: 170px;
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid #333;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.3);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            opacity: 0;
            transform: translateY(30px) scale(0.9);
        }
        
        .upgrade-overlay.active .upgrade-slot {
            animation: slotEnter 0.5s ease-out forwards;
        }
        
        .upgrade-overlay.active .upgrade-slot:nth-child(1) { animation-delay: 0.4s; }
        .upgrade-overlay.active .upgrade-slot:nth-child(2) { animation-delay: 0.55s; }
        .upgrade-overlay.active .upgrade-slot:nth-child(3) { animation-delay: 0.7s; }
        
        @keyframes slotEnter {
            0% { opacity: 0; transform: translateY(30px) scale(0.9); }
            60% { opacity: 1; transform: translateY(-5px) scale(1.02); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        .upgrade-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.08), transparent);
            animation: slotShine 3s ease-in-out infinite;
            animation-play-state: paused;
        }
        
        .upgrade-overlay.active .upgrade-slot::before {
            animation-play-state: running;
        }

        @keyframes slotShine {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(400%); }
        }
        
        .upgrade-slot.rolling {
            pointer-events: none;
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .upgrade-slot.rolling .upgrade-content {
            animation: slotRoll 0.1s linear infinite;
        }

        @keyframes slotRoll {
            0% { transform: translateY(0); }
            100% { transform: translateY(-30px); }
        }
        
        .upgrade-slot.rolling .upgrade-icon {
            animation: iconCycle 0.15s ease-in-out infinite;
        }
        
        @keyframes iconCycle {
            0%, 100% { opacity: 0.5; transform: scale(0.9); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .upgrade-slot.revealed {
            border-color: #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            cursor: pointer;
        }

        .upgrade-slot.revealed:hover {
            transform: translateY(-8px) scale(1.05);
            border-color: #f0f;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.6), 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        
        .upgrade-slot.revealed:active {
            transform: scale(0.95);
            border-color: #0f0;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
        }

        .upgrade-slot.selected {
            border-color: #00ff88;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.8);
            transform: scale(1.08);
        }
        
        /* Rarity styling (matching neon-survivors) */
        .upgrade-slot.rarity-common.revealed {
            border-color: #aaaaaa;
            box-shadow: 0 0 20px rgba(170, 170, 170, 0.3), inset 0 0 15px rgba(170, 170, 170, 0.1);
        }
        .upgrade-slot.rarity-uncommon.revealed {
            border-color: #55ff55;
            box-shadow: 0 0 25px rgba(85, 255, 85, 0.4), inset 0 0 20px rgba(85, 255, 85, 0.15);
        }
        .upgrade-slot.rarity-rare.revealed {
            border-color: #5555ff;
            box-shadow: 0 0 30px rgba(85, 85, 255, 0.5), inset 0 0 25px rgba(85, 85, 255, 0.2);
            animation: rarePulse 2s ease-in-out infinite;
        }
        .upgrade-slot.rarity-epic.revealed {
            border-color: #aa55ff;
            box-shadow: 0 0 35px rgba(170, 85, 255, 0.5), inset 0 0 25px rgba(170, 85, 255, 0.2);
            animation: epicPulse 1.8s ease-in-out infinite;
        }
        .upgrade-slot.rarity-legendary.revealed {
            border-color: #ffaa00;
            box-shadow: 0 0 40px rgba(255, 170, 0, 0.6), inset 0 0 30px rgba(255, 170, 0, 0.25);
            animation: legendaryPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes rarePulse {
            0%, 100% { box-shadow: 0 0 30px rgba(85, 85, 255, 0.5), inset 0 0 25px rgba(85, 85, 255, 0.2); }
            50% { box-shadow: 0 0 45px rgba(85, 85, 255, 0.7), inset 0 0 35px rgba(85, 85, 255, 0.3); }
        }
        
        @keyframes epicPulse {
            0%, 100% { box-shadow: 0 0 35px rgba(170, 85, 255, 0.5), inset 0 0 25px rgba(170, 85, 255, 0.2); }
            50% { box-shadow: 0 0 50px rgba(170, 85, 255, 0.8), inset 0 0 40px rgba(170, 85, 255, 0.35); }
        }
        
        @keyframes legendaryPulse {
            0%, 100% { box-shadow: 0 0 40px rgba(255, 170, 0, 0.6), inset 0 0 30px rgba(255, 170, 0, 0.25); }
            50% { box-shadow: 0 0 60px rgba(255, 170, 0, 0.9), inset 0 0 45px rgba(255, 170, 0, 0.4); }
        }
        
        .upgrade-rarity {
            font-size: 9px;
            font-weight: bold;
            letter-spacing: 1px;
            padding: 2px 8px;
            border-radius: 3px;
            margin-top: 4px;
            text-transform: uppercase;
        }
        
        .rarity-common .upgrade-rarity { color: #aaa; background: rgba(170, 170, 170, 0.15); }
        .rarity-uncommon .upgrade-rarity { color: #55ff55; background: rgba(85, 255, 85, 0.15); }
        .rarity-rare .upgrade-rarity { color: #5555ff; background: rgba(85, 85, 255, 0.2); text-shadow: 0 0 8px #5555ff; }
        .rarity-epic .upgrade-rarity { color: #aa55ff; background: rgba(170, 85, 255, 0.2); text-shadow: 0 0 10px #aa55ff; }
        .rarity-legendary .upgrade-rarity { color: #ffaa00; background: rgba(255, 170, 0, 0.25); text-shadow: 0 0 12px #ffaa00; }

        .upgrade-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 8px;
            padding: 15px;
            z-index: 1;
        }

        .upgrade-icon {
            font-size: 36px;
            filter: drop-shadow(0 0 8px currentColor);
            margin-bottom: 4px;
        }

        .upgrade-name {
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            line-height: 1.2;
        }

        .upgrade-desc {
            font-size: 11px;
            color: #0ff;
            text-align: center;
            line-height: 1.3;
            opacity: 0.9;
        }
        
        /* Reroll button */
        .reroll-container {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        
        .reroll-btn {
            padding: 8px 20px;
            font-size: 13px;
            font-weight: bold;
            background: rgba(255, 0, 255, 0.15);
            border: 2px solid #f0f;
            border-radius: 6px;
            color: #f0f;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .reroll-btn:hover:not(:disabled) {
            background: rgba(255, 0, 255, 0.3);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        .reroll-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #666;
            color: #666;
        }
        
        .reroll-count {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .upgrade-skip-btn {
            margin-top: 20px;
            padding: 12px 40px;
            font-size: 14px;
            font-weight: bold;
            background: rgba(255, 50, 50, 0.2);
            border: 2px solid #ff3333;
            border-radius: 6px;
            color: #ff3333;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .upgrade-skip-btn:hover {
            background: rgba(255, 50, 50, 0.4);
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.5);
        }

        /* Leaderboard button */
        #leaderboardBtn {
            padding: calc(10px * var(--scale, 1)) calc(15px * var(--scale, 1));
            width: calc(125px * var(--scale, 1));
            background: transparent;
            border: calc(2px * var(--scale, 1)) solid #ffcc00;
            border-radius: calc(6px * var(--scale, 1));
            color: #ffcc00;
            font-size: calc(12px * var(--scale, 1));
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        #leaderboardBtn:hover {
            background: rgba(255, 204, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.4);
        }
        
        /* Shop button */
        #shopBtn {
            padding: calc(10px * var(--scale, 1)) calc(15px * var(--scale, 1));
            width: calc(125px * var(--scale, 1));
            background: linear-gradient(180deg, #00ff88, #00cc6a);
            border: calc(2px * var(--scale, 1)) solid #00ff88;
            border-radius: calc(6px * var(--scale, 1));
            color: #000;
            font-size: calc(12px * var(--scale, 1));
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: none;
            white-space: nowrap;
        }
        
        #shopBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }
        
        #shopBtn:disabled {
            background: #444;
            border-color: #666;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Menu Overlay */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            touch-action: manipulation;
        }

        .menu-overlay.hidden {
            display: none;
            pointer-events: none;
        }

        .game-title {
            font-size: 42px;
            color: #0ff;
            text-shadow: 0 0 30px #f0f, 0 0 60px #f0f;
            margin-bottom: 10px;
            letter-spacing: 4px;
            text-align: center;
        }
        
        @media (max-width: 500px) {
            .game-title {
                font-size: 32px;
                letter-spacing: 2px;
            }
        }

        .game-subtitle {
            font-size: 16px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
            margin-bottom: 40px;
            text-align: center;
        }
        
        /* Mode Selection */
        .mode-selection {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        .mode-selection.active {
            display: flex;
        }
        
        .mode-title {
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 10px;
        }
        
        .mode-btn {
            padding: 15px 25px;
            width: 200px;
            font-size: 14px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #0ff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .mode-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .mode-btn.endless {
            border-color: #f0f;
            color: #f0f;
        }
        
        .mode-btn.endless:hover {
            background: rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        
        .mode-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            font-weight: normal;
            text-transform: none;
            letter-spacing: 0;
        }
        
        .back-btn {
            padding: 8px 20px;
            font-size: 12px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            margin-top: 10px;
        }
        
        .back-btn:hover {
            border-color: #fff;
            color: #fff;
        }
        
        /* Map Transition Overlay */
        .map-transition-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }
        
        .map-transition-overlay.active {
            display: flex;
            animation: transitionFadeIn 0.5s ease-out;
        }
        
        @keyframes transitionFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .transition-text {
            font-size: 36px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
            animation: transitionPulse 1s ease-in-out infinite;
        }
        
        .transition-subtext {
            font-size: 18px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f;
        }
        
        .transition-progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .transition-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #f0f);
            width: 0%;
            animation: transitionProgress 2s ease-out forwards;
        }
        
        @keyframes transitionPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        @keyframes transitionProgress {
            from { width: 0%; }
            to { width: 100%; }
        }
        
        /* Endless Mode HUD additions */
        .stage-display {
            display: none;
            color: #ff6600;
            font-size: calc(14px * var(--scale, 1));
            font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 102, 0, 0.8);
        }
        
        .campaign-mode .stage-display {
            display: inline;
        }
        
        .campaign-mode .wave-label::before {
            content: 'STAGE ' attr(data-stage) ' - ';
            color: #ff6600;
        }
        
        @media (max-width: 500px) {
            .game-subtitle {
                font-size: 14px;
                margin-bottom: 30px;
            }
        }

        .menu-btn {
            padding: 10px 20px;
            width: 164px;
            font-size: 13px;
            font-weight: bold;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #0ff;
            text-align: center;
            touch-action: manipulation;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .menu-btn:hover {
            background: #0ff;
            color: #000;
        }

        .menu-instructions {
            max-width: 400px;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            line-height: 1.6;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        .menu-btn.btn-tutorial {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 8px #f0f;
        }
        
        .menu-btn.btn-tutorial:hover {
            background: #f0f;
            color: #000;
        }
        
        .menu-btn.btn-leaderboard {
            border-color: #ffcc00;
            color: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
        }
        
        .menu-btn.btn-leaderboard:hover {
            background: #ffcc00;
            color: #000;
        }
        
        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .tutorial-overlay.active {
            display: flex;
        }
        
        .tutorial-container {
            position: relative;
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid #0ff;
            border-radius: 15px;
            padding: 25px 30px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .tutorial-title {
            font-size: 24px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }
        
        .tutorial-step {
            display: none;
            animation: tutorialFadeIn 0.3s ease-out;
        }
        
        .tutorial-step.active {
            display: block;
        }
        
        @keyframes tutorialFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .tutorial-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .tutorial-heading {
            font-size: 18px;
            color: #fff;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .tutorial-text {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .tutorial-highlight {
            color: #0ff;
            font-weight: bold;
        }
        
        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }
        
        .tutorial-nav-btn {
            padding: 10px 20px;
            font-size: 13px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-prev {
            background: transparent;
            border-color: #666;
            color: #888;
        }
        
        .tutorial-prev:hover {
            border-color: #999;
            color: #fff;
        }
        
        .tutorial-prev:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tutorial-next {
            background: linear-gradient(180deg, #0ff, #0aa);
            border-color: #0ff;
            color: #000;
        }
        
        .tutorial-next:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        .tutorial-dots {
            display: flex;
            gap: 8px;
        }
        
        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.2s;
        }
        
        .tutorial-dot.active {
            background: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        
        .tutorial-close {
            background: transparent;
            border: 2px solid #ff6666;
            color: #ff6666;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .tutorial-close:hover {
            background: #ff6666;
            color: #fff;
        }

        /* Game Over Overlay */
        .gameover-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .gameover-overlay.active {
            display: flex;
        }

        .gameover-title {
            font-size: 48px;
            color: #f0f;
            text-shadow: 0 0 30px #f0f;
            margin-bottom: 20px;
        }

        .gameover-stats {
            font-size: 18px;
            color: #fff;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.8;
        }

        .gameover-stats span {
            color: #0ff;
        }

        /* Confirm Overlay */
        .confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1200;
        }
        
        .confirm-overlay.active {
            display: flex;
        }
        
        .confirm-container {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid #f0f;
            border-radius: 15px;
            padding: 25px 35px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);
        }
        
        .confirm-text {
            font-size: 20px;
            color: #fff;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .confirm-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .confirm-btn {
            padding: 10px 25px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .confirm-btn.yes {
            background: linear-gradient(180deg, #f0f, #c0c);
            border: 2px solid #f0f;
            color: #000;
        }
        
        .confirm-btn.yes:hover {
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
            transform: scale(1.05);
        }
        
        .confirm-btn.no {
            background: transparent;
            border: 2px solid #888;
            color: #888;
        }
        
        .confirm-btn.no:hover {
            border-color: #fff;
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* Tower Placement Preview Overlay (Mobile) */
        .placement-preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 15px;
            z-index: 1200;
            pointer-events: none;
        }
        
        .placement-preview-overlay.active {
            display: flex;
        }
        
        .placement-preview-container {
            background: rgba(10, 10, 20, 0.92);
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 6px 12px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            pointer-events: auto;
            display: none; /* Hidden - using tower action panel instead */
        }
        
        /* Tower Action Panel - fills tower bar area */
        .tower-action-panel {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 20, 0.95);
            border: calc(2px * var(--scale, 1)) solid #0ff;
            border-radius: calc(6px * var(--scale, 1));
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: calc(8px * var(--scale, 1));
            z-index: 10;
            padding: calc(10px * var(--scale, 1));
        }
        
        .tower-action-panel.active {
            display: flex;
        }
        
        /* First placement arrow indicator - fixed position to avoid clipping */
        .first-placement-arrow {
            position: fixed;
            font-size: 34px;
            color: #ffffff;
            animation: bounceArrow 1s ease-in-out infinite;
            opacity: 1;
            transition: opacity 0.3s ease-out;
            pointer-events: none;
            z-index: 9999;
        }
        
        .first-placement-arrow.fade-out {
            opacity: 0;
        }
        
        @keyframes bounceArrow {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(8px); }
        }
        
        .tower-action-panel.move-mode {
            border-color: #f0f;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.4);
        }
        
        .tower-action-title {
            font-size: calc(16px * var(--scale, 1));
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        
        .tower-action-panel.move-mode .tower-action-title {
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }
        
        .tower-action-subtitle {
            font-size: calc(14px * var(--scale, 1));
            color: #ffd700;
            font-weight: bold;
        }
        
        .tower-action-buttons {
            display: flex;
            gap: calc(12px * var(--scale, 1));
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .tower-action-btn {
            padding: calc(10px * var(--scale, 1)) calc(15px * var(--scale, 1));
            width: calc(125px * var(--scale, 1));
            font-size: calc(12px * var(--scale, 1));
            font-weight: bold;
            border-radius: calc(6px * var(--scale, 1));
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .tower-action-btn.confirm {
            background: linear-gradient(180deg, #f0f, #c0c);
            border: calc(2px * var(--scale, 1)) solid #f0f;
            color: #000;
            text-shadow: none;
        }
        
        .tower-action-btn.confirm:hover {
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
            transform: scale(1.05);
        }
        
        .tower-action-btn.move {
            background: linear-gradient(180deg, #f0f, #c0c);
            border: calc(2px * var(--scale, 1)) solid #f0f;
            color: #000;
            text-shadow: none;
        }
        
        .tower-action-btn.move:hover {
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
            transform: scale(1.05);
        }
        
        .tower-action-btn.cancel {
            background: transparent;
            border: calc(2px * var(--scale, 1)) solid #ff6666;
            color: #ff6666;
        }
        
        .tower-action-btn.cancel:hover {
            background: rgba(255, 102, 102, 0.2);
            box-shadow: 0 0 15px rgba(255, 102, 102, 0.4);
        }
        
        @media (max-width: 600px) {
            .tower-action-title {
                font-size: calc(18px * var(--scale, 1));
            }
            
            .tower-action-subtitle {
                font-size: calc(16px * var(--scale, 1));
            }
            
            .tower-action-btn {
                padding: calc(12px * var(--scale, 1)) calc(18px * var(--scale, 1));
                font-size: calc(14px * var(--scale, 1));
            }
        }
        
        .placement-preview-text {
            font-size: 11px;
            color: #fff;
            margin-bottom: 6px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .placement-preview-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .placement-btn {
            padding: 5px 12px;
            font-size: 11px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .placement-btn.yes {
            background: linear-gradient(180deg, #0ff, #0aa);
            border: 2px solid #0ff;
            color: #000;
        }
        
        .placement-btn.yes:hover {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        .placement-btn.no {
            background: transparent;
            border: 2px solid #888;
            color: #888;
        }
        
        .placement-btn.no:hover {
            border-color: #fff;
            color: #fff;
        }

        /* Responsive */
        @media (max-width: 600px), (hover: none) {
            .tower-btn {
                width: calc(38px * var(--scale, 1));
                height: calc(50px * var(--scale, 1));
            }
            .tower-icon {
                font-size: calc(15px * var(--scale, 1));
            }
            .tower-cost {
                font-size: calc(8px * var(--scale, 1));
            }
            
            /* Make all control buttons same size on mobile */
            .control-buttons {
                gap: calc(4px * var(--scale, 1));
                padding: calc(5px * var(--scale, 1)) calc(6px * var(--scale, 1));
            }
            
            .wave-btn,
            #shopBtn,
            #leaderboardBtn {
                padding: calc(8px * var(--scale, 1));
                min-width: calc(100px * var(--scale, 1));
                font-size: calc(10px * var(--scale, 1));
            }
            
            .upgrade-slot {
                width: calc(100px * var(--scale, 1));
                height: calc(140px * var(--scale, 1));
            }
            .upgrade-icon {
                font-size: calc(28px * var(--scale, 1));
            }
            .upgrade-name {
                font-size: calc(11px * var(--scale, 1));
            }
            .upgrade-desc {
                font-size: calc(10px * var(--scale, 1));
            }
            
            .control-bar {
                gap: calc(4px * var(--scale, 1));
            }
            
            .tower-bar {
                gap: calc(3px * var(--scale, 1));
                padding: calc(5px * var(--scale, 1)) calc(6px * var(--scale, 1));
            }
            
            .game-container {
                gap: 0;
                padding: 0;
            }
        }
        
        /* Extra small screens (very small phones) */
        @media (max-width: 380px) {
            .tower-btn {
                width: calc(34px * var(--scale, 1));
                height: calc(46px * var(--scale, 1));
            }
            .tower-icon {
                font-size: calc(13px * var(--scale, 1));
            }
            .tower-cost {
                font-size: calc(7px * var(--scale, 1));
            }
            .tower-bar {
                gap: calc(2px * var(--scale, 1));
                padding: calc(4px * var(--scale, 1));
            }
            .wave-btn,
            #shopBtn,
            #leaderboardBtn {
                padding: calc(6px * var(--scale, 1));
                min-width: calc(80px * var(--scale, 1));
                font-size: calc(9px * var(--scale, 1));
            }
            .hud {
                font-size: calc(11px * var(--scale, 1));
                gap: calc(8px * var(--scale, 1));
            }
        }
        
        /* Landscape orientation on mobile - optimize layout */
        @media (max-height: 500px) and (orientation: landscape) {
            .control-bar {
                padding-bottom: 0;
            }
            .tower-btn {
                width: calc(40px * var(--scale, 1));
                height: calc(48px * var(--scale, 1));
            }
            .tower-bar {
                gap: calc(3px * var(--scale, 1));
                padding: calc(4px * var(--scale, 1)) calc(5px * var(--scale, 1));
            }
            .control-buttons {
                padding: calc(4px * var(--scale, 1)) calc(6px * var(--scale, 1));
            }
            .wave-btn,
            #shopBtn,
            #leaderboardBtn {
                padding: calc(6px * var(--scale, 1)) calc(8px * var(--scale, 1));
                min-width: calc(90px * var(--scale, 1));
            }
        }
        
        /* Score Modal */
        .score-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-content {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid #0ff;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
            max-width: 350px;
            width: 90%;
        }
        
        .score-modal-title {
            font-size: 24px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            margin-bottom: 15px;
        }
        
        .score-stats {
            font-size: 16px;
            color: #fff;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .score-stats span {
            color: #0ff;
            font-weight: bold;
        }
        
        .score-input-label {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }
        
        .score-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-transform: uppercase;
            margin-bottom: 10px;
            outline: none;
        }
        
        .score-input:focus {
            border-color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }
        
        .score-input.error {
            border-color: #ff3366;
            animation: inputShake 0.3s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .score-error {
            font-size: 12px;
            color: #ff3366;
            margin-bottom: 10px;
            min-height: 18px;
        }
        
        .score-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .score-btn {
            padding: 12px 25px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .score-btn-submit {
            background: linear-gradient(180deg, #0ff, #0aa);
            border-color: #0ff;
            color: #000;
        }
        
        .score-btn-submit:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-btn-skip {
            background: transparent;
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #fff;
        }
        
        /* Leaderboard Overlay */
        .leaderboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 3px solid #0ff;
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 450px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .leaderboard-title {
            font-size: 28px;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
        }
        
        .leaderboard-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .leaderboard-tab {
            flex: 1;
            padding: 10px 16px;
            background: transparent;
            border: 2px solid #555;
            border-radius: 8px;
            color: #888;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        
        .leaderboard-tab:hover {
            border-color: #888;
            color: #aaa;
        }
        
        .leaderboard-tab.active-campaign {
            border-color: #f0f;
            color: #f0f;
            background: rgba(255, 0, 255, 0.15);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
        }
        
        .leaderboard-tab.active-classic {
            border-color: #0ff;
            color: #0ff;
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .leaderboard-close {
            width: 36px;
            height: 36px;
            background: transparent;
            border: 2px solid #ff3366;
            border-radius: 50%;
            color: #ff3366;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .leaderboard-close:hover {
            background: #ff3366;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            padding-ight: 5px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 3px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            margin-bottom: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .leaderboard-row:hover {
            background: rgba(0, 255, 255, 0.1);
        }
        
        .leaderboard-row.top-3 {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .leaderboard-rank {
            font-size: 14px;
            font-weight: bold;
            color: #888;
            min-width: 40px;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            font-size: 16px;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 14px;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .leaderboard-score {
            font-size: 15px;
            font-weight: bold;
            color: #0ff;
            min-width: 70px;
            text-align: right;
        }
        
        .leaderboard-wave {
            font-size: 12px;
            color: #888;
            min-width: 50px;
            text-align: right;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
    </style>
</head>
<body>
    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay">
        <div class="game-title">BOO TOWER DEFENSE</div>
        <div class="game-subtitle">Place towers, upgrade and defend</div>
        <div class="menu-buttons" id="mainMenuButtons">
            <button class="menu-btn" id="startBtn">START GAME</button>
            <button class="menu-btn btn-tutorial" id="tutorialBtn">HOW TO PLAY</button>
            <button class="menu-btn btn-leaderboard" id="menuLeaderboardBtn">LEADER BOARD</button>
        </div>
        <div class="mode-selection" id="modeSelection">
            <div class="mode-title">SELECT MODE</div>
            <button class="mode-btn endless" id="campaignModeBtn">
                CAMPAIGN
                <div class="mode-desc">New map every 5 waves</div>
            </button>
            <button class="mode-btn" id="classicModeBtn">
                CLASSIC
                <div class="mode-desc">Single map, endless waves</div>
            </button>
            <button class="back-btn" id="modeBackBtn"> BACK</button>
        </div>
    </div>
    
    <!-- Map Transition Overlay -->
    <div class="map-transition-overlay" id="mapTransitionOverlay">
        <div class="transition-text" id="transitionText">STAGE 2</div>
        <div class="transition-subtext" id="transitionSubtext"></div>
        <div class="transition-progress">
            <div class="transition-progress-bar" id="transitionProgressBar"></div>
        </div>
    </div>
    
    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-container">
            <div class="tutorial-header">
                <div class="tutorial-title"> HOW TO PLAY</div>
                <button class="tutorial-close" id="tutorialClose"></button>
            </div>
            
            <div class="tutorial-step active" data-step="0">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Controls</div>
                <div class="tutorial-text">
                    <strong>Mobile:</strong> Tap a tower icon, then drag on the map to position it. Tap placed towers to upgrade.<br><br>
                    <strong>Desktop:</strong> Click to select and place towers. Click placed towers to view stats and upgrade.
                </div>
            </div>
            
            <div class="tutorial-step" data-step="1">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Defend the Path</div>
                <div class="tutorial-text">
                    Enemies travel along the <span class="tutorial-highlight">cyan path</span> from the  green entry to the  red exit. 
                    Stop them before they escape!
                </div>
            </div>
            
            <div class="tutorial-step" data-step="2">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Place Towers</div>
                <div class="tutorial-text">
                    Select a tower from the <span class="tutorial-highlight">bottom bar</span>, then place it anywhere on the map (not on the path). 
                    Each tower costs  gold shown below its icon.
                </div>
            </div>
            
            <div class="tutorial-step" data-step="3">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Tower Types (1/2)</div>
                <div class="tutorial-text">
                    <span class="tutorial-highlight"> Blaster</span> - Balanced fighter<br>
                    <span class="tutorial-highlight"> Freezer</span> - Slows enemies (Wave 2)<br>
                    <span class="tutorial-highlight"> Minigun</span> - Very fast fire rate<br>
                    <span class="tutorial-highlight"> Poison</span> - Damage over time<br>
                    <span class="tutorial-highlight"> Sniper</span> - Long range, high damage<br>
                    <span class="tutorial-highlight"> Bomber</span> - Splash damage
                </div>
            </div>
            
            <div class="tutorial-step" data-step="4">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Tower Types (2/2)</div>
                <div class="tutorial-text">
                    <span class="tutorial-highlight"> Chain</span> - Bounces between enemies<br>
                    <span class="tutorial-highlight"> Beam</span> - Damage ramps over time<br>
                    <span class="tutorial-highlight"> Inferno</span> - Burning ground zones<br>
                    <span class="tutorial-highlight"> Cannon</span> - Piercing line shot<br>
                    <span class="tutorial-highlight"> Tesla</span> - Zaps multiple enemies<br>
                    <span class="tutorial-highlight"> Buff</span> - Boosts nearby towers
                </div>
            </div>
            
            <!-- HIDDEN until champions feature complete -->
            <div class="tutorial-step" data-step="5" style="display: none;">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Champions</div>
                <div class="tutorial-text">
                    Unlock <span class="tutorial-highlight">Champions</span> at waves 20 and 25!<br><br>
                    <span class="tutorial-highlight"> Neon Striker</span> - Melee warrior (Wave 20)<br>
                    <span class="tutorial-highlight"> Void Caster</span> - Ranged mage (Wave 25)<br><br>
                    Champions are <span class="tutorial-highlight">FREE</span> hero units that walk around and fight enemies. Tap their beacon to toggle between <span class="tutorial-highlight">Single</span> and <span class="tutorial-highlight">Multi</span> target modes!
                </div>
            </div>
            
            <div class="tutorial-step" data-step="5">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Earn Gold</div>
                <div class="tutorial-text">
                    Defeat enemies to earn <span class="tutorial-highlight"> gold</span>. 
                    Tougher enemies give more gold. Use gold to build more towers!
                </div>
            </div>
            
            <div class="tutorial-step" data-step="6">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Roguelite Upgrades</div>
                <div class="tutorial-text">
                    After each wave, choose from <span class="tutorial-highlight">3 random upgrades</span> that permanently boost your towers. 
                    Stack the same upgrade multiple times for powerful combos!
                </div>
            </div>
            
            <div class="tutorial-step" data-step="7">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Tower Shop</div>
                <div class="tutorial-text">
                    Between waves, open the <span class="tutorial-highlight">SHOP</span> to upgrade specific tower types. 
                    These upgrades affect all towers of that type!
                </div>
            </div>
            
            <div class="tutorial-step" data-step="8">
                <div class="tutorial-icon"></div>
                <div class="tutorial-heading">Survive!</div>
                <div class="tutorial-text">
                    You start with <span class="tutorial-highlight">20  lives</span>. Each enemy that escapes costs a life. 
                    Survive as many waves as possible!
                </div>
            </div>
            
            <div class="tutorial-nav">
                <button class="tutorial-nav-btn tutorial-prev" id="tutorialPrev"> Back</button>
                <div class="tutorial-dots" id="tutorialDots"></div>
                <button class="tutorial-nav-btn tutorial-next" id="tutorialNext">Next </button>
            </div>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="gameover-overlay" id="gameoverOverlay">
        <div class="gameover-title">GAME OVER</div>
        <div class="gameover-stats" id="gameoverStats"></div>
        <button class="menu-btn" id="restartBtn">PLAY AGAIN</button>
    </div>

    <!-- Confirm Overlay -->
    <div class="confirm-overlay" id="confirmOverlay">
        <div class="confirm-container">
            <div class="confirm-text">Confirm to begin</div>
            <div class="confirm-buttons">
                <button class="confirm-btn yes" id="confirmYes">CONFIRM</button>
                <button class="confirm-btn no" id="confirmNo">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Tower Placement Preview Overlay (Mobile) -->
    <div class="placement-preview-overlay" id="placementPreviewOverlay">
        <div class="placement-preview-container">
            <div class="placement-preview-text">Place here?</div>
            <div class="placement-preview-buttons">
                <button class="placement-btn yes" id="placementConfirm"></button>
                <button class="placement-btn no" id="placementCancel"></button>
            </div>
        </div>
    </div>

    <!-- Upgrade Overlay -->
    <div class="upgrade-overlay" id="upgradeOverlay">
        <div class="upgrade-title">CHOOSE UPGRADE</div>
        <div class="upgrade-subtitle">Select a permanent bonus</div>
        <div class="upgrade-slots" id="upgradeSlots">
            <div class="upgrade-slot" id="slot0">
                <div class="upgrade-content">
                    <div class="upgrade-icon">?</div>
                    <div class="upgrade-name">???</div>
                    <div class="upgrade-desc">???</div>
                    <div class="upgrade-rarity">???</div>
                </div>
            </div>
            <div class="upgrade-slot" id="slot1">
                <div class="upgrade-content">
                    <div class="upgrade-icon">?</div>
                    <div class="upgrade-name">???</div>
                    <div class="upgrade-desc">???</div>
                    <div class="upgrade-rarity">???</div>
                </div>
            </div>
            <div class="upgrade-slot" id="slot2">
                <div class="upgrade-content">
                    <div class="upgrade-icon">?</div>
                    <div class="upgrade-name">???</div>
                    <div class="upgrade-desc">???</div>
                    <div class="upgrade-rarity">???</div>
                </div>
            </div>
        </div>
        <div class="reroll-container">
            <button class="reroll-btn" id="rerollBtn"> REROLL</button>
            <div class="reroll-count" id="rerollCount">3 rerolls left</div>
        </div>
    </div>
    
    <!-- Exit Confirmation Overlay -->
    <div class="exit-confirm-overlay" id="exitConfirmOverlay">
        <div class="exit-confirm-box">
            <div class="exit-confirm-text">Exit to main menu?<br><span style="font-size: 12px; color: rgba(255,255,255,0.5);">Progress will be lost</span></div>
            <div class="exit-confirm-buttons">
                <button class="exit-confirm-btn yes" id="exitYes">EXIT</button>
                <button class="exit-confirm-btn no" id="exitNo">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Score Submission Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-content">
            <div class="score-modal-title" id="scoreModalTitle">HIGH SCORE</div>
            <div class="score-stats">
                <span id="finalModeDisplay" style="color: #f0f; font-weight: bold;">CAMPAIGN</span><br>
                Waves: <span id="finalWaveDisplay">0</span><br>
                Kills: <span id="finalKillsDisplay">0</span>
            </div>
            <label class="score-input-label">Enter your name for the leaderboard:</label>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME">
            <div class="score-error" id="scoreErrorMsg"></div>
            <div class="score-buttons">
                <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
                <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            </div>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title"> LEADERBOARD</div>
                <button class="leaderboard-close" id="leaderboardClose"></button>
            </div>
            <div class="leaderboard-tabs">
                <button class="leaderboard-tab active-campaign" id="tabCampaign">Campaign</button>
                <button class="leaderboard-tab" id="tabClassic">Classic</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <div class="leaderboard-loading">Loading scores...</div>
            </div>
        </div>
    </div>
    
    <!-- Shop Overlay -->
    <div class="shop-overlay" id="shopOverlay">
        <div class="shop-container">
            <div class="shop-gold"> <span id="shopGoldDisplay">0</span></div>
            <div class="shop-header">
                <div class="shop-title" id="shopTitle"> TOWER UPGRADES</div>
            </div>
            <div class="shop-grid" id="shopGrid"></div>
            <div class="shop-stats-panel" id="shopStatsPanel">
                <div class="stats-grid" id="statsGrid"></div>
            </div>
            <div class="shop-buttons">
                <button class="shop-stats-toggle" id="shopStatsToggle">STATS</button>
                <button class="shop-continue-btn" id="shopClose">EXIT</button>
            </div>
        </div>
    </div>

    <div class="game-wrapper">
        <div class="game-container">
        <div class="hud">
            <div class="hud-item"> <span id="livesDisplay">20</span></div>
            <div class="hud-item"> <span id="goldDisplay">65</span></div>
            <div class="hud-item"> <span class="hide-mobile">Wave </span><span id="waveDisplay">1</span></div>
            <div class="hud-item"> <span id="killsDisplay">0</span></div>
        </div>
        <button class="speed-btn" id="speedBtn"> 1x</button>
        <button class="exit-btn" id="exitBtn"> EXIT</button>
        <canvas id="gameCanvas" width="648" height="576"></canvas>
        <div class="placement-tooltip" id="placementTooltip">
            <span class="tower-name"></span><span class="tower-desc"></span>
        </div>
        <div class="control-bar">
            <div class="tower-bar" id="towerBar">
                <!-- Tower Action Panel (shows over tower buttons) -->
                <div class="tower-action-panel" id="towerActionPanel">
                    <div class="tower-action-title" id="towerActionTitle">Place Tower?</div>
                    <div class="tower-action-subtitle" id="towerActionSubtitle">Tap location confirmed</div>
                    <div class="tower-action-buttons">
                        <button class="tower-action-btn confirm" id="towerActionConfirm"> PLACE</button>
                        <button class="tower-action-btn move" id="towerActionMove" style="display:none;"> MOVE</button>
                        <button class="tower-action-btn cancel" id="towerActionCancel"> CANCEL</button>
                    </div>
                    <!-- Champion focus toggle (hidden by default) -->
                    <div class="champion-focus-toggle" id="championFocusToggle" style="display:none;">
                        <span class="focus-label">FOCUS:</span>
                        <div class="focus-switch">
                            <button class="focus-option active" id="focusSingle" data-mode="single">SINGLE</button>
                            <button class="focus-option" id="focusMulti" data-mode="multi">MULTI</button>
                        </div>
                    </div>
                </div>
                <!-- Towers sorted by unlock: top-bottom per column, then left-right -->
                <!-- Col 1: Blaster(0), Minigun(0) -->
                <div class="tower-btn" data-tower="basic" title="Blaster - Balanced fighter">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$50</div>
                </div>
                <!-- Col 2: Poison(0), Sniper(0) -->
                <div class="tower-btn" data-tower="poison" title="Poison - Damage over time">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$90</div>
                </div>
                <!-- Col 3: Freezer(2), Splash(5) -->
                <div class="tower-btn" data-tower="freeze" title="Freezer - Slows enemies (Wave 2)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$75</div>
                </div>
                <!-- Col 4: Cannon(5), Chain(8) -->
                <div class="tower-btn" data-tower="cannon" title="Cannon - Piercing line shot (Wave 5)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$175</div>
                </div>
                <!-- Col 5: Laser(10), Inferno(12) -->
                <div class="tower-btn" data-tower="laser" title="Beam - Ramps up damage over time (Wave 10)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$150</div>
                </div>
                <!-- Col 6: Tesla(15), Buff(18) -->
                <div class="tower-btn" data-tower="tesla" title="Tesla Coil - Zaps multiple enemies (Wave 15)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$180</div>
                </div>
                <!-- Col 7: Striker(20), Caster(25) - HIDDEN until feature complete -->
                <div class="tower-btn champion-btn" data-tower="striker" title="Black Squirrel - Melee/ranged adaptive (Wave 20)" style="display: none;">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">FREE</div>
                </div>
                <!-- Row 2 -->
                <div class="tower-btn" data-tower="minigun" title="Minigun - Very fast fire rate">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$80</div>
                </div>
                <div class="tower-btn" data-tower="sniper" title="Sniper - Long range, high damage">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$100</div>
                </div>
                <div class="tower-btn" data-tower="splash" title="Bomber - Splash damage (Wave 5)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$125</div>
                </div>
                <div class="tower-btn" data-tower="chain" title="Chain - Bounces between enemies (Wave 8)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$140</div>
                </div>
                <div class="tower-btn" data-tower="inferno" title="Inferno - Burning ground zones (Wave 12)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$160</div>
                </div>
                <div class="tower-btn" data-tower="buff" title="Buff Tower - Boosts nearby towers (Wave 18)">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">$200</div>
                </div>
                <!-- HIDDEN until feature complete -->
                <div class="tower-btn champion-btn" data-tower="caster" title="Joust Panther - Adaptive pounce/cleave (Wave 25)" style="display: none;">
                    <div class="tower-icon"></div>
                    <div class="tower-cost">FREE</div>
                </div>
            </div>
            <div class="control-buttons">
                <button class="wave-btn" id="waveBtn">START WAVE</button>
                <button id="shopBtn">UPGRADES</button>
                <button id="leaderboardBtn">LEADER BOARD</button>
            </div>
            </div>
        </div>
    </div>

    <script>
        // ========== FIREBASE CONFIGURATION ==========
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ========== PROFANITY FILTER ==========
        const blockedPatterns = [
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i,
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i
        ];
        
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'homo'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            if (blockedExact.has(normalized)) return true;
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) return true;
            }
            return false;
        }
        
        function sanitizeUsername(name) {
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ========== GAME CONFIGURATION ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Base canvas dimensions (game logic coordinates)
        const BASE_WIDTH = 648;  // 18 cells * 36px = perfect grid fit
        const BASE_HEIGHT = 576; // 16 cells * 36px = perfect grid fit
        
        // Current canvas dimensions
        let CANVAS_WIDTH = BASE_WIDTH;
        let CANVAS_HEIGHT = BASE_HEIGHT;
        
        // ========== DEBUG UTILITY ==========
        const GameDebug = {
            enabled: false, // Toggle for debugging
            el: null,
            show(data) {
                if (!this.enabled) return this.hide();
                if (!this.el) {
                    this.el = document.createElement('div');
                    this.el.id = 'game-debug';
                    this.el.style.cssText = `
                        position: fixed; top: 60px; left: 10px;
                        background: rgba(255,0,0,0.9); color: #fff;
                        padding: 8px; font: 12px monospace;
                        z-index: 99999; border-radius: 4px;
                        max-width: 300px; pointer-events: none;
                    `;
                    document.body.appendChild(this.el);
                }
                this.el.innerHTML = Object.entries(data)
                    .map(([k, v]) => `${k}: ${v}`)
                    .join('<br>');
            },
            hide() {
                if (this.el) {
                    this.el.remove();
                    this.el = null;
                }
            }
        };
        
        // ========== iOS GESTURE PREVENTION ==========
        // Prevent iOS "swipe down to exit fullscreen" gesture
        (function() {
            if (!('ontouchstart' in window)) return;
            
            let touchStartY = 0;
            const EDGE_THRESHOLD = 50; // Pixels from top edge
            
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                // If touch started near top edge and is moving down, block it
                if (touchStartY < EDGE_THRESHOLD) {
                    const currentY = e.touches[0].clientY;
                    if (currentY > touchStartY + 10) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });
        })();
        
        // ========== COMPREHENSIVE PIXEL DENSITY SCALING ==========
        let currentScale = 1;
        let dprScale = 1;
        let displayWidth = BASE_WIDTH;
        let displayHeight = BASE_HEIGHT;
        
        // Device detection - improved for all device types
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isIPad = /iPad/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
                      (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
        const isTablet = isTouchDevice && (isIPad || Math.min(window.screen.width, window.screen.height) >= 600);
        const rawDPR = window.devicePixelRatio || 1;
        
        // Screen size detection for 4K and large displays
        const screenWidth = window.screen.width * rawDPR;
        const screenHeight = window.screen.height * rawDPR;
        const is4K = screenWidth >= 3840 || screenHeight >= 2160;
        const isLargeMonitor = screenWidth >= 2560 || screenHeight >= 1440;
        const isPhone = isTouchDevice && Math.min(window.screen.width, window.screen.height) < 600;
        
        // iOS canvas memory limit: 16,777,216 pixels max (approx 4096x4096)
        const MAX_CANVAS_PIXELS = 16777216;
        
        // Performance-based detection
        const cpuCores = navigator.hardwareConcurrency || 4;
        const isHighPerfDevice = cpuCores >= 8 || is4K;
        const isMidPerfDevice = cpuCores >= 4 && !isPhone;
        const isLowPerfDevice = cpuCores < 4 || isPhone;
        
        // DPR limits by device category
        // These determine the maximum buffer resolution multiplier
        function getMaxDPR() {
            if (is4K && isHighPerfDevice) {
                return 3.0; // 4K displays: up to 3x for maximum crispness
            }
            if (isLargeMonitor && isHighPerfDevice) {
                return 2.5; // Large monitors: 2.5x
            }
            if (isTablet || isIPad) {
                return 2.0; // Tablets/iPads: 2x (memory constrained)
            }
            if (isPhone) {
                return 2.0; // Phones: 2x (battery/memory constrained)
            }
            if (isMidPerfDevice) {
                return 2.0; // Standard laptops/desktops: 2x
            }
            return 1.5; // Low-end devices: 1.5x
        }
        
        // Get accurate viewport size (works better in iframes)
        function getViewportSize() {
            if (window.visualViewport) {
                return {
                    width: window.visualViewport.width,
                    height: window.visualViewport.height
                };
            }
            return {
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        
        function calculateScale() {
            const isNativeFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            const isInIframe = window.self !== window.top;
            
            const viewport = getViewportSize();
            const viewW = viewport.width;
            const viewH = viewport.height;
            
            const isPseudoFullscreen = !isNativeFullscreen && 
                                       (isInIframe || viewW > BASE_WIDTH * 1.15 || viewH > BASE_HEIGHT * 1.15);
            
            const isFullscreen = isNativeFullscreen || isPseudoFullscreen;
            const isMobile = viewW <= 768;
            const gameContainer = document.querySelector('.game-container');
            
            // Control bar takes about 155px (two rows of towers + buttons + padding)
            const CONTROL_BAR_HEIGHT = 155;
            const TOTAL_GAME_HEIGHT = BASE_HEIGHT + CONTROL_BAR_HEIGHT;
            const TOTAL_GAME_WIDTH = BASE_WIDTH;
            
            const gameAspect = BASE_WIDTH / BASE_HEIGHT;
            
            if (isFullscreen) {
                gameContainer.classList.add('fullscreen-mode');
                document.body.classList.add('fullscreen-active');
                
                // Minimal margin system - fit close to edges
                const borderWidth = isInIframe ? 0 : 2;
                const safetyPadding = (isTablet || isIPad) ? 10 : 0;
                const totalMargin = (borderWidth + safetyPadding) * 2;
                
                const availWidth = viewW - totalMargin;
                const availHeight = viewH - totalMargin;
                
                // Scale to fit ENTIRE game (canvas + control bar) within viewport
                const scaleByWidth = availWidth / TOTAL_GAME_WIDTH;
                const scaleByHeight = availHeight / TOTAL_GAME_HEIGHT;
                
                // Always use min to ensure everything fits
                const scaleFactor = Math.min(scaleByWidth, scaleByHeight);
                
                // Iframe stretch mode: fill available space (may distort aspect ratio)
                if (isInIframe) {
                    const controlBarScaled = CONTROL_BAR_HEIGHT * scaleByWidth;
                    displayWidth = Math.floor(availWidth);
                    displayHeight = Math.floor(availHeight - controlBarScaled);
                } else {
                    displayWidth = Math.floor(BASE_WIDTH * scaleFactor);
                    displayHeight = Math.floor(BASE_HEIGHT * scaleFactor);
                }
                
                CANVAS_WIDTH = displayWidth;
                CANVAS_HEIGHT = displayHeight;
                
                // Determine buffer scale based on device type
                const maxDPR = getMaxDPR();
                let bufferScale = Math.min(rawDPR, maxDPR);
                
                // iOS canvas memory safety check
                let bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                let bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                let totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const memScaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    bufferScale *= memScaleFactor;
                    bufferWidth = Math.round(BASE_WIDTH * bufferScale);
                    bufferHeight = Math.round(BASE_HEIGHT * bufferScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(bufferScale, bufferScale);
                dprScale = bufferScale;
                
                // Update CSS custom properties
                const uiScale = displayWidth / BASE_WIDTH;
                currentScale = uiScale;
                const root = document.documentElement;
                root.style.setProperty('--scale', uiScale);
                root.style.setProperty('--canvas-width', displayWidth + 'px');
                root.style.setProperty('--canvas-height', displayHeight + 'px');
                
                // Debug overlay
                GameDebug.show({
                    viewport: `${viewW}${viewH}`,
                    display: `${displayWidth}${displayHeight}`,
                    buffer: `${bufferWidth}${bufferHeight}`,
                    dpr: `${rawDPR.toFixed(2)}${bufferScale.toFixed(2)}`,
                    device: is4K ? '4K' : (isTablet ? 'tablet' : (isPhone ? 'phone' : 'desktop'))
                });
            } else if (isMobile) {
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
                
                const containerPadding = isInIframe ? 0 : 5;
                const maxWidth = viewW - containerPadding * 2;
                const maxHeight = viewH - (isInIframe ? 0 : 10);
                
                // Scale to fit entire game (canvas + controls)
                const scaleByWidth = maxWidth / TOTAL_GAME_WIDTH;
                const scaleByHeight = maxHeight / TOTAL_GAME_HEIGHT;
                const scaleFactor = Math.min(scaleByWidth, scaleByHeight);
                
                displayWidth = Math.floor(BASE_WIDTH * scaleFactor);
                displayHeight = Math.floor(BASE_HEIGHT * scaleFactor);
                
                CANVAS_WIDTH = displayWidth;
                CANVAS_HEIGHT = displayHeight;
                
                // Use device-appropriate DPR (phones get up to 2x, tablets up to 2x)
                const maxDPR = getMaxDPR();
                dprScale = Math.min(rawDPR, maxDPR);
                
                let bufferWidth = Math.round(BASE_WIDTH * dprScale);
                let bufferHeight = Math.round(BASE_HEIGHT * dprScale);
                let totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const memScaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    dprScale *= memScaleFactor;
                    bufferWidth = Math.round(BASE_WIDTH * dprScale);
                    bufferHeight = Math.round(BASE_HEIGHT * dprScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                
                const uiScale = displayWidth / BASE_WIDTH;
                currentScale = uiScale;
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dprScale, dprScale);
                
                const root = document.documentElement;
                root.style.setProperty('--scale', uiScale);
                root.style.setProperty('--canvas-width', displayWidth + 'px');
                root.style.setProperty('--canvas-height', displayHeight + 'px');
                
                GameDebug.hide();
            } else {
                gameContainer.classList.remove('fullscreen-mode');
                document.body.classList.remove('fullscreen-active');
                
                // Desktop/Laptop: scale to fill available space
                const containerPadding = isInIframe ? 0 : 10;
                const maxWidth = viewW - containerPadding * 2;
                const maxHeight = viewH - (isInIframe ? 0 : 20);
                
                // Scale to fit entire game (canvas + controls)
                const scaleByWidth = maxWidth / TOTAL_GAME_WIDTH;
                const scaleByHeight = maxHeight / TOTAL_GAME_HEIGHT;
                const scaleFactor = Math.min(scaleByWidth, scaleByHeight);
                
                displayWidth = Math.floor(BASE_WIDTH * scaleFactor);
                displayHeight = Math.floor(BASE_HEIGHT * scaleFactor);
                
                CANVAS_WIDTH = displayWidth;
                CANVAS_HEIGHT = displayHeight;
                
                // Use device-appropriate DPR (laptops 2x, large monitors 2.5x, 4K up to 3x)
                const maxDPR = getMaxDPR();
                dprScale = Math.min(rawDPR, maxDPR);
                
                let bufferWidth = Math.round(BASE_WIDTH * dprScale);
                let bufferHeight = Math.round(BASE_HEIGHT * dprScale);
                let totalPixels = bufferWidth * bufferHeight;
                
                if (totalPixels > MAX_CANVAS_PIXELS) {
                    const memScaleFactor = Math.sqrt(MAX_CANVAS_PIXELS / totalPixels);
                    dprScale *= memScaleFactor;
                    bufferWidth = Math.round(BASE_WIDTH * dprScale);
                    bufferHeight = Math.round(BASE_HEIGHT * dprScale);
                }
                
                canvas.width = bufferWidth;
                canvas.height = bufferHeight;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                
                const uiScale = displayWidth / BASE_WIDTH;
                currentScale = uiScale;
                
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dprScale, dprScale);
                
                const root = document.documentElement;
                root.style.setProperty('--scale', uiScale);
                root.style.setProperty('--canvas-width', displayWidth + 'px');
                root.style.setProperty('--canvas-height', displayHeight + 'px');
                
                GameDebug.hide();
            }
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        
        function resizeCanvas() {
            calculateScale();
        }
        
        function handleFullscreenChange() {
            calculateScale();
        }
        
        // Listen for fullscreen changes (all browser variants)
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Resize on orientation change and window resize
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });
        
        // Use visualViewport resize event if available (better for iframes)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
            window.visualViewport.addEventListener('scroll', resizeCanvas);
        }
        
        // Re-check size after delays for iframe loading
        setTimeout(resizeCanvas, 100);
        setTimeout(resizeCanvas, 300);
        
        // Initial scale calculation
        calculateScale();
        
        // Constants
        const MAX_PARTICLES = 200;
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;
        
        // Tower Definitions
        const TOWERS = {
            basic: {
                name: 'Blaster',
                cost: 50,
                range: 100,
                damage: 10,
                fireRate: 500,
                color: '#0ff',
                projectileSpeed: 8,
                projectileColor: '#0ff',
                icon: ''
            },
            sniper: {
                name: 'Sniper',
                cost: 100,
                range: 180,
                damage: 40,
                fireRate: 1200,
                color: '#ff0000',
                projectileSpeed: 15,
                projectileColor: '#ff0000',
                icon: ''
            },
            freeze: {
                name: 'Freezer',
                cost: 75,
                range: 80,
                damage: 5,
                fireRate: 800,
                color: '#00ccff',
                projectileSpeed: 6,
                projectileColor: '#00ccff',
                slowAmount: 0.5,
                slowDuration: 2000,
                icon: ''
            },
            splash: {
                name: 'Bomber',
                cost: 125,
                range: 90,
                damage: 15,
                fireRate: 1000,
                color: '#f0f',
                projectileSpeed: 5,
                projectileColor: '#f0f',
                splashRadius: 50,
                icon: ''
            },
            laser: {
                name: 'Beam',
                cost: 150,
                range: 120,
                damage: 12,
                fireRate: 100,
                color: '#b400ff',
                isBeam: true,
                icon: ''
            },
            minigun: {
                name: 'Minigun',
                cost: 80,
                range: 85,
                damage: 4,
                fireRate: 120,
                color: '#ff4444',
                projectileSpeed: 12,
                projectileColor: '#ff4444',
                icon: ''
            },
            cannon: {
                name: 'Cannon',
                cost: 175,
                range: 110,
                damage: 80,
                fireRate: 2500,
                color: '#8844ff',
                projectileSpeed: 8,
                projectileColor: '#8844ff',
                isPiercing: true,
                isCannon: true,
                icon: ''
            },
            poison: {
                name: 'Poison',
                cost: 90,
                range: 90,
                damage: 3,
                fireRate: 700,
                color: '#44ff44',
                projectileSpeed: 7,
                projectileColor: '#44ff44',
                poisonDamage: 2,
                poisonDuration: 3000,
                icon: ''
            },
            chain: {
                name: 'Chain',
                cost: 140,
                range: 100,
                damage: 12,
                fireRate: 900,
                color: '#ffaa00',
                projectileSpeed: 10,
                projectileColor: '#ffaa00',
                chainCount: 3,
                chainRange: 60,
                icon: ''
            },
            buff: {
                name: 'Buff Tower',
                cost: 200,
                range: 80,
                damage: 0,
                fireRate: 0,
                color: '#ff88ff',
                buffRange: 80,
                buffDamage: 0.25,
                buffFireRate: 0.15,
                icon: ''
            },
            tesla: {
                name: 'Tesla Coil',
                cost: 180,
                range: 95,
                damage: 8,
                fireRate: 400,
                color: '#00ffff',
                isTesla: true,
                maxTargets: 5,
                arcColor: '#88ffff',
                icon: ''
            },
            inferno: {
                name: 'Inferno',
                cost: 160,
                range: 130,
                damage: 0,
                fireRate: 3000,
                color: '#ff4400',
                isInferno: true,
                infernoRadius: 32,
                infernoDamage: 7,
                infernoDuration: 12000,
                infernoMaxZones: 3,
                projectileSpeed: 120,
                projectileColor: '#8B4513',
                icon: ''
            }
        };

        // Tower descriptions for tooltips
        const TOWER_DESCRIPTIONS = {
            basic: 'Balanced fighter',
            sniper: 'Long range, high damage',
            freeze: 'Slows enemies',
            splash: 'Splash damage',
            laser: 'Ramps up damage over time',
            minigun: 'Very fast fire rate',
            cannon: 'Piercing line shot',
            poison: 'Damage over time',
            chain: 'Bounces between enemies',
            buff: 'Boosts nearby towers',
            tesla: 'Zaps multiple enemies at once',
            inferno: 'Creates burning ground zones'
        };
        
                // ==================== BLACK SQUIRREL SPRITE SYSTEM ====================
        const SQUIRREL_SPRITES = {
            attack: [],  // Will hold Image objects for attack frames
            idle: [],    // Will hold Image objects for idle frames
            loaded: false,
            frameIndex: 0,
            lastFrameTime: 0
        };

        const SQUIRREL_SPRITE_DATA = {
            attack1: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAgCAYAAABU1PscAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpDBMICwHgI01/AAAHcklEQVRYw9WYbYxcVR3Gf+fec2fuvOzL7G53u7vTdndbCi1iaZFigVio0qJQjQZDRTGiH4iJhsRQjZpoE9PEL8REjYlgDFBfigKiiYil4BslVrTt0pa2LNtd2u50dnZ2Znbmztu995zjhwXjBzWzpVvkfD/3/zz3PM//PP8jjDGGd/Cy3m4A7xgCxihCU0SbJqCBi3PwcrGBB2aWuprk6PivqYq/4jJCpWBjiwi9PcMs67uOrsRV2CJ+Qd8Xi+mBup7klPc1frP3Hzz90wypbkkpZ1EpgsHQv8Jm250dfOgjt7G68+s49P7/EDA0ePbQTn7+ywf5w14JYQIMNJpNhBBIaeM4Fn0DkvdudbnrMztYP7wTSdeC6iyahGb8fTz68GM8/ahFxJFEIoogVFi2he+H+GGIqmpm8pqpMwlyZ3/G/d9Isn7oKwuCtSgmVtR4dXovxw8VUKFFECoqXh1H2mhtsCyBtCWhCegdNmy4JaTvsiajY49TVeNv/wkEJsfhw0eYK0K94UPTYAzYto0xhkQ8SqFUxQhYvzHFfTs/zeUjm2nqDAZ9aQmUm2O8nnuOkf5bSMgRQGALm5lzFtNnFZ19gvQqi8yEYS7XJBqRKKURQFtblK0fXc6mNfchGWTejma+w4rW6r9lCR058RRfuPfLPPDQJ5iu7QfAoZf3XLuOtRsF198axVIxRtY6uG0hTT9Ea0My6RKVLmfGC8z4z2FQCCEQwmoZPIC9a9euXRcOP+AvRx7i93vHOfq3WXT7Ya5adznVcAK3s4CKH+WFxx3Onwbbtkj1ac6fUSAMyUQMx7YpZQVyyUHSQ90k7NUIsTBRvEUJOSQjywhUyGxO8+QjxyHyKcZeblCthOSmNH4lTsOfo1K02XCNzeQpRaXYxLJsulNJZrOGJ75bw5Lf4tYPZBh07kWKtsUlYN7QqACWLR/ESQTE2gyudPnFdxqUZy183wYh6E45dLTHcaJNOtqjbLjBZibbZPxYnXzB0NURJ5yM8MyeOfqv+DZ2OkE68vmWsSxIQsZoDAHa+FhIhBDE2zTjmd9RKwjqpRh+TWIJgVIKow1BqKlU6qRXGyztkjkZx00YBlYapqcCPC9EaUXDsxCyjpMoctnAdixaixYLMnFg8nhqlMDkEGLeaQk5TG9PmrAeQ4cWUgq0MWhjsGyB74dEIhIpokTiikTcpZ5vp1FIsPZah9D4lMo1suer/PbHggP7J5hTf28ZU+sEDChTo25OYov5WBDqCqXGK5w4OkXgC5yIRajm+3jMjaDfaOm2bVHOughAuBWiUUmt6CL8BENXOASBpuI1OTcZkJ3OUWi8tAgEAEek0KKGb86jTIOmmaIUvohXnSMZayMIDBWvAcKgjWBwaR/L+/vwg5CqFzAx6pDsaVCcq4AwlLKSvqUxOpcIglCjRYBSmvKM2zKm1k0sQJsQbXxCMU3eHCabP8ahV55BWIbJc1miUYtIxGa24KEUGA29PW0MLe+mXG7QVA3KZUWxVMO2m6AF8ZTDBz8Z5eCzAa+fUpTzLp3xlRefgDGaps5QDSc4kz/E2cwx9j91mtPHNbGkTUeHgzECKS2SCZf8rIfrCiypqRUDCuUSrlHkciCkpFptYgmL6XOgDgj60pLZrOLqzRE6UovQRg0BFV7gpZcO8Nj3z5E9q+jsSnBitED/cIATs/CKgrVDKzg5cZaa18C2BWGo8fwK8S5NfkrTrEN6pSbVL8hOKqpeSPm4ZtW7BRvfH+PaKz9Op9zYMoGWPWCJKLP5Ir96eIyefhuv5rH2Bp+aX2f0YJWCN4eK1MjM5NnU38eWoUEqlQaz5TlkPCCo2hhlkYy79KYtNm4TJLuhVvcJtWbqdZ+7PruZ7TfuQtJOqyPngkx85tWAYtam5JWZKzfY9+QsdsTQ0QvplQ7X3BTDs6bxow6vzlXxGnX6lluke5ewpKObzvYECp8bt8v5uKM1K9bYDKwU5M/DI987wtGxfSBaT3MLuon7l3WxabvhxedrvO/D7XSlUnT3dLFuw1quXn07iVgHj+/7Jnt+MEq9U7NmwGWgp5vMhCKf96h4TRLdii3X38nIimu45+5TJJNxnn/xJzz8wFleOzXNnw/sZ92qO7BEa51oQSNlQ2U4cGoXxdoY1635HKnYOmwSuNYgwkRAQFWNcXB8N4dPPsGxP0V5+Y+SM5NVqrUmyZTi7vtG+OoX99AT34SvZ/DUMWb8/RSyEupp1gxvozOxvOWfuuCZODQVmipLzB7GEvJfGV5ggTCMzzzBDx/czYkjOWYyPo0q5GdrVBt1vrT7XdyzYzcDbbcikGgTIIQ1vxfxxu3+JpzWJLTgeUCKNuJyFULY82X+LcP7usDo6R8xNj7O0mEoeR5L0gK3TbH59iXs+Nj9SEfjBa8BYFsRLCHnSYg3AYuWwcMFplHxXwrYIs7Q0q3cdofPdKaIkwQZrbF5R5Kbb97CYOdmpGjHti7sDeg/YrnYzyrGKBQe9WYJZefIFcfo7lhGe+RKJKl58guYuC45gf9JjouKHbjEj7sXG/wlJ7AY658Vd21lDIWU/wAAAABJRU5ErkJggg==',
            attack2: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAgCAYAAABU1PscAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpDBMICwHgI01/AAAHZUlEQVRYw9WYaWwV1xXHf3fmzbzVfvbzw5jFAZudEEJCgyCLk6gpiKAkFVRV+6Fp6AJSJYTSVooqRQhFXVT1SyXUEqFWpFVIon4oUdK0UUrasCRAMWUnGAwB2xg/L89vmzf7vf1gGuVDG9sYiDjSSKPRnTn/3z3nnnPnCqWU4g427YsWMFGL3DZPCiQWjupCAKbWhE4K0JnIPN4WAF8NMmTv4+jHu3A5gTWcwBmaQ02yidb5UebMfII6fSVCjF/OLQcIVZmO4S38+levcnSvS7ahjqGrIb57jEQK7lnusnLtAR5ZWqAptRZBbFzfF7d2ESs689t4eeeL/O5nNgmzjmjUREqJpmn813XjlBhtTyb49vrvsOiuH4wL4pYu4oB+Pjj4Gru2VSCMoZTCcV1M0wDAtm08z6OQ9/n3/gqv7NzOuZ6dQDhmH7c0hcphO+cvfEx/jyAeCylbFumaGqSUFEtllIKauM6KVZJnvjGPxsZGbE7iyC5iWsvtAciVD1AsXWXW1DXoIvXpc6lc+vMd9HY5tCwUoAK6L0gc1wUBtuuhazpzl8ALL25kftMmBEmk8hipTGOzCaWQJM9b7/+U9es38uaeLYSqAIBSCqUkCaOFeDxBfV0NiXgt9ZMF1apLGIYoKVFSoUUCTKMGjXoEJrpIoYv47QGw1Ck+6TpGb6fBz7f8gQPHfgsEhAyAVqBQ7OPSyQjlXB3lvGDuYpNss0/VsdF1HYSi41jIH3e9TE/5VQJVuB6BsduEUihCltCuo2rlsDo1tm/fgb2hm9Onz1CpWFzqzHHhhEDKKoVCmcfXxrh7aYT3d9tcOhsS0SPYFYO3XnEp5V9i/YbTtE5eS1K7F4EJgBDiczVMsIy6vPz6c2zZ/Da+D+ks1KYN8n0CGUKoAiJalJraJFd7cyz/chzfSpKs9yhVihzd6xF4Og31adJ1SR5aDWu/l2LxjB8zPfUsIBDi85NE37p169aJxCBRZ3Pg0HukagRRvZbSoIEmDDRNRxMGSikqFZtI3CE7Vedad8hAl0FmUoR0VtDXHeD5ATKUdHdKcn1FtORlFs99Go0aRgnAxPvAvOan+Nb3HyGTSePbMaJRk0hEQyqFHtGIGBGklDQ0RknWaYR+iB/4nD4UoMs0rQuiGLEA23Eplqrs+bPH4f0XGfY/QCpnVP83CKA+7aICQT4nGeqLggCFwvN8EokYqVQCz/OJxQyCaopin8biB0OMuI/QFZc7HO6amWbthihNMyVV28V2fNygwNGzryGVe3MBlJLXL4CRe1f2MjjcTbVoE4+bOI6D63qYUYNK/zAZy8OyHApDDp0nBIW8Riob4AU+hWKZ00cqHHxHoAmdiCFRKuDYhwF9lzIYemJUTeOqQoEsghCgNCJaCoGGq3qIxx2yAfQPV3GckVnr6elnal0DKcNmRrYGu+pSsSoM9EqsaohVDjDjgsEBi/yQTqIWJk3X6erwSdcbrFjxAGDcvAgopdC1Gix5El/1AwJXdVOW+0nU21SiAsuuEk/ESCZHmtdgpcBgTMfzAiqWxeQWD93w6b3ko1CkM4JoQqCQ2FZILKF4cLXGdzcto3ly25h0jbMPKKryGNFIFkee56NTv+Hg4T0MD/s0tCaonIe6+jQ1yTSDQ3n6B/JomsBzfZrnW2QaIxx6L4IZDZm9VKO2QXL6XyGzF2lICWeOBDROg0Vz1pAQ99x8AA2DKC20n9vJ/n2H+GhvJ4M5n3LJ4v6HPHI5KJdMhgZKZDyfWcKgo1Bm0lSdh1eZHP9nHenaANvP89zzGea3ruRSR5nF983Gsirsfv0wmUyW6Q2rxqxpzAAjHTGkp6eb3+/YxYd7BomaUVat09jxS59CvkDLPIPeTzzcAcEzcxZwJJfjZE+J2ga4eDzNwNUoEKCkIBZL0Lbkh3xlySxQURQebfcOIlQEU29CoRCIUXWNeQ2E0qHot7OvfSeVcolNP0lSyFc5e9KmdZFi+swYtek4U2cG1E4R7BVwSiuy8EsRWhbGGRzycYMSpVIJuxowcA2kkgShTyg9AulgimmY+hRGivPo4scVASVszl78K3/500WunA/ID/hMa9Vpnr6QzT96nEXz2khEJzFUOsOh9nf529uHENdsQjdBKmZypqvMlGlpbF+BFjJr9gxQMSJaLaDQiY2675kQgC5SxKIpZi/UeGylyZtvOGzcvIavr/4FCbMZoRIIIcjEHmbOk88yb/5L7Ni+jVyPT2OTYvljglTKpe+aYt36aTyx7AV0mUFqLro2vv/gG0ohVIQFM77Go21P4RKw5pv1PL3yeVLm/OviPzs4TtJsZtbdJlIL2PdugB4NOd5eYt6iEC1MowiohudhjKny/2zcu9Gq38Xl/nfQiNHa9FVMvf5/jvNliQtXd1Os9NBzpZ9zV/7Bvr+f5/4VJvc9sIBHl22kwViHoaWvw98YyAS20599TYwy0sfyz3GtsB/bKZHNTiZjriKmTR2pNl8MwBgxlboOKxBCoFSAQiIwRirNxDLo1gPcarvjD3fveID/AE3ca1u1qwTvAAAAAElFTkSuQmCC',
            attack3: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAgCAYAAABU1PscAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpDBMICwHgI01/AAAH2ElEQVRYw9WYaWxdxRmGn5lzzt3v9RJsXwcntrMTTJyUVYGwBkJIkaHQprQFfpRCUX+UH5WqtlLVquqiqmqLaBFqSykNS1EbEEoFNAiRQEKAJiSBEDsmjgnxvt3ru519pj9s6CIRbEwKfOffOToz7zvf+33zzgitteZTHPLjBjDXMP8fk2gNQkAQ5rGDN9DYlIsudsUmlayhuqYFS7YgsD6ZBHy6GM+9wYu7t+BzgK7XEhw9BLF4yGfWBrSfX82y1tupz2xGitpZjS1OdQ3YfieHTtzBA7/tZP8ej0Skmr53QqQQJBIGhqlIpmDFKouOz5/HJWu/Qzyyasbjn+IMKPYf/iO//tUedv/DJGpm0NpGo4nHIuQLHlppKhUT/bqHkM8ST5VYe/Y9WKLl4yfgso8dLzzB9icALVAxF6UUVekESmkcxyOZiBFL+Fx7Uw3X33ArmeRKQuViSUCcagLviu9/JtJaI4Sg4nYyOHgCaUAyGZKfcJBSkE6CH3h4foDlBrQuV2z+4p001d4FWqCnHzEDBnNqowqHzuP3MTD2NOC/914gcMMe8oUxfNdk3ZUGbedAPBniugGO6xEEAa7nY5gGVZkkhowDAo0CphZgJjEnAo5/lHt+81O+/d3beL37XsD9r4wkkzEaGi36jqbJjcVYsEiAUOQmy4RKo5TCcV2OHDTZ8qcH6R9/mED3oXFROkBrdWoJlOwBCoUyx7oCfvbjX9A3ug0oYPud+GqQfXtf5em/WuQnJEMDPpdvMrnqOova+hDbs5HSoGI7DI/YbP3zED/6wffZ13MreW8LaH86GyePOdVAxEyBijDc5zPSb/PwYz+kIfsHXtnVi+1OMjJcYqQ/jhe6uH7I5GiCTLSKjs1lfF3h7495jA3B0GiOih1nYlsMT+3lgnUn+MJn26lOnX9qCaSTi1i+vJkdTx0Godn6yHG80hDlgiQIQrzQIGrBaZkMozmX472K/u6QaDRBXZPFpRs8Xt6Vp/eIh+14xGM2rzwfpfPAIIsXbuGyta1I6k+KYU4SMsiyceN1zG9RNDVbuJNpvEoUKSVCCExpIoUkn6+wtE3SuiLEdovkchVe32vz1gGL8y+cx+nNkiDU2I7H8KBPz5GQrmOPU/Re+kAMsyagteY/N+8zV2xiw7VZokYaSRQrYr73PZ1KYJoGQiiMMEM6GWfpqpBSxabsOLx9rMKhPYKL16fY/NUY8xcaOE6AFYE3DxbIT7iA4mRmYVYS0lqjtIMUMbRWCCGxnRy9b/k4FQtpKAJ3qvBqazNUyg7FYhmFZuh4nBe2xVlzqcf4uMv+VwJcI6DU4+ALi9p6yZIzLRzbI58LsSspYqkCTnCCqNn80RCA6dUXChBorfDVAOWSTamsyKTi5PNFNBpfQbYqRVguY6TTGFIyOekx2m9il13CMCSesHBsn+5OD9ElaGyyOGONwcQwbOpoJ5NYg0X9v+3sXCSktI8bjqFwccMhpjYbjRMexvEmicfjTOTLIEBKg9HRPGMVj9rGOtLJBMWSTbrWxrZ9Bk4ohBC0LBGc1mCgFJgWTIwFFHIht9+1mMvWfg+TRThhDxDOPQNa+1SCN5FEyUTPwdeDHB98lOd3/oXa+iT9b5ewIgLfh6pMgpoag0KhQjRiUiyWMSybaEJyaB8QWixsMbiqQ7Bze4AGrtiYpPeox54dHg/oY1x43j9pbikQN85CCHPuBKSIEahhTFlLJdzNnkM/4dH7D9G9P2Tl2RZRS5Ir+ixZ0oTrhuD75Eolxj0fI2Kz7mrB2GCCXNJAigo33hzltm9czOYvmQinnebmpfQN9PLs9p0sX7aUJc0bsIxaosaCk+KaRQ1IYubp9E08xN5XD7PtyYP0d6eZGJa8/MIk2cYopZLmaM8AhXyJG9uytCyqY+vBPi68wiQRqyY3ZOLYFYIwIDu/hoaqDlpqLiBmLEbpgLrlgjUr7gRtTUETfKChm3kbFS79w7u59+7Heej3h1m5rJq+E3kiqRKrz03S1VkgVWPj+JPMb5jHstVtvFURZJt9lqyI8NqLgsG+CmXbRQuPuoYkKfMiorIVrTVSmFNwdAylgI/ajbr6TQ733kdjY5SmBSZKe1TVBLiOQ/NixbxsSGOrYn2HwKoe4/4dr1KxBll3RZRiMcQXZULhUyw5JKsCIpEaJAmmPPlUn59qNAIpTYSYGbQZS0ioFEcOpHjt5UGqTlM8+LtJmhcJzlydoL6xnp/ffRHLWjcRTwiO9u7kpZeeY9dzJr4dQRpQVQ2+pyiUBEEgqcpkKQZ7SBtXIoU1vZaCGbro2RMwRB2NjQtpP3uUzs4iX/laPVddeT3tbZeRsFYTMeYjSKK1pr7ty1Slv0X/O4+QGw8ZGwlYv7GWJ/82zvKVca75XJaLzv0mBpnpw8+Ht2QzlpApa7h6/e1km+ax9nKLm2+5hUvO+SVV0Q4s2QI6Pm0zQiBGJnEJK9sbUVoxOFDi+edGKBU9rrk+SttZS/Hpww9thDBmdHR8X2XM7lYiZCT/Iv2j20nHVrG46QaEsJjSsJj2LBohJEq5OME75Ca76e67l2eeeYqeLskZK+u46aavk5kXoyF2B5ZR8+HRz57Au6F596+ZHP1stYucfx+FnMIKL2dBdhMKn6hsmnGxfsQEZkFVayBEoxCIab0L3vdG4JNG4FTHp/5y91NP4F/MCqh6LnThmgAAAABJRU5ErkJggg==',
            idle1: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAgCAYAAABU1PscAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpDBMICwHgI01/AAAFrElEQVRYw+2Y248cRxWHv6runumenZ3xzl58ycLaxtjEkg3GTnCiWDyEAJECVgQGHniIgKAIIfMHRCQoiCggBSTA5IUngpCw8EOwAwEbJxFxtDIxcaKEOI69l9je28zu7PRMX6u7iodNkJBAYnaXXZBypHrqh9/5qn7nVJ8SxhjD/3HI9U7gPYA1VTPvrFUMey3yVmaBscYZIusytfL70VENxy5S83biymEE1v8ugM9FTj7/OL944jQfOBCxOFXi+mVNwRPsOTDMF754L/u33U+BofUBeNcR4l98C9QkT/31Wxz73qvMj1WYfMVhfi5ESonnuUy91iDOfkLxaIN9le8jKHStv+IaEEAnHacZv84/GzxjrHGa48euUL9aBgRzM200OQhNnETU6z6//7nhyWNnqcfnl6W/CkWs+O2zP+KRH97HlD8KQKrnOfHcgzzy8GM0WzGFomRhsYVG47kulcoSUMGTlEouf/zVLKfOPoEmWHuARDe5cmmCs8fnOHHqZ0DIH0Z/yg8eepK//RlMWsDpC4jjFMe2sW2bVGWUBlO23KzZ/XHFPV+vUI8v0MnHu9ZfeQ0Yjc41aSx4+uRzlKoP8NSvz9FpeMw1moRkbNgERhvyXIMAyzJkKfh1xZGHPsddt32VkEksUVp7AMcq4VUkdjnh6kV4+NxJojCnv1bDsW0S1UHF7tJppYo0TbEsSbst2X1Xldv3HaZmH6TPfGxZ+iu2UKNzmbev1nGyKq6sUJBlBDaLzTZ+u0N1CBpTGdKSKKUIwpg0zSgWHfyGZPzGS0COEAIhRNf6KwZ4c+xFLl3wETg4toUQgDEkicJzXUpuGWFnZFmOlJI4TugEIalKmZ7IePrkKRrZ6LL1VwigGJu4RGM6WmqnQUSpx8XIDNuW6FwTz5cY2WthuxlKZRhjSFNFEIQsLLQ5c3yWP50/Rk5r7QHqndd59swofishThIA3r42g1sssnnjIKWSS306oFwT7LpdUOzRKKXQWi8tkzN7LeOZ37xMI3557QGipMP1iRa27eA4FnmeM1Dro7dUJQhjfD+gUI3oLGhmrgpG9toMjsh/AOR5jucWuXElYaL1OwxqbQG21PZy5Mt30j+sCJMOi75Pkiga801m5+oIN6F/RDP7lk17qsjMGwX6NjkMjkiMMSilCKMYpOLNyRdQpnsbrQjAFhW+8vnHePTH32R4T0jB03TCAK01G2olqgM2c5eL+FM25aqDV3RZnPQYGHZweyHPNU2/xfhbi1watRGi+3RWfA8UZI2hDbsI5z36e/uQVUmh4AAwMTlNrGI2f1DjukVM5FCfNrTnLAaGLa6/oVEqY/pazsDGMpJ1aKMAURwQdXI818W2LCy51IG00fQOZkhtw2KNYMEiTRRBE7yyRFoGo2HjVqhtm0MRrg/AjpEDHDo8gB/P02qHtPyA6dkGQRRS8AQy2YCUFn4nIE0z4jDHGIHlgDaaONBk9R0U6e96YlsVgJr3IY5+40GGduS0wgVmG3WCOEQKgTGGJEmZb7YIgogoikliRaZyhARjDDdtq3DH/i8hcLueOFdpJhZsr93NLbfsJYwCvGrOps0VBBbSBiXbNBd9smzpIkNoEAKdwc0HJd9+9Gvs3PRpjIFu/yZWCcCwGFyjp9cGYyj1SqIgw3YNOoeeAUW5PwU0AOUaQM6W7RZHv3OIO2+9H4nbdfKwSjOxn4zz3ccf4NSJ8+zaV6JxHVptn60f1hSLFkKV0H0J7WZMmhg+eeR93PPZT7D9pn18ZOdnKLF1yfvLABCr8TIXqhnOXfwl8/44F/7yCjcm2+y/dTcHDu7hhRfPMHr6BkEUM7S5l9vu+CiHP3UfI4OHEDgr3rxVAXh394zJiPUcoCnKfqRwCdQ0QTKDlA49xRquNYCguGLJ1QX4d1zvgC3DGf9x/FffhZZTlN3Ge2+j6x1/B0nutC3X/y1eAAAAAElFTkSuQmCC',
            idle2: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAgCAYAAABU1PscAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpDBMICwHgI01/AAAFvklEQVRYw+2Y64tdVxnGf2vvtc8+lzlz5p6kc0knvUxJDU1oHSSKTfFCLCK2lqIoiqihUAuiILWilPZDFewHUT9YFIJfrOKFJlK1CaGxJYlDm0ZMYppMJ3HuZ2bOmXP22ffLWn4IASkITnNyRqHPH7Cf58d6117v+wqtteb/WMZmB3gXoOOObS5Y2YnASgSs+KdYqE9RGYR+uQ9JF3mjHykGEZjv+PPiRl/ikMv89eJz/OQHz+N560zcY+Mu96O1wfD2Pu7d90Em7/giJfOW/z2AVLscufAIP37mMKf/aDMwWCYIEsIgRkqJacHOvQmPPfUB7rvlOSz6N+zRljvgxNOsR2f59wLXJMy2DvH8z49x7i+S3t4yLSfE9XxMaYDQqExzaarAwe/9nfPzvwZU5wE0ES8c+z5PP/sFlpyTAMSqxuET3+Fbj3+TxQUHS9r4QYjjeaA1UppoDa7r4wcur7/s8YuDB3GSC50HiFSNi+dmOPrLZX774o8AhyNTP+TJb/yMV37vE3mCoe2KpuNiGoJiIU/BtsGIGBqFsZ0Z+w+k2FuusNA4sWH/6/4LaTKSOCVNJH86fJx815c49KspanOSRmOdlTmTbaMJaZZRKuYolYqkWURlKMOpK/buH+GxLz+O3aXJMdB5AMso0z2Qp9ATMX1a892X/0zoK7q7yuTtAlEU4rsZAlBKI02JtBSrS4JSOccnH/owt/Z+Fq0FoNEahPjv/a+7hFZb55ibrmFEvRTMXvKyG2lYeF5AksYMjQqqcymZUgRhRBRHoCzSxCCfK9JymmhCBAIhjA2FbwvA+enjvPVGhGlY2DkLKU2EEKSZwrZy5GUXpqXI0owwilirN3BaLoYQBC049uIZ5ltHYYPB2wQQ8dbMRapLHgJwXI9i0UYbCdIyUFqzNKO4eZeBzEOWaXw/YKVWxw8CHNdj6iWH3x36KaGe7zxAtXWGV46dpl7zCaMYhOCfc8sUCwWGtw5R6S4T+AnjuxW77oV8WRHFKWmSEYQxSiucRsKR31xievFo5wG8cJ35yw2KhQLSMsjSlKGBfsqFCoEf02y4lPpS6ouCtSsmd9yTY+utijhN0Frjej45W7K2AOdmD5Gw0lmAkYFJHvr8PgbGUoLIo95oEoURK2s1FqsrmMWAvpGMCycFtdkc82cLbBnOM3ybIE0zojjBcT0MSzGzcJI1/2+dBciJPr7y8LN87an76R5p0jNgEqUhGuiuFLBLgunXBNUZk3KPiW1JVi4W2DKWo9QDSl194JqOw6kXFM1mY8MZrvsdyBmD9BTG6bFGqIwWCQdTojAjCCMuzybEaciOO1OKBUkWmCzPK9YXDLZsN3AbGWmWsjyXMDZRptzV29kTuCZL2jgtD4FBHKWEYYTjuiRpyuAoCGUTrPZRrwrCIKZVM6j0S0wJWZqhRMTE+wNS+8rmALzn9vvY89E8S7VFmi2P6lqd+rpDnETkSwLCCqZp4noBcZISBRq0gcyBRmCYGn/NhrBvcwAGinfxyIGvUxl1CXWTWPloMnKWBRqiKGa90cTzA/wgxPUCwiDFlAZKaSxbs+fu9zHcvW9zAEAwMfQgd919J9WVOn3b4KaRCgITYUAmW9TXWyRpitIajUIITZZoxiY0jz5zO5/++BNINn4CbZqJFavOm8hcRppoLBvcRoJd0GQJdA/FhJEmmLs6sPQMgmFmbBs3efTJXXzuU9+m19hzdR7aYEvRlpGyEf2DJ57+DEf+cJaePpvVWUGznrJjd0bONiHqotWMuXLJJwwyHv7qTXziwY8wvvW97Lx5P13WDoQW76gfaguAlyzw6pmD1L03ee3EeZbmAnZP7mDP5G2cOnGK08fX8IOQnkGbyb27eOBjBxgf/BAC63qt2zvUKx0SqioAttGHIUp4ySxeXMUwJMVcLwVzKwbFdlne+LXK23XNbaN9/3/SjV9svU3tCn5N7+5GN1v/ApdLzcRVrlA/AAAAAElFTkSuQmCC'
        };

        // Preload sprite images
        function preloadSquirrelSprites() {
            const attackOrder = ['attack1', 'attack2', 'attack3', 'attack2', 'attack1'];
            const idleOrder = ['idle1', 'idle2'];
    
            attackOrder.forEach(key => {
                const img = new Image();
                img.src = SQUIRREL_SPRITE_DATA[key.replace(/\d+$/, match => Math.min(parseInt(match), 3))];
                img.src = SQUIRREL_SPRITE_DATA[key];
                SQUIRREL_SPRITES.attack.push(img);
            });
    
            idleOrder.forEach(key => {
                const img = new Image();
                img.src = SQUIRREL_SPRITE_DATA[key];
                SQUIRREL_SPRITES.idle.push(img);
            });
    
            SQUIRREL_SPRITES.loaded = true;
        }

        // Initialize sprites on load
        preloadSquirrelSprites();
        // ==================== END SPRITE SYSTEM ====================



        // ========== CHAMPION SYSTEM ==========
        const CHAMPIONS = {
            striker: {
                name: 'Black Squirrel',
                unlockWave: 999, // HIDDEN - was 20
                range: 160,
                moveSpeed: 4.0,
                color: '#2a2a2a',
                accentColor: '#44ff44',
                eyeColor: '#88ff88',
                icon: '',
                // Primary: Ranged acorn attacks with stun
                ranged: {
                    damage: 35, // High damage
                    attackRate: 800,
                    stunDuration: 1500, // 1.5s stun per acorn
                    safeDistance: 90, // Stay this far from path
                    description: 'Throws stunning acorns from range'
                },
                // Special: AOE stun jump (every 15 seconds)
                aoeJump: {
                    damage: 25,
                    stunDuration: 2500, // 2.5s AOE stun
                    radius: 60,
                    cooldown: 15000, // 15 seconds
                    description: 'Jumps in for AOE stun, then retreats'
                }
            },
            caster: {
                name: 'Joust Panther',
                unlockWave: 999, // HIDDEN - was 25
                range: 200,
                moveSpeed: 5.0, // Very fast
                color: '#1a0a2a',
                accentColor: '#aa00ff',
                eyeColor: '#ff00ff',
                icon: '',
                // Primary: AOE cleave attacks
                cleave: {
                    damage: 18,
                    attackRate: 1000,
                    radius: 50,
                    description: 'AOE claw swipes to nearby enemies'
                },
                // Special: Pounce and pin (every 10 seconds)
                pounce: {
                    damage: 60,
                    pinDuration: 3000, // 3 second pin
                    cooldown: 10000, // 10 seconds
                    description: 'Pounces enemy near track end, pins them'
                }
            }
        };
        
        const CHAMPION_DESCRIPTIONS = {
            striker: 'Ranged stunner - throws acorns, AOE stun jump every 15s',
            caster: 'AOE cleaver - pounces to pin enemy near exit every 10s'
        };
        
        // Tower unlock waves (Campaign mode only)
        // Wave 0 = available at game start
        // Tower unlock waves (Campaign mode only)
        // Wave 0 = available at game start
        const TOWER_UNLOCKS = {
            // Row 1: Wave 0 towers
            basic: 0,    // Blaster - available from start
            sniper: 0,   // Sniper - available from start  
            minigun: 0,  // Minigun - available from start
            poison: 0,   // Poison - available from start
            // Row 2: Wave 2-8 towers
            freeze: 2,   // Freezer - Wave 2
            splash: 5,   // Bomber - Wave 5
            cannon: 5,   // Cannon - Wave 5
            chain: 8,    // Chain - Wave 8
            // Row 3: Wave 10-18 towers
            laser: 10,   // Beam - Wave 10
            inferno: 12, // Inferno - Wave 12
            tesla: 15,   // Tesla - Wave 15
            buff: 18,    // Buff - Wave 18
            // Champions
            striker: 20, // Champion unlock - Wave 20
            caster: 25   // Champion unlock - Wave 25
        };
        
        // Check if a tower type is unlocked
        function isTowerUnlocked(type) {
            // Check if it's a champion
            if (CHAMPIONS[type]) {
                return highestWaveReached >= CHAMPIONS[type].unlockWave;
            }
            
            // Classic mode: all regular towers unlocked
            if (gameMode === 'classic') {
                // But champions still need wave requirement in both modes
                const unlockWave = TOWER_UNLOCKS[type];
                if (unlockWave !== undefined && unlockWave >= 30) {
                    return highestWaveReached >= unlockWave;
                }
                return true;
            }
            
            // Campaign mode: check wave requirement
            const unlockWave = TOWER_UNLOCKS[type];
            if (unlockWave === undefined) return true; // Unknown tower = unlocked
            return highestWaveReached >= unlockWave;
        }
        
        // Check if champion is already placed
        function isChampionPlaced(type) {
            return champions[type] && champions[type].tower;
        }

        // Upgrade Definitions (slot machine) - base values scale with rarity
        const UPGRADE_BASES = [
            { id: 'damage', icon: '', name: 'Power Up', descTemplate: '+{val}% tower damage', baseVal: 8, key: 'damageBonus', isPercent: true },
            { id: 'range', icon: '', name: 'Extended Range', descTemplate: '+{val}% tower range', baseVal: 6, key: 'rangeBonus', isPercent: true },
            { id: 'firerate', icon: '', name: 'Rapid Fire', descTemplate: '+{val}% fire rate', baseVal: 6, key: 'fireRateBonus', isPercent: true },
            { id: 'splash', icon: '', name: 'Wider Splash', descTemplate: '+{val}% splash radius', baseVal: 10, key: 'splashBonus', isPercent: true },
            { id: 'slow', icon: '', name: 'Deep Freeze', descTemplate: '+{val}% slow power', baseVal: 8, key: 'slowBonus', isPercent: true },
            { id: 'gold', icon: '', name: 'Gold Rush', descTemplate: '+{val}% gold earned', baseVal: 10, key: 'goldBonus', isPercent: true },
            { id: 'discount', icon: '', name: 'Discount', descTemplate: '-{val}% tower costs', baseVal: 5, key: 'costReduction', isPercent: true },
            { id: 'poison', icon: '', name: 'Toxic', descTemplate: '+{val}% poison damage', baseVal: 12, key: 'poisonBonus', isPercent: true },
            { id: 'crit', icon: '', name: 'Critical Hit', descTemplate: '+{val}% crit chance', baseVal: 3, key: 'critChance', isPercent: true },
            { id: 'armor', icon: '', name: 'Armor Pierce', descTemplate: '+{val}% armor shred', baseVal: 6, key: 'armorShred', isPercent: true },
            { id: 'life', icon: '', name: 'Extra Life', descTemplate: '+{val} lives', baseVal: 2, key: 'lives', isPercent: false },
            { id: 'interest', icon: '', name: 'Interest', descTemplate: '+{val}% gold per wave', baseVal: 3, key: 'interest', isPercent: true },
            { id: 'chain', icon: '', name: 'Chain Power', descTemplate: '+{val} chain bounce', baseVal: 1, key: 'chainBonus', isPercent: false },
            { id: 'multishot', icon: '', name: 'Multi-Shot', descTemplate: '+{val}% double shot', baseVal: 6, key: 'multishot', isPercent: true },
            { id: 'luck', icon: '', name: 'Lucky', descTemplate: '+{val}% luck', baseVal: 5, key: 'luck', isPercent: true }
        ];
        
        // Rarity multipliers for upgrade values
        const RARITY_MULTIPLIERS = {
            common: 0.75,
            uncommon: 1.0,
            rare: 1.5,
            epic: 2.0,
            legendary: 3.0
        };
        
        // Base rarity configuration - starts common-heavy, luck shifts weights
        const RARITY_CONFIG = {
            common:    { weight: 78, color: '#aaaaaa', glow: 'rgba(170, 170, 170, 0.4)', label: 'COMMON' },
            uncommon:  { weight: 14, color: '#55ff55', glow: 'rgba(85, 255, 85, 0.5)', label: 'UNCOMMON' },
            rare:      { weight: 6,  color: '#5555ff', glow: 'rgba(85, 85, 255, 0.6)', label: 'RARE' },
            epic:      { weight: 1.5, color: '#aa55ff', glow: 'rgba(170, 85, 255, 0.6)', label: 'EPIC' },
            legendary: { weight: 0.5, color: '#ffaa00', glow: 'rgba(255, 170, 0, 0.7)', label: 'LEGENDARY' }
        };
        
        // Luck protection system
        const LUCK_PROTECTION = {
            // Bad luck protection (pity) - rolls since last rare+ upgrade
            rarePity: 5,        // After 5 common/uncommon, start boosting rare+
            epicPity: 10,       // After 10 without epic+, start boosting epic+
            legendaryPity: 20,  // After 20 without legendary, start boosting
            // Good luck protection (caps) - max per run
            maxEpic: 5,         // Cap epic upgrades per run
            maxLegendary: 2     // Cap legendary upgrades per run
        };
        
        // Luck protection state (reset each game)
        let luckState = {
            pityCounter: 0,     // Rolls since last rare+
            epicCount: 0,       // Epic upgrades this run
            legendaryCount: 0   // Legendary upgrades this run
        };
        
        // Generate an upgrade with random rarity (with luck protection)
        function generateUpgrade(base) {
            // Build adjusted weights based on luck protection
            let weights = {
                common: RARITY_CONFIG.common.weight,
                uncommon: RARITY_CONFIG.uncommon.weight,
                rare: RARITY_CONFIG.rare.weight,
                epic: RARITY_CONFIG.epic.weight,
                legendary: RARITY_CONFIG.legendary.weight
            };
            
            // Apply player luck stat - boosts uncommon+ weights with scaling effect
            const luckBonus = permUpgrades.luck || 0;
            if (luckBonus > 0) {
                // Luck scales 5:1, with boost for rare+
                const luckPercent = luckBonus / 100; // Convert to decimal (e.g., 5% -> 0.05)
                weights.uncommon *= (1 + luckPercent * 5.0);
                weights.rare *= (1 + luckPercent * 9.0);
                weights.epic *= (1 + luckPercent * 12.0);
                weights.legendary *= (1 + luckPercent * 15.0);
                // Reduce common weight proportionally
                weights.common = Math.max(30, weights.common - (luckBonus * 2));
            }
            
            // Bad luck protection - boost higher rarities based on pity counter
            const pity = luckState.pityCounter;
            if (pity >= LUCK_PROTECTION.rarePity) {
                // Each roll past pity threshold adds +3 to rare weight
                weights.rare += (pity - LUCK_PROTECTION.rarePity + 1) * 3;
            }
            if (pity >= LUCK_PROTECTION.epicPity) {
                // Each roll past epic pity adds +2 to epic weight
                weights.epic += (pity - LUCK_PROTECTION.epicPity + 1) * 2;
            }
            if (pity >= LUCK_PROTECTION.legendaryPity) {
                // Each roll past legendary pity adds +1 to legendary weight
                weights.legendary += (pity - LUCK_PROTECTION.legendaryPity + 1) * 1;
            }
            
            // Good luck protection - cap high rarities
            if (luckState.epicCount >= LUCK_PROTECTION.maxEpic) {
                weights.epic = 0;
            }
            if (luckState.legendaryCount >= LUCK_PROTECTION.maxLegendary) {
                weights.legendary = 0;
            }
            
            // Roll for rarity with adjusted weights
            const rarities = Object.keys(weights);
            const weightValues = rarities.map(r => weights[r]);
            const totalWeight = weightValues.reduce((sum, w) => sum + w, 0);
            let roll = Math.random() * totalWeight;
            let rarity = 'common';
            for (let i = 0; i < rarities.length; i++) {
                roll -= weightValues[i];
                if (roll <= 0) {
                    rarity = rarities[i];
                    break;
                }
            }
            
            // Update luck protection state based on result
            if (rarity === 'common' || rarity === 'uncommon') {
                luckState.pityCounter++;
            } else {
                // Got rare or better - reset pity
                luckState.pityCounter = 0;
                if (rarity === 'epic') {
                    luckState.epicCount++;
                } else if (rarity === 'legendary') {
                    luckState.legendaryCount++;
                }
            }
            
            const multiplier = RARITY_MULTIPLIERS[rarity];
            const scaledVal = base.isPercent 
                ? Math.round(base.baseVal * multiplier) 
                : Math.round(base.baseVal * multiplier);
            const desc = base.descTemplate.replace('{val}', scaledVal);
            
            return {
                id: base.id,
                icon: base.icon,
                name: base.name,
                desc: desc,
                rarity: rarity,
                value: scaledVal,
                apply: () => {
                    if (base.key === 'lives') {
                        lives += scaledVal;
                        updateHUD();
                    } else {
                        const val = base.isPercent ? scaledVal / 100 : scaledVal;
                        permUpgrades[base.key] = (permUpgrades[base.key] || 0) + val;
                    }
                }
            };
        }
        
        // Tower Shop Upgrades (purchasable between waves)
        const TOWER_SHOP = {
            // Row 1: Wave 0 towers
            basic: {
                name: 'Blaster',
                icon: '',
                maxLevel: 10,
                baseCost: 75,
                costMult: 1.6,
                effects: [
                    { damage: 1.0, range: 1.0, fireRate: 1.0 },
                    { damage: 1.2, range: 1.08, fireRate: 1.08 },
                    { damage: 1.45, range: 1.16, fireRate: 1.16 },
                    { damage: 1.75, range: 1.24, fireRate: 1.26 },
                    { damage: 2.1, range: 1.32, fireRate: 1.36 },
                    { damage: 2.5, range: 1.4, fireRate: 1.48 },
                    { damage: 3.0, range: 1.5, fireRate: 1.6 },
                    { damage: 3.6, range: 1.6, fireRate: 1.75 },
                    { damage: 4.3, range: 1.7, fireRate: 1.9 },
                    { damage: 5.2, range: 1.8, fireRate: 2.1 },
                    { damage: 6.5, range: 2.0, fireRate: 2.4 }
                ]
            },
            sniper: {
                name: 'Sniper',
                icon: '',
                maxLevel: 10,
                baseCost: 100,
                costMult: 1.6,
                effects: [
                    { damage: 1.0, range: 1.0, fireRate: 1.0 },
                    { damage: 1.25, range: 1.1, fireRate: 1.03 },
                    { damage: 1.55, range: 1.2, fireRate: 1.06 },
                    { damage: 1.9, range: 1.3, fireRate: 1.1 },
                    { damage: 2.35, range: 1.4, fireRate: 1.14 },
                    { damage: 2.9, range: 1.5, fireRate: 1.18 },
                    { damage: 3.5, range: 1.65, fireRate: 1.23 },
                    { damage: 4.3, range: 1.8, fireRate: 1.28 },
                    { damage: 5.2, range: 1.95, fireRate: 1.34 },
                    { damage: 6.4, range: 2.1, fireRate: 1.4 },
                    { damage: 8.0, range: 2.3, fireRate: 1.5 }
                ]
            },
            minigun: {
                name: 'Minigun',
                icon: '',
                maxLevel: 10,
                baseCost: 90,
                costMult: 1.55,
                effects: [
                    { damage: 1.0, range: 1.0, fireRate: 1.0 },
                    { damage: 1.1, range: 1.04, fireRate: 1.15 },
                    { damage: 1.2, range: 1.08, fireRate: 1.3 },
                    { damage: 1.35, range: 1.12, fireRate: 1.5 },
                    { damage: 1.5, range: 1.16, fireRate: 1.7 },
                    { damage: 1.7, range: 1.2, fireRate: 1.95 },
                    { damage: 1.9, range: 1.25, fireRate: 2.2 },
                    { damage: 2.15, range: 1.3, fireRate: 2.5 },
                    { damage: 2.4, range: 1.35, fireRate: 2.85 },
                    { damage: 2.7, range: 1.4, fireRate: 3.2 },
                    { damage: 3.2, range: 1.5, fireRate: 3.8 }
                ]
            },
            poison: {
                name: 'Poison',
                icon: '',
                maxLevel: 10,
                baseCost: 95,
                costMult: 1.55,
                effects: [
                    { damage: 1.0, range: 1.0, poison: 1.0 },
                    { damage: 1.15, range: 1.08, poison: 1.2 },
                    { damage: 1.3, range: 1.16, poison: 1.45 },
                    { damage: 1.5, range: 1.24, poison: 1.75 },
                    { damage: 1.7, range: 1.32, poison: 2.1 },
                    { damage: 1.95, range: 1.4, poison: 2.5 },
                    { damage: 2.2, range: 1.5, poison: 3.0 },
                    { damage: 2.5, range: 1.6, poison: 3.6 },
                    { damage: 2.85, range: 1.7, poison: 4.3 },
                    { damage: 3.3, range: 1.8, poison: 5.2 },
                    { damage: 4.0, range: 2.0, poison: 6.5 }
                ]
            },
            // Row 2: Wave 2-5 towers
            freeze: {
                name: 'Freezer',
                icon: '',
                maxLevel: 10,
                baseCost: 80,
                costMult: 1.55,
                effects: [
                    { damage: 1.0, range: 1.0, slow: 0.5 },
                    { damage: 1.15, range: 1.08, slow: 0.47 },
                    { damage: 1.3, range: 1.16, slow: 0.44 },
                    { damage: 1.5, range: 1.24, slow: 0.4 },
                    { damage: 1.7, range: 1.32, slow: 0.36 },
                    { damage: 1.95, range: 1.4, slow: 0.32 },
                    { damage: 2.2, range: 1.5, slow: 0.28 },
                    { damage: 2.5, range: 1.6, slow: 0.24 },
                    { damage: 2.85, range: 1.7, slow: 0.2 },
                    { damage: 3.3, range: 1.8, slow: 0.16 },
                    { damage: 4.0, range: 2.0, slow: 0.12 }
                ]
            },
            splash: {
                name: 'Bomber',
                icon: '',
                maxLevel: 10,
                baseCost: 120,
                costMult: 1.6,
                effects: [
                    { damage: 1.0, range: 1.0, splash: 1.0 },
                    { damage: 1.2, range: 1.08, splash: 1.1 },
                    { damage: 1.4, range: 1.16, splash: 1.2 },
                    { damage: 1.65, range: 1.24, splash: 1.35 },
                    { damage: 1.95, range: 1.32, splash: 1.5 },
                    { damage: 2.3, range: 1.4, splash: 1.7 },
                    { damage: 2.7, range: 1.5, splash: 1.9 },
                    { damage: 3.2, range: 1.6, splash: 2.15 },
                    { damage: 3.8, range: 1.7, splash: 2.4 },
                    { damage: 4.5, range: 1.8, splash: 2.7 },
                    { damage: 5.5, range: 2.0, splash: 3.2 }
                ]
            },
            cannon: {
                name: 'Cannon',
                icon: '',
                maxLevel: 10,
                baseCost: 160,
                costMult: 1.65,
                effects: [
                    { damage: 1.0, range: 1.0, splash: 1.0 },
                    { damage: 1.25, range: 1.08, splash: 1.08 },
                    { damage: 1.55, range: 1.16, splash: 1.16 },
                    { damage: 1.9, range: 1.24, splash: 1.26 },
                    { damage: 2.3, range: 1.32, splash: 1.36 },
                    { damage: 2.8, range: 1.4, splash: 1.5 },
                    { damage: 3.4, range: 1.5, splash: 1.65 },
                    { damage: 4.1, range: 1.6, splash: 1.8 },
                    { damage: 5.0, range: 1.7, splash: 2.0 },
                    { damage: 6.0, range: 1.8, splash: 2.2 },
                    { damage: 7.5, range: 2.0, splash: 2.5 }
                ]
            },
            chain: {
                name: 'Chain',
                icon: '',
                maxLevel: 10,
                baseCost: 130,
                costMult: 1.6,
                effects: [
                    { damage: 1.0, range: 1.0, chains: 3 },
                    { damage: 1.15, range: 1.08, chains: 3 },
                    { damage: 1.3, range: 1.16, chains: 4 },
                    { damage: 1.5, range: 1.24, chains: 4 },
                    { damage: 1.7, range: 1.32, chains: 5 },
                    { damage: 1.95, range: 1.4, chains: 5 },
                    { damage: 2.2, range: 1.5, chains: 6 },
                    { damage: 2.5, range: 1.6, chains: 6 },
                    { damage: 2.85, range: 1.7, chains: 7 },
                    { damage: 3.3, range: 1.8, chains: 8 },
                    { damage: 4.0, range: 2.0, chains: 10 }
                ]
            },
            // Row 3: Wave 10-18 towers
            laser: {
                name: 'Beam',
                icon: '',
                maxLevel: 10,
                baseCost: 140,
                costMult: 1.65,
                effects: [
                    { damage: 1.0, range: 1.0, rampSpeed: 1.0 },
                    { damage: 1.2, range: 1.08, rampSpeed: 1.1 },
                    { damage: 1.45, range: 1.16, rampSpeed: 1.2 },
                    { damage: 1.75, range: 1.24, rampSpeed: 1.35 },
                    { damage: 2.1, range: 1.32, rampSpeed: 1.5 },
                    { damage: 2.5, range: 1.4, rampSpeed: 1.7 },
                    { damage: 3.0, range: 1.5, rampSpeed: 1.9 },
                    { damage: 3.6, range: 1.6, rampSpeed: 2.15 },
                    { damage: 4.3, range: 1.7, rampSpeed: 2.4 },
                    { damage: 5.2, range: 1.8, rampSpeed: 2.7 },
                    { damage: 6.5, range: 2.0, rampSpeed: 3.2 }
                ]
            },
            inferno: {
                name: 'Inferno',
                icon: '',
                maxLevel: 10,
                baseCost: 160,
                costMult: 1.65,
                effects: [
                    { damage: 1.0, range: 1.0, fireRate: 1.0 },
                    { damage: 1.2, range: 1.08, fireRate: 1.1 },
                    { damage: 1.45, range: 1.16, fireRate: 1.2 },
                    { damage: 1.75, range: 1.24, fireRate: 1.32 },
                    { damage: 2.1, range: 1.32, fireRate: 1.45 },
                    { damage: 2.5, range: 1.4, fireRate: 1.6 },
                    { damage: 3.0, range: 1.5, fireRate: 1.75 },
                    { damage: 3.6, range: 1.6, fireRate: 1.92 },
                    { damage: 4.3, range: 1.7, fireRate: 2.1 },
                    { damage: 5.2, range: 1.8, fireRate: 2.3 },
                    { damage: 6.5, range: 2.0, fireRate: 2.6 }
                ]
            },
            tesla: {
                name: 'Tesla',
                icon: '',
                maxLevel: 10,
                baseCost: 150,
                costMult: 1.65,
                effects: [
                    { damage: 1.0, range: 1.0, fireRate: 1.0 },
                    { damage: 1.2, range: 1.08, fireRate: 1.08 },
                    { damage: 1.45, range: 1.16, fireRate: 1.16 },
                    { damage: 1.75, range: 1.24, fireRate: 1.26 },
                    { damage: 2.1, range: 1.32, fireRate: 1.36 },
                    { damage: 2.5, range: 1.4, fireRate: 1.48 },
                    { damage: 3.0, range: 1.5, fireRate: 1.6 },
                    { damage: 3.6, range: 1.6, fireRate: 1.75 },
                    { damage: 4.3, range: 1.7, fireRate: 1.9 },
                    { damage: 5.2, range: 1.8, fireRate: 2.1 },
                    { damage: 6.5, range: 2.0, fireRate: 2.4 }
                ]
            },
            buff: {
                name: 'Buff',
                icon: '',
                maxLevel: 10,
                baseCost: 180,
                costMult: 1.7,
                effects: [
                    { buffDamage: 0.25, buffRange: 1.0, buffFireRate: 0.15 },
                    { buffDamage: 0.32, buffRange: 1.1, buffFireRate: 0.2 },
                    { buffDamage: 0.4, buffRange: 1.2, buffFireRate: 0.26 },
                    { buffDamage: 0.48, buffRange: 1.3, buffFireRate: 0.32 },
                    { buffDamage: 0.57, buffRange: 1.4, buffFireRate: 0.38 },
                    { buffDamage: 0.67, buffRange: 1.5, buffFireRate: 0.45 },
                    { buffDamage: 0.78, buffRange: 1.65, buffFireRate: 0.52 },
                    { buffDamage: 0.9, buffRange: 1.8, buffFireRate: 0.6 },
                    { buffDamage: 1.05, buffRange: 1.95, buffFireRate: 0.7 },
                    { buffDamage: 1.2, buffRange: 2.1, buffFireRate: 0.8 },
                    { buffDamage: 1.4, buffRange: 2.3, buffFireRate: 0.95 }
                ]
            }
        };
        
        // Tower upgrade levels (persists per game)
        let towerLevels = {};
        function resetTowerLevels() {
            towerLevels = {};
            for (const type in TOWER_SHOP) {
                towerLevels[type] = 0;
            }
        }
        resetTowerLevels();

        // Path waypoints - aligned to grid cell centers (GRID_SIZE=36, centers at 18+n*36)
        // Cell centers at: 18, 54, 90, 126, 162, 198, 234, 270, 306, 342, 378, 414, 450, 486, 522, 558, 594, 630
        const PATH = [
            { x: 0, y: 90 },      // Entry (row 3 center) - shifted down for HUD clearance
            { x: 162, y: 90 },    // First corner
            { x: 162, y: 198 },   // Down
            { x: 486, y: 198 },   // Across to right
            { x: 486, y: 90 },    // Up
            { x: 594, y: 90 },    // Right side
            { x: 594, y: 342 },   // Down
            { x: 54, y: 342 },    // Across to left
            { x: 54, y: 450 },    // Down
            { x: 486, y: 450 },   // Across to right
            { x: 486, y: 522 },   // Down
            { x: 644, y: 522 }    // Exit
        ];
        
        // Multiple map layouts for Endless Mode (all aligned to 36px grid)
        // Progressive complexity - starts simple, gets more challenging
        const MAP_LAYOUTS = [
            // Map 0: Simple S-curve (easiest) - 36px grid aligned
            [
                { x: 0, y: 126 }, { x: 234, y: 126 }, { x: 234, y: 450 },
                { x: 450, y: 450 }, { x: 450, y: 198 }, { x: 644, y: 198 }
            ],
            // Map 1: Wide U-turn - 36px grid aligned
            [
                { x: 0, y: 90 }, { x: 558, y: 90 }, { x: 558, y: 486 },
                { x: 126, y: 486 }, { x: 126, y: 306 }, { x: 644, y: 306 }
            ],
            // Map 2: Descending steps - 36px grid aligned
            [
                { x: 0, y: 90 }, { x: 198, y: 90 }, { x: 198, y: 234 },
                { x: 342, y: 234 }, { x: 342, y: 378 }, { x: 486, y: 378 },
                { x: 486, y: 522 }, { x: 644, y: 522 }
            ],
            // Map 3: Double bend (medium) - 36px grid aligned
            [
                { x: 0, y: 486 }, { x: 162, y: 486 }, { x: 162, y: 198 },
                { x: 378, y: 198 }, { x: 378, y: 414 }, { x: 558, y: 414 },
                { x: 558, y: 126 }, { x: 644, y: 126 }
            ],
            // Map 4: Stepped path - 36px grid aligned
            [
                { x: 0, y: 126 }, { x: 198, y: 126 }, { x: 198, y: 306 },
                { x: 378, y: 306 }, { x: 378, y: 486 }, { x: 558, y: 486 },
                { x: 558, y: 234 }, { x: 644, y: 234 }
            ],
            // Map 5: Winding river - 36px grid aligned
            [
                { x: 0, y: 270 }, { x: 126, y: 270 }, { x: 126, y: 90 },
                { x: 342, y: 90 }, { x: 342, y: 378 }, { x: 522, y: 378 },
                { x: 522, y: 198 }, { x: 644, y: 198 }
            ],
            // Map 6: Snake path (harder) - 36px grid aligned
            [
                { x: 0, y: 90 }, { x: 486, y: 90 }, { x: 486, y: 234 },
                { x: 162, y: 234 }, { x: 162, y: 378 }, { x: 486, y: 378 },
                { x: 486, y: 522 }, { x: 644, y: 522 }
            ],
            // Map 7: Switchback - 36px grid aligned
            [
                { x: 0, y: 162 }, { x: 270, y: 162 }, { x: 270, y: 414 },
                { x: 90, y: 414 }, { x: 90, y: 522 }, { x: 450, y: 522 },
                { x: 450, y: 270 }, { x: 594, y: 270 }, { x: 594, y: 126 }, { x: 644, y: 126 }
            ],
            // Map 8: Figure eight lite - 36px grid aligned
            [
                { x: 0, y: 306 }, { x: 126, y: 306 }, { x: 126, y: 90 },
                { x: 342, y: 90 }, { x: 342, y: 450 }, { x: 486, y: 450 },
                { x: 486, y: 162 }, { x: 594, y: 162 }, { x: 594, y: 378 }, { x: 644, y: 378 }
            ],
            // Map 9: Gauntlet (most complex) - 36px grid aligned
            [
                { x: 0, y: 486 }, { x: 126, y: 486 }, { x: 126, y: 162 },
                { x: 270, y: 162 }, { x: 270, y: 378 }, { x: 414, y: 378 },
                { x: 414, y: 90 }, { x: 558, y: 90 }, { x: 558, y: 450 }, { x: 644, y: 450 }
            ],
            // Map 10: Spiral Out - 36px grid aligned
            [
                { x: 0, y: 306 }, { x: 306, y: 306 }, { x: 306, y: 126 },
                { x: 522, y: 126 }, { x: 522, y: 450 }, { x: 162, y: 450 },
                { x: 162, y: 234 }, { x: 644, y: 234 }
            ],
            // Map 11: Lightning Bolt - 36px grid aligned
            [
                { x: 0, y: 90 }, { x: 270, y: 90 }, { x: 198, y: 234 },
                { x: 450, y: 234 }, { x: 378, y: 414 }, { x: 594, y: 414 },
                { x: 594, y: 306 }, { x: 644, y: 306 }
            ],
            // Map 12: Cross Pattern - 36px grid aligned
            [
                { x: 0, y: 270 }, { x: 234, y: 270 }, { x: 234, y: 90 },
                { x: 414, y: 90 }, { x: 414, y: 270 }, { x: 414, y: 450 },
                { x: 234, y: 450 }, { x: 234, y: 342 }, { x: 558, y: 342 }, { x: 644, y: 342 }
            ],
            // Map 13: Maze Runner - 36px grid aligned
            [
                { x: 0, y: 522 }, { x: 198, y: 522 }, { x: 198, y: 162 },
                { x: 342, y: 162 }, { x: 342, y: 414 }, { x: 486, y: 414 },
                { x: 486, y: 90 }, { x: 594, y: 90 }, { x: 594, y: 306 }, { x: 644, y: 306 }
            ],
            // Map 14: Diamond Path - 36px grid aligned
            [
                { x: 0, y: 306 }, { x: 162, y: 306 }, { x: 306, y: 126 },
                { x: 450, y: 306 }, { x: 558, y: 126 }, { x: 558, y: 378 }, { x: 644, y: 378 }
            ],
            // Map 15: Hourglass - 36px grid aligned
            [
                { x: 0, y: 90 }, { x: 522, y: 90 }, { x: 306, y: 306 },
                { x: 90, y: 522 }, { x: 522, y: 522 }, { x: 594, y: 306 }, { x: 644, y: 306 }
            ],
            // Map 16: Teeth Pattern - 36px grid aligned
            [
                { x: 0, y: 198 }, { x: 126, y: 198 }, { x: 126, y: 450 },
                { x: 270, y: 450 }, { x: 270, y: 126 }, { x: 414, y: 126 },
                { x: 414, y: 450 }, { x: 558, y: 450 }, { x: 558, y: 198 }, { x: 644, y: 198 }
            ],
            // Map 17: The Fortress - 36px grid aligned
            [
                { x: 0, y: 486 }, { x: 90, y: 486 }, { x: 90, y: 198 },
                { x: 306, y: 198 }, { x: 306, y: 378 }, { x: 450, y: 378 },
                { x: 450, y: 90 }, { x: 558, y: 90 }, { x: 558, y: 522 }, { x: 644, y: 522 }
            ],
            // Map 18: Serpent's Coil - 36px grid aligned
            [
                { x: 0, y: 126 }, { x: 486, y: 126 }, { x: 486, y: 270 },
                { x: 162, y: 270 }, { x: 162, y: 414 }, { x: 522, y: 414 },
                { x: 522, y: 522 }, { x: 644, y: 522 }
            ],
            // Map 19: The Labyrinth (hardest) - 36px grid aligned
            [
                { x: 0, y: 54 }, { x: 162, y: 54 }, { x: 162, y: 234 },
                { x: 306, y: 234 }, { x: 306, y: 90 }, { x: 450, y: 90 },
                { x: 450, y: 378 }, { x: 234, y: 378 }, { x: 234, y: 522 },
                { x: 558, y: 522 }, { x: 558, y: 234 }, { x: 644, y: 234 }
            ]
        ];
        
        // Current active path (can be swapped in Endless mode)
        let currentPath = PATH;
        let currentMapIndex = 0;
        
        // Set the current path (no rotation - consistent gameplay)
        function setCurrentPath(basePath) {
            currentPath = basePath;
        }
        
        // Grid size for tower snap-to-grid placement
        // Yellow line segment should equal exactly 3 grid squares
        const GRID_SIZE = 36;
        
        // Snap coordinates to grid center
        function snapToGrid(x, y) {
            const snappedX = Math.floor(x / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
            const snappedY = Math.floor(y / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
            return { x: snappedX, y: snappedY };
        }

        // Game State
        let gameRunning = false;
        let gameLoopId = null;
        let gamePaused = false;
        let gameSpeed = 1;
        let gold = 65;
        let lives = 20;
        let wave = 0;
        let kills = 0;
        let rerollsRemaining = 3;
        
        // Game Mode State
        let gameMode = 'classic'; // 'classic' or 'campaign'
        
        // Campaign mode state (5-wave stages)
        let campaignStage = 1; // Current stage in campaign mode
        let campaignStageWave = 0; // Wave within current stage (1-5)
        let highestWaveReached = 0; // For tower unlocks persistence
        let goldSpentThisStage = 0; // Track gold spent for refunds
        let isInfiniteMode = false; // True when wave 75+ reached in campaign
        let infiniteSpawnRate = 1; // Accelerates during infinite mode
        
        // Legacy endless mode variables (kept for compatibility)
        let endlessStage = 1;
        let stageWave = 0;
        let totalEndlessWaves = 0;
        let endlessDifficultyMult = 1;
        
        // Leprechaun system - spawns once per 10-wave cycle on waves 7-10
        let leprechaunSpawnedThisCycle = false;
        let leprechaunAlive = false; // Track if leprechaun is currently on field
        let leprechaunDamaged = false; // Track if leprechaun has been hit
        let preleprechaunSpeed = 1; // Store game speed before leprechaun slowdown
        
        // Tower limit bonus (unused in classic, used in campaign for stage progression)
        let endlessTowerLimitBonus = 0;
        
        // Tutorial state
        let tutorialActive = true;
        let tutorialAlpha = 1;
        let tutorialStartTime = 0;
        let showPathArrows = true;
        let pathArrowProgress = 0;
        let selectedTower = null;
        let inspectedTower = null; // Tower being inspected (clicked on map)
        let inspectedChampion = null; // Champion being inspected (clicked on map)
        let towers = [];
        let towerCounts = {}; // Track number of each tower type placed
        let enemies = [];
        let projectiles = [];
        let particles = [];
        
        // Champion state
        let champions = {}; // { striker: {tower, unit}, caster: {tower, unit} }
        let championEffects = []; // Visual effects for champion attacks
        let waveInProgress = false;
        let enemiesToSpawn = 0;
        let spawnTimer = 0;
        let lastTime = 0;

        // Mouse state
        let mouseX = -1000;
        let mouseY = -1000;
        
        // Mobile placement preview state
        let isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        let pendingPlacement = null; // {x, y, type} for mobile two-tap system
        let showingPlacementPreview = false;
        let movingTower = null; // Tower currently being moved

        // Permanent Upgrades
        let permUpgrades = {
            damageBonus: 0,
            rangeBonus: 0,
            fireRateBonus: 0,
            goldBonus: 0,
            costReduction: 0,
            splashBonus: 0,
            slowBonus: 0,
            critChance: 0,
            interest: 0,
            poisonBonus: 0,
            armorShred: 0,
            chainBonus: 0,
            multishot: 0,
            luck: 0
        };
        let permUpgradeStacks = {};
        let upgradeOfferHistory = {};
        
        // Upgrade selection state
        let currentUpgradeChoices = [];
        let upgradeSelectionActive = false;

        // DOM Elements
        const menuOverlay = document.getElementById('menuOverlay');
        const gameoverOverlay = document.getElementById('gameoverOverlay');
        const upgradeOverlay = document.getElementById('upgradeOverlay');
        const upgradeSlots = [
            document.getElementById('slot0'),
            document.getElementById('slot1'),
            document.getElementById('slot2')
        ];
        const livesDisplay = document.getElementById('livesDisplay');
        const goldDisplay = document.getElementById('goldDisplay');
        const waveDisplay = document.getElementById('waveDisplay');
        const killsDisplay = document.getElementById('killsDisplay');
        const waveBtn = document.getElementById('waveBtn');
        const towerBar = document.getElementById('towerBar');
        const permUpgradesDisplay = document.getElementById('permUpgrades'); // May be null
        const placementTooltip = document.getElementById('placementTooltip');

        // Update placement tooltip based on selected tower or inspected tower
        function updatePlacementTooltip() {
            if (inspectedTower) {
                // Show info for inspected placed tower
                const def = TOWERS[inspectedTower.type];
                const desc = TOWER_DESCRIPTIONS[inspectedTower.type];
                placementTooltip.querySelector('.tower-name').textContent = def.name;
                placementTooltip.querySelector('.tower-desc').textContent = ' - ' + desc;
                placementTooltip.classList.add('active');
                positionTooltipOverTowerBar();
            } else if (selectedTower && !waveInProgress) {
                // Check if it's a champion
                if (CHAMPIONS[selectedTower]) {
                    const def = CHAMPIONS[selectedTower];
                    const desc = CHAMPION_DESCRIPTIONS[selectedTower];
                    placementTooltip.querySelector('.tower-name').textContent = def.name;
                    placementTooltip.querySelector('.tower-desc').textContent = ' - ' + desc;
                    placementTooltip.classList.add('active');
                    positionTooltipOverTowerBar();
                } else {
                    // Show info for tower being placed
                    const def = TOWERS[selectedTower];
                    const desc = TOWER_DESCRIPTIONS[selectedTower];
                    placementTooltip.querySelector('.tower-name').textContent = def.name;
                    placementTooltip.querySelector('.tower-desc').textContent = ' - ' + desc;
                    placementTooltip.classList.add('active');
                    positionTooltipOverTowerBar();
                }
            } else {
                placementTooltip.classList.remove('active');
            }
        }
        
        function positionTooltipOverTowerBar() {
            const towerBarEl = document.getElementById('towerBar');
            const gameContainer = document.querySelector('.game-container');
            if (!towerBarEl || !gameContainer) return;
            
            const barRect = towerBarEl.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            const tooltipWidth = placementTooltip.offsetWidth;
            const tooltipHeight = placementTooltip.offsetHeight;
            
            // Calculate center of tower bar relative to game container
            const barCenterX = barRect.left + barRect.width / 2 - containerRect.left;
            const tooltipLeft = barCenterX - tooltipWidth / 2;
            
            // Position tooltip directly above tower bar (0px gap)
            const tooltipBottom = containerRect.bottom - barRect.top;
            
            placementTooltip.style.left = tooltipLeft + 'px';
            placementTooltip.style.bottom = tooltipBottom + 'px';
            placementTooltip.style.transform = 'none';
        }
        
        // Check if a point is within a placed tower
        function getTowerAtPoint(x, y) {
            for (const tower of towers) {
                const dx = tower.x - x;
                const dy = tower.y - y;
                if (Math.sqrt(dx * dx + dy * dy) <= 18) { // Tower radius + some padding
                    return tower;
                }
            }
            return null;
        }
        
        function getChampionAtPoint(x, y) {
            for (const type in champions) {
                const champ = champions[type];
                if (!champ || !champ.tower) continue;
                const dx = champ.tower.x - x;
                const dy = champ.tower.y - y;
                if (Math.sqrt(dx * dx + dy * dy) <= 25) { // Larger hitbox for champion beacons
                    return { type, ...champ };
                }
            }
            return null;
        }
        
        // Clear inspected tower (legacy - now uses cancelTowerAction)
        function clearInspectedTower() {
            cancelTowerAction();
        }

        // ========== INITIALIZATION ==========
        function init() {
            setupEventListeners();
            render(); // Initial render
        }

        function setupEventListeners() {
            // Mode selection flow
            document.getElementById('startBtn').addEventListener('click', () => {
                document.getElementById('mainMenuButtons').style.display = 'none';
                document.getElementById('modeSelection').classList.add('active');
            });
            document.getElementById('modeBackBtn').addEventListener('click', () => {
                document.getElementById('modeSelection').classList.remove('active');
                document.getElementById('mainMenuButtons').style.display = 'flex';
            });
            document.getElementById('classicModeBtn').addEventListener('click', () => {
                gameMode = 'classic';
                startGame();
            });
            document.getElementById('campaignModeBtn').addEventListener('click', () => {
                gameMode = 'campaign';
                startGame();
            });
            document.getElementById('restartBtn').addEventListener('click', startGame);
            waveBtn.addEventListener('click', showConfirmWave);
            
            // Speed button - cycle through 1x, 2x, 4x, 6x
            document.getElementById('speedBtn').addEventListener('click', () => {
                if (gameSpeed === 1) {
                    gameSpeed = 2;
                } else if (gameSpeed === 2) {
                    gameSpeed = 4;
                } else if (gameSpeed === 4) {
                    gameSpeed = 8;
                } else {
                    gameSpeed = 1;
                }
                const btn = document.getElementById('speedBtn');
                btn.textContent = ' ' + gameSpeed + 'x';
                btn.classList.toggle('active', gameSpeed > 1);
            });
            
            // Exit button
            document.getElementById('exitBtn').addEventListener('click', () => {
                document.getElementById('exitConfirmOverlay').classList.add('active');
            });
            document.getElementById('exitYes').addEventListener('click', () => {
                document.getElementById('exitConfirmOverlay').classList.remove('active');
                exitToMenu();
            });
            document.getElementById('exitNo').addEventListener('click', () => {
                document.getElementById('exitConfirmOverlay').classList.remove('active');
            });
            document.getElementById('exitConfirmOverlay').addEventListener('click', (e) => {
                if (e.target.id === 'exitConfirmOverlay') {
                    document.getElementById('exitConfirmOverlay').classList.remove('active');
                }
            });
            
            // Confirm overlay buttons
            document.getElementById('confirmYes').addEventListener('click', () => {
                document.getElementById('confirmOverlay').classList.remove('active');
                startWave();
            });
            document.getElementById('confirmNo').addEventListener('click', () => {
                document.getElementById('confirmOverlay').classList.remove('active');
            });
            document.getElementById('confirmOverlay').addEventListener('click', (e) => {
                if (e.target.id === 'confirmOverlay') {
                    document.getElementById('confirmOverlay').classList.remove('active');
                }
            });
            
            // Tower action panel buttons
            document.getElementById('towerActionConfirm').addEventListener('click', confirmPlacement);
            document.getElementById('towerActionMove').addEventListener('click', startTowerMove);
            document.getElementById('towerActionCancel').addEventListener('click', cancelTowerAction);
            
            // Champion focus toggle buttons
            document.getElementById('focusSingle').addEventListener('click', () => setChampionFocus('single'));
            document.getElementById('focusMulti').addEventListener('click', () => setChampionFocus('multi'));
            
            // Legacy placement preview overlay (keep for backwards compatibility)
            document.getElementById('placementConfirm').addEventListener('click', confirmPlacement);
            document.getElementById('placementCancel').addEventListener('click', cancelPlacementPreview);
            document.getElementById('placementPreviewOverlay').addEventListener('click', (e) => {
                if (e.target.id === 'placementPreviewOverlay') {
                    cancelPlacementPreview();
                }
            });

            // Tower selection
            towerBar.querySelectorAll('.tower-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Cancel any pending placement preview
                    if (showingPlacementPreview || movingTower || inspectedTower || inspectedChampion) {
                        cancelTowerAction();
                    }
                    
                    const type = btn.dataset.tower;
                    
                    // Don't allow selecting locked towers
                    if (!isTowerUnlocked(type)) {
                        return;
                    }
                    
                    // Don't allow selecting already placed champions
                    if (CHAMPIONS[type] && isChampionPlaced(type)) {
                        return;
                    }
                    
                    if (selectedTower === type) {
                        selectedTower = null;
                        btn.classList.remove('selected');
                    } else {
                        towerBar.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
                        selectedTower = type;
                        btn.classList.add('selected');
                    }
                    updatePlacementTooltip();
                });
            });

            // Canvas click for tower placement
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('touchend', handleCanvasTouch);
            
            // Mobile drag-to-place: touchstart begins preview, touchmove updates position
            canvas.addEventListener('touchstart', (e) => {
                if (!selectedTower || waveInProgress) return;
                e.preventDefault();
                const touch = e.touches[0];
                const pos = getCanvasCoords(touch.clientX, touch.clientY);
                
                // Check if touching a placed tower first
                const tappedTower = getTowerAtPoint(pos.x, pos.y);
                if (tappedTower) return; // Let touchend handle tower inspection
                
                // Snap to grid
                const snapped = snapToGrid(pos.x, pos.y);
                
                // Start placement preview if valid spot
                if (isValidPlacement(snapped.x, snapped.y)) {
                    pendingPlacement = { x: snapped.x, y: snapped.y, type: selectedTower };
                    showingPlacementPreview = true;
                    mouseX = snapped.x;
                    mouseY = snapped.y;
                    // Don't show confirm dialog yet - wait for touchend
                }
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!showingPlacementPreview || !pendingPlacement) return;
                e.preventDefault();
                const touch = e.touches[0];
                const pos = getCanvasCoords(touch.clientX, touch.clientY);
                
                // Snap to grid
                const snapped = snapToGrid(pos.x, pos.y);
                
                // Update preview position if valid
                if (isValidPlacement(snapped.x, snapped.y)) {
                    pendingPlacement.x = snapped.x;
                    pendingPlacement.y = snapped.y;
                    mouseX = snapped.x;
                    mouseY = snapped.y;
                }
            }, { passive: false });

            // Mouse tracking for placement preview
            canvas.addEventListener('mousemove', (e) => {
                const pos = getCanvasCoords(e.clientX, e.clientY);
                mouseX = pos.x;
                mouseY = pos.y;
            });
            
            canvas.addEventListener('mouseleave', () => {
                mouseX = -1000;
                mouseY = -1000;
            });

            // Upgrade selection
            upgradeSlots.forEach((slot, index) => {
                slot.addEventListener('click', () => selectUpgrade(index));
                slot.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    selectUpgrade(index);
                });
            });
            
            // Reroll button
            document.getElementById('rerollBtn').addEventListener('click', rerollUpgrades);
        }

        // Get canvas coordinates accounting for scaling
        function getCanvasCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            // Always return coordinates in base dimensions (game logic space)
            const scaleX = BASE_WIDTH / rect.width;
            const scaleY = BASE_HEIGHT / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        function exitToMenu() {
            // Stop the game
            gameRunning = false;
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            // Hide game over and show menu
            gameoverOverlay.classList.remove('active');
            menuOverlay.classList.remove('hidden');
        }

        function startGame() {
            // Prevent multiple game loops
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            menuOverlay.classList.add('hidden');
            gameoverOverlay.classList.remove('active');
            document.getElementById('placementPreviewOverlay').classList.remove('active');
            document.getElementById('modeSelection').classList.remove('active');
            document.getElementById('mainMenuButtons').style.display = 'flex';
            
            // Reset game state
            gold = gameMode === 'campaign' ? 65 : 65; // Starting gold
            lives = 20;
            wave = 0;
            kills = 0;
            rerollsRemaining = 3;
            towers = [];
            towerCounts = {}; // Reset tower counts
            enemies = [];
            projectiles = [];
            particles = [];
            splashRings = [];
            railgunLines = [];
            infernoZones = [];
            champions = {}; // Reset champions
            championEffects = [];
            waveInProgress = false;
            selectedTower = null;
            inspectedTower = null;
            movingTower = null;
            gamePaused = false;
            gameSpeed = 1;
            document.getElementById('speedBtn').textContent = ' 1x';
            document.getElementById('speedBtn').classList.remove('active');
            document.getElementById('towerActionPanel').classList.remove('active', 'move-mode');
            
            // Reset campaign mode state
            campaignStage = 1;
            campaignStageWave = 0;
            highestWaveReached = 0;
            goldSpentThisStage = 0;
            isInfiniteMode = false;
            infiniteSpawnRate = 1;
            
            // Reset legacy endless mode state
            endlessStage = 1;
            stageWave = 0;
            totalEndlessWaves = 0;
            endlessDifficultyMult = 1;
            endlessTowerLimitBonus = 0;
            
            // Reset leprechaun state
            leprechaunSpawnedThisCycle = false;
            leprechaunAlive = false;
            leprechaunDamaged = false;
            preleprechaunSpeed = 1;
            
            // Set starting map based on mode
            if (gameMode === 'campaign') {
                // Campaign mode starts with MAP_LAYOUTS[0]
                currentMapIndex = 0;
                setCurrentPath(MAP_LAYOUTS[0]);
            } else {
                // Classic mode uses the original PATH (single map)
                setCurrentPath(PATH);
                currentMapIndex = -1; // Not using MAP_LAYOUTS
            }
            
            // Apply campaign mode class for UI changes
            if (gameMode === 'campaign') {
                document.body.classList.add('campaign-mode');
            } else {
                document.body.classList.remove('campaign-mode');
            }
            
            // ====== TEST: Wave 30 test build (no pre-placed towers) ======
            // Champions and towers available, place them manually to test
            // ====== END TEST SETUP ======
            
            // Reset tutorial
            tutorialActive = true;
            tutorialAlpha = 1;
            tutorialStartTime = 0;
            showPathArrows = true;
            pathArrowProgress = 0;
            
            // Reset mobile placement preview state
            pendingPlacement = null;
            showingPlacementPreview = false;
            
            // Deselect all tower buttons and reset wave-active state
            towerBar.classList.remove('wave-active');
            towerBar.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            updatePlacementTooltip();
            
            // Reset upgrades
            permUpgrades = {
                damageBonus: 0,
                rangeBonus: 0,
                fireRateBonus: 0,
                goldBonus: 0,
                costReduction: 0,
                splashBonus: 0,
                slowBonus: 0,
                critChance: 0,
                interest: 0,
                poisonBonus: 0,
                armorShred: 0,
                chainBonus: 0,
                multishot: 0,
                luck: 0
            };
            permUpgradeStacks = {};
            upgradeOfferHistory = {};
            currentUpgradeChoices = [];
            upgradeSelectionActive = false;
            
            // Reset luck protection state
            luckState = {
                pityCounter: 0,
                epicCount: 0,
                legendaryCount: 0
            };
            
            resetTowerLevels();
            
            updateHUD();
            updateTowerButtons();
            updatePermUpgradesDisplay();
            
            // Enable control buttons
            waveBtn.disabled = false;
            waveBtn.textContent = 'START WAVE';
            shopBtn.disabled = false;
            
            gameRunning = true;
            lastTime = performance.now();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // ========== GAME LOOP ==========
        function gameLoop(currentTime) {
            if (!gameRunning) {
                gameLoopId = null;
                return;
            }
            
            const deltaTime = Math.min(currentTime - lastTime, 100); // Cap delta to prevent spiral
            lastTime = currentTime;
            
            // Normalize to 60fps and apply game speed
            const dt = (deltaTime / FRAME_TIME) * gameSpeed;
            const scaledDeltaTime = deltaTime * gameSpeed;
            
            if (!gamePaused) {
                update(dt, scaledDeltaTime);
            }
            
            // Update tutorial (always at normal speed)
            updateTutorial(deltaTime);
            
            render();
            
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        // Tutorial system
        function updateTutorial(rawDt) {
            if (!tutorialActive && !showPathArrows) return;
            
            // Tutorial text fades after 5 seconds
            if (tutorialActive) {
                if (tutorialStartTime === 0) {
                    tutorialStartTime = performance.now();
                }
                const elapsed = performance.now() - tutorialStartTime;
                if (elapsed > 4000) {
                    tutorialActive = false;
                    tutorialAlpha = 0;
                } else if (elapsed > 3000) {
                    // Fade out over last second
                    tutorialAlpha = 1 - ((elapsed - 3000) / 1000);
                }
            }
            
            // Path arrows animate for first 3 seconds
            if (showPathArrows) {
                pathArrowProgress += rawDt * 0.002;
                if (tutorialStartTime > 0 && performance.now() - tutorialStartTime > 3000) {
                    showPathArrows = false;
                }
            }
        }

        function update(dt, rawDt) {
            // Spawn enemies
            if (waveInProgress && enemiesToSpawn > 0) {
                spawnTimer -= rawDt;
                if (spawnTimer <= 0) {
                    spawnEnemy();
                    enemiesToSpawn--;
                    // Base spawn interval, accelerated in infinite mode
                    let baseInterval = 550 + Math.random() * 100;
                    if (isInfiniteMode) {
                        // Spawn faster and faster in infinite mode
                        baseInterval = Math.max(100, baseInterval / infiniteSpawnRate);
                    }
                    spawnTimer = baseInterval;
                }
            }
            
            // Infinite mode: keep spawning forever
            if (isInfiniteMode && waveInProgress && enemiesToSpawn === 0) {
                // Replenish enemies continuously
                enemiesToSpawn += Math.ceil(5 * infiniteSpawnRate);
                infiniteSpawnRate += 0.02; // Gradually accelerate
            }

            // Check wave complete (not in infinite mode)
            if (waveInProgress && enemiesToSpawn === 0 && enemies.length === 0 && !isInfiniteMode) {
                waveComplete();
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                updateEnemy(enemies[i], dt);
                if (!enemies[i].alive || enemies[i].escaped) {
                    enemies.splice(i, 1);
                }
            }

            // Update towers
            for (const tower of towers) {
                updateTower(tower, dt);
            }
            
            // Update champions
            updateChampions(dt, rawDt);

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                updateProjectile(projectiles[i], dt);
                if (!projectiles[i].alive) {
                    projectiles.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= rawDt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.alpha = Math.max(0, p.life / p.maxLife);
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update splash rings
            updateSplashRings(dt);
            
            // Update railgun lines
            updateRailgunLines(dt);
            
            // Update inferno zones
            updateInfernoZones(dt);
        }

        // ========== ENEMY SYSTEM ==========
        function spawnEnemy() {
            // Progressive difficulty scaling
            let healthMult = 1;
            let speedMult = 1;
            let dangerMult = 0; // For enemy type chances
            
            if (gameMode === 'campaign') {
                // Campaign mode: wall at wave 75, infinite after
                // Balanced for 100% gold refund between stages
                if (wave <= 2) {
                    // Waves 1-2: intro unchanged
                    healthMult = 0.55 + (wave * 0.05);
                    speedMult = 0.88 + (wave * 0.01);
                    dangerMult = 0;
                } else if (wave <= 5) {
                    // Waves 3-5: slightly gentler (reduced health growth)
                    healthMult = 0.63 + ((wave - 2) * 0.04);
                    speedMult = 0.88 + (wave * 0.01);
                    dangerMult = 0;
                } else if (wave <= 10) {
                    // Late novice: slightly harder (waves 6-10, +12% health instead of 15%)
                    healthMult = (0.55 + (wave * 0.05)) * 1.12;
                    speedMult = 0.88 + (wave * 0.011);
                    dangerMult = Math.max(0, (wave - 6) * 0.07);
                } else if (wave <= 11) {
                    // Wave 11: transition
                    healthMult = (1.1 + 0.10) * 1.18;
                    speedMult = 0.98 + 0.012;
                    dangerMult = 0.35 + 0.04;
                } else if (wave <= 20) {
                    // Waves 12-20: gentler scaling (+15% health instead of +18%)
                    const w = wave - 11;
                    healthMult = (1.2 + (w * 0.09)) * 1.15;
                    speedMult = 0.992 + (w * 0.011);
                    dangerMult = 0.39 + (w * 0.035);
                } else if (wave <= 30) {
                    // Medium: noticeable difficulty (+17% health instead of +20%)
                    const w = wave - 20;
                    healthMult = (2.2 + (w * 0.18)) * 1.17;
                    speedMult = 1.07 + (w * 0.013);
                    dangerMult = 0.65 + (w * 0.045);
                } else if (wave <= 40) {
                    // Medium-Hard: demanding (+18% health instead of +20%)
                    const w = wave - 30;
                    healthMult = 4.2 * 1.18 * Math.pow(1.065, w);
                    speedMult = 1.18 + (w * 0.013);
                    dangerMult = 1.10 + (w * 0.052);
                } else if (wave <= 50) {
                    // Hard: punishing (+18% health)
                    const w = wave - 40;
                    healthMult = 9.2 * 1.18 * Math.pow(1.085, w);
                    speedMult = 1.30 + (w * 0.019);
                    dangerMult = 1.58 + (w * 0.070);
                } else if (wave <= 60) {
                    // Very Difficult: elite territory (+18% health)
                    const w = wave - 50;
                    healthMult = 25 * 1.18 * Math.pow(1.10, w);
                    speedMult = 1.48 + (w * 0.026);
                    dangerMult = 2.28 + (w * 0.095);
                } else if (wave <= 70) {
                    // Expert: requires perfect play (+20% health)
                    const w = wave - 60;
                    healthMult = 85 * 1.20 * Math.pow(1.13, w); // ~115 - ~300
                    speedMult = 1.75 + (w * 0.028); // 1.78 - 2.03
                    dangerMult = 3.25 + (w * 0.12);
                } else if (wave <= 75) {
                    // Impossible approach: the wall (+20% health)
                    const w = wave - 70;
                    healthMult = 260 * 1.20 * Math.pow(1.22, w); // ~380 - ~936
                    speedMult = 2.0 + (w * 0.038); // 2.04 - 2.19
                    dangerMult = 4.35 + (w * 0.15);
                } else {
                    // Infinite mode: exponential madness after wave 75
                    const infiniteWaves = wave - 75;
                    healthMult = 960 * Math.pow(1.18, infiniteWaves);
                    speedMult = 2.2 * Math.pow(1.02, infiniteWaves);
                    dangerMult = 5.05 + (infiniteWaves * 0.20);
                    infiniteSpawnRate = 1 + (infiniteWaves * 0.07);
                }
            } else {
                // Classic mode scaling (original - wall around 60)
                if (wave <= 2) {
                    // Waves 1-2: unchanged intro
                    healthMult = 1 + ((wave - 1) * 0.028);
                    speedMult = 1;
                    dangerMult = 0;
                } else if (wave <= 9) {
                    // Waves 3-9: gentler ramp (reduced from 0.028 to 0.022 per wave)
                    healthMult = 1.028 + ((wave - 2) * 0.022);
                    speedMult = 1;
                    dangerMult = Math.max(0, (wave - 5) * 0.08);
                } else if (wave <= 11) {
                    // Waves 10-11: transition
                    const wavesPast9 = wave - 9;
                    healthMult = 1.18 * Math.pow(1.035, wavesPast9);
                    speedMult = 1 + (wavesPast9 * 0.009);
                    dangerMult = 0.35 + (wavesPast9 * 0.018);
                } else if (wave <= 20) {
                    // Waves 12-20: gentler scaling
                    const wavesPast11 = wave - 11;
                    healthMult = 1.18 * Math.pow(1.035, 2) * Math.pow(1.030, wavesPast11);
                    speedMult = 1.018 + (wavesPast11 * 0.008);
                    dangerMult = 0.386 + (wavesPast11 * 0.016);
                } else if (wave <= 30) {
                    const wavesPast20 = wave - 20;
                    const wave20HealthMult = 1.18 * Math.pow(1.035, 2) * Math.pow(1.030, 9);
                    healthMult = wave20HealthMult * Math.pow(1.085, wavesPast20);
                    speedMult = 1.05 + (wavesPast20 * 0.015);
                    dangerMult = 0.53 + (wavesPast20 * 0.038);
                } else if (wave <= 39) {
                    const wavesPast30 = wave - 30;
                    const wave30HealthMult = 1.18 * Math.pow(1.035, 2) * Math.pow(1.030, 9) * Math.pow(1.085, 10);
                    healthMult = wave30HealthMult * Math.pow(1.12, wavesPast30);
                    speedMult = 1.20 + (wavesPast30 * 0.019);
                    dangerMult = 0.91 + (wavesPast30 * 0.048);
                } else {
                    const wavesPast39 = wave - 39;
                    const wave39HealthMult = 1.18 * Math.pow(1.035, 2) * Math.pow(1.030, 9) * Math.pow(1.085, 10) * Math.pow(1.12, 9);
                    healthMult = wave39HealthMult * Math.pow(1.20, wavesPast39);
                    speedMult = 1.37 + (wavesPast39 * 0.029);
                    dangerMult = 1.34 + (wavesPast39 * 0.060);
                }
            }
            
            // Wave 10+ gets 10% easier
            if (wave >= 10) {
                healthMult *= 0.90;
            }
            
            // Base stats with scaling applied
            // Reduced base formula for gentler early game
            const baseHealth = (20 + wave * 10) * healthMult;
            const baseSpeed = (1.0 + wave * 0.03) * speedMult;
            
            // Random enemy types based on wave
            let type = 'normal';
            const roll = Math.random();
            
            // Enemy type chances increase with dangerMult
            // Reduced base chances for easier early game
            const megabossChance = wave >= 30 ? 0.02 + (dangerMult * 0.02) : 0; // Rare but terrifying
            const bossChance = 0.05 + (dangerMult * 0.06);
            const tankChance = 0.12 + (dangerMult * 0.10);
            // Fast enemies spawn less frequently after wave 10
            const fastChance = wave > 10 ? 0.15 + (dangerMult * 0.05) : 0.20 + (dangerMult * 0.08);
            
            // Pushed back special enemy wave requirements
            if (wave >= 30 && roll < megabossChance) {
                type = 'megaboss';
            } else if (wave >= 15 && roll < bossChance) {
                type = 'boss';
            } else if (wave >= 6 && roll < tankChance) {
                type = 'tank';
            } else if (wave >= 4 && roll < fastChance) {
                type = 'fast';
            }
            
            // Leprechaun spawn check - waves 8-10 of each 10-wave cycle
            const cycleWave = ((wave - 1) % 10) + 1; // 1-10 within cycle
            if (!leprechaunSpawnedThisCycle && !leprechaunAlive && cycleWave >= 8) {
                // Increasing chance: 15% at wave 8, 35% at 9, 100% at 10
                const leprechaunChance = cycleWave === 8 ? 0.15 : 
                                         cycleWave === 9 ? 0.35 : 1.0;
                if (Math.random() < leprechaunChance) {
                    type = 'leprechaun';
                    leprechaunSpawnedThisCycle = true;
                    leprechaunAlive = true;
                }
            }
            
            const enemyTypes = {
                normal: { healthMult: 1, speedMult: 1, size: 9, color: '#ff3366', gold: 5 },
                fast: { healthMult: 0.6, speedMult: 1.5, size: 7, color: '#ffcc00', gold: 7 },
                tank: { healthMult: 3, speedMult: 0.6, size: 14, color: '#9933ff', gold: 15 },
                boss: { healthMult: 8, speedMult: 0.4, size: 20, color: '#ff0000', gold: 50 },
                megaboss: { healthMult: 25, speedMult: 0.25, size: 28, color: '#ff00ff', gold: 200 },
                leprechaun: { healthMult: 2, speedMult: 1.8, size: 11, color: '#00ff66', gold: 100 }
            };
            
            const config = enemyTypes[type];
            const health = Math.floor(baseHealth * config.healthMult);
            
            enemies.push({
                x: currentPath[0].x,
                y: currentPath[0].y,
                pathIndex: 0,
                pathProgress: 0,
                health: health,
                maxHealth: health,
                speed: baseSpeed * config.speedMult,
                size: config.size,
                color: config.color,
                gold: config.gold,
                type: type,
                alive: true,
                escaped: false,
                slowUntil: 0,
                slowAmount: 1,
                poisonUntil: 0,
                poisonDamage: 0,
                lastPoisonTick: 0,
                incomingDamage: 0
            });
        }

        function updateEnemy(enemy, dt) {
            if (!enemy.alive || enemy.escaped) return;
            
            const now = performance.now();
            
            // Check stun status
            if (enemy.stunned && now >= enemy.stunEndTime) {
                enemy.stunned = false;
            }
            
            // If stunned or pinned, don't move
            if (enemy.stunned || enemy.pinned) {
                // Still take poison damage while stunned
                if (now < enemy.poisonUntil && now - enemy.lastPoisonTick >= 500 / gameSpeed) {
                    enemy.lastPoisonTick = now;
                    damageEnemy(enemy, enemy.poisonDamage, false);
                    createParticles(enemy.x, enemy.y, '#44ff44', 3);
                }
                return;
            }
            
            // Apply poison damage
            if (now < enemy.poisonUntil && now - enemy.lastPoisonTick >= 500 / gameSpeed) {
                enemy.lastPoisonTick = now;
                damageEnemy(enemy, enemy.poisonDamage, false);
                createParticles(enemy.x, enemy.y, '#44ff44', 3);
            }
            
            // Apply slow effect
            let speedMult = 1;
            if (now < enemy.slowUntil) {
                speedMult = enemy.slowAmount;
            }
            
            // Move along path
            const currentPoint = currentPath[enemy.pathIndex];
            const nextPoint = currentPath[enemy.pathIndex + 1];
            
            if (!nextPoint) {
                enemy.escaped = true;
                
                // Leprechaun escape: no penalty, just missed bonus
                if (enemy.type === 'leprechaun') {
                    leprechaunAlive = false;
                    leprechaunDamaged = false;
                    // Resume previous game speed
                    if (preleprechaunSpeed > 1) {
                        gameSpeed = preleprechaunSpeed;
                        const btn = document.getElementById('speedBtn');
                        btn.textContent = ' ' + gameSpeed + 'x';
                        btn.classList.add('active');
                        preleprechaunSpeed = 1;
                    }
                    createParticles(enemy.x, enemy.y, '#00ff66', 15);
                    createParticles(enemy.x, enemy.y, '#ffd700', 10);
                    return;
                }
                
                // Megaboss: 5 lives, Boss/Tank: 3 lives, Others: 1 life
                let livesLost = 1;
                if (enemy.type === 'megaboss') {
                    livesLost = 5;
                } else if (enemy.type === 'boss' || enemy.type === 'tank') {
                    livesLost = 3;
                }
                lives -= livesLost;
                updateHUD();
                createParticles(enemy.x, enemy.y, '#ff0000', enemy.type === 'megaboss' ? 25 : 10);
                
                if (lives <= 0) {
                    gameOver();
                }
                return;
            }
            
            const dx = nextPoint.x - currentPoint.x;
            const dy = nextPoint.y - currentPoint.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Store normalized velocity for lead prediction
            const actualSpeed = enemy.speed * speedMult;
            enemy.vx = (dx / dist) * actualSpeed;
            enemy.vy = (dy / dist) * actualSpeed;
            
            enemy.pathProgress += (actualSpeed * dt) / dist;
            
            if (enemy.pathProgress >= 1) {
                enemy.pathIndex++;
                enemy.pathProgress = 0;
            }
            
            // Interpolate position
            if (enemy.pathIndex < currentPath.length - 1) {
                const cp = currentPath[enemy.pathIndex];
                const np = currentPath[enemy.pathIndex + 1];
                enemy.x = cp.x + (np.x - cp.x) * enemy.pathProgress;
                enemy.y = cp.y + (np.y - cp.y) * enemy.pathProgress;
            }
        }

        function damageEnemy(enemy, damage, isCrit = false) {
            if (!enemy.alive) return;
            
            // Slow down game speed when leprechaun is first damaged
            if (enemy.type === 'leprechaun' && !leprechaunDamaged) {
                leprechaunDamaged = true;
                if (gameSpeed > 1) {
                    preleprechaunSpeed = gameSpeed;
                    // If at 8x, slow to 2x; otherwise slow to 1x
                    gameSpeed = preleprechaunSpeed >= 8 ? 2 : 1;
                    const btn = document.getElementById('speedBtn');
                    btn.textContent = ' ' + gameSpeed + 'x';
                    btn.classList.toggle('active', gameSpeed > 1);
                }
            }
            
            enemy.health -= damage;
            createDamageNumber(enemy.x, enemy.y - enemy.size, damage, isCrit);
            
            if (enemy.health <= 0) {
                enemy.alive = false;
                const goldEarned = Math.floor(enemy.gold * (1 + permUpgrades.goldBonus));
                gold += goldEarned;
                kills++;
                updateHUD();
                updateTowerButtons();
                
                // Leprechaun death: special reward!
                if (enemy.type === 'leprechaun') {
                    leprechaunAlive = false;
                    leprechaunDamaged = false;
                    // Resume previous game speed
                    if (preleprechaunSpeed > 1) {
                        gameSpeed = preleprechaunSpeed;
                        const btn = document.getElementById('speedBtn');
                        btn.textContent = ' ' + gameSpeed + 'x';
                        btn.classList.add('active');
                        preleprechaunSpeed = 1;
                    }
                    createParticles(enemy.x, enemy.y, '#00ff66', 30);
                    createParticles(enemy.x, enemy.y, '#ffd700', 25);
                    createParticles(enemy.x, enemy.y, '#ffffff', 15);
                    createSplashRing(enemy.x, enemy.y, '#00ff66', 100);
                    createSplashRing(enemy.x, enemy.y, '#ffd700', 70);
                    // Delay upgrade selector slightly for visual effect
                    setTimeout(() => {
                        showUpgradeSelector();
                    }, 300);
                // Megaboss death: massive explosion effect
                } else if (enemy.type === 'megaboss') {
                    createParticles(enemy.x, enemy.y, '#ff00ff', 40);
                    createParticles(enemy.x, enemy.y, '#ff6600', 25);
                    createParticles(enemy.x, enemy.y, '#ffffff', 15);
                    createSplashRing(enemy.x, enemy.y, '#ff00ff', 120);
                    createSplashRing(enemy.x, enemy.y, '#ff6600', 80);
                } else {
                    createParticles(enemy.x, enemy.y, enemy.color, 15);
                }
            }
        }

        // ========== TOWER SYSTEM ==========
        function handleCanvasClick(e) {
            const pos = getCanvasCoords(e.clientX, e.clientY);
            
            // If we're moving a tower, handle the move
            if (movingTower) {
                completeTowerMove(pos.x, pos.y);
                return;
            }
            
            // Check if clicking on a champion first
            const clickedChampion = getChampionAtPoint(pos.x, pos.y);
            
            if (clickedChampion) {
                // Cancel any other action first
                if (showingPlacementPreview || inspectedTower) {
                    cancelTowerAction();
                }
                
                // Toggle inspection of this champion
                if (inspectedChampion && inspectedChampion.type === clickedChampion.type) {
                    cancelTowerAction();
                } else {
                    showChampionInspection(clickedChampion);
                }
                return;
            }
            
            // Check if clicking on a placed tower
            const clickedTower = getTowerAtPoint(pos.x, pos.y);
            
            if (clickedTower) {
                // Cancel any placement preview first
                if (showingPlacementPreview) {
                    cancelTowerAction();
                }
                
                // Toggle inspection of this tower
                if (inspectedTower === clickedTower) {
                    cancelTowerAction();
                } else {
                    showTowerInspection(clickedTower);
                }
                return;
            }
            
            // Clear inspected tower/champion when clicking elsewhere
            if (inspectedTower || inspectedChampion) {
                cancelTowerAction();
            }
            
            // Tower placement logic
            if (!selectedTower || waveInProgress) return;
            
            // On desktop, show placement preview (same as mobile now)
            showPlacementPreview(pos.x, pos.y);
        }

        function handleCanvasTouch(e) {
            e.preventDefault();
            
            const touch = e.changedTouches[0];
            const pos = getCanvasCoords(touch.clientX, touch.clientY);
            
            // If we're moving a tower, handle the move
            if (movingTower) {
                completeTowerMove(pos.x, pos.y);
                return;
            }
            
            // Check if tapping on a champion first
            const tappedChampion = getChampionAtPoint(pos.x, pos.y);
            
            if (tappedChampion) {
                // Cancel any other action first
                if (showingPlacementPreview || inspectedTower) {
                    cancelTowerAction();
                }
                
                // Toggle inspection of this champion
                if (inspectedChampion && inspectedChampion.type === tappedChampion.type) {
                    cancelTowerAction();
                } else {
                    showChampionInspection(tappedChampion);
                }
                return;
            }
            
            // Check if tapping on a placed tower
            const tappedTower = getTowerAtPoint(pos.x, pos.y);
            
            if (tappedTower) {
                // Cancel any placement preview first
                if (showingPlacementPreview) {
                    cancelTowerAction();
                }
                
                // Toggle inspection of this tower
                if (inspectedTower === tappedTower) {
                    cancelTowerAction();
                } else {
                    showTowerInspection(tappedTower);
                }
                return;
            }
            
            // Clear inspected tower/champion when tapping elsewhere
            if (inspectedTower || inspectedChampion) {
                cancelTowerAction();
            }
            
            // Tower placement logic
            if (!selectedTower || waveInProgress) return;
            
            // Snap to grid for placement
            const snapped = snapToGrid(pos.x, pos.y);
            
            // Show placement preview
            showPlacementPreview(snapped.x, snapped.y);
        }
        
        function showPlacementPreview(x, y) {
            // Snap to grid
            const snapped = snapToGrid(x, y);
            x = snapped.x;
            y = snapped.y;
            
            if (!isValidPlacement(x, y)) return;
            
            // Store pending placement
            pendingPlacement = { x: x, y: y, type: selectedTower };
            showingPlacementPreview = true;
            
            // Update mouse position to show preview on canvas
            mouseX = x;
            mouseY = y;
            
            // Show tower action panel for placement confirmation
            const panel = document.getElementById('towerActionPanel');
            const isChamp = !!CHAMPIONS[selectedTower];
            const def = isChamp ? CHAMPIONS[selectedTower] : TOWERS[selectedTower];
            const costText = isChamp ? 'FREE' : `Cost: $${getTowerCost(selectedTower)}`;
            
            document.getElementById('towerActionTitle').textContent = `Place ${def.name}?`;
            document.getElementById('towerActionSubtitle').textContent = costText;
            document.getElementById('towerActionConfirm').style.display = '';
            document.getElementById('towerActionConfirm').textContent = ' PLACE';
            document.getElementById('towerActionMove').style.display = 'none';
            document.getElementById('championFocusToggle').style.display = 'none';
            panel.classList.remove('move-mode');
            panel.classList.add('active');
            
            // Show bouncing arrow for tower placement
            const arrow = document.getElementById('firstPlacementArrow');
            if (arrow) {
                // Clear any existing timeout
                if (arrow.fadeTimeout) {
                    clearTimeout(arrow.fadeTimeout);
                    arrow.fadeTimeout = null;
                }
                if (arrow.hideTimeout) {
                    clearTimeout(arrow.hideTimeout);
                    arrow.hideTimeout = null;
                }
                
                // Wait a frame for panel and tooltip to render, then position arrow above tooltip
                requestAnimationFrame(() => {
                    const tooltip = document.getElementById('placementTooltip');
                    if (tooltip && tooltip.classList.contains('active')) {
                        const tooltipRect = tooltip.getBoundingClientRect();
                        arrow.style.left = (tooltipRect.left + tooltipRect.width / 2 - 12) + 'px';
                        arrow.style.top = (tooltipRect.top - 51) + 'px';
                    } else {
                        // Fallback to panel positioning if tooltip not visible
                        const panelRect = panel.getBoundingClientRect();
                        arrow.style.left = (panelRect.left + panelRect.width / 2 - 12) + 'px';
                        arrow.style.top = (panelRect.top - 86) + 'px';
                    }
                    arrow.style.display = 'block';
                    arrow.classList.remove('fade-out');
                    // Longer display time - will be cancelled if tower placed
                    arrow.fadeTimeout = setTimeout(() => {
                        arrow.classList.add('fade-out');
                        arrow.hideTimeout = setTimeout(() => {
                            arrow.style.display = 'none';
                        }, 300);
                    }, 2000);
                });
            }
        }
        
        function showTowerInspection(tower) {
            inspectedTower = tower;
            inspectedChampion = null;
            const panel = document.getElementById('towerActionPanel');
            const def = TOWERS[tower.type];
            document.getElementById('towerActionTitle').textContent = def.name;
            document.getElementById('towerActionSubtitle').textContent = TOWER_DESCRIPTIONS[tower.type];
            document.getElementById('towerActionConfirm').style.display = 'none';
            document.getElementById('towerActionMove').style.display = waveInProgress ? 'none' : ''; // Hide during active wave
            document.getElementById('championFocusToggle').style.display = 'none';
            panel.classList.remove('move-mode');
            panel.classList.add('active');
            updatePlacementTooltip();
        }
        
        function showChampionInspection(champData) {
            inspectedChampion = champData;
            inspectedTower = null;
            const panel = document.getElementById('towerActionPanel');
            const def = CHAMPIONS[champData.type];
            const unit = champData.unit;
            
            // Title and status
            document.getElementById('towerActionTitle').textContent = def.name;
            
            // Build status text based on champion type and state
            let statusText;
            if (unit.state === 'knockedDown') {
                statusText = ' RECOVERING';
            } else if (unit.state === 'pinning') {
                statusText = ' PINNING TARGET';
            } else if (champData.type === 'striker') {
                // Black Squirrel
                if (unit.combatMode === 'jumping_in') {
                    statusText = ' JUMPING IN';
                } else if (unit.combatMode === 'aoe_attack') {
                    statusText = ' AOE STUN!';
                } else if (unit.combatMode === 'retreating') {
                    statusText = ' RETREATING';
                } else if (unit.state === 'attacking') {
                    statusText = ' THROWING ACORNS';
                } else {
                    statusText = ' RANGED MODE';
                }
            } else if (champData.type === 'caster') {
                // Joust Panther
                if (unit.combatMode === 'pouncing') {
                    statusText = ' POUNCING';
                } else if (unit.state === 'attacking') {
                    statusText = ' CLEAVING';
                } else {
                    statusText = ' AOE MODE';
                }
            } else {
                statusText = unit.state === 'attacking' ? ' FIGHTING' :
                            unit.state === 'moving' ? ' MOVING' : ' READY';
            }
            document.getElementById('towerActionSubtitle').textContent = statusText;
            
            // Hide all action buttons - champions are fully autonomous now
            document.getElementById('towerActionConfirm').style.display = 'none';
            document.getElementById('towerActionMove').style.display = 'none';
            document.getElementById('championFocusToggle').style.display = 'none';
            
            panel.classList.remove('move-mode');
            panel.classList.add('active');
            updatePlacementTooltip();
        }
        
        function updateFocusToggle(mode) {
            const singleBtn = document.getElementById('focusSingle');
            const multiBtn = document.getElementById('focusMulti');
            
            if (mode === 'single') {
                singleBtn.classList.add('active');
                multiBtn.classList.remove('active');
            } else {
                singleBtn.classList.remove('active');
                multiBtn.classList.add('active');
            }
        }
        
        function setChampionFocus(mode) {
            // Champions are now fully autonomous - this function is deprecated
            // Kept for compatibility but does nothing
            return;
        }
        
        function startTowerMove() {
            if (!inspectedTower) return;
            if (waveInProgress) return; // Can't move towers during active wave
            
            movingTower = inspectedTower;
            const panel = document.getElementById('towerActionPanel');
            const def = TOWERS[movingTower.type];
            document.getElementById('towerActionTitle').textContent = `Moving ${def.name}`;
            document.getElementById('towerActionSubtitle').textContent = 'Tap new location';
            document.getElementById('towerActionConfirm').style.display = 'none';
            document.getElementById('towerActionMove').style.display = 'none';
            panel.classList.add('move-mode');
            
            // Clear inspection but keep panel open
            inspectedTower = null;
            updatePlacementTooltip();
        }
        
        function completeTowerMove(newX, newY) {
            if (!movingTower) return;
            
            const snapped = snapToGrid(newX, newY);
            
            // Check if new position is valid (temporarily remove tower from validation)
            const oldX = movingTower.x;
            const oldY = movingTower.y;
            movingTower.x = -1000; // Temporarily move off-screen for validation
            movingTower.y = -1000;
            
            if (isValidPlacement(snapped.x, snapped.y)) {
                // Move successful
                movingTower.x = snapped.x;
                movingTower.y = snapped.y;
            } else {
                // Invalid position - restore original
                movingTower.x = oldX;
                movingTower.y = oldY;
            }
            
            cancelTowerAction();
        }
        
        function cancelTowerAction() {
            pendingPlacement = null;
            showingPlacementPreview = false;
            movingTower = null;
            inspectedTower = null;
            inspectedChampion = null;
            mouseX = -1000;
            mouseY = -1000;
            document.getElementById('towerActionPanel').classList.remove('active', 'move-mode');
            document.getElementById('championFocusToggle').style.display = 'none';
            updatePlacementTooltip();
        }
        
        function confirmPlacement() {
            if (pendingPlacement) {
                // Temporarily store the tower type since we'll clear pendingPlacement
                const type = pendingPlacement.type;
                const x = pendingPlacement.x;
                const y = pendingPlacement.y;
                
                // Set selectedTower in case it was deselected
                selectedTower = type;
                
                // Immediately fade the arrow when placing, cancel any pending timeouts
                const arrow = document.getElementById('firstPlacementArrow');
                if (arrow && arrow.style.display !== 'none') {
                    if (arrow.fadeTimeout) {
                        clearTimeout(arrow.fadeTimeout);
                        arrow.fadeTimeout = null;
                    }
                    if (arrow.hideTimeout) {
                        clearTimeout(arrow.hideTimeout);
                        arrow.hideTimeout = null;
                    }
                    arrow.classList.add('fade-out');
                    setTimeout(() => {
                        arrow.style.display = 'none';
                    }, 300);
                }
                
                placeTower(x, y);
            }
            cancelTowerAction();
        }
        
        function cancelPlacementPreview() {
            cancelTowerAction();
        }

        // Tower limits: 4 for buff, 8 for others
        // Campaign mode has dynamic limits within stages
        function getTowerLimit(type) {
            const baseMax = type === 'buff' ? 4 : 8;
            
            if (gameMode === 'classic') {
                // Classic mode: fixed limits
                return baseMax;
            }
            
            // Campaign mode: dynamic limits based on stage and wave within stage
            // Stage 1: 2-5, Stage 2: 3-6, Stage 3: 4-7, etc.
            const stageBase = Math.min(1 + campaignStage, 6); // Caps at 6 base
            const waveBonus = Math.floor((campaignStageWave) * 0.8); // +0 to +4 across 5 waves
            const dynamicLimit = stageBase + waveBonus;
            
            // Return minimum of dynamic limit and tower's max limit
            return Math.min(dynamicLimit, baseMax);
        }
        
        // Get current cost of a tower type (50% more per tower of same type placed)
        function getTowerCost(type) {
            const def = TOWERS[type];
            const count = towerCounts[type] || 0;
            // First tower is 35% cheaper, then scales exponentially
            // 1st: 0.65x, 2nd: ~1x, 3rd: ~1.56x, 5th: ~3.75x, 10th: ~26x
            const scaledCost = def.cost * 0.65 * Math.pow(1.55, count);
            return Math.floor(scaledCost * (1 - permUpgrades.costReduction));
        }
        
        // Check if tower type has reached its placement limit
        function isTowerAtLimit(type) {
            const count = towerCounts[type] || 0;
            return count >= getTowerLimit(type);
        }

        function placeTower(x, y) {
            // Snap to grid
            const snapped = snapToGrid(x, y);
            x = snapped.x;
            y = snapped.y;
            
            if (!isValidPlacement(x, y)) return;
            
            // Check if tower is unlocked
            if (!isTowerUnlocked(selectedTower)) return;
            
            // Check if this is a champion
            if (CHAMPIONS[selectedTower]) {
                placeChampion(x, y, selectedTower);
                return;
            }
            
            // Check tower limit
            if (isTowerAtLimit(selectedTower)) return;
            
            const cost = getTowerCost(selectedTower);
            const def = TOWERS[selectedTower];
            
            if (gold >= cost) {
                gold -= cost;
                
                // Track gold spent this stage for refunds (campaign mode)
                if (gameMode === 'campaign') {
                    goldSpentThisStage += cost;
                }
                
                // Increment tower count
                towerCounts[selectedTower] = (towerCounts[selectedTower] || 0) + 1;
                
                towers.push({
                    x: x,
                    y: y,
                    type: selectedTower,
                    lastFire: -99999, // Allow immediate first shot
                    target: null,
                    angle: -Math.PI / 2, // Default pointing up
                    targetAngle: -Math.PI / 2
                });
                updateHUD();
                updateTowerButtons();
                createParticles(x, y, def.color, 8);
                
                // Deselect tower and hide tooltip after placement
                selectedTower = null;
                towerBar.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
                updatePlacementTooltip();
            }
        }
        
        function placeChampion(x, y, type) {
            // Check if already placed
            if (isChampionPlaced(type)) return;
            
            const def = CHAMPIONS[type];
            
            // Create champion tower (base/beacon)
            const tower = {
                x: x,
                y: y,
                type: type,
                isChampion: true,
                focusMode: 'single' // 'single' or 'multi'
            };
            
            // Create champion unit (the hero that walks around)
            const unit = {
                x: x,
                y: y,
                homeX: x,
                homeY: y,
                type: type,
                target: null,
                state: 'idle', // 'idle', 'moving', 'attacking', 'returning', 'knockedDown'
                lastAttack: 0,
                angle: 0,
                knockdownTimer: 0,
                attackEffectTimer: 0
            };
            
            champions[type] = { tower, unit };
            
            // Flashy placement effect
            createParticles(x, y, def.color, 20);
            createParticles(x, y, def.accentColor, 15);
            createSplashRing(x, y, def.color, 80);
            
            // Deselect and update
            selectedTower = null;
            towerBar.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            updateTowerButtons();
            updatePlacementTooltip();
        }

        function isValidPlacement(x, y) {
            const minPathDist = 26;
            const minTowerDist = 32;
            
            // Check distance from path
            for (let i = 0; i < currentPath.length - 1; i++) {
                const p1 = currentPath[i];
                const p2 = currentPath[i + 1];
                const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                if (dist < minPathDist) return false;
            }
            
            // Check distance from other towers
            for (const tower of towers) {
                const dx = tower.x - x;
                const dy = tower.y - y;
                if (Math.sqrt(dx * dx + dy * dy) < minTowerDist) return false;
            }
            
            // Check bounds - minimal margins since towers are small (14px radius)
            if (x < 15 || x > BASE_WIDTH - 15 || y < 15 || y > BASE_HEIGHT - 15) return false;
            
            return true;
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = lenSq !== 0 ? dot / lenSq : -1;
            
            let xx, yy;
            if (param < 0) {
                xx = x1; yy = y1;
            } else if (param > 1) {
                xx = x2; yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            return Math.sqrt((px - xx) ** 2 + (py - yy) ** 2);
        }

        // Get tower upgrade multipliers
        function getTowerUpgrades(type) {
            const shop = TOWER_SHOP[type];
            const level = towerLevels[type] || 0;
            return shop.effects[level];
        }
        
        function updateTower(tower, dt) {
            const def = TOWERS[tower.type];
            const upgrades = getTowerUpgrades(tower.type);
            
            // Smooth tower tracking for blaster and cannon
            // They track enemies anywhere on screen, not just in range
            if (tower.type === 'basic' || tower.type === 'cannon') {
                // Find nearest enemy on screen to track
                let trackTarget = null;
                let nearestDist = Infinity;
                
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dx = enemy.x - tower.x;
                    const dy = enemy.y - tower.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        trackTarget = enemy;
                    }
                }
                
                // Calculate target angle
                if (trackTarget) {
                    tower.targetAngle = Math.atan2(trackTarget.y - tower.y, trackTarget.x - tower.x);
                }
                
                // Smooth rotation towards target angle
                if (tower.angle === undefined) tower.angle = -Math.PI / 2;
                if (tower.targetAngle === undefined) tower.targetAngle = -Math.PI / 2;
                
                // Calculate shortest rotation direction
                let angleDiff = tower.targetAngle - tower.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // Rotation speed (radians per frame at 60fps)
                const rotationSpeed = 0.15 * dt;
                
                if (Math.abs(angleDiff) < rotationSpeed) {
                    tower.angle = tower.targetAngle;
                } else {
                    tower.angle += Math.sign(angleDiff) * rotationSpeed;
                }
                
                // Normalize angle
                while (tower.angle > Math.PI) tower.angle -= Math.PI * 2;
                while (tower.angle < -Math.PI) tower.angle += Math.PI * 2;
            }
            
            // Buff towers don't fire, they just boost nearby towers
            if (def.buffRange) {
                tower.target = null;
                return;
            }
            
            // Calculate buff bonuses from nearby buff towers
            let buffDamageBonus = 0;
            let buffFireRateBonus = 0;
            for (const other of towers) {
                if (other === tower) continue;
                const otherDef = TOWERS[other.type];
                if (!otherDef.buffRange) continue;
                
                const otherUpgrades = getTowerUpgrades(other.type);
                const buffRange = otherDef.buffRange * (otherUpgrades.buffRange || 1) * (1 + permUpgrades.rangeBonus);
                
                const dx = tower.x - other.x;
                const dy = tower.y - other.y;
                if (Math.sqrt(dx * dx + dy * dy) <= buffRange) {
                    buffDamageBonus += otherUpgrades.buffDamage || otherDef.buffDamage;
                    buffFireRateBonus += otherUpgrades.buffFireRate || otherDef.buffFireRate;
                }
            }
            
            // Apply tower upgrade multipliers
            const rangeMultiplier = upgrades.range || 1;
            const fireRateMultiplier = upgrades.fireRate || 1;
            
            const range = def.range * rangeMultiplier * (1 + permUpgrades.rangeBonus);
            // Fire rate bonus reduces interval (makes it faster), gameSpeed also speeds up firing
            const fireInterval = def.fireRate / (fireRateMultiplier * (1 + permUpgrades.fireRateBonus + buffFireRateBonus) * gameSpeed);
            
            // Find target (furthest along path within range)
            // Beam towers prefer slow high-health enemies (megaboss > boss > tank)
            // Cannon towers prefer fast high-health enemies
            let bestTarget = null;
            let bestProgress = -1;
            let bestPriority = 0; // Higher priority for special enemies
            
            for (const enemy of enemies) {
                if (!enemy.alive) continue;
                const dx = enemy.x - tower.x;
                const dy = enemy.y - tower.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist <= range) {
                    const progress = enemy.pathIndex + enemy.pathProgress;
                    // Default priority is 1
                    let priority = 1;
                    
                    if (def.isBeam) {
                        // Beam prioritizes slow, high-health enemies that stay in range longer
                        // megaboss (5) > boss (4) > tank (3) > normal (1) > fast (0)
                        if (enemy.type === 'megaboss') priority = 5;
                        else if (enemy.type === 'boss') priority = 4;
                        else if (enemy.type === 'tank') priority = 3;
                        else if (enemy.type === 'fast') priority = 0;
                    } else if (def.isCannon) {
                        // Cannon prioritizes fast, high-health enemies
                        // fast (4) > megaboss (3) > boss (2) > tank (1) > normal (0)
                        if (enemy.type === 'fast') priority = 4;
                        else if (enemy.type === 'megaboss') priority = 3;
                        else if (enemy.type === 'boss') priority = 2;
                        else if (enemy.type === 'tank') priority = 1;
                        else priority = 0;
                    }
                    
                    // Pick target with highest priority, or furthest progress if same priority
                    if (priority > bestPriority || (priority === bestPriority && progress > bestProgress)) {
                        bestProgress = progress;
                        bestPriority = priority;
                        bestTarget = enemy;
                    }
                }
            }
            
            tower.target = bestTarget;
            tower.buffBonus = buffDamageBonus; // Store for damage calculation
            tower.upgrades = upgrades; // Store for projectile/beam damage
            
            // Fire at target
            const now = performance.now();
            // Inferno towers can fire at path points even without a direct target
            // But check zone limit before entering the firing block
            let canFire = bestTarget;
            if (def.isInferno) {
                const maxZones = def.infernoMaxZones || 3;
                const inFlightBoulders = projectiles.filter(p => p.isBoulder && p.alive).length;
                const totalActive = infernoZones.length + inFlightBoulders;
                // Inferno can fire preemptively as soon as wave starts, doesn't need enemies in range
                canFire = waveInProgress && totalActive < maxZones;
            }
            if (canFire && now - tower.lastFire >= fireInterval) {
                tower.lastFire = now;
                
                if (def.isBeam) {
                    // Track beam target for damage ramping
                    if (tower.beamTarget !== bestTarget) {
                        tower.beamTarget = bestTarget;
                        tower.beamLockTime = now;
                        tower.beamRetargetTime = now; // Track when we switched targets
                    }
                    
                    // Retargeting delay - beam needs 800ms to acquire new target before dealing damage
                    const retargetDelay = 800;
                    if (now - tower.beamRetargetTime < retargetDelay) {
                        // Still acquiring target, no damage yet
                        return;
                    }
                    
                    // Calculate ramp multiplier - starts at 0.4x, accelerates to massive damage
                    // Reaches ~1.4x at 1 second, ~4.4x at 2 seconds, ~9.4x at 3 seconds
                    const lockDuration = (now - tower.beamLockTime - retargetDelay) / 1000; // seconds (subtract delay)
                    const rampSpeed = upgrades.rampSpeed || 1;
                    const rampMultiplier = 0.4 + Math.pow(Math.max(0, lockDuration) * rampSpeed, 2.0);
                    
                    const damageMultiplier = upgrades.damage || 1;
                    const baseDamage = def.damage * damageMultiplier * (1 + permUpgrades.damageBonus + buffDamageBonus);
                    const damage = baseDamage * rampMultiplier;
                    const isCrit = Math.random() < permUpgrades.critChance;
                    damageEnemy(bestTarget, isCrit ? damage * 2 : damage, isCrit);
                } else if (def.isTesla) {
                    // Tesla Coil - zaps multiple enemies with chain lightning
                    const damageMultiplier = upgrades.damage || 1;
                    const baseDamage = def.damage * damageMultiplier * (1 + permUpgrades.damageBonus + buffDamageBonus);
                    const maxTargets = def.maxTargets || 5;
                    
                    // Find all enemies in range, sorted by distance
                    let targets = [];
                    for (const enemy of enemies) {
                        if (!enemy.alive) continue;
                        const dx = enemy.x - tower.x;
                        const dy = enemy.y - tower.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= range) {
                            targets.push({ enemy, dist });
                        }
                    }
                    targets.sort((a, b) => a.dist - b.dist);
                    targets = targets.slice(0, maxTargets);
                    
                    // Store arc targets for rendering
                    tower.teslaTargets = targets.map(t => t.enemy);
                    tower.teslaFireTime = now;
                    
                    // Damage all targets
                    for (const t of targets) {
                        const isCrit = Math.random() < permUpgrades.critChance;
                        damageEnemy(t.enemy, isCrit ? baseDamage * 2 : baseDamage, isCrit);
                        createParticles(t.enemy.x, t.enemy.y, def.arcColor, 3);
                    }
                } else if (def.isInferno) {
                    // Inferno - fires slow boulder projectile that creates AOE zone on impact
                    // Zone limit already checked in canFire above
                    
                    const damageMultiplier = upgrades.damage || 1;
                    const infernoRadius = def.infernoRadius * (1 + permUpgrades.splashBonus * 0.5);
                    const infernoDamage = def.infernoDamage * damageMultiplier * (1 + permUpgrades.damageBonus + buffDamageBonus);
                    const infernoDuration = def.infernoDuration;
                    
                    // Find all valid path points within range
                    let validPoints = [];
                    
                    for (let i = 0; i < currentPath.length - 1; i++) {
                        const p1 = currentPath[i];
                        const p2 = currentPath[i + 1];
                        
                        for (let t = 0; t <= 1; t += 0.1) {
                            const px = p1.x + (p2.x - p1.x) * t;
                            const py = p1.y + (p2.y - p1.y) * t;
                            
                            const dx = px - tower.x;
                            const dy = py - tower.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist <= range) {
                                // Calculate path progress for this point
                                const pathProgress = i + t;
                                
                                // Check not too close to existing zones or incoming boulders
                                let tooClose = false;
                                for (const zone of infernoZones) {
                                    const zd = Math.sqrt((px - zone.x) ** 2 + (py - zone.y) ** 2);
                                    if (zd < infernoRadius * 1.8) {
                                        tooClose = true;
                                        break;
                                    }
                                }
                                if (!tooClose) {
                                    for (const proj of projectiles) {
                                        if (proj.isBoulder && proj.alive) {
                                            const pd = Math.sqrt((px - proj.targetX) ** 2 + (py - proj.targetY) ** 2);
                                            if (pd < infernoRadius * 1.8) {
                                                tooClose = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                if (!tooClose) {
                                    validPoints.push({ x: px, y: py, pathProgress: pathProgress });
                                }
                            }
                        }
                    }
                    
                    // Find the frontmost enemy's progress on path
                    let frontmostProgress = -1;
                    for (const enemy of enemies) {
                        if (!enemy.alive) continue;
                        const enemyProgress = enemy.pathIndex + (enemy.pathProgress || 0);
                        if (enemyProgress > frontmostProgress) {
                            frontmostProgress = enemyProgress;
                        }
                    }
                    
                    let aheadPoints;
                    
                    // If no enemies yet, target early parts of the path to prepare
                    if (frontmostProgress < 0) {
                        // Sort by path progress and pick from earlier points
                        aheadPoints = validPoints.sort((a, b) => a.pathProgress - b.pathProgress);
                        // Take the first third of valid points (earliest on path)
                        aheadPoints = aheadPoints.slice(0, Math.max(1, Math.ceil(aheadPoints.length / 3)));
                    } else {
                        // Filter to points that are AHEAD of the frontmost enemy
                        const leadAmount = 0.5; // How far ahead on the path to target
                        aheadPoints = validPoints.filter(p => p.pathProgress > frontmostProgress + leadAmount);
                        
                        // If no points ahead, use points near the front
                        if (aheadPoints.length === 0) {
                            aheadPoints = validPoints.filter(p => p.pathProgress >= frontmostProgress - 0.5);
                        }
                        
                        // If still no points, use any valid point
                        if (aheadPoints.length === 0) {
                            aheadPoints = validPoints;
                        }
                    }
                    
                    // Pick a random point from valid points
                    let bestPathPoint = null;
                    if (aheadPoints.length > 0) {
                        const randomIndex = Math.floor(Math.random() * aheadPoints.length);
                        bestPathPoint = aheadPoints[randomIndex];
                    }
                    
                    // Fire boulder projectile at the target point
                    if (bestPathPoint) {
                        const dx = bestPathPoint.x - tower.x;
                        const dy = bestPathPoint.y - tower.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            tower.lastFired = now;
                            
                            // Create slow-moving boulder projectile
                            projectiles.push({
                                x: tower.x,
                                y: tower.y - 5,
                                vx: (dx / dist) * def.projectileSpeed,
                                vy: (dy / dist) * def.projectileSpeed,
                                targetX: bestPathPoint.x,
                                targetY: bestPathPoint.y,
                                damage: 0,
                                color: def.projectileColor,
                                type: 'inferno',
                                alive: true,
                                isBoulder: true,
                                infernoRadius: infernoRadius,
                                infernoDamage: infernoDamage,
                                infernoDuration: infernoDuration,
                                infernoColor: def.color,
                                hitEnemies: [],
                                trail: [{x: tower.x, y: tower.y - 5}],
                                rotation: 0
                            });
                        }
                    }
                } else {
                    fireProjectile(tower, bestTarget);
                }
            }
        }

        function fireProjectile(tower, target) {
            const def = TOWERS[tower.type];
            
            // Inferno towers only fire boulder projectiles, not regular ones
            if (def.isInferno) return;
            
            const upgrades = tower.upgrades || getTowerUpgrades(tower.type);
            
            // Calculate damage this projectile would do
            const buffBonus = tower.buffBonus || 0;
            const damageMultiplier = upgrades.damage || 1;
            const projDamage = def.damage * damageMultiplier * (1 + permUpgrades.damageBonus + buffBonus);
            
            // Check if target will die from already in-flight projectiles
            const incomingDamage = target.incomingDamage || 0;
            if (target.health - incomingDamage <= 0) {
                return; // Target already doomed, don't waste the shot
            }
            
            // Track this damage as incoming
            target.incomingDamage = incomingDamage + projDamage;
            
            // Calculate lead prediction for moving targets
            let targetX = target.x;
            let targetY = target.y;
            
            // If enemy is moving, predict where they'll be
            if (target.vx !== undefined && target.vy !== undefined) {
                const dx = target.x - tower.x;
                const dy = target.y - tower.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const timeToHit = dist / def.projectileSpeed;
                
                // Predict position (with a small multiplier to slightly over-lead)
                targetX = target.x + target.vx * timeToHit * 0.8;
                targetY = target.y + target.vy * timeToHit * 0.8;
            }
            
            const dx = targetX - tower.x;
            const dy = targetY - tower.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist === 0) return;
            
            // Tower firing pulse effect
            tower.lastFired = performance.now();
            
            projectiles.push({
                x: tower.x,
                y: tower.y,
                vx: (dx / dist) * def.projectileSpeed,
                vy: (dy / dist) * def.projectileSpeed,
                damage: projDamage,
                color: def.projectileColor,
                type: tower.type,
                alive: true,
                chainCount: upgrades.chains || def.chainCount || 0,
                chainRange: def.chainRange || 0,
                hitEnemies: [],
                splashMult: upgrades.splash || 1,
                poisonMult: upgrades.poison || 1,
                slowMult: upgrades.slow || 1,
                trail: [{x: tower.x, y: tower.y}],
                intendedTarget: target // Track target for incoming damage cleanup
            });
            
            // Create railgun line visual for piercing weapons
            if (def.isPiercing) {
                createRailgunLine(tower.x, tower.y, dx, dy, def.projectileColor);
            }
        }

        // ========== CHAMPION SYSTEM UPDATE ==========
        function updateChampions(dt, rawDt) {
            const now = performance.now();
            
            for (const type in champions) {
                const champ = champions[type];
                if (!champ || !champ.unit) continue;
                
                const unit = champ.unit;
                const tower = champ.tower;
                const def = CHAMPIONS[type];
                if (!def) continue;
                const range = def.range * (1 + permUpgrades.rangeBonus);
                
                // Initialize champion-specific state
                if (unit.lastAttack === undefined) unit.lastAttack = 0;
                if (unit.lastSpecial === undefined) unit.lastSpecial = 0;
                if (unit.combatMode === undefined) unit.combatMode = type === 'striker' ? 'ranged' : 'aoe';
                if (unit.pinnedTarget === undefined) unit.pinnedTarget = null;
                if (unit.pinStartTime === undefined) unit.pinStartTime = 0;
                if (unit.specialTarget === undefined) unit.specialTarget = null;
                
                // Handle knockdown recovery
                if (unit.state === 'knockedDown') {
                    unit.knockdownTimer -= rawDt;
                    if (unit.knockdownTimer <= 0) {
                        unit.state = 'idle';
                        unit.x = tower.x;
                        unit.y = tower.y;
                        unit.combatMode = type === 'striker' ? 'ranged' : 'aoe';
                        createParticles(unit.x, unit.y, def.accentColor, 15);
                        createParticles(unit.x, unit.y, '#ffffff', 10);
                    }
                    continue;
                }
                
                // Decay attack effect timer
                if (unit.attackEffectTimer > 0) {
                    unit.attackEffectTimer -= rawDt;
                }
                
                // Find enemies within tower range
                let targets = [];
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dx = enemy.x - tower.x;
                    const dy = enemy.y - tower.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= range) {
                        targets.push({ enemy, dist, pathProgress: enemy.pathIndex + (enemy.pathProgress || 0) });
                    }
                }
                
                // Sort by distance for general use
                targets.sort((a, b) => a.dist - b.dist);
                
                if (targets.length === 0) {
                    // No enemies - return to tower
                    unit.pinnedTarget = null;
                    unit.specialTarget = null;
                    if (unit.state !== 'idle') {
                        unit.state = 'returning';
                        unit.target = null;
                    }
                    
                    if (unit.state === 'returning') {
                        const dx = tower.x - unit.x;
                        const dy = tower.y - unit.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 5) {
                            unit.state = 'idle';
                            unit.x = tower.x;
                            unit.y = tower.y;
                        } else {
                            unit.x += (dx / dist) * def.moveSpeed * dt;
                            unit.y += (dy / dist) * def.moveSpeed * dt;
                            unit.angle = Math.atan2(dy, dx);
                        }
                    }
                    continue;
                }
                
                // === BLACK SQUIRREL BEHAVIOR ===
                // Primary: Ranged acorns with stun from safe distance
                // Special (every 15s): Jump in for AOE stun, then retreat
                if (type === 'striker') {
                    const rangedMode = def.ranged;
                    const aoeMode = def.aoeJump;
                    
                    // Check if special is ready
                    const specialReady = now - unit.lastSpecial >= aoeMode.cooldown;
                    
                    // Calculate safe position (away from path)
                    let safeX = tower.x;
                    let safeY = tower.y;
                    let minPathDist = Infinity;
                    let nearestPathPoint = null;
                    
                    for (let i = 0; i < currentPath.length - 1; i++) {
                        const p1 = currentPath[i];
                        const p2 = currentPath[i + 1];
                        const dist = pointToLineDistance(tower.x, tower.y, p1.x, p1.y, p2.x, p2.y);
                        if (dist < minPathDist) {
                            minPathDist = dist;
                            const t = Math.max(0, Math.min(1, 
                                ((tower.x - p1.x) * (p2.x - p1.x) + (tower.y - p1.y) * (p2.y - p1.y)) /
                                (Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))
                            ));
                            nearestPathPoint = {
                                x: p1.x + t * (p2.x - p1.x),
                                y: p1.y + t * (p2.y - p1.y)
                            };
                        }
                    }
                    
                    if (nearestPathPoint) {
                        const awayX = tower.x - nearestPathPoint.x;
                        const awayY = tower.y - nearestPathPoint.y;
                        const awayDist = Math.sqrt(awayX * awayX + awayY * awayY) || 1;
                        safeX = nearestPathPoint.x + (awayX / awayDist) * rangedMode.safeDistance;
                        safeY = nearestPathPoint.y + (awayY / awayDist) * rangedMode.safeDistance;
                        
                        // Clamp to tower range
                        const tdx = safeX - tower.x;
                        const tdy = safeY - tower.y;
                        const tdist = Math.sqrt(tdx * tdx + tdy * tdy);
                        if (tdist > range - 20) {
                            safeX = tower.x + (tdx / tdist) * (range - 20);
                            safeY = tower.y + (tdy / tdist) * (range - 20);
                        }
                    }
                    
                    // State machine
                    if (unit.combatMode === 'jumping_in') {
                        // Moving toward cluster for AOE
                        const targetEnemy = targets[0].enemy;
                        const dx = targetEnemy.x - unit.x;
                        const dy = targetEnemy.y - unit.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 30) {
                            // Arrived - do AOE stun
                            unit.combatMode = 'aoe_attack';
                            unit.lastSpecial = now;
                            unit.attackEffectTimer = 400;
                            
                            const baseDamage = aoeMode.damage * (1 + permUpgrades.damageBonus);
                            
                            // AOE stun all enemies in radius
                            for (const t of targets) {
                                const eDx = t.enemy.x - unit.x;
                                const eDy = t.enemy.y - unit.y;
                                if (Math.sqrt(eDx * eDx + eDy * eDy) <= aoeMode.radius) {
                                    damageEnemy(t.enemy, baseDamage, false);
                                    t.enemy.stunned = true;
                                    t.enemy.stunEndTime = now + aoeMode.stunDuration;
                                }
                            }
                            
                            // AOE effect
                            championEffects.push({
                                type: 'squirrelAoe',
                                x: unit.x, y: unit.y,
                                radius: aoeMode.radius,
                                color: def.accentColor,
                                life: 300, maxLife: 300
                            });
                            
                            createSplashRing(unit.x, unit.y, def.accentColor, aoeMode.radius);
                            createParticles(unit.x, unit.y, '#ffff00', 20);
                            createParticles(unit.x, unit.y, def.accentColor, 15);
                        } else {
                            // Move fast toward target
                            unit.state = 'jumping';
                            unit.x += (dx / dist) * def.moveSpeed * 1.5 * dt;
                            unit.y += (dy / dist) * def.moveSpeed * 1.5 * dt;
                            unit.angle = Math.atan2(dy, dx);
                        }
                    } else if (unit.combatMode === 'aoe_attack' || unit.combatMode === 'retreating') {
                        // Retreat to safe position after AOE
                        unit.combatMode = 'retreating';
                        const dx = safeX - unit.x;
                        const dy = safeY - unit.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 10) {
                            unit.combatMode = 'ranged';
                            unit.state = 'idle';
                        } else {
                            unit.state = 'retreating';
                            unit.x += (dx / dist) * def.moveSpeed * 1.3 * dt;
                            unit.y += (dy / dist) * def.moveSpeed * 1.3 * dt;
                            unit.angle = Math.atan2(dy, dx);
                        }
                    } else {
                        // Ranged mode - throw acorns from safe distance
                        unit.combatMode = 'ranged';
                        
                        // Check if should jump in for AOE
                        if (specialReady && targets.length >= 2) {
                            unit.combatMode = 'jumping_in';
                            createParticles(unit.x, unit.y, def.accentColor, 10);
                        } else {
                            // Stay at safe distance
                            const dx = safeX - unit.x;
                            const dy = safeY - unit.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > 15) {
                                unit.state = 'moving';
                                unit.x += (dx / dist) * def.moveSpeed * dt;
                                unit.y += (dy / dist) * def.moveSpeed * dt;
                            } else {
                                unit.state = 'attacking';
                            }
                            
                            // Throw acorns at closest enemy
                            const primaryTarget = targets[0].enemy;
                            const targetDx = primaryTarget.x - unit.x;
                            const targetDy = primaryTarget.y - unit.y;
                            unit.angle = Math.atan2(targetDy, targetDx);
                            unit.target = primaryTarget;
                            
                            const attackRate = rangedMode.attackRate * (1 - permUpgrades.fireRateBonus * 0.5);
                            
                            if (now - unit.lastAttack >= attackRate) {
                                unit.lastAttack = now;
                                unit.attackEffectTimer = 250;
                                
                                const baseDamage = rangedMode.damage * (1 + permUpgrades.damageBonus);
                                damageEnemy(primaryTarget, baseDamage, false);
                                
                                // Stun the target
                                primaryTarget.stunned = true;
                                primaryTarget.stunEndTime = now + rangedMode.stunDuration;
                                
                                // Acorn effect
                                championEffects.push({
                                    type: 'acorn',
                                    x: unit.x, y: unit.y,
                                    targetX: primaryTarget.x, targetY: primaryTarget.y,
                                    color: '#8B4513',
                                    life: 150, maxLife: 150
                                });
                                
                                createParticles(primaryTarget.x, primaryTarget.y, '#ffff00', 6);
                                createParticles(primaryTarget.x, primaryTarget.y, '#8B4513', 4);
                            }
                        }
                    }
                }
                
                // === JOUST PANTHER BEHAVIOR ===
                // Primary: AOE cleave attacks to nearby enemies
                // Special (every 10s): Pounce to enemy nearest to track end, pin them
                else if (type === 'caster') {
                    const cleaveMode = def.cleave;
                    const pounceMode = def.pounce;
                    
                    // Handle active pin
                    if (unit.pinnedTarget) {
                        if (!unit.pinnedTarget.alive || now - unit.pinStartTime >= pounceMode.pinDuration) {
                            // Release pin
                            unit.pinnedTarget.pinned = false;
                            unit.pinnedTarget = null;
                            unit.combatMode = 'aoe';
                            unit.state = 'idle';
                        } else {
                            // Keep pinning
                            unit.pinnedTarget.pinned = true;
                            unit.state = 'pinning';
                            unit.x = unit.pinnedTarget.x;
                            unit.y = unit.pinnedTarget.y - 5;
                            unit.angle = 0;
                            continue;
                        }
                    }
                    
                    // Check if pounce is ready
                    const pounceReady = now - unit.lastSpecial >= pounceMode.cooldown;
                    
                    // Find enemy furthest along path (closest to exit)
                    let pounceTarget = null;
                    if (pounceReady) {
                        let maxProgress = -1;
                        for (const t of targets) {
                            if (t.pathProgress > maxProgress) {
                                maxProgress = t.pathProgress;
                                pounceTarget = t.enemy;
                            }
                        }
                    }
                    
                    if (unit.combatMode === 'pouncing' && unit.specialTarget) {
                        // Moving to pounce target
                        if (!unit.specialTarget.alive) {
                            unit.combatMode = 'aoe';
                            unit.specialTarget = null;
                        } else {
                            const dx = unit.specialTarget.x - unit.x;
                            const dy = unit.specialTarget.y - unit.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < 25) {
                                // Pounce attack!
                                unit.lastSpecial = now;
                                unit.attackEffectTimer = 500;
                                
                                const baseDamage = pounceMode.damage * (1 + permUpgrades.damageBonus);
                                damageEnemy(unit.specialTarget, baseDamage, false);
                                
                                // Pin the target
                                unit.pinnedTarget = unit.specialTarget;
                                unit.pinStartTime = now;
                                unit.specialTarget.pinned = true;
                                unit.combatMode = 'pinning';
                                
                                // Pounce effect
                                championEffects.push({
                                    type: 'pounce',
                                    x: unit.x, y: unit.y,
                                    targetX: unit.specialTarget.x, targetY: unit.specialTarget.y,
                                    color: def.accentColor,
                                    life: 400, maxLife: 400
                                });
                                
                                createParticles(unit.specialTarget.x, unit.specialTarget.y, def.accentColor, 15);
                                createParticles(unit.specialTarget.x, unit.specialTarget.y, '#ffffff', 10);
                                
                                unit.specialTarget = null;
                            } else {
                                // Fast pounce movement
                                unit.state = 'pouncing';
                                unit.x += (dx / dist) * def.moveSpeed * 1.8 * dt;
                                unit.y += (dy / dist) * def.moveSpeed * 1.8 * dt;
                                unit.angle = Math.atan2(dy, dx);
                            }
                        }
                    } else if (pounceTarget && pounceReady) {
                        // Start pounce!
                        unit.combatMode = 'pouncing';
                        unit.specialTarget = pounceTarget;
                        createParticles(unit.x, unit.y, def.accentColor, 12);
                    } else {
                        // AOE cleave mode
                        unit.combatMode = 'aoe';
                        const primaryTarget = targets[0].enemy;
                        unit.target = primaryTarget;
                        
                        const dx = primaryTarget.x - unit.x;
                        const dy = primaryTarget.y - unit.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 40) {
                            // In cleave range
                            unit.state = 'attacking';
                            unit.angle = Math.atan2(dy, dx);
                            
                            const attackRate = cleaveMode.attackRate * (1 - permUpgrades.fireRateBonus * 0.5);
                            
                            if (now - unit.lastAttack >= attackRate) {
                                unit.lastAttack = now;
                                unit.attackEffectTimer = 300;
                                
                                const baseDamage = cleaveMode.damage * (1 + permUpgrades.damageBonus);
                                
                                // AOE damage
                                for (const t of targets) {
                                    const eDx = t.enemy.x - unit.x;
                                    const eDy = t.enemy.y - unit.y;
                                    if (Math.sqrt(eDx * eDx + eDy * eDy) <= cleaveMode.radius) {
                                        damageEnemy(t.enemy, baseDamage, false);
                                    }
                                }
                                
                                // Cleave effect
                                championEffects.push({
                                    type: 'cleave',
                                    x: unit.x, y: unit.y,
                                    radius: cleaveMode.radius,
                                    color: def.accentColor,
                                    life: 250, maxLife: 250
                                });
                                
                                createParticles(unit.x, unit.y, def.accentColor, 10);
                            }
                        } else {
                            // Move toward target
                            unit.state = 'moving';
                            unit.x += (dx / dist) * def.moveSpeed * dt;
                            unit.y += (dy / dist) * def.moveSpeed * dt;
                            unit.angle = Math.atan2(dy, dx);
                        }
                    }
                }
                
                // Clamp unit to tower range
                const udx = unit.x - tower.x;
                const udy = unit.y - tower.y;
                const udist = Math.sqrt(udx * udx + udy * udy);
                if (udist > range - 10) {
                    unit.x = tower.x + (udx / udist) * (range - 10);
                    unit.y = tower.y + (udy / udist) * (range - 10);
                }
                
                // Check if overwhelmed (knockdown)
                if (unit.state !== 'knockedDown' && unit.combatMode !== 'ranged' && unit.combatMode !== 'retreating') {
                    let nearbyEnemyPower = 0;
                    for (const enemy of enemies) {
                        if (!enemy.alive) continue;
                        const dx = enemy.x - unit.x;
                        const dy = enemy.y - unit.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 35) {
                            nearbyEnemyPower += enemy.type === 'boss' ? 3 : 
                                               enemy.type === 'megaboss' ? 5 :
                                               enemy.type === 'tank' ? 2 : 1;
                        }
                    }
                    
                    const knockdownThreshold = type === 'striker' ? 12 : 8;
                    if (nearbyEnemyPower >= knockdownThreshold) {
                        unit.state = 'knockedDown';
                        unit.knockdownTimer = 5000;
                        unit.target = null;
                        unit.pinnedTarget = null;
                        unit.specialTarget = null;
                        unit.combatMode = type === 'striker' ? 'ranged' : 'aoe';
                        
                        createParticles(unit.x, unit.y, '#ff0000', 15);
                        createParticles(unit.x, unit.y, def.accentColor, 10);
                    }
                }
            }
            
            // Update champion effects
            for (let i = championEffects.length - 1; i >= 0; i--) {
                const effect = championEffects[i];
                effect.life -= rawDt;
                if (effect.life <= 0) {
                    championEffects.splice(i, 1);
                }
            }
        }

        function updateProjectile(proj, dt) {
            // Store previous position for swept collision detection
            const prevX = proj.x;
            const prevY = proj.y;
            
            proj.x += proj.vx * dt;
            proj.y += proj.vy * dt;
            
            // Update trail (keep last 6 positions for performance)
            if (proj.trail) {
                proj.trail.push({x: proj.x, y: proj.y});
                if (proj.trail.length > 6) proj.trail.shift();
            }
            
            // Check bounds
            if (proj.x < -20 || proj.x > BASE_WIDTH + 20 || proj.y < -20 || proj.y > BASE_HEIGHT + 20) {
                proj.alive = false;
                
                // Boulders going out of bounds should still create their AOE at target
                if (proj.isBoulder) {
                    const now = performance.now();
                    infernoZones.push({
                        x: proj.targetX,
                        y: proj.targetY,
                        radius: proj.infernoRadius,
                        damage: proj.infernoDamage,
                        duration: proj.infernoDuration,
                        startTime: now,
                        color: proj.infernoColor,
                        lastDamageTick: now
                    });
                    createParticles(proj.targetX, proj.targetY, '#ff4400', 20);
                    createParticles(proj.targetX, proj.targetY, '#ffaa00', 15);
                    createSplashRing(proj.targetX, proj.targetY, '#ff4400', proj.infernoRadius);
                    return;
                }
                
                // Clear incoming damage tracking from intended target
                if (proj.intendedTarget && proj.intendedTarget.incomingDamage) {
                    proj.intendedTarget.incomingDamage = Math.max(0, proj.intendedTarget.incomingDamage - proj.damage);
                }
                return;
            }
            
            // Handle boulder projectiles (inferno tower)
            if (proj.isBoulder) {
                // Update rotation for visual spin
                proj.rotation = (proj.rotation || 0) + 0.15;
                
                // Check if reached target (or passed it)
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if we've passed the target (dot product of velocity and remaining distance)
                const dotProduct = dx * proj.vx + dy * proj.vy;
                const passedTarget = dotProduct < 0;
                
                // Impact if close enough OR passed the target
                if (dist < 25 || passedTarget) {
                    // Impact! Create inferno zone at target location
                    proj.alive = false;
                    
                    const now = performance.now();
                    infernoZones.push({
                        x: proj.targetX,
                        y: proj.targetY,
                        radius: proj.infernoRadius,
                        damage: proj.infernoDamage,
                        duration: proj.infernoDuration,
                        startTime: now,
                        color: proj.infernoColor,
                        lastDamageTick: now
                    });
                    
                    // Impact explosion particles
                    createParticles(proj.targetX, proj.targetY, '#ff4400', 20);
                    createParticles(proj.targetX, proj.targetY, '#ffaa00', 15);
                    createParticles(proj.targetX, proj.targetY, '#8B4513', 10);
                    
                    // Create impact ring
                    createSplashRing(proj.targetX, proj.targetY, '#ff4400', proj.infernoRadius);
                }
                return; // Boulder doesn't collide with enemies directly
            }
            
            // Check collision with enemies using swept collision (line segment to circle)
            // This prevents tunneling at high game speeds
            for (const enemy of enemies) {
                if (!enemy.alive) continue;
                if (proj.hitEnemies && proj.hitEnemies.includes(enemy)) continue; // Skip already hit enemies for chain
                
                // Calculate closest point on line segment (prevPos -> newPos) to enemy center
                const segDx = proj.x - prevX;
                const segDy = proj.y - prevY;
                const segLenSq = segDx * segDx + segDy * segDy;
                
                let closestX, closestY;
                if (segLenSq < 0.001) {
                    // Projectile barely moved, use current position
                    closestX = proj.x;
                    closestY = proj.y;
                } else {
                    // Project enemy position onto line segment
                    const t = Math.max(0, Math.min(1, 
                        ((enemy.x - prevX) * segDx + (enemy.y - prevY) * segDy) / segLenSq
                    ));
                    closestX = prevX + t * segDx;
                    closestY = prevY + t * segDy;
                }
                
                // Distance from closest point on path to enemy center
                const dx = enemy.x - closestX;
                const dy = enemy.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Hit radius based on enemy size
                const hitRadius = enemy.size + 6;
                
                if (dist < hitRadius) {
                    // Clear incoming damage tracking (shot has connected)
                    if (proj.intendedTarget && proj.intendedTarget.incomingDamage && !proj.incomingCleared) {
                        proj.intendedTarget.incomingDamage = Math.max(0, proj.intendedTarget.incomingDamage - proj.damage);
                        proj.incomingCleared = true; // Only clear once for piercing/chain projectiles
                    }
                    
                    const isCrit = Math.random() < permUpgrades.critChance;
                    const damage = isCrit ? proj.damage * 2 : proj.damage;
                    const towerDef = TOWERS[proj.type];
                    
                    if (towerDef.splashRadius) {
                        proj.alive = false;
                        const splashMult = proj.splashMult || 1;
                        const splashRadius = towerDef.splashRadius * splashMult * (1 + permUpgrades.splashBonus);
                        for (const e of enemies) {
                            if (!e.alive) continue;
                            const sdx = e.x - proj.x;
                            const sdy = e.y - proj.y;
                            if (Math.sqrt(sdx * sdx + sdy * sdy) <= splashRadius) {
                                damageEnemy(e, damage, isCrit);
                            }
                        }
                        createParticles(proj.x, proj.y, proj.color, 20);
                        createSplashRing(proj.x, proj.y, proj.color, splashRadius);
                    } else if (towerDef.isPiercing) {
                        // Piercing projectile - damage enemy and continue through
                        damageEnemy(enemy, damage, isCrit);
                        proj.hitEnemies.push(enemy);
                        createParticles(proj.x, proj.y, proj.color, 5);
                        // Don't set alive = false, projectile continues
                        // Don't break - continue checking other enemies this frame
                        continue;
                    } else if (proj.chainCount > 0) {
                        // Chain projectile - damage and bounce to next enemy
                        damageEnemy(enemy, damage, isCrit);
                        proj.hitEnemies.push(enemy);
                        
                        // Find next target to chain to
                        let nextTarget = null;
                        let closestDist = proj.chainRange;
                        for (const e of enemies) {
                            if (!e.alive || proj.hitEnemies.includes(e)) continue;
                            const cdx = e.x - enemy.x;
                            const cdy = e.y - enemy.y;
                            const cdist = Math.sqrt(cdx * cdx + cdy * cdy);
                            if (cdist < closestDist) {
                                closestDist = cdist;
                                nextTarget = e;
                            }
                        }
                        
                        if (nextTarget) {
                            // Redirect projectile to next target
                            proj.x = enemy.x;
                            proj.y = enemy.y;
                            const ndx = nextTarget.x - proj.x;
                            const ndy = nextTarget.y - proj.y;
                            const ndist = Math.sqrt(ndx * ndx + ndy * ndy);
                            proj.vx = (ndx / ndist) * towerDef.projectileSpeed;
                            proj.vy = (ndy / ndist) * towerDef.projectileSpeed;
                            proj.chainCount--;
                            createParticles(proj.x, proj.y, proj.color, 5);
                        } else {
                            proj.alive = false;
                        }
                    } else {
                        proj.alive = false;
                        damageEnemy(enemy, damage, isCrit);
                        
                        // Apply slow if freeze tower (use upgrade multiplier)
                        if (towerDef.slowAmount) {
                            const slowMult = proj.slowMult || 1;
                            const baseSlowStrength = towerDef.slowAmount * slowMult;
                            // slowBonus makes enemies slower (lower value = slower)
                            // +20% slow power means enemies move 20% slower
                            const slowStrength = baseSlowStrength * (1 - permUpgrades.slowBonus);
                            enemy.slowAmount = Math.max(0.15, Math.min(enemy.slowAmount, slowStrength));
                            enemy.slowUntil = performance.now() + towerDef.slowDuration;
                        }
                        
                        // Apply poison if poison tower (use upgrade multiplier)
                        if (towerDef.poisonDamage) {
                            const poisonMult = proj.poisonMult || 1;
                            enemy.poisonDamage = towerDef.poisonDamage * poisonMult * (1 + permUpgrades.damageBonus);
                            enemy.poisonUntil = performance.now() + towerDef.poisonDuration;
                        }
                    }
                    break;
                }
            }
        }

        // ========== WAVE SYSTEM ==========
        function showConfirmWave() {
            if (waveInProgress) return;
            document.getElementById('confirmOverlay').classList.add('active');
        }
        
        function startWave() {
            if (waveInProgress) return;
            
            // Hide tutorial when first wave starts
            tutorialActive = false;
            showPathArrows = false;
            
            // Cancel any pending placement preview
            if (showingPlacementPreview) {
                cancelPlacementPreview();
            }
            
            wave++;
            
            // Track highest wave for tower unlocks (campaign mode)
            highestWaveReached = Math.max(highestWaveReached, wave);
            
            // Reset leprechaun spawn tracker at start of each 10-wave cycle
            const cycleWave = ((wave - 1) % 10) + 1;
            if (cycleWave === 1) {
                leprechaunSpawnedThisCycle = false;
            }
            
            // Campaign mode tracking (5 waves per stage)
            if (gameMode === 'campaign') {
                campaignStageWave = ((wave - 1) % 5) + 1; // 1-5 within each stage
                campaignStage = Math.floor((wave - 1) / 5) + 1;
                
                // Check for infinite mode (wave 75+)
                if (wave >= 75) {
                    isInfiniteMode = true;
                }
            }
            
            // Update wave display
            if (gameMode === 'campaign') {
                waveDisplay.textContent = `${campaignStage}-${campaignStageWave}`;
            } else {
                waveDisplay.textContent = wave;
            }
            
            waveInProgress = true;
            waveBtn.disabled = true;
            
            // Cancel any tower move in progress
            if (movingTower) {
                cancelTowerAction();
            }
            
            if (gameMode === 'campaign') {
                waveBtn.textContent = `STAGE ${campaignStage}-${campaignStageWave}`;
            } else {
                waveBtn.textContent = 'WAVE ' + wave;
            }
            
            towerBar.classList.add('wave-active');
            updateShopButton();
            updateTowerButtons(); // Update for new tower limit and unlocks
            
            // Calculate enemy count based on mode
            let enemiesToSpawnCalc;
            
            if (gameMode === 'campaign') {
                enemiesToSpawnCalc = calculateCampaignEnemyCount();
            } else {
                // Classic mode enemy count scaling
                let countMult = 1;
                if (wave <= 2) {
                    // Waves 1-2: intro
                    countMult = 0.6 + (wave * 0.035);
                } else if (wave <= 9) {
                    // Waves 3-9: gentler ramp
                    countMult = 0.67 + ((wave - 2) * 0.030);
                } else if (wave <= 11) {
                    // Waves 10-11: transition
                    const wavesPast9 = wave - 9;
                    countMult = 0.88 + (wavesPast9 * 0.042);
                } else if (wave <= 20) {
                    // Waves 12-20: gentler scaling
                    const wavesPast11 = wave - 11;
                    countMult = 0.964 + (wavesPast11 * 0.038);
                } else if (wave <= 30) {
                    const wavesPast20 = wave - 20;
                    countMult = 1.31 + (wavesPast20 * 0.060);
                } else if (wave <= 39) {
                    const wavesPast30 = wave - 30;
                    countMult = 1.91 + (wavesPast30 * 0.090);
                } else {
                    const wavesPast39 = wave - 39;
                    countMult = 2.72 * Math.pow(1.16, wavesPast39);
                }
                // Base: 4 + wave*1.8 (was 5 + wave*2)
                enemiesToSpawnCalc = Math.floor((4 + wave * 1.8) * countMult);
            }
            
            enemiesToSpawn = enemiesToSpawnCalc;
            spawnTimer = 0;
            
            selectedTower = null;
            inspectedTower = null;
            towerBar.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            updatePlacementTooltip();
        }
        
        // Calculate enemy count for campaign mode
        function calculateCampaignEnemyCount() {
            // Base count increases with wave (reduced for 65 starting gold)
            let baseCount = 4 + wave * 1.2;
            
            // Gentler early-mid game (waves 3-10)
            if (wave >= 3 && wave <= 10) {
                baseCount *= 0.92;
            } else if (wave >= 12) {
                // Waves 12+: slightly reduced scaling
                baseCount *= 0.95;
            }
            
            // Stage multiplier (each stage = 5 waves)
            const stageMult = 1 + (campaignStage - 1) * 0.13;
            
            // Wave within stage adds enemies
            baseCount += campaignStageWave * 1.35;
            
            // Infinite mode (wave 75+): exponential scaling
            if (isInfiniteMode) {
                const infiniteWaves = wave - 74;
                baseCount = Math.floor(baseCount * Math.pow(1.15, infiniteWaves));
            }
            
            return Math.floor(baseCount * stageMult);
        }
        
        // Calculate enemy count for endless mode (compressed 10-wave stages)
        function calculateEndlessEnemyCount() {
            const stageMultiplier = Math.pow(1.22, endlessStage - 1); // 22% more per stage
            
            // Compressed progression: waves 1-10 represent full difficulty curve
            let baseCount;
            if (stageWave <= 3) {
                baseCount = 6 + stageWave * 3;
            } else if (stageWave <= 6) {
                baseCount = 15 + (stageWave - 3) * 5;
            } else if (stageWave <= 9) {
                baseCount = 30 + (stageWave - 6) * 8;
            } else {
                // Wave 10: Boss wave with many enemies
                baseCount = 55;
            }
            
            // Infinite mode: exponentially increasing spawn
            if (isInfiniteMode) {
                const infiniteWaves = totalEndlessWaves - 49;
                baseCount = Math.floor(baseCount * Math.pow(1.12, infiniteWaves));
            }
            
            return Math.floor(baseCount * stageMultiplier * endlessDifficultyMult);
        }

        function waveComplete() {
            waveInProgress = false;
            waveBtn.disabled = false;
            waveBtn.textContent = 'START WAVE';
            towerBar.classList.remove('wave-active');
            updateShopButton();
            
            // Wave 1 completion bonus (both modes)
            if (wave === 1) {
                gold += 32;
            }
            
            // Campaign mode: check for stage completion (every 5 waves)
            if (gameMode === 'campaign' && campaignStageWave === 5 && !isInfiniteMode) {
                // Stage complete! Trigger campaign transition
                triggerCampaignStageTransition();
                return; // Don't show upgrade selector yet
            }
            
            // Interest bonus
            if (permUpgrades.interest > 0) {
                const interestGold = Math.floor(gold * permUpgrades.interest);
                gold += interestGold;
                updateHUD();
            }
            
            updateTowerButtons();
            showUpgradeSelector();
        }
        
        // Trigger campaign stage transition (every 5 waves)
        function triggerCampaignStageTransition() {
            const overlay = document.getElementById('mapTransitionOverlay');
            const transitionText = document.getElementById('transitionText');
            const transitionSubtext = document.getElementById('transitionSubtext');
            const progressBar = document.getElementById('transitionProgressBar');
            
            const nextStage = campaignStage + 1;
            transitionText.textContent = `STAGE ${nextStage}`;
            transitionSubtext.style.display = 'none'; // Hide subtext
            
            // Reset progress bar animation
            progressBar.style.animation = 'none';
            progressBar.offsetHeight; // Trigger reflow
            progressBar.style.animation = 'transitionProgress 2s ease-out forwards';
            
            overlay.classList.add('active');
            
            // After transition animation, complete the stage change
            setTimeout(() => {
                completeCampaignStageTransition();
                overlay.classList.remove('active');
                showUpgradeSelector();
            }, 2500);
        }
        
        // Complete campaign stage transition - refund gold, change map, clear towers
        // NOTE: permUpgrades (shop upgrades) persist between stages - this is intentional!
        function completeCampaignStageTransition() {
            // Full 100% refund of gold spent on towers
            const refund = goldSpentThisStage;
            
            // Calculate starting gold for new stage (100% refund + stage bonus)
            let startingGold;
            if (campaignStage <= 1) {
                startingGold = 60;
            } else if (campaignStage <= 2) {
                startingGold = 75;
            } else if (campaignStage <= 4) {
                startingGold = 90 + (campaignStage * 8);
            } else {
                startingGold = 110 + (campaignStage * 10);
            }
            
            // Set gold to refund + starting bonus
            gold = refund + startingGold;
            goldSpentThisStage = 0;
            
            // Switch to new map layout - cycle through maps in order
            currentMapIndex = campaignStage % MAP_LAYOUTS.length;
            setCurrentPath(MAP_LAYOUTS[currentMapIndex]);
            
            // Clear towers
            towers = [];
            towerCounts = {};
            
            // Clear battlefield
            enemies = [];
            projectiles = [];
            particles = [];
            splashRings = [];
            railgunLines = [];
            infernoZones = [];
            
            // Reset leprechaun state for new stage
            leprechaunSpawnedThisCycle = false;
            leprechaunAlive = false;
            
            updateHUD();
            updateTowerButtons();
        }
        
        // Complete the stage transition - reset for new map
        function completeStageTransition() {
            endlessStage++;
            wave = 0; // Reset wave counter for new stage
            stageWave = 0;
            
            // Increase difficulty multiplier (gentler growth)
            endlessDifficultyMult *= 1.08;
            
            // Switch to new map layout - semi-random selection
            // Allow occasional repeats (20% chance) but mostly pick new maps
            let newMapIndex;
            const allowRepeat = Math.random() < 0.2; // 20% chance to allow same map
            
            if (allowRepeat && endlessStage > 2) {
                // Can repeat any map
                newMapIndex = Math.floor(Math.random() * MAP_LAYOUTS.length);
            } else {
                // Pick a different map than current
                do {
                    newMapIndex = Math.floor(Math.random() * MAP_LAYOUTS.length);
                } while (newMapIndex === currentMapIndex && MAP_LAYOUTS.length > 1);
            }
            
            currentMapIndex = newMapIndex;
            setCurrentPath(MAP_LAYOUTS[currentMapIndex]);
            
            // Reset towers and shop
            towers = [];
            towerCounts = {};
            resetTowerLevels();
            
            // Reset upgrades but keep some scaling benefits
            permUpgrades = {
                damageBonus: 0,
                rangeBonus: 0,
                fireRateBonus: 0,
                goldBonus: 0,
                costReduction: 0,
                splashBonus: 0,
                slowBonus: 0,
                critChance: 0,
                interest: 0,
                poisonBonus: 0,
                armorShred: 0,
                chainBonus: 0,
                multishot: 0,
                luck: 0
            };
            permUpgradeStacks = {};
            upgradeOfferHistory = {};
            
            // Reset luck protection for new stage
            luckState = {
                pityCounter: 0,
                epicCount: 0,
                legendaryCount: 0
            };
            
            // Give starting gold for new stage (increases with stage number)
            gold = 125 + (endlessStage * 35);
            
            // Increase tower placement limit
            endlessTowerLimitBonus += 2;
            
            // Clear battlefield
            enemies = [];
            projectiles = [];
            particles = [];
            splashRings = [];
            railgunLines = [];
            infernoZones = [];
            
            updateHUD();
            updateTowerButtons();
            updatePermUpgradesDisplay();
        }

        // ========== UPGRADE SYSTEM ==========
        // Store slot roll intervals for cleanup
        let slotRollIntervals = [];
        
        function showUpgradeSelector() {
            gamePaused = true;
            upgradeSelectionActive = false;
            upgradeOverlay.classList.add('active');
            updateRerollDisplay();
            
            // Clear any existing intervals
            slotRollIntervals.forEach(id => clearInterval(id));
            slotRollIntervals = [];
            
            currentUpgradeChoices = generateUpgradeChoices(3);
            
            // Track offers
            for (const upgrade of currentUpgradeChoices) {
                upgradeOfferHistory[upgrade.id] = 0;
            }
            UPGRADE_BASES.forEach(u => {
                if (!currentUpgradeChoices.some(c => c.id === u.id)) {
                    upgradeOfferHistory[u.id] = Math.min((upgradeOfferHistory[u.id] || 0) + 1, 5);
                }
            });
            
            // Reset slots to rolling with cycling animation
            upgradeSlots.forEach((slot, i) => {
                if (!slot) {
                    console.error('Slot element is null at index', i);
                    return;
                }
                slot.className = 'upgrade-slot rolling';
                slot.style.opacity = '1';
                slot.style.transform = 'translateY(0) scale(1)';
                slot.style.pointerEvents = '';
                
                // Start cycling through random upgrades
                const cycleUpgrades = () => {
                    const randomBase = UPGRADE_BASES[Math.floor(Math.random() * UPGRADE_BASES.length)];
                    const iconEl = slot.querySelector('.upgrade-icon');
                    const nameEl = slot.querySelector('.upgrade-name');
                    const descEl = slot.querySelector('.upgrade-desc');
                    const rarityEl = slot.querySelector('.upgrade-rarity');
                    if (iconEl) iconEl.textContent = randomBase.icon;
                    if (nameEl) nameEl.textContent = randomBase.name;
                    if (descEl) descEl.textContent = '???';
                    if (rarityEl) rarityEl.textContent = '???';
                };
                
                // Initial random display
                cycleUpgrades();
                
                // Cycle every 80ms for slot machine effect
                const intervalId = setInterval(cycleUpgrades, 80);
                slotRollIntervals.push(intervalId);
                
                // Stop and reveal final choice with staggered timing
                const stopTime = 800 + i * 400;
                setTimeout(() => {
                    clearInterval(intervalId);
                    slot.classList.remove('rolling');
                    slot.classList.add('revealed');
                    
                    const upgrade = currentUpgradeChoices[i];
                    if (!upgrade) {
                        console.error('Missing upgrade at index', i, 'choices:', currentUpgradeChoices);
                        // Still show something - pick a random one
                        const fallback = generateUpgrade(UPGRADE_BASES[Math.floor(Math.random() * UPGRADE_BASES.length)]);
                        currentUpgradeChoices[i] = fallback;
                    }
                    const finalUpgrade = currentUpgradeChoices[i];
                    const rarityConfig = RARITY_CONFIG[finalUpgrade.rarity] || RARITY_CONFIG.common;
                    
                    // Add rarity class
                    slot.classList.add('rarity-' + finalUpgrade.rarity);
                    
                    const iconEl = slot.querySelector('.upgrade-icon');
                    const nameEl = slot.querySelector('.upgrade-name');
                    const descEl = slot.querySelector('.upgrade-desc');
                    const rarityEl = slot.querySelector('.upgrade-rarity');
                    if (iconEl) iconEl.textContent = finalUpgrade.icon;
                    if (nameEl) nameEl.textContent = finalUpgrade.name;
                    if (descEl) descEl.textContent = finalUpgrade.desc;
                    if (rarityEl) rarityEl.textContent = rarityConfig.label;
                    
                    // Enable selection after last reveal
                    if (i === upgradeSlots.length - 1) {
                        setTimeout(() => {
                            upgradeSelectionActive = true;
                        }, 200);
                    }
                }, stopTime);
            });
        }

        function generateUpgradeChoices(count) {
            const selected = [];
            const usedIds = new Set();
            
            // Always generate exactly 'count' upgrades
            while (selected.length < count) {
                // Pick a random upgrade type that hasn't been used yet this selection
                let pool = UPGRADE_BASES.filter(b => !usedIds.has(b.id));
                
                // Safety check - if pool is somehow empty, reset usedIds
                if (pool.length === 0) {
                    usedIds.clear();
                    pool = [...UPGRADE_BASES];
                }
                
                // Weight by "not seen recently"
                const weights = pool.map(b => {
                    const roundsSince = upgradeOfferHistory[b.id] || 1;
                    return 1 + roundsSince * 0.5;
                });
                
                const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                let roll = Math.random() * totalWeight;
                let selectedIdx = 0;
                
                for (let j = 0; j < weights.length; j++) {
                    roll -= weights[j];
                    if (roll <= 0) {
                        selectedIdx = j;
                        break;
                    }
                }
                
                const base = pool[selectedIdx];
                if (base) {
                    usedIds.add(base.id);
                    const upgrade = generateUpgrade(base);
                    if (upgrade) {
                        selected.push(upgrade);
                    }
                }
            }
            
            return selected;
        }
        
        function rerollUpgrades() {
            if (rerollsRemaining <= 0 || !upgradeSelectionActive) return;
            
            rerollsRemaining--;
            updateRerollDisplay();
            upgradeSelectionActive = false;
            
            slotRollIntervals.forEach(id => clearInterval(id));
            slotRollIntervals = [];
            
            currentUpgradeChoices = generateUpgradeChoices(3);
            
            upgradeSlots.forEach((slot, i) => {
                if (!slot) return;
                slot.className = 'upgrade-slot rolling';
                slot.style.opacity = '1';
                slot.style.transform = 'translateY(0) scale(1)';
                
                const cycleUpgrades = () => {
                    const randomBase = UPGRADE_BASES[Math.floor(Math.random() * UPGRADE_BASES.length)];
                    const iconEl = slot.querySelector('.upgrade-icon');
                    const nameEl = slot.querySelector('.upgrade-name');
                    const descEl = slot.querySelector('.upgrade-desc');
                    const rarityEl = slot.querySelector('.upgrade-rarity');
                    if (iconEl) iconEl.textContent = randomBase.icon;
                    if (nameEl) nameEl.textContent = randomBase.name;
                    if (descEl) descEl.textContent = '???';
                    if (rarityEl) rarityEl.textContent = '???';
                };
                
                cycleUpgrades();
                const intervalId = setInterval(cycleUpgrades, 80);
                slotRollIntervals.push(intervalId);
                
                const stopTime = 400 + i * 200;
                setTimeout(() => {
                    clearInterval(intervalId);
                    slot.classList.remove('rolling');
                    slot.classList.add('revealed');
                    
                    const upgrade = currentUpgradeChoices[i];
                    if (!upgrade) {
                        const fallback = generateUpgrade(UPGRADE_BASES[Math.floor(Math.random() * UPGRADE_BASES.length)]);
                        currentUpgradeChoices[i] = fallback;
                    }
                    const finalUpgrade = currentUpgradeChoices[i];
                    const rarityConfig = RARITY_CONFIG[finalUpgrade.rarity] || RARITY_CONFIG.common;
                    
                    // Add rarity class
                    slot.classList.add('rarity-' + finalUpgrade.rarity);
                    
                    const iconEl = slot.querySelector('.upgrade-icon');
                    const nameEl = slot.querySelector('.upgrade-name');
                    const descEl = slot.querySelector('.upgrade-desc');
                    const rarityEl = slot.querySelector('.upgrade-rarity');
                    if (iconEl) iconEl.textContent = finalUpgrade.icon;
                    if (nameEl) nameEl.textContent = finalUpgrade.name;
                    if (descEl) descEl.textContent = finalUpgrade.desc;
                    if (rarityEl) rarityEl.textContent = rarityConfig.label;
                    
                    if (i === upgradeSlots.length - 1) {
                        setTimeout(() => { upgradeSelectionActive = true; }, 100);
                    }
                }, stopTime);
            });
        }
        
        function updateRerollDisplay() {
            const btn = document.getElementById('rerollBtn');
            const countEl = document.getElementById('rerollCount');
            countEl.textContent = rerollsRemaining + ' reroll' + (rerollsRemaining !== 1 ? 's' : '') + ' left';
            btn.disabled = rerollsRemaining <= 0;
        }

        function selectUpgrade(index) {
            // Prevent double selection
            if (!upgradeSelectionActive) return;
            upgradeSelectionActive = false;
            
            const choice = currentUpgradeChoices[index];
            if (!choice) return;
            
            // Visual feedback
            upgradeSlots.forEach((slot, i) => {
                if (i === index) {
                    slot.classList.add('selected');
                } else {
                    slot.style.opacity = '0.3';
                    slot.style.pointerEvents = 'none';
                }
            });
            
            // Apply upgrade
            choice.apply();
            
            // Track stacks
            permUpgradeStacks[choice.id] = (permUpgradeStacks[choice.id] || 0) + 1;
            updatePermUpgradesDisplay();
            
            // Close overlay
            setTimeout(() => {
                upgradeOverlay.classList.remove('active');
                upgradeSlots.forEach(slot => {
                    slot.style.opacity = '';
                    slot.style.pointerEvents = '';
                    slot.classList.remove('selected', 'revealed', 'rolling');
                });
                gamePaused = false;
            }, 600);
        }
        
        function skipUpgrade() {
            // Close overlay without selecting any upgrade
            if (!upgradeSelectionActive) return;
            upgradeSelectionActive = false;
            
            upgradeOverlay.classList.remove('active');
            upgradeSlots.forEach(slot => {
                slot.style.opacity = '';
                slot.style.pointerEvents = '';
                slot.classList.remove('selected', 'revealed', 'rolling');
            });
            gamePaused = false;
        }

        function updatePermUpgradesDisplay() {
            if (!permUpgradesDisplay) return; // Element removed from UI
            
            permUpgradesDisplay.innerHTML = '';
            
            for (const [id, stacks] of Object.entries(permUpgradeStacks)) {
                if (stacks <= 0) continue;
                const upgrade = UPGRADE_BASES.find(u => u.id === id);
                if (!upgrade) continue;
                
                const el = document.createElement('div');
                el.className = 'perm-icon';
                el.innerHTML = upgrade.icon;
                if (stacks > 1) {
                    el.innerHTML += `<span class="perm-stack">x${stacks}</span>`;
                }
                el.title = `${upgrade.name} x${stacks}`;
                permUpgradesDisplay.appendChild(el);
            }
        }

        // ========== GAME OVER ==========
        function gameOver() {
            gameRunning = false;
            gameoverOverlay.classList.add('active');
            
            let statsHtml;
            if (gameMode === 'campaign') {
                statsHtml = `
                    Stage Reached: <span>${campaignStage}</span><br>
                    Total Waves: <span>${wave}</span><br>
                    Enemies Killed: <span>${kills}</span><br>
                    Towers Built: <span>${towers.length}</span>
                `;
            } else {
                statsHtml = `
                    Waves Survived: <span>${wave}</span><br>
                    Enemies Killed: <span>${kills}</span><br>
                    Towers Built: <span>${towers.length}</span>
                `;
            }
            document.getElementById('gameoverStats').innerHTML = statsHtml;
            
            // Show score submission modal
            showScoreModal(wave, kills);
        }
        
        // ========== SCORE SUBMISSION ==========
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalWaveDisplay = document.getElementById('finalWaveDisplay');
        const finalKillsDisplay = document.getElementById('finalKillsDisplay');
        const finalModeDisplay = document.getElementById('finalModeDisplay');
        
        let pendingWave = 0;
        let pendingKills = 0;
        let pendingMode = 'campaign';
        
        async function showScoreModal(finalWave, finalKills) {
            pendingWave = finalWave;
            pendingKills = finalKills;
            pendingMode = gameMode; // Use current gameMode directly
            
            finalWaveDisplay.textContent = finalWave;
            finalKillsDisplay.textContent = finalKills;
            finalModeDisplay.textContent = pendingMode.toUpperCase();
            finalModeDisplay.style.color = pendingMode === 'campaign' ? '#f0f' : '#0ff';
            
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
            submitScoreBtn.disabled = false;
            
            // Check rank
            let rank = await getScoreRank(finalWave);
            
            if (rank === 1) {
                scoreModalTitle.textContent = " YOU'RE #1 ";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'GAME OVER';
            }
            
            scoreModal.classList.add('active');
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        async function getScoreRank(playerWave) {
            try {
                let scores = [];
                
                if (firebaseReady && db) {
                    const snapshot = await db.collection('towerdefense_scores')
                        .orderBy('wave', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        // Filter by mode (treat missing mode as 'classic' for legacy scores)
                        if ((data.mode || 'classic') === pendingMode) {
                            scores.push(data.wave);
                        }
                    });
                } else {
                    const localScores = getLocalScores();
                    scores = localScores
                        .filter(s => (s.mode || 'classic') === pendingMode)
                        .map(s => s.wave);
                }
                
                let rank = 1;
                for (const existingWave of scores) {
                    if (playerWave <= existingWave) {
                        rank++;
                    } else {
                        break;
                    }
                }
                
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999;
            }
        }
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection('towerdefense_scores').add({
                        name: username,
                        wave: pendingWave,
                        kills: pendingKills,
                        mode: pendingMode,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } else {
                    saveLocalScore(username, pendingWave, pendingKills, pendingMode);
                }
                
               hideScoreModal();
                
            } catch (e) {
                console.warn('Score submission failed:', e);
                saveLocalScore(username, pendingWave, pendingKills, pendingMode);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        function saveLocalScore(name, waveNum, killCount, mode) {
            try {
                const scores = JSON.parse(localStorage.getItem('towerdefense_scores') || '[]');
                scores.push({ name, wave: waveNum, kills: killCount, mode: mode, timestamp: Date.now() });
                scores.sort((a, b) => b.wave - a.wave || b.kills - a.kills);
                localStorage.setItem('towerdefense_scores', JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem('towerdefense_scores') || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Score modal event listeners
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            submitScore();
        });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            hideScoreModal();
        });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitScore();
            }
            if (e.key === 'Escape') {
                hideScoreModal();
            }
        });
        
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ========== LEADERBOARD ==========
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const menuLeaderboardBtn = document.getElementById('menuLeaderboardBtn');
        const tabCampaign = document.getElementById('tabCampaign');
        const tabClassic = document.getElementById('tabClassic');
        
        let currentLeaderboardMode = 'campaign';
        let cachedScores = []; // Cache scores to avoid refetching on tab switch
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            // Reset to campaign tab
            currentLeaderboardMode = 'campaign';
            updateLeaderboardTabs();
            
            try {
                cachedScores = [];
                
                if (firebaseReady && db) {
                    const snapshot = await db.collection('towerdefense_scores')
                        .orderBy('wave', 'desc')
                        .limit(200)
                        .get();
                    
                    snapshot.forEach(doc => {
                        cachedScores.push(doc.data());
                    });
                } else {
                    cachedScores = getLocalScores();
                }
                
                renderLeaderboard();
                
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                cachedScores = getLocalScores();
                renderLeaderboard();
            }
        }
        
        function updateLeaderboardTabs() {
            tabCampaign.className = 'leaderboard-tab' + (currentLeaderboardMode === 'campaign' ? ' active-campaign' : '');
            tabClassic.className = 'leaderboard-tab' + (currentLeaderboardMode === 'classic' ? ' active-classic' : '');
        }
        
        function renderLeaderboard() {
            // Filter scores by current mode (treat missing mode as 'classic' for legacy)
            const filteredScores = cachedScores.filter(s => (s.mode || 'classic') === currentLeaderboardMode);
            
            if (filteredScores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            // Sort and limit to top 100
            filteredScores.sort((a, b) => b.wave - a.wave || b.kills - a.kills);
            const topScores = filteredScores.slice(0, 100);
            
            let html = '';
            topScores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">Wave ${entry.wave}</div>
                        <div class="leaderboard-wave">${entry.kills} kills</div>
                    </div>
                `;
            });
            
            leaderboardList.innerHTML = html;
        }
        
        // Tab click handlers
        tabCampaign.addEventListener('click', () => {
            if (currentLeaderboardMode !== 'campaign') {
                currentLeaderboardMode = 'campaign';
                updateLeaderboardTabs();
                renderLeaderboard();
            }
        });
        
        tabClassic.addEventListener('click', () => {
            if (currentLeaderboardMode !== 'classic') {
                currentLeaderboardMode = 'classic';
                updateLeaderboardTabs();
                renderLeaderboard();
            }
        });
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        // Leaderboard event listeners
        leaderboardBtn.addEventListener('click', showLeaderboard);
        menuLeaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) {
                hideLeaderboard();
            }
        });
        
        // ========== SHOP SYSTEM ==========
        const shopOverlay = document.getElementById('shopOverlay');
        const shopGrid = document.getElementById('shopGrid');
        const shopClose = document.getElementById('shopClose');
        const shopBtn = document.getElementById('shopBtn');
        const shopGoldDisplay = document.getElementById('shopGoldDisplay');
        
        function getUpgradeCost(type) {
            const shop = TOWER_SHOP[type];
            const level = towerLevels[type] || 0;
            if (level >= shop.maxLevel) return Infinity;
            return Math.floor(shop.baseCost * Math.pow(shop.costMult, level));
        }
        
        function getUpgradeEffectText(type) {
            const shop = TOWER_SHOP[type];
            const level = towerLevels[type] || 0;
            const current = shop.effects[level];
            const next = shop.effects[level + 1];
            
            if (!next) return 'MAX LEVEL';
            
            let effects = [];
            if (next.damage && next.damage !== current.damage) {
                effects.push(`DMG ${Math.round(current.damage * 100)}%  ${Math.round(next.damage * 100)}%`);
            }
            if (next.range && next.range !== current.range) {
                effects.push(`RNG ${Math.round(current.range * 100)}%  ${Math.round(next.range * 100)}%`);
            }
            if (next.fireRate && next.fireRate !== current.fireRate) {
                effects.push(`SPD ${Math.round(current.fireRate * 100)}%  ${Math.round(next.fireRate * 100)}%`);
            }
            if (next.splash && next.splash !== current.splash) {
                effects.push(`AOE ${Math.round(current.splash * 100)}%  ${Math.round(next.splash * 100)}%`);
            }
            if (next.slow && next.slow !== current.slow) {
                effects.push(`SLOW ${Math.round((1 - current.slow) * 100)}%  ${Math.round((1 - next.slow) * 100)}%`);
            }
            if (next.poison && next.poison !== current.poison) {
                effects.push(`PSN ${Math.round(current.poison * 100)}%  ${Math.round(next.poison * 100)}%`);
            }
            if (next.chains && next.chains !== current.chains) {
                effects.push(`CHAIN ${current.chains}  ${next.chains}`);
            }
            if (next.buffDamage && next.buffDamage !== current.buffDamage) {
                effects.push(`BUFF ${Math.round(current.buffDamage * 100)}%  ${Math.round(next.buffDamage * 100)}%`);
            }
            
            return effects.join('<br>');
        }
        
        function renderShop() {
            shopGoldDisplay.textContent = gold;
            shopGrid.innerHTML = '';
            
            for (const type in TOWER_SHOP) {
                const shop = TOWER_SHOP[type];
                const level = towerLevels[type];
                const cost = getUpgradeCost(type);
                const isMaxed = level >= shop.maxLevel;
                const canAfford = gold >= cost;
                const isUnlocked = isTowerUnlocked(type);
                
                const item = document.createElement('div');
                item.className = 'shop-item';
                if (!isUnlocked) item.classList.add('locked');
                else if (isMaxed) item.classList.add('maxed');
                else if (!canAfford) item.classList.add('disabled');
                
                // Show unlock wave requirement for locked towers
                const costDisplay = !isUnlocked ? `Wave ${TOWER_UNLOCKS[type]}` : (isMaxed ? '---' : '$' + cost);
                const levelDisplay = !isUnlocked ? 'LOCKED' : `Lv.${level}${isMaxed ? ' MAX' : `  ${level + 1}`}`;
                
                item.innerHTML = `
                    <div class="shop-item-icon">${shop.icon}</div>
                    <div class="shop-item-name">${shop.name}</div>
                    <div class="shop-item-level">${levelDisplay}</div>
                    <div class="shop-item-effect">${isUnlocked ? getUpgradeEffectText(type) : ''}</div>
                    <div class="shop-item-cost">${costDisplay}</div>
                `;
                
                if (isUnlocked && !isMaxed && canAfford) {
                    item.addEventListener('click', () => purchaseUpgrade(type));
                }
                
                shopGrid.appendChild(item);
            }
        }
        
        function purchaseUpgrade(type) {
            const cost = getUpgradeCost(type);
            if (gold < cost) return;
            if (!isTowerUnlocked(type)) return; // Extra safety check
            
            gold -= cost;
            towerLevels[type]++;
            
            updateHUD();
            updateTowerButtons();
            renderShop();
        }
        
        function showShop() {
            if (waveInProgress) return;
            renderShop();
            shopOverlay.classList.add('active');
        }
        
        // Shop event listeners
        shopBtn.addEventListener('click', showShop);
        shopClose.addEventListener('click', hideShop);
        shopOverlay.addEventListener('click', (e) => {
            if (e.target === shopOverlay) {
                hideShop();
            }
        });
        
        // Stats toggle functionality
        const shopStatsToggle = document.getElementById('shopStatsToggle');
        const shopStatsPanel = document.getElementById('shopStatsPanel');
        const shopTitle = document.getElementById('shopTitle');
        const statsGrid = document.getElementById('statsGrid');
        let showingStats = false;
        
        function renderStatsPanel() {
            statsGrid.innerHTML = '';
            
            const statDefs = [
                { key: 'damageBonus', name: ' Damage', suffix: '%' },
                { key: 'luck', name: ' Luck', suffix: '%' },
                { key: 'rangeBonus', name: ' Range', suffix: '%' },
                { key: 'fireRateBonus', name: ' Fire Rate', suffix: '%' },
                { key: 'splashBonus', name: ' Splash', suffix: '%' },
                { key: 'slowBonus', name: ' Slow', suffix: '%' },
                { key: 'goldBonus', name: ' Gold', suffix: '%' },
                { key: 'costReduction', name: ' Cost Reduction', suffix: '%' },
                { key: 'poisonBonus', name: ' Poison', suffix: '%' },
                { key: 'critChance', name: ' Crit Chance', suffix: '%' },
                { key: 'armorShred', name: ' Armor Shred', suffix: '%' },
                { key: 'interest', name: ' Interest', suffix: '%' },
                { key: 'multishot', name: ' Multi-Shot', suffix: '%' },
                { key: 'chainBonus', name: ' Chain Bonus', suffix: '', isFlat: true }
            ];
            
            for (const stat of statDefs) {
                let value = permUpgrades[stat.key] || 0;
                // Convert decimal to percentage for display
                if (!stat.isFlat && value > 0 && value < 1) {
                    value = Math.round(value * 100);
                } else if (!stat.isFlat) {
                    value = Math.round(value);
                }
                
                const row = document.createElement('div');
                row.className = 'stat-row';
                
                const valueClass = value > 0 ? 'positive' : 'zero';
                const displayValue = value > 0 ? `+${value}${stat.suffix}` : `0${stat.suffix}`;
                
                row.innerHTML = `
                    <span class="stat-name">${stat.name}</span>
                    <span class="stat-value ${valueClass}">${displayValue}</span>
                `;
                statsGrid.appendChild(row);
            }
        }
        
        shopStatsToggle.addEventListener('click', () => {
            showingStats = !showingStats;
            
            if (showingStats) {
                shopGrid.classList.add('hidden');
                shopStatsPanel.classList.add('active');
                shopStatsToggle.textContent = 'SHOP';
                shopTitle.textContent = ' PLAYER STATS';
                renderStatsPanel();
            } else {
                shopGrid.classList.remove('hidden');
                shopStatsPanel.classList.remove('active');
                shopStatsToggle.textContent = 'STATS';
                shopTitle.textContent = ' TOWER UPGRADES';
            }
        });
        
        // Reset stats view when shop closes
        function hideShop() {
            shopOverlay.classList.remove('active');
            // Reset to shop view
            showingStats = false;
            shopGrid.classList.remove('hidden');
            shopStatsPanel.classList.remove('active');
            shopStatsToggle.textContent = 'STATS';
            shopTitle.textContent = ' TOWER UPGRADES';
        }
        
        // Disable shop button during waves
        function updateShopButton() {
            shopBtn.disabled = waveInProgress;
        }
        
        // ========== TUTORIAL ==========
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialBtn = document.getElementById('tutorialBtn');
        const tutorialClose = document.getElementById('tutorialClose');
        const tutorialPrev = document.getElementById('tutorialPrev');
        const tutorialNext = document.getElementById('tutorialNext');
        const tutorialDots = document.getElementById('tutorialDots');
        const tutorialSteps = document.querySelectorAll('.tutorial-step');
        const totalSteps = tutorialSteps.length;
        let currentStep = 0;
        
        // Create dots
        for (let i = 0; i < totalSteps; i++) {
            const dot = document.createElement('div');
            dot.className = 'tutorial-dot' + (i === 0 ? ' active' : '');
            dot.addEventListener('click', () => goToStep(i));
            tutorialDots.appendChild(dot);
        }
        
        function showTutorial() {
            tutorialOverlay.classList.add('active');
            goToStep(0);
        }
        
        function hideTutorial() {
            tutorialOverlay.classList.remove('active');
        }
        
        function goToStep(step) {
            currentStep = step;
            
            // Update steps
            tutorialSteps.forEach((s, i) => {
                s.classList.toggle('active', i === step);
            });
            
            // Update dots
            const dots = tutorialDots.querySelectorAll('.tutorial-dot');
            dots.forEach((d, i) => {
                d.classList.toggle('active', i === step);
            });
            
            // Update buttons
            tutorialPrev.disabled = step === 0;
            tutorialNext.textContent = step === totalSteps - 1 ? 'Got it!' : 'Next ';
        }
        
        function nextStep() {
            if (currentStep < totalSteps - 1) {
                goToStep(currentStep + 1);
            } else {
                hideTutorial();
            }
        }
        
        function prevStep() {
            if (currentStep > 0) {
                goToStep(currentStep - 1);
            }
        }
        
        tutorialBtn.addEventListener('click', showTutorial);
        tutorialClose.addEventListener('click', hideTutorial);
        tutorialPrev.addEventListener('click', prevStep);
        tutorialNext.addEventListener('click', nextStep);
        tutorialOverlay.addEventListener('click', (e) => {
            if (e.target === tutorialOverlay) {
                hideTutorial();
            }
        });
        
        // Keyboard navigation for tutorial
        document.addEventListener('keydown', (e) => {
            if (!tutorialOverlay.classList.contains('active')) return;
            if (e.key === 'ArrowRight' || e.key === 'Enter') nextStep();
            if (e.key === 'ArrowLeft') prevStep();
            if (e.key === 'Escape') hideTutorial();
        });
        
        // Escape key to cancel tower actions
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (showingPlacementPreview || movingTower || inspectedTower) {
                    cancelTowerAction();
                } else if (selectedTower) {
                    selectedTower = null;
                    document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
                    updatePlacementTooltip();
                }
            }
        });

        // Draw subtle grid for tower placement
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            
            // Vertical lines - including edges at 0 and BASE_WIDTH
            for (let x = 0; x <= BASE_WIDTH; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, BASE_HEIGHT);
                ctx.stroke();
            }
            
            // Horizontal lines - including edges at 0 and BASE_HEIGHT
            for (let y = 0; y <= BASE_HEIGHT; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(BASE_WIDTH, y);
                ctx.stroke();
            }
            
            // Draw grid cell centers as small dots
            ctx.fillStyle = 'rgba(0, 255, 255, 0.12)';
            for (let x = GRID_SIZE / 2; x < BASE_WIDTH; x += GRID_SIZE) {
                for (let y = GRID_SIZE / 2; y < BASE_HEIGHT; y += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ========== RENDERING ==========
        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // Draw snap grid when placing towers or moving a tower
            if ((selectedTower && !waveInProgress) || showingPlacementPreview || movingTower) {
                drawGrid();
            }
            
            drawPath();
            
            // Draw path arrows during tutorial
            if (showPathArrows) {
                drawPathArrows();
            }
            
            drawInfernoZones();
            drawTowers();
            drawEnemies();
            drawChampions();
            drawProjectiles();
            drawRailgunLines();
            drawSplashRings();
            drawParticles();
            
            // Show placement preview on desktop hover OR mobile two-tap preview OR moving tower
            if ((selectedTower && !waveInProgress) || showingPlacementPreview || movingTower) {
                drawPlacementPreview();
            }
            
            // Draw tutorial text
            if (tutorialActive && tutorialAlpha > 0) {
                drawTutorialText();
            }
        }
        
        function drawPathArrows() {
            const arrowSpacing = 80;
            const arrowSize = 6;
            
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Animate offset
            const animOffset = (pathArrowProgress % 1) * arrowSpacing;
            
            // Draw simple chevron arrows along path segments
            for (let i = 0; i < currentPath.length - 1; i++) {
                const p1 = currentPath[i];
                const p2 = currentPath[i + 1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const segLen = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Normalize direction
                const nx = dx / segLen;
                const ny = dy / segLen;
                
                // Draw arrows along this segment
                for (let d = animOffset; d < segLen; d += arrowSpacing) {
                    const x = p1.x + nx * d;
                    const y = p1.y + ny * d;
                    
                    // Simple chevron arrow (>)
                    ctx.beginPath();
                    ctx.moveTo(x + Math.cos(angle + 2.5) * arrowSize, y + Math.sin(angle + 2.5) * arrowSize);
                    ctx.lineTo(x + Math.cos(angle) * arrowSize, y + Math.sin(angle) * arrowSize);
                    ctx.lineTo(x + Math.cos(angle - 2.5) * arrowSize, y + Math.sin(angle - 2.5) * arrowSize);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
        }
        
        function drawTutorialText() {
            ctx.save();
            ctx.globalAlpha = tutorialAlpha;
            
            const text = "Place towers then start wave";
            ctx.font = 'bold 16px Arial';
            const textWidth = ctx.measureText(text).width;
            const boxWidth = textWidth + 30;
            const boxHeight = 36;
            const boxX = (BASE_WIDTH - boxWidth) / 2;
            const boxY = BASE_HEIGHT / 2 - 60;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 10;
            ctx.fillText(text, BASE_WIDTH / 2, boxY + boxHeight / 2);
            
            ctx.restore();
        }

        function drawPath() {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Path outer glow
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.12)';
            ctx.lineWidth = 36;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.stroke();
            
            // Main path
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.25)';
            ctx.lineWidth = 22;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.stroke();
            
            // Inner path highlight
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.stroke();
            
            // Path border
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.stroke();
            
            // Entry marker - bigger with START text and outer ring
            // Offset toward canvas center (inward) based on X position only
            const startRawX = currentPath[0].x;
            const startRawY = currentPath[0].y;
            const startOffsetX = startRawX < BASE_WIDTH / 2 ? 17 : -17; // Offset toward center
            const startX = startRawX + startOffsetX;
            const startY = startRawY; // Keep Y centered on track
            // Outer ring
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(startX, startY, 24, 0, Math.PI * 2);
            ctx.stroke();
            // Inner filled circle
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(startX, startY, 16, 0, Math.PI * 2);
            ctx.fill();
            // Text
            ctx.font = 'bold 9px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 0;
            ctx.fillText('START', startX, startY);
            
            // Exit marker - bigger with END text and outer ring
            // Offset toward canvas center (inward) based on X position only
            const endRawX = currentPath[currentPath.length - 1].x;
            const endRawY = currentPath[currentPath.length - 1].y;
            const endOffsetX = endRawX < BASE_WIDTH / 2 ? 14 : -14; // Offset toward center
            const endX = endRawX + endOffsetX;
            const endY = endRawY; // Keep Y centered on track
            // Outer ring
            ctx.strokeStyle = '#ff3366';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ff3366';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(endX, endY, 24, 0, Math.PI * 2);
            ctx.stroke();
            // Inner filled circle
            ctx.fillStyle = '#ff3366';
            ctx.beginPath();
            ctx.arc(endX, endY, 16, 0, Math.PI * 2);
            ctx.fill();
            // Text
            ctx.font = 'bold 10px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 0;
            ctx.fillText('END', endX, endY);
            
            ctx.shadowBlur = 0;
        }

        function drawTowers() {
            const now = performance.now();
            
            // Draw moving tower highlight (behind everything)
            if (movingTower) {
                const def = TOWERS[movingTower.type];
                const towerUpgrades = getTowerUpgrades(movingTower.type);
                const rangeMultiplier = towerUpgrades.range || 1;
                let range;
                
                if (def.buffRange) {
                    range = def.buffRange * (towerUpgrades.buffRange || 1) * (1 + permUpgrades.rangeBonus);
                } else {
                    range = def.range * rangeMultiplier * (1 + permUpgrades.rangeBonus);
                }
                
                // Fast pulsing effect - magenta for move mode
                const pulse = 0.5 + Math.sin(now / 150) * 0.5;
                
                // Range circle
                ctx.fillStyle = `rgba(255, 0, 255, ${0.15 * pulse})`;
                ctx.strokeStyle = `rgba(255, 0, 255, ${0.8 * pulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(movingTower.x, movingTower.y, range, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Highlight ring around tower being moved
                ctx.strokeStyle = `rgba(255, 0, 255, ${0.9 * pulse})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(movingTower.x, movingTower.y, 20, 0, Math.PI * 2);
                ctx.stroke();
                
                // "MOVING" indicator
                ctx.fillStyle = `rgba(255, 0, 255, ${pulse})`;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MOVING', movingTower.x, movingTower.y - 28);
            }
            
            // Draw inspected tower range (behind everything)
            if (inspectedTower) {
                const def = TOWERS[inspectedTower.type];
                const upgrades = getTowerUpgrades(inspectedTower.type);
                const rangeMultiplier = upgrades.range || 1;
                let range;
                
                if (def.buffRange) {
                    // Buff tower uses buffRange
                    range = def.buffRange * (upgrades.buffRange || 1) * (1 + permUpgrades.rangeBonus);
                } else {
                    // Normal towers use range
                    range = def.range * rangeMultiplier * (1 + permUpgrades.rangeBonus);
                }
                
                // Pulsing effect
                const pulse = 0.7 + Math.sin(now / 300) * 0.3;
                
                // Range circle
                ctx.fillStyle = `rgba(0, 255, 255, ${0.12 * pulse})`;
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.7 * pulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(inspectedTower.x, inspectedTower.y, range, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Highlight ring around inspected tower
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 * pulse})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(inspectedTower.x, inspectedTower.y, 18, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            for (const tower of towers) {
                const def = TOWERS[tower.type];
                
                // Buff tower range circle
                if (def.buffRange) {
                    const towerUpgrades = getTowerUpgrades(tower.type);
                    const buffRangeVisual = def.buffRange * (towerUpgrades.buffRange || 1) * (1 + permUpgrades.rangeBonus);
                    ctx.fillStyle = 'rgba(255, 136, 255, 0.1)';
                    ctx.strokeStyle = 'rgba(255, 136, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, buffRangeVisual, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                
                // Firing pulse effect
                const timeSinceFired = now - (tower.lastFired || 0);
                const pulseActive = timeSinceFired < 150;
                const pulseScale = pulseActive ? 1 + (1 - timeSinceFired / 150) * 0.3 : 1;
                const pulseGlow = pulseActive ? 20 + (1 - timeSinceFired / 150) * 15 : 10;
                
                // Tower base (common to all)
                ctx.fillStyle = '#1a1a1a';
                ctx.strokeStyle = def.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = def.color;
                ctx.shadowBlur = pulseGlow;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, 14 * pulseScale, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Draw tower-specific design
                ctx.fillStyle = def.color;
                ctx.strokeStyle = def.color;
                ctx.lineWidth = 2;
                
                switch(tower.type) {
                    case 'basic': //  Blaster - Rotating gun barrel
                        // Use smooth tracked angle from updateTower
                        const blasterAngle = tower.angle !== undefined ? tower.angle : -Math.PI / 2;
                        // Gun barrel
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(tower.x, tower.y);
                        ctx.lineTo(tower.x + Math.cos(blasterAngle) * 10 * pulseScale, tower.y + Math.sin(blasterAngle) * 10 * pulseScale);
                        ctx.stroke();
                        // Center hub
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 4 * pulseScale, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'sniper': //  Sniper - Simple bullseye
                        // Outer ring
                        ctx.strokeStyle = '#ff4444';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 8 * pulseScale, 0, Math.PI * 2);
                        ctx.stroke();
                        // Center dot
                        ctx.fillStyle = '#ff4444';
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 3 * pulseScale, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'freeze': //  Freezer - Snowflake
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI / 3);
                            const len = 8 * pulseScale;
                            ctx.beginPath();
                            ctx.moveTo(tower.x, tower.y);
                            ctx.lineTo(tower.x + Math.cos(angle) * len, tower.y + Math.sin(angle) * len);
                            ctx.stroke();
                            // Small branches
                            const bx = tower.x + Math.cos(angle) * len * 0.6;
                            const by = tower.y + Math.sin(angle) * len * 0.6;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(angle + 0.5) * 3, by + Math.sin(angle + 0.5) * 3);
                            ctx.moveTo(bx, by);
                            ctx.lineTo(bx + Math.cos(angle - 0.5) * 3, by + Math.sin(angle - 0.5) * 3);
                            ctx.stroke();
                            ctx.lineWidth = 2;
                        }
                        break;
                        
                    case 'splash': //  Bomber - Explosion/starburst
                        // Outer spikes
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4) + now / 2000;
                            const len = (i % 2 === 0 ? 9 : 6) * pulseScale;
                            ctx.beginPath();
                            ctx.moveTo(tower.x, tower.y);
                            ctx.lineTo(tower.x + Math.cos(angle) * len, tower.y + Math.sin(angle) * len);
                            ctx.stroke();
                        }
                        // Center
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 3 * pulseScale, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'laser': //  Beam - Satellite dish (rotated 90 clockwise)
                        ctx.save();
                        ctx.translate(tower.x, tower.y);
                        ctx.rotate(Math.PI / 2); // 90 degrees clockwise
                        ctx.translate(-tower.x, -tower.y);
                        // Dish arc
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(tower.x - 3, tower.y, 8 * pulseScale, -Math.PI * 0.4, Math.PI * 0.4);
                        ctx.stroke();
                        // Antenna/emitter
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(tower.x - 3, tower.y);
                        ctx.lineTo(tower.x + 8 * pulseScale, tower.y);
                        ctx.stroke();
                        // Feed point
                        ctx.beginPath();
                        ctx.arc(tower.x + 8 * pulseScale, tower.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        break;
                        
                    case 'minigun': //  Minigun - Multiple spinning barrels
                        const spinAngle = now / 100;
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        for (let i = 0; i < 4; i++) {
                            const angle = spinAngle + (i * Math.PI / 2);
                            ctx.beginPath();
                            ctx.moveTo(tower.x + Math.cos(angle) * 3, tower.y + Math.sin(angle) * 3);
                            ctx.lineTo(tower.x + Math.cos(angle) * 10 * pulseScale, tower.y + Math.sin(angle) * 10 * pulseScale);
                            ctx.stroke();
                        }
                        // Center hub
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'cannon': //  Cannon - Rotating big chunky barrel
                        // Use smooth tracked angle from updateTower
                        const cannonAngle = tower.angle !== undefined ? tower.angle : -Math.PI / 2;
                        // Wide barrel pointing at target
                        ctx.lineWidth = 7;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(tower.x, tower.y);
                        ctx.lineTo(tower.x + Math.cos(cannonAngle) * 12 * pulseScale, tower.y + Math.sin(cannonAngle) * 12 * pulseScale);
                        ctx.stroke();
                        // Barrel opening
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.arc(tower.x + Math.cos(cannonAngle) * 12 * pulseScale, tower.y + Math.sin(cannonAngle) * 12 * pulseScale, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = def.color;
                        // Base
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'poison': //  Poison - Skull shape with bubbles
                        // Skull outline
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y - 1, 6 * pulseScale, 0, Math.PI * 2);
                        ctx.fill();
                        // Eye sockets (dark)
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.arc(tower.x - 2.5, tower.y - 2, 2, 0, Math.PI * 2);
                        ctx.arc(tower.x + 2.5, tower.y - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        // Jaw
                        ctx.fillStyle = def.color;
                        ctx.fillRect(tower.x - 4, tower.y + 3, 8, 3);
                        // Bubbles
                        ctx.globalAlpha = 0.6;
                        const bubbleOffset = Math.sin(now / 300) * 2;
                        ctx.beginPath();
                        ctx.arc(tower.x + 8, tower.y - 4 + bubbleOffset, 2, 0, Math.PI * 2);
                        ctx.arc(tower.x + 6, tower.y - 8 + bubbleOffset, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'chain': //  Chain - Chain links
                        ctx.lineWidth = 2;
                        ctx.fillStyle = 'transparent';
                        // Three chain links
                        const linkAngle = now / 500;
                        for (let i = 0; i < 3; i++) {
                            const angle = linkAngle + (i * Math.PI * 2 / 3);
                            const lx = tower.x + Math.cos(angle) * 5;
                            const ly = tower.y + Math.sin(angle) * 5;
                            ctx.beginPath();
                            ctx.ellipse(lx, ly, 4 * pulseScale, 2.5 * pulseScale, angle, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        // Center connector
                        ctx.fillStyle = def.color;
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'buff': //  Buff Tower - Star with sparkles
                        // Star shape
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const outerAngle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                            const innerAngle = outerAngle + Math.PI / 5;
                            const outerR = 9 * pulseScale;
                            const innerR = 4 * pulseScale;
                            if (i === 0) {
                                ctx.moveTo(tower.x + Math.cos(outerAngle) * outerR, tower.y + Math.sin(outerAngle) * outerR);
                            } else {
                                ctx.lineTo(tower.x + Math.cos(outerAngle) * outerR, tower.y + Math.sin(outerAngle) * outerR);
                            }
                            ctx.lineTo(tower.x + Math.cos(innerAngle) * innerR, tower.y + Math.sin(innerAngle) * innerR);
                        }
                        ctx.closePath();
                        ctx.fill();
                        // Animated sparkles
                        ctx.globalAlpha = 0.5 + Math.sin(now / 200) * 0.3;
                        const sparkleR = 12 + Math.sin(now / 300) * 2;
                        for (let i = 0; i < 4; i++) {
                            const sAngle = now / 800 + (i * Math.PI / 2);
                            const sx = tower.x + Math.cos(sAngle) * sparkleR;
                            const sy = tower.y + Math.sin(sAngle) * sparkleR;
                            ctx.beginPath();
                            ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'inferno': //  Inferno - Volcano with billowing smoke
                        // Volcano cone (mountain shape)
                        ctx.fillStyle = '#4a2800';
                        ctx.beginPath();
                        ctx.moveTo(tower.x - 10 * pulseScale, tower.y + 8);
                        ctx.lineTo(tower.x - 4 * pulseScale, tower.y - 6 * pulseScale);
                        ctx.lineTo(tower.x + 4 * pulseScale, tower.y - 6 * pulseScale);
                        ctx.lineTo(tower.x + 10 * pulseScale, tower.y + 8);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Lava glow at crater
                        ctx.fillStyle = '#ff4400';
                        ctx.shadowColor = '#ff4400';
                        ctx.shadowBlur = 12 * pulseScale;
                        ctx.beginPath();
                        ctx.ellipse(tower.x, tower.y - 5 * pulseScale, 4 * pulseScale, 2 * pulseScale, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Inner hot core
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.ellipse(tower.x, tower.y - 5 * pulseScale, 2 * pulseScale, 1 * pulseScale, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Billowing smoke particles
                        ctx.globalAlpha = 0.6;
                        for (let s = 0; s < 4; s++) {
                            const smokeTime = now / 400 + s * 1.5;
                            const smokeY = tower.y - 8 - (smokeTime % 3) * 6;
                            const smokeX = tower.x + Math.sin(smokeTime * 2 + s) * (3 + s);
                            const smokeSize = 2 + (smokeTime % 3) * 1.5;
                            const smokeAlpha = 0.5 - (smokeTime % 3) * 0.15;
                            
                            ctx.fillStyle = `rgba(80, 80, 80, ${Math.max(0, smokeAlpha)})`;
                            ctx.beginPath();
                            ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                        break;
                        
                    default:
                        // Fallback - simple circle
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 6 * pulseScale, 0, Math.PI * 2);
                        ctx.fill();
                }
                
                // Inner bright core on fire
                if (pulseActive) {
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = 1 - timeSinceFired / 150;
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, 3 * pulseScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // Enhanced laser beam with pulsing layers
                if (def.isBeam && tower.target && tower.target.alive) {
                    const retargetDelay = 800;
                    const isAcquiring = tower.beamRetargetTime && (now - tower.beamRetargetTime < retargetDelay);
                    
                    if (isAcquiring) {
                        // Thin flickering "acquiring" beam
                        const flicker = Math.random() > 0.3 ? 1 : 0.3;
                        ctx.strokeStyle = def.color;
                        ctx.globalAlpha = 0.4 * flicker;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 8;
                        ctx.setLineDash([8, 8]);
                        ctx.beginPath();
                        ctx.moveTo(tower.x, tower.y);
                        ctx.lineTo(tower.target.x, tower.target.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    } else {
                        // Full powered beam
                        const beamPulse = 0.7 + Math.sin(now / 50) * 0.3;
                        
                        // Outer glow beam
                        ctx.strokeStyle = def.color;
                        ctx.globalAlpha = 0.3;
                        ctx.lineWidth = 8 * beamPulse;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.moveTo(tower.x, tower.y);
                        ctx.lineTo(tower.target.x, tower.target.y);
                        ctx.stroke();
                        
                        // Middle beam
                        ctx.globalAlpha = 0.6;
                        ctx.lineWidth = 4 * beamPulse;
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.moveTo(tower.x, tower.y);
                        ctx.lineTo(tower.target.x, tower.target.y);
                        ctx.stroke();
                        
                        // Core beam (bright)
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.9;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 5;
                        ctx.beginPath();
                        ctx.moveTo(tower.x, tower.y);
                        ctx.lineTo(tower.target.x, tower.target.y);
                        ctx.stroke();
                    }
                    
                    ctx.globalAlpha = 1;
                }
                
                ctx.shadowBlur = 0;
            }
        }
        
        // ========== DRAW CHAMPIONS ==========
        function drawChampions() {
            const now = performance.now();
            
            for (const type in champions) {
                const champ = champions[type];
                if (!champ) continue;
                
                const tower = champ.tower;
                const unit = champ.unit;
                const def = CHAMPIONS[type];
                const range = def.range * (1 + permUpgrades.rangeBonus);
                
                // Draw tower base (beacon/pedestal)
                ctx.save();
                
                // Range circle (subtle)
                ctx.strokeStyle = def.color;
                ctx.globalAlpha = 0.15;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, range, 0, Math.PI * 2);
                ctx.stroke();
                
                // Pulsing beacon at tower location
                const beaconPulse = 0.5 + Math.sin(now / 400) * 0.3;
                ctx.globalAlpha = beaconPulse * 0.4;
                ctx.fillStyle = def.color;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Beacon ring
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = def.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, 18, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner beacon
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = def.accentColor;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                // Draw champion unit
                if (unit.state === 'knockedDown') {
                    // Draw knocked down indicator at tower
                    ctx.save();
                    ctx.globalAlpha = 0.4 + Math.sin(now / 200) * 0.2;
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(' RECOVERING', tower.x, tower.y - 30);
                    
                    // Recovery progress bar
                    const recoveryPct = 1 - (unit.knockdownTimer / 5000);
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(tower.x - 25, tower.y - 15, 50, 6);
                    ctx.fillStyle = def.color;
                    ctx.fillRect(tower.x - 25, tower.y - 15, 50 * recoveryPct, 6);
                    ctx.strokeStyle = def.color;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(tower.x - 25, tower.y - 15, 50, 6);
                    
                    ctx.restore();
                    continue;
                }
                
                // Draw the hero unit
                ctx.save();
                
                const ux = unit.x;
                const uy = unit.y;
                
                // Connection line from unit to tower (when far)
                const distToTower = Math.sqrt(Math.pow(ux - tower.x, 2) + Math.pow(uy - tower.y, 2));
                if (distToTower > 30) {
                    ctx.strokeStyle = def.color;
                    ctx.globalAlpha = 0.2;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(tower.x, tower.y);
                    ctx.lineTo(ux, uy);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                ctx.globalAlpha = 1;
                
                // Glow effect
                ctx.shadowColor = def.accentColor;
                ctx.shadowBlur = 15;
                
                // Draw animal champions
                if (type === 'striker') {
                    // Black Squirrel
                    drawStrikerUnit(ux, uy, unit.angle, def, unit.attackEffectTimer > 0, now, unit.combatMode);
                } else {
                    // Joust Panther
                    const isPinning = unit.state === 'pinning';
                    drawCasterUnit(ux, uy, unit.angle, def, unit.attackEffectTimer > 0, now, unit.combatMode, isPinning);
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            
            // Draw champion attack effects
            for (const effect of championEffects) {
                const alpha = effect.life / effect.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                
                if (effect.type === 'squirrelSwipe') {
                    // Quick claw swipe
                    const angle = Math.atan2(effect.targetY - effect.y, effect.targetX - effect.x);
                    ctx.translate(effect.x, effect.y);
                    ctx.rotate(angle);
                    
                    // Three claw marks
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 * alpha;
                    ctx.lineCap = 'round';
                    for (let i = -1; i <= 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(5, i * 6);
                        ctx.lineTo(20, i * 8);
                        ctx.stroke();
                    }
                    
                    // Impact spark
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(15, 0, 6 * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (effect.type === 'acorn') {
                    // Acorn projectile trail
                    const progress = 1 - alpha;
                    const currentX = effect.x + (effect.targetX - effect.x) * progress;
                    const currentY = effect.y + (effect.targetY - effect.y) * progress;
                    
                    // Acorn
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(currentX, currentY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cap
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(currentX, currentY - 2, 3, Math.PI, 0);
                    ctx.fill();
                    
                    // Trail
                    ctx.strokeStyle = 'rgba(139, 69, 19, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(effect.x, effect.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    
                } else if (effect.type === 'pounce') {
                    // Pounce impact - claw marks and dust
                    ctx.translate(effect.targetX, effect.targetY);
                    
                    // Claw mark X pattern
                    ctx.strokeStyle = effect.color;
                    ctx.lineWidth = 3 * alpha;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = effect.color;
                    ctx.shadowBlur = 10;
                    
                    // Cross pattern
                    const size = 20 * (1 + (1 - alpha) * 0.5);
                    ctx.beginPath();
                    ctx.moveTo(-size, -size); ctx.lineTo(size, size);
                    ctx.moveTo(size, -size); ctx.lineTo(-size, size);
                    ctx.stroke();
                    
                    // Inner claws
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1.5 * alpha;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.7, -size * 0.7); ctx.lineTo(size * 0.7, size * 0.7);
                    ctx.moveTo(size * 0.7, -size * 0.7); ctx.lineTo(-size * 0.7, size * 0.7);
                    ctx.stroke();
                    
                } else if (effect.type === 'cleave') {
                    // AOE cleave - expanding claw ring
                    ctx.translate(effect.x, effect.y);
                    
                    const expand = (1 - alpha) * 0.5;
                    const radius = effect.radius * (0.5 + expand);
                    
                    // Claw ring
                    ctx.strokeStyle = effect.color;
                    ctx.lineWidth = 4 * alpha;
                    ctx.shadowColor = effect.color;
                    ctx.shadowBlur = 15;
                    
                    // Draw claw marks around the ring
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const innerR = radius * 0.7;
                        const outerR = radius;
                        
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR);
                        ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                        ctx.stroke();
                    }
                    
                    // Outer ring
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                } else if (effect.type === 'squirrelAoe') {
                    // Squirrel AOE stun - green shockwave with stars
                    ctx.translate(effect.x, effect.y);
                    
                    const expand = (1 - alpha) * 0.8;
                    const radius = effect.radius * (0.3 + expand);
                    
                    // Green shockwave ring
                    ctx.strokeStyle = effect.color;
                    ctx.lineWidth = 5 * alpha;
                    ctx.shadowColor = effect.color;
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Stun stars
                    ctx.strokeStyle = '#ffff00';
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 8;
                    ctx.lineWidth = 2 * alpha;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + (1 - alpha) * Math.PI;
                        const starR = radius * 0.9;
                        ctx.save();
                        ctx.translate(Math.cos(angle) * starR, Math.sin(angle) * starR);
                        ctx.rotate(angle + Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(0, -4 * alpha); ctx.lineTo(0, 4 * alpha);
                        ctx.moveTo(-4 * alpha, 0); ctx.lineTo(4 * alpha, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                } else if (effect.type === 'slash') {
                    // Legacy slash (keeping for compatibility)
                    const angle = Math.atan2(effect.targetY - effect.y, effect.targetX - effect.x);
                    ctx.translate(effect.x, effect.y);
                    ctx.rotate(angle);
                    
                    ctx.strokeStyle = effect.color;
                    ctx.lineWidth = 4 * alpha;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(15, 0, 25, -0.8, 0.8);
                    ctx.stroke();
                } else if (effect.type === 'bolt') {
                    // Magic bolt (legacy)
                    ctx.strokeStyle = effect.color;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = effect.color;
                    ctx.shadowBlur = 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(effect.x, effect.y);
                    ctx.lineTo(effect.targetX, effect.targetY);
                    ctx.stroke();
                    
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.targetX, effect.targetY, 8 * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        function drawStrikerUnit(x, y, angle, def, attacking, now, combatMode) {
            ctx.save();
            ctx.translate(x, y);
            
            // Determine which sprite set and frame to use
            let sprites, frameInterval;
            const isMoving = combatMode === 'jumping_in' || combatMode === 'retreating';
            const isAttacking = attacking || combatMode === 'aoe_attack';
            
            if (isAttacking || isMoving) {
                sprites = SQUIRREL_SPRITES.attack;
                frameInterval = 150; // Faster animation for action
            } else {
                sprites = SQUIRREL_SPRITES.idle;
                frameInterval = 800; // Slow breathing for idle
            }
            
            // Update animation frame
            if (now - SQUIRREL_SPRITES.lastFrameTime > frameInterval) {
                SQUIRREL_SPRITES.frameIndex = (SQUIRREL_SPRITES.frameIndex + 1) % sprites.length;
                SQUIRREL_SPRITES.lastFrameTime = now;
            }
            
            const sprite = sprites[SQUIRREL_SPRITES.frameIndex % sprites.length];
            
            if (sprite && sprite.complete && SQUIRREL_SPRITES.loaded) {
                // Determine facing direction based on movement/combat
                let facingLeft = false;
                if (combatMode === 'retreating') {
                    facingLeft = true; // Facing back toward base
                }
                
                // Scale sprite to match original size (~40px)
                const scale = 1.25;
                const spriteW = sprite.width * scale;
                const spriteH = sprite.height * scale;
                
                // Neon glow effect
                ctx.shadowColor = '#44ff44';
                ctx.shadowBlur = 8;
                
                // Flip horizontally if needed
                if (facingLeft) {
                    ctx.scale(-1, 1);
                }
                
                // Draw sprite centered
                ctx.drawImage(sprite, -spriteW / 2, -spriteH / 2, spriteW, spriteH);
                
                ctx.shadowBlur = 0;
            } else {
                // Fallback: simple circle if sprites not loaded
                ctx.fillStyle = def.color;
                ctx.shadowColor = '#44ff44';
                ctx.shadowBlur = 6;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Combat mode indicator (preserve original functionality)
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            if (combatMode === 'aoe_attack') {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.9)';
                ctx.fillText('', 0, -28);
            } else if (combatMode === 'retreating') {
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.fillText('', 0, -28);
            } else {
                ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
                ctx.fillText('', 0, -28);
            }
            
            ctx.restore();
        }

        function drawCasterUnit(x, y, angle, def, attacking, now, combatMode, isPinning) {
            ctx.save();
            ctx.translate(x, y);
            
            // Scale - larger than squirrel
            const scale = 1.7;
            ctx.scale(scale, scale);
            
            // Animation
            const breathe = Math.sin(now / 200) * 0.5;
            const tailWag = Math.sin(now / 150) * 0.25;
            
            // Colors
            const bodyColor = def.color;
            const glowColor = def.accentColor;
            
            // Shadow on ground
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(0, 10, 18, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Set up glow outline
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 2;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 10;
            ctx.fillStyle = bodyColor;
            
            // === TAIL (long, curving up and back) ===
            ctx.save();
            ctx.translate(-15, 2);
            ctx.rotate(tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-8, -4, -16, -10, -20, -20);
            ctx.bezierCurveTo(-18, -22, -16, -20, -14, -18);
            ctx.bezierCurveTo(-12, -12, -6, -6, 0, -2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
            
            // === HIND LEGS ===
            // Left hind leg
            ctx.beginPath();
            ctx.roundRect(-12, 4, 5, 8, 2);
            ctx.fill();
            ctx.stroke();
            
            // Right hind leg  
            ctx.beginPath();
            ctx.roundRect(-6, 5, 5, 7, 2);
            ctx.fill();
            ctx.stroke();
            
            // === BODY (long oval) ===
            ctx.beginPath();
            ctx.ellipse(0, 0 + breathe, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // === FRONT LEGS ===
            if (attacking || isPinning) {
                // Extended attack pose
                const ext = isPinning ? 8 : 4 + Math.sin(now / 60) * 4;
                
                // Front leg reaching forward
                ctx.beginPath();
                ctx.roundRect(10, 2, 5 + ext, 6, 2);
                ctx.fill();
                ctx.stroke();
                
                // Claws
                ctx.strokeStyle = '#fff';
                ctx.shadowColor = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(16 + ext, 2); ctx.lineTo(20 + ext, -2);
                ctx.moveTo(16 + ext, 5); ctx.lineTo(21 + ext, 4);
                ctx.moveTo(16 + ext, 8); ctx.lineTo(20 + ext, 10);
                ctx.stroke();
                
                // Reset
                ctx.strokeStyle = glowColor;
                ctx.shadowColor = glowColor;
                ctx.lineWidth = 2;
            } else {
                // Standing legs
                ctx.beginPath();
                ctx.roundRect(8, 4, 5, 8, 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.roundRect(13, 5, 5, 7, 2);
                ctx.fill();
                ctx.stroke();
            }
            
            // === NECK ===
            ctx.beginPath();
            ctx.ellipse(14, -4 + breathe, 6, 5, 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // === HEAD (round cat head) ===
            ctx.beginPath();
            ctx.arc(20, -8 + breathe, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // === EARS (small triangles on top of head) ===
            // Left ear
            ctx.beginPath();
            ctx.moveTo(15, -12 + breathe);
            ctx.lineTo(14, -20 + breathe);
            ctx.lineTo(18, -14 + breathe);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Right ear
            ctx.beginPath();
            ctx.moveTo(21, -14 + breathe);
            ctx.lineTo(22, -21 + breathe);
            ctx.lineTo(25, -14 + breathe);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Inner ear
            ctx.fillStyle = '#2a1a3a';
            ctx.beginPath();
            ctx.moveTo(15, -13 + breathe);
            ctx.lineTo(15, -18 + breathe);
            ctx.lineTo(17, -14 + breathe);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(22, -14 + breathe);
            ctx.lineTo(23, -19 + breathe);
            ctx.lineTo(24, -14 + breathe);
            ctx.closePath();
            ctx.fill();
            
            // === SNOUT (small bump) ===
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(27, -6 + breathe, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // === EYES (glowing, cat-like) ===
            ctx.fillStyle = def.eyeColor;
            ctx.shadowColor = def.eyeColor;
            ctx.shadowBlur = 15;
            
            // Left eye
            ctx.beginPath();
            ctx.ellipse(18, -9 + breathe, 2.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Right eye
            ctx.beginPath();
            ctx.ellipse(24, -8 + breathe, 2.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Pupils (vertical slits)
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.ellipse(18, -9 + breathe, 0.7, 1.6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(24, -8 + breathe, 0.7, 1.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // === NOSE ===
            ctx.fillStyle = '#1a0a1a';
            ctx.beginPath();
            ctx.moveTo(30, -6 + breathe);
            ctx.lineTo(31, -5 + breathe);
            ctx.lineTo(30, -4 + breathe);
            ctx.lineTo(29, -5 + breathe);
            ctx.closePath();
            ctx.fill();
            
            // === MODE INDICATOR ===
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0;
            if (isPinning) {
                ctx.fillStyle = glowColor;
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 8;
                ctx.fillText('', 0, -26);
            } else if (combatMode === 'pouncing') {
                ctx.fillStyle = 'rgba(170, 0, 255, 0.9)';
                ctx.fillText('', 0, -26);
            } else {
                ctx.fillStyle = 'rgba(170, 0, 255, 0.7)';
                ctx.fillText('', 0, -26);
            }
            
            ctx.restore();
        }

        function drawEnemies() {
            const now = performance.now();
            for (const enemy of enemies) {
                if (!enemy.alive) continue;
                
                const isSlowed = now < enemy.slowUntil;
                const isPoisoned = now < enemy.poisonUntil;
                const isMegaboss = enemy.type === 'megaboss';
                const isBoss = enemy.type === 'boss';
                const isTank = enemy.type === 'tank';
                const isFast = enemy.type === 'fast';
                const isLeprechaun = enemy.type === 'leprechaun';
                
                // Determine color based on status
                let color = enemy.color;
                if (isSlowed) color = '#00ccff';
                if (isPoisoned) color = '#44ff44';
                if (isSlowed && isPoisoned) color = '#00ffaa';
                // Leprechaun keeps its color unless status effect
                if (isLeprechaun && !isSlowed && !isPoisoned) color = enemy.color;
                
                // Stun/Pin indicators
                const isStunned = enemy.stunned && now < enemy.stunEndTime;
                const isPinned = enemy.pinned;
                
                if (isStunned || isPinned) {
                    // Yellow stun stars
                    ctx.save();
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 8;
                    const starCount = isPinned ? 4 : 3;
                    for (let i = 0; i < starCount; i++) {
                        const angle = (now / 200) + (i * Math.PI * 2 / starCount);
                        const dist = enemy.size + 8;
                        const sx = enemy.x + Math.cos(angle) * dist;
                        const sy = enemy.y - enemy.size - 5 + Math.sin(angle * 2) * 3;
                        ctx.font = '8px Arial';
                        ctx.fillText('', sx - 4, sy);
                    }
                    ctx.restore();
                    
                    // Pin indicator (panther claws)
                    if (isPinned) {
                        ctx.strokeStyle = '#aa00ff';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#aa00ff';
                        ctx.shadowBlur = 10;
                        // Draw claw marks over enemy
                        ctx.beginPath();
                        ctx.moveTo(enemy.x - 8, enemy.y - 8);
                        ctx.lineTo(enemy.x + 8, enemy.y + 8);
                        ctx.moveTo(enemy.x + 8, enemy.y - 8);
                        ctx.lineTo(enemy.x - 8, enemy.y + 8);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
                
                const s = enemy.size; // shorthand for size
                const x = enemy.x;
                const y = enemy.y;
                
                // Gentle floating animation
                const floatOffset = Math.sin(now / 300 + enemy.pathIndex) * 2;
                const ghostY = y + floatOffset;
                
                // MEGABOSS special outer effects - pulsing rings
                if (isMegaboss) {
                    const pulse = 0.5 + Math.sin(now / 150) * 0.5;
                    const pulse2 = 0.5 + Math.sin(now / 200 + 1) * 0.5;
                    
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.4 * pulse;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(x, ghostY, s * 1.6, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#ff6600';
                    ctx.globalAlpha = 0.3 * pulse2;
                    ctx.beginPath();
                    ctx.arc(x, ghostY, s * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                // LEPRECHAUN special outer effects - gold shimmer
                if (isLeprechaun) {
                    const shimmer = 0.5 + Math.sin(now / 120) * 0.5;
                    const shimmer2 = 0.5 + Math.sin(now / 80 + 2) * 0.5;
                    
                    // Rainbow beam going up into the sky
                    const rainbowColors = ['#ff0000', '#ff7700', '#ffff00', '#00ff00', '#0088ff', '#8800ff'];
                    const beamWidth = s * 0.4;
                    const beamTop = 0; // Top of canvas
                    const beamBottom = ghostY - s * 1.2; // Just above the hat
                    ctx.globalAlpha = 0.5 + shimmer * 0.3;
                    for (let i = 0; i < rainbowColors.length; i++) {
                        const offsetX = (i - 2.5) * (beamWidth / 6);
                        ctx.strokeStyle = rainbowColors[i];
                        ctx.lineWidth = beamWidth / 5;
                        ctx.shadowColor = rainbowColors[i];
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.moveTo(x + offsetX, beamBottom);
                        ctx.lineTo(x + offsetX * 0.3, beamTop);
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                    
                    // Gold sparkle ring
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6 * shimmer;
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(x, ghostY, s * 1.4, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner green glow
                    ctx.strokeStyle = '#00ff66';
                    ctx.globalAlpha = 0.4 * shimmer2;
                    ctx.shadowColor = '#00ff66';
                    ctx.beginPath();
                    ctx.arc(x, ghostY, s * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Floating gold particles around leprechaun
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowBlur = 8;
                    for (let i = 0; i < 4; i++) {
                        const angle = (now / 500) + (i * Math.PI / 2);
                        const dist = s * 1.3 + Math.sin(now / 200 + i) * s * 0.2;
                        const px = x + Math.cos(angle) * dist;
                        const py = ghostY + Math.sin(angle) * dist * 0.6;
                        ctx.globalAlpha = 0.7 * (0.5 + Math.sin(now / 150 + i) * 0.5);
                        ctx.beginPath();
                        ctx.arc(px, py, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Leprechaun hat - drawn above ghost body
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    const hatTop = ghostY - s * 1.2;
                    const hatBrimY = ghostY - s * 0.55;
                    const hatWidth = s * 1.1;
                    const hatHeight = s * 0.7;
                    
                    // Hat body (green top hat)
                    ctx.fillStyle = '#006600';
                    ctx.beginPath();
                    ctx.moveTo(x - hatWidth * 0.35, hatBrimY);
                    ctx.lineTo(x - hatWidth * 0.3, hatTop);
                    ctx.lineTo(x + hatWidth * 0.3, hatTop);
                    ctx.lineTo(x + hatWidth * 0.35, hatBrimY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Hat brim (wider dark green)
                    ctx.fillStyle = '#004400';
                    ctx.beginPath();
                    ctx.ellipse(x, hatBrimY, hatWidth * 0.55, s * 0.12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gold buckle/band
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 5;
                    ctx.fillRect(x - hatWidth * 0.35, hatBrimY - hatHeight * 0.25, hatWidth * 0.7, s * 0.12);
                    // Buckle square
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(x - s * 0.12, hatBrimY - hatHeight * 0.3, s * 0.24, s * 0.18);
                    ctx.fillStyle = '#006600';
                    ctx.fillRect(x - s * 0.06, hatBrimY - hatHeight * 0.23, s * 0.12, s * 0.08);
                    
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
                
                // Status effect outer glow
                if (isSlowed || isPoisoned) {
                    const pulse = 0.5 + Math.sin(now / 100) * 0.3;
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.3 * pulse;
                    ctx.beginPath();
                    ctx.arc(x, ghostY, s * 1.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // ===== GHOST BODY SHAPE =====
                ctx.fillStyle = color;
                ctx.shadowColor = enemy.color;
                ctx.shadowBlur = isMegaboss ? 25 : isLeprechaun ? 18 : 12;
                
                ctx.beginPath();
                // Dome top (semicircle from left to right)
                ctx.arc(x, ghostY - s * 0.2, s, Math.PI, 0, false);
                
                // Wavy bottom - 3 curves for the ghostly tail
                const bottomY = ghostY + s * 0.8;
                const waveAmp = s * 0.25;
                const tailWiggle = Math.sin(now / 200 + enemy.pathIndex) * s * 0.1;
                
                // Right side down
                ctx.lineTo(x + s, bottomY - waveAmp);
                // First wave (right)
                ctx.quadraticCurveTo(x + s * 0.7 + tailWiggle, bottomY + waveAmp, x + s * 0.35, bottomY - waveAmp * 0.5);
                // Middle wave
                ctx.quadraticCurveTo(x + tailWiggle * 0.5, bottomY + waveAmp, x - s * 0.35, bottomY - waveAmp * 0.5);
                // Left wave
                ctx.quadraticCurveTo(x - s * 0.7 + tailWiggle, bottomY + waveAmp, x - s, bottomY - waveAmp);
                // Left side up
                ctx.lineTo(x - s, ghostY - s * 0.2);
                
                ctx.closePath();
                ctx.fill();
                
                // Ghost outline for definition
                ctx.strokeStyle = isMegaboss ? '#ff00ff' : isBoss ? '#ff3333' : isLeprechaun ? '#ffd700' : 'rgba(255,255,255,0.4)';
                ctx.lineWidth = isMegaboss ? 2.5 : isBoss ? 2 : isLeprechaun ? 2 : 1.5;
                ctx.shadowBlur = 0;
                ctx.stroke();
                
                // ===== GHOST FACE =====
                const eyeY = ghostY - s * 0.25;
                const eyeSpacing = s * 0.35;
                const eyeSize = s * 0.22;
                const mouthY = ghostY + s * 0.2;
                
                if (isMegaboss) {
                    // Megaboss: Menacing skull-like eyes
                    ctx.fillStyle = '#1a0a1a';
                    ctx.beginPath();
                    ctx.ellipse(x - eyeSpacing, eyeY, eyeSize * 1.2, eyeSize * 1.4, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + eyeSpacing, eyeY, eyeSize * 1.2, eyeSize * 1.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Glowing red pupils
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(x - eyeSpacing, eyeY, eyeSize * 0.5, 0, Math.PI * 2);
                    ctx.arc(x + eyeSpacing, eyeY, eyeSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Angry jagged mouth
                    ctx.fillStyle = '#1a0a1a';
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.moveTo(x - s * 0.4, mouthY);
                    for (let i = 0; i < 5; i++) {
                        ctx.lineTo(x - s * 0.4 + (i + 0.5) * s * 0.16, mouthY + (i % 2 ? -s * 0.12 : s * 0.08));
                    }
                    ctx.lineTo(x + s * 0.4, mouthY);
                    ctx.closePath();
                    ctx.fill();
                } else if (isBoss) {
                    // Boss: Angry eyes with furrowed brows
                    ctx.fillStyle = '#1a0000';
                    ctx.beginPath();
                    ctx.ellipse(x - eyeSpacing, eyeY, eyeSize, eyeSize * 1.2, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + eyeSpacing, eyeY, eyeSize, eyeSize * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Angry eyebrows
                    ctx.strokeStyle = '#1a0000';
                    ctx.lineWidth = s * 0.12;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x - eyeSpacing - eyeSize, eyeY - eyeSize * 1.3);
                    ctx.lineTo(x - eyeSpacing + eyeSize * 0.5, eyeY - eyeSize * 0.8);
                    ctx.moveTo(x + eyeSpacing + eyeSize, eyeY - eyeSize * 1.3);
                    ctx.lineTo(x + eyeSpacing - eyeSize * 0.5, eyeY - eyeSize * 0.8);
                    ctx.stroke();
                    // Frowning mouth
                    ctx.beginPath();
                    ctx.arc(x, mouthY + s * 0.15, s * 0.2, Math.PI * 1.2, Math.PI * 1.8);
                    ctx.stroke();
                } else if (isTank) {
                    // Tank: Determined/tough look with thick brows
                    ctx.fillStyle = '#1a001a';
                    ctx.beginPath();
                    ctx.ellipse(x - eyeSpacing, eyeY, eyeSize * 0.9, eyeSize, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + eyeSpacing, eyeY, eyeSize * 0.9, eyeSize, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Flat serious mouth
                    ctx.strokeStyle = '#1a001a';
                    ctx.lineWidth = s * 0.1;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x - s * 0.2, mouthY);
                    ctx.lineTo(x + s * 0.2, mouthY);
                    ctx.stroke();
                } else if (isFast) {
                    // Fast: Excited/happy with blush marks
                    ctx.fillStyle = '#1a1a00';
                    ctx.beginPath();
                    ctx.ellipse(x - eyeSpacing, eyeY, eyeSize * 0.8, eyeSize * 0.9, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + eyeSpacing, eyeY, eyeSize * 0.8, eyeSize * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Blush marks
                    ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(x - eyeSpacing * 1.5, eyeY + s * 0.15, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + eyeSpacing * 1.5, eyeY + s * 0.15, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Happy open mouth
                    ctx.fillStyle = '#1a1a00';
                    ctx.beginPath();
                    ctx.ellipse(x, mouthY, s * 0.15, s * 0.12, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (isLeprechaun) {
                    // Leprechaun: Mischievous winking face with gold sparkle
                    ctx.fillStyle = '#0a3d0a';
                    // Left eye (winking - closed arc)
                    ctx.lineWidth = s * 0.08;
                    ctx.strokeStyle = '#0a3d0a';
                    ctx.beginPath();
                    ctx.arc(x - eyeSpacing, eyeY, eyeSize * 0.6, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                    // Right eye (open, sparkling)
                    ctx.beginPath();
                    ctx.ellipse(x + eyeSpacing, eyeY, eyeSize * 0.7, eyeSize * 0.85, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Gold sparkle in eye
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 6;
                    ctx.beginPath();
                    ctx.arc(x + eyeSpacing + eyeSize * 0.15, eyeY - eyeSize * 0.2, eyeSize * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Cheeky smirk
                    ctx.strokeStyle = '#0a3d0a';
                    ctx.lineWidth = s * 0.1;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(x + s * 0.05, mouthY, s * 0.18, 0.3, Math.PI - 0.1);
                    ctx.stroke();
                } else {
                    // Normal: Classic cute ghost face (like favicon)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.ellipse(x - eyeSpacing, eyeY, eyeSize * 0.7, eyeSize * 0.85, 0, 0, Math.PI * 2);
                    ctx.ellipse(x + eyeSpacing, eyeY, eyeSize * 0.7, eyeSize * 0.85, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Small "o" mouth (surprised/cute)
                    ctx.beginPath();
                    ctx.ellipse(x, mouthY, s * 0.12, s * 0.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Highlight shine on ghost head
                ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
                ctx.beginPath();
                ctx.ellipse(x - s * 0.35, ghostY - s * 0.55, s * 0.25, s * 0.2, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const barWidth = isMegaboss ? s * 2.5 : s * 2;
                    const barHeight = isMegaboss ? 6 : 4;
                    const healthPct = enemy.health / enemy.maxHealth;
                    
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(x - barWidth / 2, ghostY - s * 1.4 - (isMegaboss ? 8 : 4), barWidth, barHeight);
                    
                    if (isMegaboss) {
                        ctx.fillStyle = healthPct > 0.5 ? '#ff00ff' : healthPct > 0.25 ? '#ff6600' : '#ff0000';
                    } else {
                        ctx.fillStyle = healthPct > 0.5 ? '#00ff88' : healthPct > 0.25 ? '#ffcc00' : '#ff3366';
                    }
                    ctx.fillRect(x - barWidth / 2, ghostY - s * 1.4 - (isMegaboss ? 8 : 4), barWidth * healthPct, barHeight);
                }
                
                ctx.shadowBlur = 0;
            }
        }

        function drawProjectiles() {
            ctx.globalAlpha = 1; // Ensure visibility
            for (const proj of projectiles) {
                // Special boulder projectile drawing
                if (proj.isBoulder) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(proj.rotation || 0);
                    
                    // Smoke trail
                    if (proj.trail && proj.trail.length > 1) {
                        for (let i = 1; i < proj.trail.length; i++) {
                            const alpha = (i / proj.trail.length) * 0.4;
                            const size = 4 + (i / proj.trail.length) * 6;
                            ctx.globalAlpha = alpha;
                            ctx.fillStyle = '#555';
                            ctx.beginPath();
                            ctx.arc(proj.trail[i].x - proj.x, proj.trail[i].y - proj.y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                    
                    // Boulder body (rocky brown)
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#5a3d2b';
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rocky texture (darker patches)
                    ctx.fillStyle = '#3d2817';
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.arc(-3, -2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(4, 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glowing lava cracks
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.moveTo(-6, -4);
                    ctx.lineTo(0, 2);
                    ctx.lineTo(5, -1);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-2, 5);
                    ctx.lineTo(3, 0);
                    ctx.stroke();
                    
                    // Hot glowing core visible through cracks
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(0, 1, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    continue;
                }
                
                // Draw trail
                if (proj.trail && proj.trail.length > 1) {
                    ctx.lineCap = 'round';
                    for (let i = 1; i < proj.trail.length; i++) {
                        const alpha = i / proj.trail.length * 0.6;
                        const width = (i / proj.trail.length) * 4;
                        ctx.strokeStyle = proj.color;
                        ctx.globalAlpha = alpha;
                        ctx.lineWidth = width;
                        ctx.beginPath();
                        ctx.moveTo(proj.trail[i-1].x, proj.trail[i-1].y);
                        ctx.lineTo(proj.trail[i].x, proj.trail[i].y);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Outer glow
                ctx.shadowColor = proj.color;
                ctx.shadowBlur = 12;
                ctx.fillStyle = proj.color;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Main projectile
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Bright center
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        }

        function drawParticles() {
            for (const p of particles) {
                ctx.globalAlpha = p.alpha;
                if (p.isText) {
                    ctx.font = `bold ${p.size}px Arial`;
                    ctx.fillStyle = p.color;
                    ctx.textAlign = 'center';
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 8;
                    ctx.fillText(p.text, p.x, p.y);
                    ctx.shadowBlur = 0;
                } else if (p.type === 'spark') {
                    // Bright spark with glow
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 6;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Regular particle with subtle glow
                    ctx.fillStyle = p.color;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawPlacementPreview() {
            // Use pending placement for mobile preview, otherwise use mouse position
            let previewX, previewY, towerType;
            
            if (movingTower) {
                // For moving tower, show preview at mouse position
                if (mouseX < 0 || mouseY < 0) {
                    // If no mouse position, show at original tower position
                    previewX = movingTower.x;
                    previewY = movingTower.y;
                } else {
                    const snapped = snapToGrid(mouseX, mouseY);
                    previewX = snapped.x;
                    previewY = snapped.y;
                }
                towerType = movingTower.type;
            } else if (showingPlacementPreview && pendingPlacement) {
                previewX = pendingPlacement.x;
                previewY = pendingPlacement.y;
                towerType = pendingPlacement.type;
            } else {
                if (mouseX < 0 || mouseY < 0) return;
                previewX = mouseX;
                previewY = mouseY;
                towerType = selectedTower;
            }
            
            // Snap preview to grid
            const snapped = snapToGrid(previewX, previewY);
            previewX = snapped.x;
            previewY = snapped.y;
            
            if (!towerType) return;
            
            // Check if it's a champion or tower
            const isChamp = !!CHAMPIONS[towerType];
            const def = isChamp ? CHAMPIONS[towerType] : TOWERS[towerType];
            const range = def.range * (1 + permUpgrades.rangeBonus);
            
            // For move mode, temporarily remove tower from check
            let valid;
            if (movingTower) {
                const oldX = movingTower.x;
                const oldY = movingTower.y;
                movingTower.x = -1000;
                movingTower.y = -1000;
                valid = isValidPlacement(previewX, previewY);
                movingTower.x = oldX;
                movingTower.y = oldY;
            } else {
                valid = isValidPlacement(previewX, previewY);
            }
            
            const now = performance.now();
            
            // Pulsing effect for preview
            const isMoving = !!movingTower;
            const pulse = (showingPlacementPreview || isMoving) ? 0.5 + Math.sin(now / 200) * 0.3 : 1;
            
            // Range circle - magenta for move mode
            const rangeColor = isMoving ? (valid ? 'rgba(255, 0, 255, ' : 'rgba(255, 51, 102, ') : (valid ? 'rgba(0, 255, 136, ' : 'rgba(255, 51, 102, ');
            ctx.fillStyle = rangeColor + `${0.15 * pulse})`;
            ctx.strokeStyle = rangeColor + `${0.6 * pulse})`;
            ctx.lineWidth = (showingPlacementPreview || isMoving) ? 2 : 1;
            ctx.beginPath();
            ctx.arc(previewX, previewY, range, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Tower base preview
            ctx.globalAlpha = (showingPlacementPreview || isMoving) ? 0.5 * pulse : 0.6;
            const color = valid ? (isMoving ? '#f0f' : def.color) : '#ff3366';
            ctx.fillStyle = '#1a1a1a';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(previewX, previewY, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw tower-specific preview icon
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            
            switch(towerType) {
                case 'basic': // Gun barrel pointing up
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(previewX, previewY);
                    ctx.lineTo(previewX, previewY - 10);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'sniper': // Simple bullseye
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'freeze': // Snowflake
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI / 3);
                        ctx.beginPath();
                        ctx.moveTo(previewX, previewY);
                        ctx.lineTo(previewX + Math.cos(angle) * 8, previewY + Math.sin(angle) * 8);
                        ctx.stroke();
                    }
                    break;
                    
                case 'splash': // Starburst
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI / 4);
                        const len = i % 2 === 0 ? 9 : 6;
                        ctx.beginPath();
                        ctx.moveTo(previewX, previewY);
                        ctx.lineTo(previewX + Math.cos(angle) * len, previewY + Math.sin(angle) * len);
                        ctx.stroke();
                    }
                    break;
                    
                case 'laser': // Dish (rotated 90 clockwise)
                    ctx.save();
                    ctx.translate(previewX, previewY);
                    ctx.rotate(Math.PI / 2);
                    ctx.translate(-previewX, -previewY);
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(previewX - 3, previewY, 8, -Math.PI * 0.4, Math.PI * 0.4);
                    ctx.stroke();
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(previewX - 3, previewY);
                    ctx.lineTo(previewX + 8, previewY);
                    ctx.stroke();
                    ctx.restore();
                    break;
                    
                case 'minigun': // Multi-barrel
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI / 2);
                        ctx.beginPath();
                        ctx.moveTo(previewX + Math.cos(angle) * 3, previewY + Math.sin(angle) * 3);
                        ctx.lineTo(previewX + Math.cos(angle) * 10, previewY + Math.sin(angle) * 10);
                        ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'cannon': // Big barrel pointing up
                    ctx.lineWidth = 7;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(previewX, previewY);
                    ctx.lineTo(previewX, previewY - 12);
                    ctx.stroke();
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(previewX, previewY - 12, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'poison': // Skull
                    ctx.beginPath();
                    ctx.arc(previewX, previewY - 1, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(previewX - 2.5, previewY - 2, 2, 0, Math.PI * 2);
                    ctx.arc(previewX + 2.5, previewY - 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = color;
                    ctx.fillRect(previewX - 4, previewY + 3, 8, 3);
                    break;
                    
                case 'chain': // Chain links
                    ctx.fillStyle = 'transparent';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i * Math.PI * 2 / 3);
                        const lx = previewX + Math.cos(angle) * 5;
                        const ly = previewY + Math.sin(angle) * 5;
                        ctx.beginPath();
                        ctx.ellipse(lx, ly, 4, 2.5, angle, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case 'tesla': // Lightning bolt
                    ctx.strokeStyle = '#00ffff';
                    ctx.fillStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(previewX - 2, previewY - 8);
                    ctx.lineTo(previewX + 2, previewY - 2);
                    ctx.lineTo(previewX - 1, previewY - 2);
                    ctx.lineTo(previewX + 3, previewY + 8);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case 'inferno': // Volcano with smoke
                    // Volcano cone
                    ctx.fillStyle = '#4a2800';
                    ctx.beginPath();
                    ctx.moveTo(previewX - 8, previewY + 6);
                    ctx.lineTo(previewX - 3, previewY - 5);
                    ctx.lineTo(previewX + 3, previewY - 5);
                    ctx.lineTo(previewX + 8, previewY + 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lava glow
                    ctx.fillStyle = '#ff4400';
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.ellipse(previewX, previewY - 4, 3, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Hot core
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.ellipse(previewX, previewY - 4, 1.5, 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Smoke puffs
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';
                    ctx.beginPath();
                    ctx.arc(previewX - 1, previewY - 9, 2, 0, Math.PI * 2);
                    ctx.arc(previewX + 2, previewY - 12, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'buff': // Star
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const outerAngle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                        const innerAngle = outerAngle + Math.PI / 5;
                        if (i === 0) {
                            ctx.moveTo(previewX + Math.cos(outerAngle) * 9, previewY + Math.sin(outerAngle) * 9);
                        } else {
                            ctx.lineTo(previewX + Math.cos(outerAngle) * 9, previewY + Math.sin(outerAngle) * 9);
                        }
                        ctx.lineTo(previewX + Math.cos(innerAngle) * 4, previewY + Math.sin(innerAngle) * 4);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                
                case 'striker': // Black Squirrel icon
                    ctx.fillStyle = '#2a2a2a';
                    ctx.strokeStyle = '#4a4a4a';
                    ctx.lineWidth = 1.5;
                    // Body
                    ctx.beginPath();
                    ctx.ellipse(previewX, previewY + 2, 6, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Head
                    ctx.beginPath();
                    ctx.arc(previewX + 4, previewY - 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Tail (fluffy)
                    ctx.beginPath();
                    ctx.moveTo(previewX - 4, previewY);
                    ctx.quadraticCurveTo(previewX - 10, previewY - 8, previewX - 6, previewY - 12);
                    ctx.quadraticCurveTo(previewX - 2, previewY - 8, previewX - 4, previewY);
                    ctx.fill();
                    // Eye (green)
                    ctx.fillStyle = '#88ff88';
                    ctx.beginPath();
                    ctx.arc(previewX + 6, previewY - 3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case 'caster': // Joust Panther icon
                    ctx.fillStyle = '#1a0a2a';
                    ctx.strokeStyle = '#aa00ff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#aa00ff';
                    ctx.shadowBlur = 8;
                    // Body (long oval)
                    ctx.beginPath();
                    ctx.ellipse(previewX, previewY + 2, 10, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Head (round)
                    ctx.beginPath();
                    ctx.arc(previewX + 10, previewY - 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Ears
                    ctx.beginPath();
                    ctx.moveTo(previewX + 7, previewY - 5);
                    ctx.lineTo(previewX + 6, previewY - 10);
                    ctx.lineTo(previewX + 9, previewY - 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(previewX + 11, previewY - 6);
                    ctx.lineTo(previewX + 12, previewY - 11);
                    ctx.lineTo(previewX + 14, previewY - 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // Tail
                    ctx.beginPath();
                    ctx.moveTo(previewX - 8, previewY + 2);
                    ctx.bezierCurveTo(previewX - 14, previewY, previewX - 16, previewY - 8, previewX - 14, previewY - 12);
                    ctx.stroke();
                    // Eyes (magenta glow)
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(previewX + 9, previewY - 3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(previewX + 13, previewY - 2, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;
                    
                default:
                    ctx.beginPath();
                    ctx.arc(previewX, previewY, 6, 0, Math.PI * 2);
                    ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }

        // ========== PARTICLES ==========
        function createParticles(x, y, color, count) {
            // Limit total particles
            const toAdd = Math.min(count, MAX_PARTICLES - particles.length);
            
            for (let i = 0; i < toAdd; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const life = 400 + Math.random() * 400;
                const type = Math.random() > 0.7 ? 'spark' : 'normal';
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: type === 'spark' ? 1 + Math.random() * 2 : 2 + Math.random() * 4,
                    color: color,
                    life: life,
                    maxLife: life,
                    alpha: 1,
                    type: type
                });
            }
        }
        
        // Splash ring effects array
        let splashRings = [];
        
        // Railgun/piercing line effects
        let railgunLines = [];
        
        // Inferno (fire zone) effects
        let infernoZones = [];
        
        function createRailgunLine(x1, y1, dx, dy, color) {
            // Extend line to edge of screen
            const speed = Math.sqrt(dx * dx + dy * dy);
            const normX = dx / speed;
            const normY = dy / speed;
            
            // Calculate endpoint at screen edge
            let endX, endY;
            const maxDist = 1000; // Max distance to travel
            endX = x1 + normX * maxDist;
            endY = y1 + normY * maxDist;
            
            railgunLines.push({
                x1: x1,
                y1: y1,
                x2: endX,
                y2: endY,
                color: color,
                alpha: 1,
                life: 400, // Duration in ms
                maxLife: 400
            });
        }
        
        function updateRailgunLines(dt) {
            for (let i = railgunLines.length - 1; i >= 0; i--) {
                const line = railgunLines[i];
                line.life -= dt * 1000;
                line.alpha = line.life / line.maxLife;
                if (line.life <= 0) {
                    railgunLines.splice(i, 1);
                }
            }
        }
        
        function drawRailgunLines() {
            for (const line of railgunLines) {
                // Outer glow
                ctx.strokeStyle = line.color;
                ctx.lineWidth = 12 * line.alpha;
                ctx.globalAlpha = line.alpha * 0.3;
                ctx.shadowColor = line.color;
                ctx.shadowBlur = 25;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
                
                // Middle glow
                ctx.lineWidth = 6 * line.alpha;
                ctx.globalAlpha = line.alpha * 0.5;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
                
                // Core beam (bright)
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = line.alpha * 0.9;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            ctx.lineCap = 'butt';
        }
        
        function createSplashRing(x, y, color, maxRadius) {
            splashRings.push({
                x: x,
                y: y,
                color: color,
                radius: 5,
                maxRadius: maxRadius,
                alpha: 1
            });
        }
        
        function updateSplashRings(dt) {
            for (let i = splashRings.length - 1; i >= 0; i--) {
                const ring = splashRings[i];
                ring.radius += dt * 150;
                ring.alpha = 1 - (ring.radius / ring.maxRadius);
                if (ring.radius >= ring.maxRadius) {
                    splashRings.splice(i, 1);
                }
            }
        }
        
        function drawSplashRings() {
            for (const ring of splashRings) {
                ctx.strokeStyle = ring.color;
                ctx.lineWidth = 3;
                ctx.globalAlpha = ring.alpha * 0.7;
                ctx.shadowColor = ring.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner ring
                ctx.lineWidth = 1;
                ctx.globalAlpha = ring.alpha * 0.4;
                ctx.beginPath();
                ctx.arc(ring.x, ring.y, ring.radius * 0.6, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function updateInfernoZones(dt) {
            const now = performance.now();
            
            for (let i = infernoZones.length - 1; i >= 0; i--) {
                const zone = infernoZones[i];
                
                // Check if zone has expired
                if (now - zone.startTime >= zone.duration) {
                    infernoZones.splice(i, 1);
                    continue;
                }
                
                // Damage enemies in zone every 200ms
                if (now - zone.lastDamageTick >= 200) {
                    zone.lastDamageTick = now;
                    
                    for (const enemy of enemies) {
                        if (!enemy.alive) continue;
                        const dx = enemy.x - zone.x;
                        const dy = enemy.y - zone.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist <= zone.radius) {
                            const isCrit = Math.random() < permUpgrades.critChance;
                            damageEnemy(enemy, isCrit ? zone.damage * 2 : zone.damage, isCrit);
                            
                            // Fire particles
                            if (Math.random() < 0.3) {
                                createParticles(enemy.x, enemy.y, '#ff6600', 2);
                            }
                        }
                    }
                }
            }
        }
        
        function drawInfernoZones() {
            const now = performance.now();
            
            for (const zone of infernoZones) {
                const elapsed = now - zone.startTime;
                const remaining = zone.duration - elapsed;
                const fadeAlpha = Math.min(1, remaining / 500); // Fade out in last 500ms
                const pulseAlpha = 0.5 + Math.sin(now / 150) * 0.2;
                const safeRadius = Math.max(1, zone.radius); // Ensure positive radius
                
                ctx.save();
                
                // Outer lava glow ring
                ctx.strokeStyle = `rgba(255, 60, 0, ${0.6 * fadeAlpha})`;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#ff4400';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, safeRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Base lava pool gradient
                const gradient = ctx.createRadialGradient(
                    zone.x, zone.y, 0,
                    zone.x, zone.y, safeRadius
                );
                gradient.addColorStop(0, `rgba(255, 200, 50, ${0.7 * fadeAlpha * pulseAlpha})`);
                gradient.addColorStop(0.3, `rgba(255, 100, 0, ${0.6 * fadeAlpha * pulseAlpha})`);
                gradient.addColorStop(0.6, `rgba(200, 50, 0, ${0.5 * fadeAlpha * pulseAlpha})`);
                gradient.addColorStop(0.85, `rgba(100, 20, 0, ${0.4 * fadeAlpha * pulseAlpha})`);
                gradient.addColorStop(1, 'rgba(50, 10, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, safeRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Bubbling lava blobs
                ctx.globalAlpha = fadeAlpha;
                for (let b = 0; b < 8; b++) {
                    const bubblePhase = (now / 300 + b * 0.8) % 3;
                    const bubbleAngle = (b / 8) * Math.PI * 2 + Math.sin(now / 500 + b) * 0.3;
                    const bubbleDist = safeRadius * (0.2 + bubblePhase * 0.2);
                    const bx = zone.x + Math.cos(bubbleAngle) * bubbleDist;
                    const by = zone.y + Math.sin(bubbleAngle) * bubbleDist;
                    const bsize = Math.max(1, 3 + Math.sin(bubblePhase * Math.PI) * 4);
                    const bAlpha = Math.max(0, Math.sin(bubblePhase * Math.PI) * 0.8);
                    
                    // Bubble glow
                    const bubbleGrad = ctx.createRadialGradient(bx, by, 0, bx, by, bsize);
                    bubbleGrad.addColorStop(0, `rgba(255, 220, 100, ${bAlpha})`);
                    bubbleGrad.addColorStop(0.5, `rgba(255, 150, 50, ${bAlpha * 0.7})`);
                    bubbleGrad.addColorStop(1, `rgba(255, 80, 0, 0)`);
                    
                    ctx.fillStyle = bubbleGrad;
                    ctx.beginPath();
                    ctx.arc(bx, by, bsize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Rising heat/ember particles
                for (let e = 0; e < 5; e++) {
                    const emberTime = (now / 600 + e * 1.2) % 2;
                    const emberAngle = (e / 5) * Math.PI * 2 + now / 1000;
                    const emberDist = safeRadius * 0.4 * (1 - emberTime * 0.3);
                    const ex = zone.x + Math.cos(emberAngle) * emberDist;
                    const ey = zone.y + Math.sin(emberAngle) * emberDist - emberTime * 15;
                    const esize = 2 - emberTime * 0.8;
                    const eAlpha = (1 - emberTime * 0.5) * 0.9;
                    
                    ctx.fillStyle = `rgba(255, ${180 + emberTime * 50}, 50, ${eAlpha})`;
                    ctx.beginPath();
                    ctx.arc(ex, ey, Math.max(0.5, esize), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Cracking dark lines (cooled lava crust)
                ctx.strokeStyle = `rgba(40, 10, 0, ${0.4 * fadeAlpha})`;
                ctx.lineWidth = 1;
                for (let c = 0; c < 4; c++) {
                    const crackAngle = (c / 4) * Math.PI * 2 + 0.3;
                    const crackLen = safeRadius * (0.4 + Math.sin(now / 800 + c) * 0.15);
                    ctx.beginPath();
                    ctx.moveTo(zone.x, zone.y);
                    ctx.lineTo(
                        zone.x + Math.cos(crackAngle) * crackLen,
                        zone.y + Math.sin(crackAngle) * crackLen
                    );
                    ctx.stroke();
                }
                
                // Center hotspot (brightest)
                const coreGrad = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, 12);
                coreGrad.addColorStop(0, `rgba(255, 255, 200, ${0.9 * fadeAlpha})`);
                coreGrad.addColorStop(0.4, `rgba(255, 200, 50, ${0.6 * fadeAlpha})`);
                coreGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        function createDamageNumber(x, y, damage, isCrit) {
            if (particles.length >= MAX_PARTICLES) return;
            
            const life = 600;
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 1.5,
                vy: -1.5,
                size: isCrit ? 14 : 10,
                color: isCrit ? '#ffcc00' : '#fff',
                life: life,
                maxLife: life,
                alpha: 1,
                text: Math.floor(damage).toString(),
                isText: true
            });
        }

        // ========== UTILITIES ==========
        function updateHUD() {
            livesDisplay.textContent = lives;
            goldDisplay.textContent = gold;
            waveDisplay.textContent = wave || 1;
            killsDisplay.textContent = kills;
        }

        function updateTowerButtons() {
            towerBar.querySelectorAll('.tower-btn').forEach(btn => {
                const type = btn.dataset.tower;
                const unlocked = isTowerUnlocked(type);
                const isChamp = !!CHAMPIONS[type];
                
                // Handle champions differently
                if (isChamp) {
                    const placed = isChampionPlaced(type);
                    
                    if (!unlocked) {
                        btn.classList.add('locked');
                        btn.classList.remove('placed', 'disabled');
                        btn.querySelector('.tower-cost').textContent = 'Wave ' + CHAMPIONS[type].unlockWave;
                    } else if (placed) {
                        btn.classList.remove('locked', 'disabled');
                        btn.classList.add('placed');
                        btn.querySelector('.tower-cost').textContent = 'PLACED';
                    } else {
                        btn.classList.remove('locked', 'placed', 'disabled');
                        btn.querySelector('.tower-cost').textContent = 'FREE';
                    }
                    
                    // Hide count for champions
                    let countEl = btn.querySelector('.tower-count');
                    if (countEl) countEl.style.display = 'none';
                    return;
                }
                
                const cost = getTowerCost(type);
                const count = towerCounts[type] || 0;
                const limit = getTowerLimit(type);
                const atLimit = count >= limit;
                
                // Handle locked towers (Campaign mode only)
                if (!unlocked) {
                    btn.classList.add('locked');
                    btn.classList.remove('disabled', 'at-limit');
                    btn.querySelector('.tower-cost').textContent = 'Wave ' + TOWER_UNLOCKS[type];
                    
                    // Hide count for locked towers
                    let countEl = btn.querySelector('.tower-count');
                    if (countEl) {
                        countEl.style.display = 'none';
                    }
                    return;
                }
                
                // Tower is unlocked
                btn.classList.remove('locked');
                
                // Update cost display
                btn.querySelector('.tower-cost').textContent = atLimit ? 'MAX' : '$' + cost;
                
                // Add/update count display
                let countEl = btn.querySelector('.tower-count');
                if (!countEl) {
                    countEl = document.createElement('div');
                    countEl.className = 'tower-count';
                    btn.appendChild(countEl);
                }
                countEl.style.display = '';
                countEl.textContent = count + '/' + limit;
                
                // Disable if can't afford or at limit
                if (gold < cost || atLimit) {
                    btn.classList.add('disabled');
                } else {
                    btn.classList.remove('disabled');
                }
                
                // Add at-limit styling
                if (atLimit) {
                    btn.classList.add('at-limit');
                } else {
                    btn.classList.remove('at-limit');
                }
            });
        }

        // Initialize
        init();
    </script>
    <!-- First placement arrow (outside game container to avoid clipping) -->
    <div class="first-placement-arrow" id="firstPlacementArrow" style="display:none;"></div>
</body>
</html>

