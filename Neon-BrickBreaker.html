<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=overlays-content">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Brickbreaker</title>
    <script>window.onerror=function(){return true};window.onunhandledrejection=function(e){if(e&&e.preventDefault)e.preventDefault();return true};</script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overscroll-behavior: none; /* Prevent overscroll/bounce */
            -webkit-overflow-scrolling: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100%;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none; /* Prevent overscroll/bounce */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 6px;
            /* Size to fit content */
            width: fit-content;
            height: fit-content;
            max-width: 100%;
            max-height: 100%;
            transform: translateZ(0);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
            overflow: visible;
            /* Add border to outer container instead of canvas */
            border: 3px solid #0ff;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            border-radius: 8px;
            background: #0a0a0a;
        }
        
        /* Button container - overlays the game container, centered on entire area */
        .button-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 400;
            pointer-events: auto;
            /* Semi-transparent backdrop for visibility */
            background: rgba(0, 0, 0, 0.75);
            padding: 20px 30px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }
        
        #leaderboardBtn {
            /* No extra margin needed - gap handles spacing */
        }

        #gameCanvas {
            border-radius: 3px;
            max-width: 100%;
            height: auto;
            touch-action: none;
            /* GPU acceleration */
            transform: translateZ(0);
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* Mobile optimizations */
        @media (max-width: 800px), (hover: none) {
            #gameCanvas {
                /* Keep canvas clean on mobile */
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                transition-duration: 0.01ms !important;
            }
        }

        /* ========== UNIFIED TRACKPAD ZONE ========== */
        /* Contains: permanent upgrades + power-up timers + spacer + instructions */
        .trackpad-zone {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            height: 300px;
            min-height: 300px;
            padding: 8px 12px;
            box-sizing: border-box;
            flex-shrink: 0;
            /* Touch control */
            touch-action: none;
            pointer-events: auto;
            /* Visual styling */
            border-top: 1px solid rgba(0, 255, 255, 0.15);
            background: linear-gradient(to bottom, rgba(0, 255, 255, 0.06), transparent);
            border-radius: 0 0 5px 5px;
        }
        
        /* Permanent upgrades display - centered between divider lines */
        .permanent-upgrades {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 6px;
            height: 24px;
            min-height: 24px;
            width: 100%;
            pointer-events: none;
            flex-shrink: 0;
        }
        
        /* Always show divider lines even when empty */
        .permanent-upgrades-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            margin-bottom: 6px;
            flex-shrink: 0;
        }
        
        .perm-upgrade {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 22px;
            height: 22px;
        }
        
        .perm-icon {
            font-size: 14px;
            filter: drop-shadow(0 0 3px currentColor);
        }
        
        .perm-stack {
            position: absolute;
            bottom: -2px;
            right: -4px;
            font-size: 9px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 3px #000, 0 0 3px #000;
        }
        
        /* Power-up timers container - fixed 4 rows */
        .power-up-timers {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            /* Fixed height for exactly 4 rows: 4 x 17px = 68px */
            height: 68px;
            min-height: 68px;
            max-height: 68px;
            width: 100%;
            overflow: hidden;
            pointer-events: none;
            flex-shrink: 0;
        }
        
        .power-up-timers span {
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            /* Each row exactly 17px */
            height: 17px;
            min-height: 17px;
            max-height: 17px;
            line-height: 17px;
            font-size: 13px;
            padding: 0 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            box-sizing: border-box;
            pointer-events: none;
            flex-shrink: 0;
        }
        
        /* Spacer - grows to fill remaining space */
        .trackpad-spacer {
            flex: 1;
            min-height: 40px;
            width: 100%;
            pointer-events: none;
        }
        
        /* Instructions at bottom of trackpad */
        .trackpad-instructions {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 24px;
            min-height: 24px;
            width: 100%;
            font-size: 11px;
            color: rgba(0, 255, 255, 0.7);
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            pointer-events: none;
            flex-shrink: 0;
        }
        
        .hud {
            display: flex;
            gap: 25px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px #0ff;
        }

        .hud span {
            color: #0ff;
        }

        #startBtn {
            padding: 8px 16px;
            font-size: 12px;
            background: transparent;
            color: #f0f;
            border: 2px solid #f0f;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #f0f;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            width: 185px;
            box-sizing: border-box;
            white-space: nowrap;
            text-align: center;
        }

        #startBtn:hover, #startBtn:active {
            background: #f0f;
            color: #000;
            box-shadow: 0 0 12px #f0f;
        }
        
        /* Mobile button sizing */
        @media (max-width: 800px), (hover: none) {
            #startBtn {
                padding: 12px 20px;
                font-size: 13px;
                min-height: 42px;
                width: 200px;
            }
            .button-container {
                /* Keep absolute positioning, just adjust z-index */
                z-index: 400;
            }
        }

        .message {
            color: #fff;
            font-size: 11px;
            text-shadow: 0 0 5px #0ff;
            opacity: 0.7;
            text-align: center;
            padding: 2px 10px;
            margin: 0;
            position: relative;
            z-index: 100; /* Above touch zone */
            pointer-events: none; /* Allow touches through */
        }
        
        @media (max-width: 800px), (hover: none) {
            /* Ensure button container has higher z-index and pointer-events */
            .button-container {
                z-index: 400 !important;
                pointer-events: auto !important;
            }
            #startBtn, #leaderboardBtn {
                pointer-events: auto !important;
                position: relative !important;
                z-index: 401 !important;
            }
            #gameCanvas {
                position: relative;
                z-index: 45;
            }
        }
        
        /* Mobile layout adjustments - only essential overrides */
        @media (max-width: 800px), (hover: none), (pointer: coarse) {
            .hud {
                gap: 20px;
                font-size: 14px;
            }
            .game-container {
                padding: 4px;
                gap: 3px;
                box-shadow: 0 0 10px #0ff;
            }
            .button-container {
                gap: 20px;
            }
            .menu-buttons {
                gap: 12px;
            }
        }
        
        /* JS-based mobile detection - only essential overrides */
        body.is-mobile .hud {
            gap: 20px;
            font-size: 14px;
        }
        
        /* Mobile: smaller trackpad zone */
        body.is-mobile .trackpad-zone {
            height: 240px;
            min-height: 240px;
            padding: 6px 10px;
        }
        body.is-mobile .trackpad-spacer {
            min-height: 30px;
        }
        body.is-mobile .trackpad-instructions {
            height: 20px;
            min-height: 20px;
            font-size: 10px;
        }
        
        /* Mobile: 3 powerup timer rows, smaller text */
        body.is-mobile .power-up-timers {
            /* 3 rows x 15px = 45px */
            height: 45px;
            min-height: 45px;
            max-height: 45px;
        }
        body.is-mobile .power-up-timers span {
            font-size: 12px;
            height: 15px;
            min-height: 15px;
            max-height: 15px;
            line-height: 15px;
            padding: 0 6px;
        }
        
        /* Desktop: larger HUD and powerup text */
        body.is-desktop .hud {
            font-size: 20px;
            gap: 30px;
        }
        body.is-desktop .power-up-timers span {
            font-size: 17px;
            height: 21px;
            min-height: 21px;
            max-height: 21px;
            line-height: 21px;
        }
        body.is-desktop .power-up-timers {
            /* 4 rows x 21px = 84px */
            height: 84px;
            min-height: 84px;
            max-height: 84px;
        }
        
        /* ========== UPGRADE SELECTOR OVERLAY ========== */
        .upgrade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500; /* Above all other elements */
            font-family: Arial, sans-serif;
            /* Allow touch interactions */
            touch-action: manipulation;
            pointer-events: none; /* Don't block touches when hidden */
        }
        
        .upgrade-overlay.active {
            display: flex;
            pointer-events: auto; /* Enable touches when visible */
        }
        
        .upgrade-title {
            font-size: 26px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
            margin-bottom: 6px;
            animation: titlePulse 1.5s ease-in-out infinite;
        }
        
        .upgrade-subtitle {
            font-size: 13px;
            color: #888;
            margin-bottom: 15px;
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff; }
            50% { text-shadow: 0 0 30px #0ff, 0 0 60px #0ff, 0 0 80px #f0f; }
        }
        
        .upgrade-slots {
            display: flex;
            gap: 12px;
            perspective: 1000px;
        }
        
        .upgrade-slot {
            width: 120px;
            height: 155px;
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 2px solid #333;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.3);
            /* Mobile touch improvements */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .upgrade-slot::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent 40%, rgba(255,255,255,0.03) 50%, transparent 60%);
            animation: slotShine 3s linear infinite;
            animation-play-state: paused; /* Paused by default */
        }
        
        /* Only animate when overlay is active */
        .upgrade-overlay.active .upgrade-slot::before {
            animation-play-state: running;
        }
        
        @keyframes slotShine {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }
        
        .upgrade-slot.rolling {
            pointer-events: none;
        }
        
        .upgrade-slot.rolling .upgrade-content {
            animation: slotRoll 0.1s linear infinite;
        }
        
        @keyframes slotRoll {
            0% { transform: translateY(-100%); opacity: 0; }
            50% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(100%); opacity: 0; }
        }
        
        .upgrade-slot.revealed {
            border-color: #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            cursor: pointer;
        }
        
        .upgrade-slot.revealed:hover {
            transform: translateY(-8px) scale(1.05);
            border-color: #f0f;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.6), 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        
        /* Touch/active state for mobile */
        .upgrade-slot.revealed:active {
            transform: scale(0.95);
            border-color: #0f0;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
        }
        
        .upgrade-slot.selected {
            border-color: #0f0;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.8);
            transform: scale(1.08);
        }
        
        .upgrade-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 10px;
            z-index: 1;
        }
        
        .upgrade-icon {
            font-size: 34px;
            margin-bottom: 8px;
            filter: drop-shadow(0 0 8px currentColor);
        }
        
        .upgrade-name {
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 6px;
            line-height: 1.2;
        }
        
        .upgrade-desc {
            font-size: 11px;
            color: #0ff;
            opacity: 0.9;
        }
        
        .upgrade-slot[data-type="paddle"] .upgrade-icon { color: #0ff; }
        .upgrade-slot[data-type="speed"] .upgrade-icon { color: #00ff88; }
        .upgrade-slot[data-type="crusher"] .upgrade-icon { color: #ff6600; }
        .upgrade-slot[data-type="bigpaddle"] .upgrade-icon { color: #f0f; }
        .upgrade-slot[data-type="powerup"] .upgrade-icon { color: #ffcc00; }
        
        @media (max-width: 500px) {
            .upgrade-slots { gap: 8px; }
            .upgrade-slot { width: 90px; height: 125px; border-width: 2px; }
            .upgrade-content { padding: 8px; }
            .upgrade-icon { font-size: 25px; margin-bottom: 6px; }
            .upgrade-name { font-size: 10px; margin-bottom: 4px; }
            .upgrade-desc { font-size: 9px; }
            .upgrade-title { font-size: 19px; margin-bottom: 4px; }
            .upgrade-subtitle { font-size: 10px; margin-bottom: 10px; }
        }
        
        /* ========== SCORE SUBMISSION MODAL ========== */
        .score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-title {
            font-size: 38px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00, 0 0 40px #ff6600;
            text-align: center;
            margin-bottom: 0;
        }
        
        .score-modal-score {
            font-size: 26px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            text-align: center;
            margin-top: -4px;
        }
        
        .score-modal-level {
            font-size: 16px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-top: -8px;
        }
        
        .score-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        
        .score-input-label {
            font-size: 14px;
            color: #fff;
            opacity: 0.9;
        }
        
        .score-input {
            width: 200px;
            padding: 10px 14px;
            font-size: 16px;
            font-family: inherit;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            /* Allow text selection and input on mobile */
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }
        
        .score-input:focus {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-input.error {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.15);
            animation: inputShake 0.4s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }
        
        .score-error-msg {
            font-size: 12px;
            color: #ff3366;
            text-shadow: 0 0 8px #ff3366;
            min-height: 16px;
            text-align: center;
        }
        
        .score-buttons {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }
        
        .score-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .score-btn:active {
            transform: scale(0.98);
        }
        
        .score-btn-submit {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 255, 0.2));
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .score-btn-submit:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }
        
        .score-btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .score-btn-skip {
            background: rgba(255, 255, 255, 0.05);
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #aaa;
        }
        
        /* ========== LEADERBOARD OVERLAY ========== */
        .leaderboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            /* Allow touch interactions */
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .leaderboard-title {
            font-size: 32px;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00, 0 0 40px #ff6600;
        }
        
        .leaderboard-close {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Mobile touch improvements */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            z-index: 10;
        }
        
        .leaderboard-close:hover {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        .leaderboard-close:active {
            transform: scale(0.95);
            border-color: #0ff;
            color: #0ff;
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            touch-action: pan-y; /* Allow vertical scroll only */
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 10px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 4px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .leaderboard-row.top-3 {
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.15), rgba(255, 102, 0, 0.1));
            border: 1px solid rgba(255, 204, 0, 0.3);
        }
        
        .leaderboard-row.highlight {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.15));
            border: 1px solid rgba(0, 255, 255, 0.5);
        }
        
        .leaderboard-rank {
            width: 40px;
            font-size: 16px;
            font-weight: bold;
            color: #888;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            color: #ffcc00;
            text-shadow: 0 0 8px #ffcc00;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .leaderboard-score {
            font-size: 16px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            min-width: 70px;
            text-align: right;
        }
        
        .leaderboard-level {
            font-size: 12px;
            color: #00ff88;
            min-width: 50px;
            text-align: right;
            opacity: 0.8;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 16px;
        }
        
        .leaderboard-loading {
            color: #0ff;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
        
        /* Leaderboard button on main menu */
        #leaderboardBtn {
            padding: 8px 16px;
            font-size: 12px;
            background: transparent;
            border: 2px solid #ffcc00;
            border-radius: 5px;
            color: #ffcc00;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 8px #ffcc00;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            width: 185px;
            box-sizing: border-box;
            white-space: nowrap;
            text-align: center;
        }
        
        #leaderboardBtn:hover {
            background: #ffcc00;
            color: #000;
            box-shadow: 0 0 12px #ffcc00;
        }
        
        #leaderboardBtn:active {
            transform: scale(0.98);
        }
        
        /* Mobile leaderboard button sizing - match start button */
        @media (max-width: 800px), (hover: none) {
            #leaderboardBtn {
                padding: 12px 20px;
                font-size: 13px;
                min-height: 42px;
                width: 200px;
            }
        }
        
        @media (max-width: 500px) {
            .score-modal-title { font-size: 32px; }
            .score-modal-score { font-size: 22px; }
            .score-input { width: 180px; font-size: 16px; }
            .score-btn { padding: 10px 20px; font-size: 14px; }
            .leaderboard-title { font-size: 26px; }
            .leaderboard-row { padding: 8px 10px; }
            .leaderboard-name { font-size: 13px; }
            .leaderboard-score { font-size: 14px; min-width: 60px; }
            .leaderboard-level { font-size: 11px; min-width: 40px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
        </div>
        <canvas id="gameCanvas" width="640" height="492"></canvas>
        
        <!-- Unified trackpad zone: permanent upgrades + power-up timers + spacer + instructions -->
        <div class="trackpad-zone" id="trackpadZone">
            <div class="permanent-upgrades-wrapper">
                <div class="permanent-upgrades" id="permanentUpgradesBar"></div>
            </div>
            <div class="power-up-timers" id="powerUpBar"></div>
            <div class="trackpad-spacer">&nbsp;</div>
            <div class="trackpad-instructions">
                ‚Üê ARROW KEYS, MOUSE OR TOUCH TO MOVE ‚Üí
            </div>
        </div>
        
        <!-- Upgrade Selector Overlay -->
        <div class="upgrade-overlay" id="upgradeOverlay">
            <div class="upgrade-title">LEVEL UP!</div>
            <div class="upgrade-subtitle">Choose an upgrade</div>
            <div class="upgrade-slots" id="upgradeSlots">
                <div class="upgrade-slot" id="slot1">
                    <div class="upgrade-content">
                        <div class="upgrade-icon">?</div>
                        <div class="upgrade-name">???</div>
                        <div class="upgrade-desc">???</div>
                    </div>
                </div>
                <div class="upgrade-slot" id="slot2">
                    <div class="upgrade-content">
                        <div class="upgrade-icon">?</div>
                        <div class="upgrade-name">???</div>
                        <div class="upgrade-desc">???</div>
                    </div>
                </div>
                <div class="upgrade-slot" id="slot3">
                    <div class="upgrade-content">
                        <div class="upgrade-icon">?</div>
                        <div class="upgrade-name">???</div>
                        <div class="upgrade-desc">???</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="button-container" id="buttonContainer">
            <div class="menu-buttons">
                <button id="startBtn">üéÆ&nbsp;Start Game&nbsp;üéÆ</button>
            </div>
            <button id="leaderboardBtn">üèÜ Leaderboard üèÜ</button>
        </div>
    </div>
    
    <!-- Score Submission Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-title" id="scoreModalTitle">HIGH SCORE</div>
        <div class="score-modal-score">Score: <span id="finalScoreDisplay">0</span></div>
        <div class="score-modal-level">Level <span id="finalLevelDisplay">1</span></div>
        <div class="score-input-container">
            <label class="score-input-label">Enter your name for the leaderboard:</label>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME" autocomplete="off" spellcheck="false">
            <div class="score-error-msg" id="scoreErrorMsg"></div>
        </div>
        <div class="score-buttons">
            <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title">üèÜ TOP 100</div>
                <button class="leaderboard-close" id="leaderboardClose">‚úï</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <div class="leaderboard-loading">Loading scores...</div>
            </div>
        </div>
    </div>

    <script>
        // RELIABLE DEVICE DETECTION - Uses multiple signals for accuracy
        // Works correctly even inside iframes
        const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
        const hasHover = window.matchMedia('(hover: hover)').matches;
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isSmallScreen = screen.width < 800;
        const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Desktop: has hover capability AND no coarse pointer, OR large screen without mobile UA
        const isTrueDesktop = (hasHover && !hasCoarsePointer) || (!isSmallScreen && !isMobileUA && !hasTouchScreen);
        const isTrueMobile = !isTrueDesktop;
        
        (function() {
            if (isTrueDesktop) {
                document.body.classList.add('is-desktop');
            } else {
                document.body.classList.add('is-mobile');
            }
        })();
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimization: disable alpha for faster rendering
        const startBtn = document.getElementById('startBtn');
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const buttonContainer = document.getElementById('buttonContainer');
        const trackpadZone = document.getElementById('trackpadZone');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const powerUpBarEl = document.getElementById('powerUpBar'); // Cached DOM reference
        const permanentUpgradesBarEl = document.getElementById('permanentUpgradesBar'); // Cached DOM reference

        // Performance detection
        const isMobile = isTrueMobile; // Use unified detection
        const isLowPower = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : isMobile;
        const isVeryLowPower = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 2 : false;
        
        // Shadow blur values (tiered based on device capability)
        const shadowSettings = isVeryLowPower ? {
            // Very low power: no shadows at all
            paddle: 0,
            ball: 0,
            brick: 0,
            brickPowerUp: 0,
            brickPowerUpMax: 0,
            boss: 0
        } : isMobile ? {
            // Mobile: minimal shadows
            paddle: 0,
            ball: 0,
            brick: 0,
            brickPowerUp: 3,
            brickPowerUpMax: 6,
            boss: 10
        } : {
            // Desktop: reduced shadows
            paddle: 12,
            ball: 10,
            brick: 5,
            brickPowerUp: 8,
            brickPowerUpMax: 15,
            boss: 20
        };

        // Game state
        let gameRunning = false;
        let gameHasStarted = false; // Tracks if game has ever been started (hides paddle/ball until first start)
        let score = 0;
        let lives = 3;
        let level = 1;
        
        // Life loss pause state
        let lifeLostPause = false;
        let lifeLostPauseEnd = 0;
        
        // Boss phase transition pause states
        let bossSpawnPause = false;
        let bossSpawnPauseEnd = 0;
        let levelTransitionPause = false;
        let levelTransitionPauseEnd = 0;
        let extraLifePause = false;
        let extraLifePauseEnd = 0;
        
        // Upgrade selection state
        let upgradeSelectionActive = false;
        let currentUpgradeChoices = [];
        let preBossUpgrade = false; // True when showing upgrade after bricks cleared (before boss)
        
        // Permanent upgrades (persist across levels, reset on new game)
        let permanentUpgrades = {
            paddleSizeBonus: 0,      // Percentage bonus to paddle size
            speedReduction: 0,       // Percentage reduction to ball speed
            crusherDurationBonus: 0, // Extra seconds for crusher
            bigPaddleDurationBonus: 0, // Extra seconds for big paddle
            powerupSpawnBonus: 0,    // Bonus to powerup spawn chance (increases max powerups)
            multiBallBounceBonus: 0  // Extra bounces for multiball
        };
        
        // Upgrade definitions
        const upgradeDefinitions = [
            {
                id: 'paddle',
                name: 'Larger Paddle',
                desc: '+15% Permanent Paddle Size Bonus',
                icon: 'üèì',
                apply: () => { permanentUpgrades.paddleSizeBonus += 15; }
            },
            {
                id: 'speed',
                name: 'Slower Ball',
                desc: '-8% Permanent Ball Speed Reduction',
                icon: 'üê¢',
                apply: () => { permanentUpgrades.speedReduction += 8; }
            },
            {
                id: 'crusher',
                name: 'Crusher+',
                desc: '+5s Crusher Powerup Duration',
                icon: 'üí•',
                apply: () => { permanentUpgrades.crusherDurationBonus += 5; }
            },
            {
                id: 'bigpaddle',
                name: 'Huge Paddle+',
                desc: 'Huge Paddle duration+',
                icon: 'üìè',
                apply: () => { permanentUpgrades.bigPaddleDurationBonus += 8; }
            },
            {
                id: 'powerup',
                name: 'Lucky Drops',
                desc: '+50% Extra Powerup Spawn Chance',
                icon: 'üçÄ',
                apply: () => { permanentUpgrades.powerupSpawnBonus += 50; }
            },
            {
                id: 'multiball',
                name: 'Multi-Ball+',
                desc: '+1 Extra Multi-Ball',
                icon: 'üé±',
                apply: () => { permanentUpgrades.multiBallBounceBonus += 1; }
            }
        ];
        
        // Smart RNG tracking for upgrade selection
        // Tracks how many rounds since each upgrade was last offered (higher = more likely to appear)
        let upgradeOfferHistory = {};
        // Initialize history for all upgrades
        upgradeDefinitions.forEach(u => { upgradeOfferHistory[u.id] = 3; }); // Start with equal weight
        
        // Mapping upgrade IDs to their icons for permanent display
        const upgradeIcons = {
            paddle: { icon: 'üèì', color: '#0ff' },
            speed: { icon: 'üê¢', color: '#00ff88' },
            crusher: { icon: 'üí•', color: '#ff6600' },
            bigpaddle: { icon: 'üìè', color: '#f0f' },
            powerup: { icon: 'üçÄ', color: '#ffcc00' },
            multiball: { icon: 'üé±', color: '#ff66ff' }
        };
        
        // Update permanent upgrades display
        function updatePermanentUpgradesDisplay() {
            const upgrades = [];
            
            // Check each upgrade type for stacks
            const paddleStacks = Math.floor(permanentUpgrades.paddleSizeBonus / 15);
            const speedStacks = Math.floor(permanentUpgrades.speedReduction / 8);
            const crusherStacks = Math.floor(permanentUpgrades.crusherDurationBonus / 5);
            const bigPaddleStacks = Math.floor(permanentUpgrades.bigPaddleDurationBonus / 8);
            const powerupStacks = Math.floor(permanentUpgrades.powerupSpawnBonus / 50);
            const multiballStacks = Math.floor(permanentUpgrades.multiBallBounceBonus / 1);
            
            if (paddleStacks > 0) upgrades.push({ id: 'paddle', stacks: paddleStacks });
            if (speedStacks > 0) upgrades.push({ id: 'speed', stacks: speedStacks });
            if (crusherStacks > 0) upgrades.push({ id: 'crusher', stacks: crusherStacks });
            if (bigPaddleStacks > 0) upgrades.push({ id: 'bigpaddle', stacks: bigPaddleStacks });
            if (powerupStacks > 0) upgrades.push({ id: 'powerup', stacks: powerupStacks });
            if (multiballStacks > 0) upgrades.push({ id: 'multiball', stacks: multiballStacks });
            
            // Build HTML with squircle backgrounds
            const html = upgrades.map(u => {
                const info = upgradeIcons[u.id];
                const stackText = u.stacks > 1 ? `<span class="perm-stack">x${u.stacks}</span>` : '';
                return `<span class="perm-upgrade" style="color: ${info.color}"><span class="perm-icon">${info.icon}</span>${stackText}</span>`;
            }).join('');
            
            permanentUpgradesBarEl.innerHTML = html;
        }
        
        // Boss state
        let bossPhase = false; // True when fighting bosses
        let bosses = []; // Array of boss objects
        let bossesDropping = false; // True during drop animation
        let bossDropProgress = 0; // 0 to 1 for smooth drop
        let bossHitCooldownEnd = 0; // Global cooldown timer for boss damage
        let bossDeathParticles = []; // Particles for boss death explosions
        let bossDeathAnimationEnd = 0; // Time when last boss death animation ends
        let waitingForBossDeathAnimation = false; // True when waiting for animation before level transition
        const bossConfig = {
            width: 50,
            height: 25,
            speed: 2.25, // 10% slower than original 2.5
            speedPenaltyPerBoss: 0.15, // 15% slower per additional boss
            minSpeedMultiplier: 0.25, // Never slower than 25% speed
            dropDistance: 20,
            dropSpeed: 0.08, // How fast the drop animation plays (0-1 per frame)
            hitsRequired: 3,
            hitCooldown: 200, // Milliseconds between allowed hits
            colors: ['#ff0066', '#ff3300', '#ff00ff', '#00ffcc', '#ffcc00'], // Different colors per boss
            pointsPerHit: 30,
            pointsPerKill: 0,
            deathAnimationDuration: 800, // ms to wait for death animation
            // Laser settings
            laserCooldown: 8000, // 8 seconds per boss
            globalLaserCooldown: 6000, // 6 seconds minimum between any laser
            laserSpeed: 2.9, // 15% faster than original 2.5
            laserWidth: 8,
            laserHeight: 12, // Shorter than before
            laserColor: '#ff0000'
        };
        
        // Laser state
        let bossLasers = []; // Active laser projectiles
        let lastGlobalLaserTime = 0; // Timestamp of last laser fired (any boss)

        // Power-up state
        let activePowerUps = {
            bigPaddle: { active: false, timeLeft: 0, originalWidth: 107 },
            multiBall: { active: false, bouncesLeft: 0 },
            crusher: { active: false, timeLeft: 0 },
            smallPaddle: { active: false, timeLeft: 0, originalWidth: 107 }
        };
        let balls = []; // Array to hold multiple balls
        let levelsSinceSkull = 0; // Track levels since last skull brick
        let lastLevelHadSkull = false; // Track if previous level had skull
        
        // Ball color transition state
        let ballColorTransition = {
            currentR: 255, currentG: 255, currentB: 255,
            targetR: 255, targetG: 255, targetB: 255,
            speed: 0.1 // How fast to transition (0-1)
        };

        // Neon colors
        const neonColors = [
            '#ffaa00', // Yellow-orange (between yellow and orange)
            '#00ffff', // Cyan
            '#ff00ff', // Magenta
            '#00ffa0', // Blue-green (was pure green)
            '#bf00ff', // Neon Purple
        ];

        // Power-up types
        const powerUpTypes = [
            { type: 'bigPaddle', color: '#00cc66', symbol: '‚Üî' },
            { type: 'multiBall', color: '#ff6a00', symbol: '‚ú¶' },
            { type: 'crusher', color: '#ff0028', symbol: '‚ö°' }
        ];
        
        // Debuff types
        const debuffTypes = [
            { type: 'smallPaddle', color: '#888888', symbol: '‚ò†' }  // Grey skull brick
        ];

        // Paddle
        const paddle = {
            width: 107,
            height: 11,
            x: 267,
            y: 459,
            speed: 8,
            color: '#0ff',
            dx: 0,
            targetX: 267,
            smoothing: 0.15
        };

        // Ball template
        const ballTemplate = {
            x: 320,
            y: 447,
            radius: 7,
            speed: 5.75,
            dx: 5.75,
            dy: -5.75,
            color: '#fff'
        };

        function createBall(x, y, dx, dy, speed) {
            return {
                x: x,
                y: y,
                radius: 7,
                speed: speed || ballTemplate.speed,
                dx: dx,
                dy: dy,
                color: '#fff'
            };
        }

        // Bricks - calculated for perfect centering
        // Scaled down from 780x600 to 640x492
        // 11 cols, 49px wide, 7px padding = 539 + 70 = 609, offset = (640-609)/2 ‚âà 16
        const brickConfig = {
            rows: 4,
            cols: 11,
            width: 49,
            height: 16,
            padding: 7,
            offsetTop: 41,
            offsetLeft: 16
        };

        let bricks = [];

        function createBricks() {
            bricks = [];
            const totalBricks = brickConfig.rows * brickConfig.cols;
            const cols = brickConfig.cols;
            
            // Helper to get adjacent positions (including diagonals)
            function getAdjacentPositions(pos) {
                const row = Math.floor(pos / cols);
                const col = pos % cols;
                const adjacent = [];
                
                for (let r = row - 1; r <= row + 1; r++) {
                    for (let c = col - 1; c <= col + 1; c++) {
                        if (r >= 0 && r < brickConfig.rows && c >= 0 && c < cols) {
                            adjacent.push(r * cols + c);
                        }
                    }
                }
                return adjacent;
            }
            
            // Luck protection: guarantee 2+ power-ups per level, each unique
            // Max power-ups increases by 1 every 3 levels (3 at level 1-2, 4 at level 3-5, etc.)
            const minPowerUps = 2;
            const baseMaxPowerUps = 3 + Math.floor(level / 3);
            // Base random number of powerups
            let numPowerUps = Math.floor(Math.random() * (baseMaxPowerUps - minPowerUps + 1)) + minPowerUps;
            
            // Lucky Drops upgrade: each stack gives a 50% chance for +1 extra powerup
            // These rolls are independent, so 2 stacks = 2 separate 50% rolls
            const luckyStacks = Math.floor(permanentUpgrades.powerupSpawnBonus / 50);
            for (let i = 0; i < luckyStacks; i++) {
                if (Math.random() < 0.5) {
                    numPowerUps++;
                }
            }
            
            // Pick random unique power-up types
            const availablePowerUps = [...powerUpTypes];
            const selectedPowerUps = [];
            for (let i = 0; i < numPowerUps && availablePowerUps.length > 0; i++) {
                const idx = Math.floor(Math.random() * availablePowerUps.length);
                selectedPowerUps.push(availablePowerUps.splice(idx, 1)[0]);
            }
            
            // Pick random brick positions for power-ups with at least 1 brick separation
            const powerUpPositions = new Map();
            const usedPositions = new Set();
            const blockedPositions = new Set(); // Positions adjacent to power-ups
            
            for (let i = 0; i < selectedPowerUps.length; i++) {
                let pos;
                let attempts = 0;
                do {
                    pos = Math.floor(Math.random() * totalBricks);
                    attempts++;
                    // Fallback after many attempts to avoid infinite loop
                    if (attempts > 100) break;
                } while (usedPositions.has(pos) || blockedPositions.has(pos));
                
                if (attempts <= 100) {
                    usedPositions.add(pos);
                    powerUpPositions.set(pos, selectedPowerUps[i]);
                    
                    // Block adjacent positions
                    getAdjacentPositions(pos).forEach(adj => blockedPositions.add(adj));
                }
            }
            
            // Skull brick logic: not on consecutive levels, but must appear within 3 levels
            // Only eligible starting at level 3
            const skullPositions = new Set();
            let addSkull = false;
            
            if (level >= 3) {
                if (lastLevelHadSkull) {
                    // Can't have skull two levels in a row
                    addSkull = false;
                } else if (levelsSinceSkull >= 2) {
                    // Must have skull if it's been 2+ levels
                    addSkull = true;
                } else {
                    // Random chance (roughly every 3 levels)
                    addSkull = Math.random() < 0.4;
                }
                
                if (addSkull) {
                    let skullPos;
                    let attempts = 0;
                    do {
                        skullPos = Math.floor(Math.random() * totalBricks);
                        attempts++;
                        if (attempts > 100) break;
                    } while (usedPositions.has(skullPos) || blockedPositions.has(skullPos));
                    
                    if (attempts <= 100) {
                        skullPositions.add(skullPos);
                        usedPositions.add(skullPos);
                    }
                    lastLevelHadSkull = true;
                    levelsSinceSkull = 0;
                } else {
                    lastLevelHadSkull = false;
                    levelsSinceSkull++;
                }
            }
            
            let brickIndex = 0;
            for (let row = 0; row < brickConfig.rows; row++) {
                bricks[row] = [];
                for (let col = 0; col < brickConfig.cols; col++) {
                    let powerUp = null;
                    let debuff = null;
                    
                    if (powerUpPositions.has(brickIndex)) {
                        powerUp = powerUpPositions.get(brickIndex);
                    } else if (skullPositions.has(brickIndex)) {
                        debuff = debuffTypes[0];
                    }
                    
                    bricks[row][col] = {
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop,
                        alive: true,
                        color: powerUp ? powerUp.color : (debuff ? debuff.color : neonColors[row % neonColors.length]),
                        powerUp: powerUp,
                        debuff: debuff,
                        twinkleOffset: Math.random() * Math.PI * 2 // For twinkle animation
                    };
                    brickIndex++;
                }
            }
        }

        // ========== BOSS SYSTEM ==========
        function createBosses() {
            bosses = [];
            bossLasers = []; // Clear any existing lasers
            const numBosses = level; // Level 1 = 1 boss, Level 2 = 2 bosses, etc.
            const spacing = canvas.width / (numBosses + 1);
            
            // Stagger initial laser cooldowns so bosses don't all fire at once
            const now = performance.now();
            
            for (let i = 0; i < numBosses; i++) {
                // Randomize initial cooldown between 2-6 seconds to keep player guessing
                const initialCooldown = 2000 + Math.random() * 4000;
                bosses.push({
                    x: spacing * (i + 1) - bossConfig.width / 2,
                    y: 50,
                    width: bossConfig.width,
                    height: bossConfig.height,
                    hits: 0,
                    alive: true,
                    direction: 1, // 1 = right, -1 = left
                    color: bossConfig.colors[i % bossConfig.colors.length],
                    flashUntil: 0, // Timestamp when flash effect ends
                    nextLaserTime: now + initialCooldown // When this boss can fire next
                });
            }
            bossPhase = true;
        }
        
        function drawBosses() {
            if (!bossPhase) return;
            
            ctx.shadowBlur = shadowSettings.boss;
            const now = frameTime;
            
            for (let i = 0; i < bosses.length; i++) {
                const boss = bosses[i];
                if (!boss.alive) continue;
                
                // Check if boss is flashing from damage
                const isFlashing = now < boss.flashUntil;
                let displayColor = boss.color;
                
                if (isFlashing) {
                    // Rapid flash between white and original color
                    const flashPhase = Math.floor((boss.flashUntil - now) / 30) % 2;
                    displayColor = flashPhase === 0 ? '#ffffff' : boss.color;
                }
                
                // Draw boss body with glow
                ctx.beginPath();
                ctx.roundRect(boss.x, boss.y, boss.width, boss.height, 8);
                ctx.fillStyle = displayColor;
                ctx.shadowColor = isFlashing ? '#ffffff' : boss.color;
                ctx.fill();
                
                // Draw hit indicator (3 teeth showing remaining health)
                // Order: left tooth removed first, then right, then center last
                const hitsRemaining = bossConfig.hitsRequired - boss.hits;
                const dotSpacing = boss.width / 4;
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                
                // Teeth removal order: left first, right second, center last
                // At 0 hits (3 remaining): show left, right, center
                // At 1 hit (2 remaining): hide left, show right and center
                // At 2 hits (1 remaining): hide left and right, show only center
                
                // Draw center tooth (position 2) - always shown unless dead
                if (hitsRemaining >= 1) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 2, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Draw right tooth (position 3) - shown if 2+ hits remaining
                if (hitsRemaining >= 2) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 3, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Draw left tooth (position 1) - only shown if all 3 hits remaining
                if (hitsRemaining >= 3) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 1, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw menacing eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(boss.x + 15, boss.y + 10, 5, 0, Math.PI * 2);
                ctx.arc(boss.x + boss.width - 15, boss.y + 10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = shadowSettings.boss;
            }
            ctx.shadowBlur = 0;
        }
        
        function moveBosses() {
            if (!bossPhase || bosses.length === 0) return;
            
            // Calculate speed multiplier based on number of active bosses
            // Each additional boss slows all bosses by 5%
            const aliveBossCount = bosses.filter(b => b.alive).length;
            const speedMultiplier = aliveBossCount > 1 ? 1 - ((aliveBossCount - 1) * bossConfig.speedPenaltyPerBoss) : 1;
            const effectiveSpeed = bossConfig.speed * Math.max(speedMultiplier, bossConfig.minSpeedMultiplier);
            
            // If currently dropping, animate the drop
            if (bossesDropping) {
                bossDropProgress += bossConfig.dropSpeed * deltaMultiplier;
                
                if (bossDropProgress >= 1) {
                    // Drop complete
                    bossDropProgress = 0;
                    bossesDropping = false;
                    
                    // Finalize positions and flip direction
                    bosses.forEach(boss => {
                        if (!boss.alive) return;
                        boss.y = boss.targetY;
                        boss.direction *= -1;
                    });
                } else {
                    // Smooth easing for drop animation
                    const easeProgress = 1 - Math.pow(1 - bossDropProgress, 2); // Ease out quad
                    bosses.forEach(boss => {
                        if (!boss.alive) return;
                        boss.y = boss.startY + (boss.targetY - boss.startY) * easeProgress;
                    });
                }
                return; // Don't move horizontally while dropping
            }
            
            // Check if any boss needs to change direction
            let needsDrop = false;
            bosses.forEach(boss => {
                if (!boss.alive) return;
                
                // Check if boss hits edge
                if (boss.direction === 1 && boss.x + boss.width >= canvas.width - 10) {
                    needsDrop = true;
                } else if (boss.direction === -1 && boss.x <= 10) {
                    needsDrop = true;
                }
            });
            
            // Start drop animation
            if (needsDrop) {
                bossesDropping = true;
                bossDropProgress = 0;
                bosses.forEach(boss => {
                    if (!boss.alive) return;
                    boss.startY = boss.y;
                    boss.targetY = boss.y + bossConfig.dropDistance;
                });
            } else {
                // Normal horizontal movement (frame-rate independent) with speed multiplier
                bosses.forEach(boss => {
                    if (!boss.alive) return;
                    boss.x += effectiveSpeed * boss.direction * deltaMultiplier;
                });
            }
            
            // Check if bosses reached the bottom (game over condition)
            bosses.forEach(boss => {
                if (boss.alive && boss.y + boss.height >= paddle.y - 20) {
                    lives--;
                    livesEl.textContent = lives;
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        // Reset bosses to top and show life lost message
                        showLifeLostMessage();
                        resetBossPositions();
                    }
                }
            });
        }
        
        function resetBossPositions() {
            const numBosses = bosses.filter(b => b.alive).length;
            const aliveBosses = bosses.filter(b => b.alive);
            const spacing = canvas.width / (numBosses + 1);
            
            // Reset drop animation state
            bossesDropping = false;
            bossDropProgress = 0;
            
            // Clear all active lasers and reset global cooldown
            bossLasers = [];
            lastGlobalLaserTime = 0;
            
            // Reset laser cooldowns with staggered timing
            const now = performance.now();
            aliveBosses.forEach((boss, i) => {
                boss.x = spacing * (i + 1) - boss.width / 2;
                boss.y = 50;
                boss.direction = 1;
                // Stagger laser cooldowns again after reset
                boss.nextLaserTime = now + 2000 + Math.random() * 4000;
            });
        }
        
        // ========== BOSS DEATH PARTICLE SYSTEM ==========
        function createBossDeathExplosion(boss) {
            const centerX = boss.x + boss.width / 2;
            const centerY = boss.y + boss.height / 2;
            const particleCount = 30;
            const now = performance.now();
            
            // Create explosion particles
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
                const speed = 2 + Math.random() * 4;
                const size = 4 + Math.random() * 8;
                
                bossDeathParticles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: size,
                    originalSize: size,
                    color: boss.color,
                    alpha: 1,
                    createdAt: now,
                    lifetime: 600 + Math.random() * 400, // 600-1000ms
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
            
            // Create smoke puff particles (gray/white)
            const smokeCount = 15;
            for (let i = 0; i < smokeCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.5 + Math.random() * 2;
                const size = 10 + Math.random() * 15;
                
                bossDeathParticles.push({
                    x: centerX + (Math.random() - 0.5) * boss.width,
                    y: centerY + (Math.random() - 0.5) * boss.height,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1, // Slight upward drift
                    size: size,
                    originalSize: size,
                    color: '#ffffff',
                    alpha: 0.7,
                    createdAt: now,
                    lifetime: 500 + Math.random() * 500,
                    rotation: 0,
                    rotationSpeed: 0,
                    isSmoke: true
                });
            }
        }
        
        function updateBossDeathParticles() {
            const now = performance.now();
            
            bossDeathParticles = bossDeathParticles.filter(p => {
                const age = now - p.createdAt;
                if (age >= p.lifetime) return false;
                
                // Update position
                p.x += p.vx * deltaMultiplier;
                p.y += p.vy * deltaMultiplier;
                
                // Apply gravity to non-smoke particles
                if (!p.isSmoke) {
                    p.vy += 0.1 * deltaMultiplier;
                }
                
                // Slow down
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                // Update rotation
                p.rotation += p.rotationSpeed * deltaMultiplier;
                
                // Fade out and shrink
                const lifeProgress = age / p.lifetime;
                p.alpha = 1 - lifeProgress;
                p.size = p.originalSize * (1 - lifeProgress * 0.5);
                
                return true;
            });
        }
        
        function drawBossDeathParticles() {
            if (bossDeathParticles.length === 0) return;
            
            // Batch smoke particles (simpler rendering)
            ctx.shadowBlur = 0;
            bossDeathParticles.forEach(p => {
                if (p.isSmoke) {
                    // Draw smoke as simple fading circles (no gradient - faster)
                    ctx.globalAlpha = p.alpha * 0.4;
                    ctx.fillStyle = `rgb(180, 180, 180)`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Batch colored explosion particles
            bossDeathParticles.forEach(p => {
                if (!p.isSmoke) {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.globalAlpha = p.alpha;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    ctx.restore();
                }
            });
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        // Boss laser system
        function updateBossLasers() {
            if (!bossPhase) return;
            
            const now = performance.now();
            
            // Check if any boss can fire (respects global cooldown)
            if (now >= lastGlobalLaserTime + bossConfig.globalLaserCooldown) {
                // Get all bosses that are ready to fire
                const readyBosses = bosses.filter(b => b.alive && now >= b.nextLaserTime);
                
                if (readyBosses.length > 0) {
                    // Pick a random ready boss to fire (keeps player guessing)
                    const shooter = readyBosses[Math.floor(Math.random() * readyBosses.length)];
                    
                    // Fire laser from center bottom of boss
                    bossLasers.push({
                        x: shooter.x + shooter.width / 2 - bossConfig.laserWidth / 2,
                        y: shooter.y + shooter.height,
                        width: bossConfig.laserWidth,
                        height: bossConfig.laserHeight,
                        color: shooter.color // Match boss color
                    });
                    
                    // Set cooldowns
                    shooter.nextLaserTime = now + bossConfig.laserCooldown;
                    lastGlobalLaserTime = now;
                }
            }
            
            // Move lasers downward
            bossLasers = bossLasers.filter(laser => {
                laser.y += bossConfig.laserSpeed * deltaMultiplier;
                
                // Check collision with paddle
                if (laser.y + laser.height >= paddle.y &&
                    laser.y <= paddle.y + paddle.height &&
                    laser.x + laser.width >= paddle.x &&
                    laser.x <= paddle.x + paddle.width) {
                    // Hit paddle - lose a life
                    lives--;
                    livesEl.textContent = lives;
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        showLifeLostMessage();
                        resetBossPositions();
                    }
                    return false; // Remove laser
                }
                
                // Remove if off screen
                return laser.y < canvas.height;
            });
        }
        
        function drawBossLasers() {
            if (bossLasers.length === 0) return;
            
            bossLasers.forEach(laser => {
                // Draw laser beam with glow
                ctx.shadowColor = laser.color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = laser.color;
                
                // Main laser body
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                
                // Bright core
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                const coreWidth = laser.width * 0.4;
                const coreX = laser.x + (laser.width - coreWidth) / 2;
                ctx.fillRect(coreX, laser.y, coreWidth, laser.height);
            });
            
            ctx.shadowBlur = 0;
        }
        
        function checkBossCollisions() {
            if (!bossPhase) return;
            
            // Cache time once per frame
            const now = performance.now();
            if (now < bossHitCooldownEnd) return;
            
            // Use labeled loop for early exit after hit
            ballLoop: for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                for (let j = 0; j < bosses.length; j++) {
                    const boss = bosses[j];
                    if (!boss.alive) continue;
                    
                    // Re-check cooldown (may have been set by previous ball)
                    if (bossHitCooldownEnd > now) break ballLoop;
                    
                    // Simple rectangle collision
                    if (ball.x + ball.radius > boss.x &&
                        ball.x - ball.radius < boss.x + boss.width &&
                        ball.y + ball.radius > boss.y &&
                        ball.y - ball.radius < boss.y + boss.height) {
                        
                        // Set cooldown
                        bossHitCooldownEnd = now + bossConfig.hitCooldown;
                        
                        // Damage the boss and trigger flash
                        boss.hits++;
                        boss.flashUntil = now + 150; // Flash for 150ms
                        score += bossConfig.pointsPerHit;
                        scoreEl.textContent = score;
                        
                        // Check if boss is destroyed
                        if (boss.hits >= bossConfig.hitsRequired) {
                            boss.alive = false;
                            score += bossConfig.pointsPerKill;
                            scoreEl.textContent = score;
                            
                            // Check if this was the last boss - freeze ball IMMEDIATELY
                            if (bosses.every(b => !b.alive)) {
                                waitingForBossDeathAnimation = true;
                            }
                            
                            // Create death explosion AFTER setting freeze flag
                            createBossDeathExplosion(boss);
                            bossDeathAnimationEnd = now + bossConfig.deathAnimationDuration;
                            
                            // If ball is now frozen, don't bounce - exit immediately
                            if (waitingForBossDeathAnimation) {
                                break ballLoop;
                            }
                        }
                        
                        // Bounce the ball (only if not frozen)
                        ball.dy = Math.abs(ball.dy); // Always bounce down
                        
                        // Exit after processing one hit per frame
                        break ballLoop;
                    }
                }
            }
        }

        function drawPaddle() {
            // Determine paddle color - green when big paddle active
            let paddleColor = paddle.color; // default cyan
            if (activePowerUps.bigPaddle.active) {
                paddleColor = '#00cc66'; // green
            } else if (activePowerUps.smallPaddle.active) {
                paddleColor = '#888888'; // grey for debuff
            }
            
            // Draw horizontal line underneath paddle area - matches border style
            // Position at canvas bottom where ball terminates (ball removed when ball.y + radius > canvas.height)
            const lineY = canvas.height - 1;
            ctx.beginPath();
            ctx.moveTo(0, lineY);
            ctx.lineTo(canvas.width, lineY);
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 1;
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = isMobile ? 3 : 6;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw paddle
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 7);
            ctx.fillStyle = paddleColor;
            ctx.shadowColor = paddleColor;
            ctx.shadowBlur = shadowSettings.paddle;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawBall() {
            // Determine target ball color based on active power-ups (excluding big paddle)
            let targetR = 255, targetG = 255, targetB = 255;
            
            if (activePowerUps.crusher.active) {
                // #ff0028
                targetR = 255; targetG = 0; targetB = 40;
            } else if (activePowerUps.multiBall.active) {
                // #ff6a00
                targetR = 255; targetG = 106; targetB = 0;
            }
            
            // Smoothly transition current color toward target
            ballColorTransition.currentR += (targetR - ballColorTransition.currentR) * ballColorTransition.speed;
            ballColorTransition.currentG += (targetG - ballColorTransition.currentG) * ballColorTransition.speed;
            ballColorTransition.currentB += (targetB - ballColorTransition.currentB) * ballColorTransition.speed;
            
            const r = Math.round(ballColorTransition.currentR);
            const g = Math.round(ballColorTransition.currentG);
            const b = Math.round(ballColorTransition.currentB);
            const ballColor = `rgb(${r}, ${g}, ${b})`;
            
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                
                ctx.fillStyle = ballColor;
                ctx.shadowColor = ballColor;
                ctx.shadowBlur = shadowSettings.ball;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        function drawBricks() {
            // Calculate twinkle once per frame, not per brick
            const twinkle = isMobile ? 0.5 : (Math.sin(frameTime / 250) * 0.5 + 0.5);
            const twinkleShadow = shadowSettings.brickPowerUp + twinkle * (shadowSettings.brickPowerUpMax - shadowSettings.brickPowerUp);
            const twinkleAlpha = 0.8 + twinkle * 0.2;
            
            // Pre-calculate brick dimensions
            const brickW = brickConfig.width;
            const brickH = brickConfig.height;
            
            // Draw all regular bricks first (batched by similar state)
            ctx.shadowBlur = shadowSettings.brick;
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (brick.alive && !brick.powerUp && !brick.debuff) {
                        ctx.beginPath();
                        ctx.roundRect(brick.x, brick.y, brickW, brickH, 5);
                        ctx.fillStyle = brick.color;
                        ctx.shadowColor = brick.color;
                        ctx.fill();
                    }
                }
            }
            
            // Draw power-up/debuff bricks with pulsing glow effect
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (brick.alive && (brick.powerUp || brick.debuff)) {
                        // Calculate per-brick pulse using its unique offset (2 second cycle)
                        const pulsePhase = (frameTime / 2000 + brick.twinkleOffset) * Math.PI * 2;
                        const pulse = isMobile ? 0.5 : (Math.sin(pulsePhase) * 0.5 + 0.5);
                        
                        // Pulsing glow intensity (subtle range)
                        const glowBlur = shadowSettings.brickPowerUp + pulse * (shadowSettings.brickPowerUpMax - shadowSettings.brickPowerUp);
                        const glowAlpha = 0.85 + pulse * 0.15;
                        
                        ctx.globalAlpha = glowAlpha;
                        ctx.shadowColor = brick.color;
                        ctx.shadowBlur = glowBlur;
                        
                        ctx.beginPath();
                        ctx.roundRect(brick.x, brick.y, brickW, brickH, 5);
                        ctx.fillStyle = brick.color;
                        ctx.fill();
                    }
                }
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Draw symbols on special bricks (separate pass for text rendering)
            const symbolShadow = isMobile ? 0 : 5;
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (!brick.alive) continue;
                    
                    const centerX = brick.x + brickW / 2;
                    const centerY = brick.y + brickH / 2;
                    
                    // Draw symbol on power-up bricks
                    if (brick.powerUp) {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = symbolShadow;
                        ctx.shadowColor = '#fff';
                        
                        if (brick.powerUp.type === 'crusher') {
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, 7, 0, Math.PI * 2);
                            ctx.fillStyle = '#fff';
                            ctx.shadowBlur = 0;
                            ctx.fill();
                            ctx.font = 'bold 14px Arial';
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        } else if (brick.powerUp.type === 'multiBall') {
                            ctx.fillStyle = '#fff';
                            ctx.shadowBlur = symbolShadow;
                            ctx.beginPath();
                            ctx.arc(centerX - 5, centerY, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(centerX + 5, centerY, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (brick.powerUp.type === 'bigPaddle') {
                            ctx.font = '900 18px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 1;
                            ctx.strokeText(brick.powerUp.symbol, centerX, centerY);
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        } else {
                            ctx.font = 'bold 14px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        }
                    }
                    
                    // Draw symbol on debuff bricks
                    if (brick.debuff) {
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = isMobile ? 3 : 5;
                        ctx.shadowColor = '#fff';
                        ctx.fillText(brick.debuff.symbol, centerX, centerY);
                    }
                }
            }
            ctx.shadowBlur = 0;
        }

        function movePaddle() {
            // Smooth keyboard movement (frame-rate independent)
            paddle.targetX += paddle.dx * deltaMultiplier;
            
            // Clamp target
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
            
            // Smooth interpolation (adjust for frame rate)
            const smoothFactor = 1 - Math.pow(1 - paddle.smoothing, deltaMultiplier);
            paddle.x += (paddle.targetX - paddle.x) * smoothFactor;
        }

        function moveBall() {
            let ballsToRemove = [];
            let levelChanged = false;
            
            // Store all ball positions before any movement (for freeze restoration on boss death)
            const savedPositions = balls.map(b => ({ x: b.x, y: b.y }));
            
            for (let ballIndex = 0; ballIndex < balls.length; ballIndex++) {
                if (levelChanged) break;
                const ball = balls[ballIndex];
                
                // Apply delta time for frame-rate independent movement
                ball.x += ball.dx * deltaMultiplier;
                ball.y += ball.dy * deltaMultiplier;

                // Wall collision - FIXED: Reposition ball to prevent getting stuck
                // Left wall
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius; // Reposition inside
                    ball.dx = Math.abs(ball.dx); // Force moving right
                }
                // Right wall
                if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius; // Reposition inside
                    ball.dx = -Math.abs(ball.dx); // Force moving left
                }
                // Top wall
                if (ball.y - ball.radius < 0) {
                    ball.y = ball.radius; // Reposition inside
                    ball.dy = Math.abs(ball.dy); // Force moving down
                }

                // Bottom - remove ball
                if (ball.y + ball.radius > canvas.height) {
                    ballsToRemove.push(ballIndex);
                    continue;
                }

                // Paddle collision
                if (ball.y + ball.radius > paddle.y &&
                    ball.y - ball.radius < paddle.y + paddle.height &&
                    ball.x > paddle.x &&
                    ball.x < paddle.x + paddle.width) {
                    
                    ball.y = paddle.y - ball.radius;
                    
                    // Angle based on where ball hits paddle (-0.8 to 0.8 range for max angle)
                    let hitPoint = (ball.x - paddle.x) / paddle.width;
                    let angle = (hitPoint - 0.5) * 1.6; // Max angle ~38 degrees
                    
                    // Normalize velocity to maintain consistent speed
                    ball.dx = ball.speed * Math.sin(angle * Math.PI / 2);
                    ball.dy = -ball.speed * Math.cos(angle * Math.PI / 2);
                    
                    // Ensure ball always moves upward
                    if (ball.dy > -ball.speed * 0.3) {
                        ball.dy = -ball.speed * 0.3;
                        // Renormalize dx to maintain speed
                        const dxMax = Math.sqrt(ball.speed * ball.speed - ball.dy * ball.dy);
                        ball.dx = Math.sign(ball.dx) * Math.min(Math.abs(ball.dx), dxMax);
                    }
                    
                    // Multiball: spawn new ball on paddle hit
                    if (activePowerUps.multiBall.active && activePowerUps.multiBall.bouncesLeft > 0) {
                        activePowerUps.multiBall.bouncesLeft--;
                        
                        // Spawn a new ball at random angle (normalized velocity)
                        const spawnAngle = (Math.random() - 0.5) * Math.PI * 0.6; // -54¬∞ to +54¬∞
                        const newBall = createBall(
                            ball.x,
                            ball.y - 10,
                            ball.speed * Math.sin(spawnAngle),
                            -ball.speed * Math.cos(spawnAngle),
                            ball.speed
                        );
                        balls.push(newBall);
                        
                        if (activePowerUps.multiBall.bouncesLeft <= 0) {
                            activePowerUps.multiBall.active = false;
                        }
                    }
                }

                // Brick collision - only during brick phase
                if (!bossPhase) {
                    // Early exit: skip if ball is clearly outside brick area
                    const brickAreaBottom = brickConfig.offsetTop + brickConfig.rows * (brickConfig.height + brickConfig.padding);
                    if (ball.y - ball.radius <= brickAreaBottom && ball.y + ball.radius >= brickConfig.offsetTop) {
                        for (let row = 0; row < brickConfig.rows; row++) {
                            if (levelChanged) break;
                            
                            // Skip rows that ball can't possibly touch
                            const rowY = brickConfig.offsetTop + row * (brickConfig.height + brickConfig.padding);
                            if (ball.y + ball.radius < rowY) break; // Ball above this row and all below
                            if (ball.y - ball.radius > rowY + brickConfig.height) continue; // Ball below this row
                            
                            for (let col = 0; col < brickConfig.cols; col++) {
                                if (levelChanged) break;
                                const brick = bricks[row][col];
                                if (brick.alive) {
                                    // Check collision with ball radius on all sides
                                    if (ball.x + ball.radius > brick.x &&
                                        ball.x - ball.radius < brick.x + brickConfig.width &&
                                        ball.y + ball.radius > brick.y &&
                                        ball.y - ball.radius < brick.y + brickConfig.height) {
                                        
                                        // Only bounce if crusher is not active
                                        if (!activePowerUps.crusher.active) {
                                            // Determine which side was hit for proper bounce direction
                                            const overlapLeft = (ball.x + ball.radius) - brick.x;
                                            const overlapRight = (brick.x + brickConfig.width) - (ball.x - ball.radius);
                                            const overlapTop = (ball.y + ball.radius) - brick.y;
                                            const overlapBottom = (brick.y + brickConfig.height) - (ball.y - ball.radius);
                                            
                                            const minOverlapX = Math.min(overlapLeft, overlapRight);
                                            const minOverlapY = Math.min(overlapTop, overlapBottom);
                                            
                                            if (minOverlapX < minOverlapY) {
                                                ball.dx *= -1;
                                            } else {
                                                ball.dy *= -1;
                                            }
                                        }
                                        
                                        brick.alive = false;
                                        score += 1;
                                        scoreEl.textContent = score;
                                    
                                    // Activate power-up if brick had one
                                    if (brick.powerUp) {
                                        activatePowerUp(brick.powerUp.type);
                                    }
                                    
                                    // Activate debuff if brick had one
                                    if (brick.debuff) {
                                        activatePowerUp(brick.debuff.type);
                                    }

                                    // Check win - triggers pre-boss upgrade then boss phase
                                    if (checkWin() && !bossPhase) {
                                        preBossUpgrade = true;
                                        showUpgradeSelector();
                                        levelChanged = true;
                                    }
                                }
                            }
                        }
                    }
                    } // End early exit check
                }
            }
            
            if (levelChanged) return;
            
            // Boss phase logic
            if (bossPhase) {
                moveBosses();
                updateBossLasers();
                checkBossCollisions();
                
                // If boss death triggered freeze, restore all ball positions
                if (waitingForBossDeathAnimation) {
                    balls.forEach((ball, i) => {
                        if (savedPositions[i]) {
                            ball.x = savedPositions[i].x;
                            ball.y = savedPositions[i].y;
                        }
                    });
                    return; // Exit immediately, ball is frozen
                }
            }
            
            // Update boss death particles (always, even after boss phase ends)
            updateBossDeathParticles();
            
            // Remove balls that fell off screen (Set for O(1) lookup)
            if (ballsToRemove.length > 0) {
                const removeSet = new Set(ballsToRemove);
                balls = balls.filter((_, index) => !removeSet.has(index));
            }
            
            // If no balls left, lose a life
            if (balls.length === 0) {
                lives--;
                livesEl.textContent = lives;
                if (lives <= 0) {
                    gameOver();
                } else {
                    showLifeLostMessage();
                }
            }
        }

        // Show life lost message and pause briefly
        function showLifeLostMessage() {
            lifeLostPause = true;
            lifeLostPauseEnd = performance.now() + 1275; // 1.275 second pause (15% shorter)
        }
        
        function drawLifeLostMessage() {
            if (!lifeLostPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Magenta text (matches game over)
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 20;
            ctx.fillText(`${lives} ${lives === 1 ? 'LIFE' : 'LIVES'} REMAINING`, canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }

        function checkWin() {
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    if (bricks[row][col].alive) return false;
                }
            }
            return true;
        }
        
        function startBossPhase() {
            // Pause before bosses appear
            bossSpawnPause = true;
            bossSpawnPauseEnd = performance.now() + 1200; // 1.2 second pause
        }
        
        function startLevelTransition() {
            // Check if player earns an extra life (every 5 levels)
            if (level % 5 === 0) {
                lives++;
                livesEl.textContent = lives;
                // Show extra life message first, then upgrade selector
                extraLifePause = true;
                extraLifePauseEnd = performance.now() + 1200; // 1.2 second pause
            } else {
                // Show upgrade selector directly
                showUpgradeSelector();
            }
        }
        
        // ========== UPGRADE SELECTOR SYSTEM ==========
        const upgradeOverlay = document.getElementById('upgradeOverlay');
        const slots = [
            document.getElementById('slot1'),
            document.getElementById('slot2'),
            document.getElementById('slot3')
        ];
        
        // Event delegation for upgrade selection (robust iOS support)
        upgradeOverlay.addEventListener('click', (e) => {
            if (!upgradeSelectionActive) return;
            const slot = e.target.closest('.upgrade-slot.revealed');
            if (slot) {
                const index = slots.indexOf(slot);
                if (index !== -1) selectUpgrade(index);
            }
        });
        
        // Touch event delegation (iOS Safari needs this)
        upgradeOverlay.addEventListener('touchstart', (e) => {
            // Allow touches on slots, but stop propagation to prevent game controls
            e.stopPropagation();
        }, { passive: true });
        
        upgradeOverlay.addEventListener('touchend', (e) => {
            if (!upgradeSelectionActive) return;
            const slot = e.target.closest('.upgrade-slot.revealed');
            if (slot) {
                e.preventDefault();
                const index = slots.indexOf(slot);
                if (index !== -1) selectUpgrade(index);
            }
        }, { passive: false });
        
        function showUpgradeSelector() {
            upgradeSelectionActive = true;
            
            // Smart RNG: Weight upgrades by how long since they were offered
            // Upgrades not shown recently have higher chance of appearing
            function weightedRandomSelect(available, count) {
                const selected = [];
                const pool = [...available];
                
                for (let i = 0; i < count && pool.length > 0; i++) {
                    // Calculate weights based on history (higher = shown longer ago)
                    const weights = pool.map(u => {
                        const roundsSince = upgradeOfferHistory[u.id] || 1;
                        // Weight formula: rounds since last offer squared (exponential preference for variety)
                        return roundsSince * roundsSince;
                    });
                    
                    // Calculate total weight
                    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                    
                    // Random selection based on weights
                    let random = Math.random() * totalWeight;
                    let selectedIdx = 0;
                    
                    for (let j = 0; j < weights.length; j++) {
                        random -= weights[j];
                        if (random <= 0) {
                            selectedIdx = j;
                            break;
                        }
                    }
                    
                    selected.push(pool.splice(selectedIdx, 1)[0]);
                }
                
                return selected;
            }
            
            // Pick 3 upgrades using weighted selection
            currentUpgradeChoices = weightedRandomSelect(upgradeDefinitions, 3);
            
            // Update history: reset offered upgrades to 0, increment others
            upgradeDefinitions.forEach(u => {
                const wasOffered = currentUpgradeChoices.some(c => c.id === u.id);
                if (wasOffered) {
                    upgradeOfferHistory[u.id] = 0; // Just offered
                } else {
                    // Increment rounds since last offer (cap at 5 to prevent runaway weights)
                    upgradeOfferHistory[u.id] = Math.min((upgradeOfferHistory[u.id] || 0) + 1, 5);
                }
            });
            
            // Reset slots to rolling state
            slots.forEach((slot, i) => {
                slot.className = 'upgrade-slot rolling';
                slot.dataset.type = '';
                slot.querySelector('.upgrade-icon').textContent = '?';
                slot.querySelector('.upgrade-name').textContent = '???';
                slot.querySelector('.upgrade-desc').textContent = '???';
            });
            
            upgradeOverlay.classList.add('active');
            
            // Start the slot machine roll animation
            rollSlots();
        }
        
        function rollSlots() {
            const rollDuration = 1500; // Total roll time
            const staggerDelay = 300; // Delay between each slot stopping
            
            slots.forEach((slot, index) => {
                const stopTime = rollDuration + (index * staggerDelay);
                let rollInterval;
                
                // Rapidly cycle through random upgrades
                rollInterval = setInterval(() => {
                    const randomUpgrade = upgradeDefinitions[Math.floor(Math.random() * upgradeDefinitions.length)];
                    slot.querySelector('.upgrade-icon').textContent = randomUpgrade.icon;
                    slot.querySelector('.upgrade-name').textContent = randomUpgrade.name;
                    slot.querySelector('.upgrade-desc').textContent = randomUpgrade.desc;
                }, 80);
                
                // Stop on the actual choice
                setTimeout(() => {
                    clearInterval(rollInterval);
                    const choice = currentUpgradeChoices[index];
                    slot.className = 'upgrade-slot revealed';
                    slot.dataset.type = choice.id;
                    slot.querySelector('.upgrade-icon').textContent = choice.icon;
                    slot.querySelector('.upgrade-name').textContent = choice.name;
                    slot.querySelector('.upgrade-desc').textContent = choice.desc;
                    
                    // Add click handler for desktop
                    slot.onclick = () => selectUpgrade(index);
                    
                    // Add touch handler for mobile (iOS Safari needs this)
                    slot.ontouchend = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        selectUpgrade(index);
                    };
                }, stopTime);
            });
        }
        
        function selectUpgrade(index) {
            if (!upgradeSelectionActive) return;
            
            // Immediately disable to prevent double-application from touch+click
            upgradeSelectionActive = false;
            
            const choice = currentUpgradeChoices[index];
            
            // Visual feedback
            slots.forEach((slot, i) => {
                if (i === index) {
                    slot.classList.add('selected');
                } else {
                    slot.style.opacity = '0.3';
                    slot.style.pointerEvents = 'none';
                }
            });
            
            // Apply the upgrade
            choice.apply();
            
            // Update the permanent upgrades display
            updatePermanentUpgradesDisplay();
            
            // Brief pause then continue
            setTimeout(() => {
                upgradeOverlay.classList.remove('active');
                
                // Reset slot styles and clear all handlers
                slots.forEach(slot => {
                    slot.style.opacity = '';
                    slot.style.pointerEvents = '';
                    slot.classList.remove('selected');
                    slot.onclick = null;
                    slot.ontouchend = null;
                });
                
                // Check if this was a pre-boss upgrade
                if (preBossUpgrade) {
                    preBossUpgrade = false;
                    startBossPhase();
                } else {
                    // Post-boss upgrade - show level clear message
                    levelTransitionPause = true;
                    levelTransitionPauseEnd = performance.now() + 1200;
                }
            }, 800);
        }
        
        function drawExtraLifeMessage() {
            if (!extraLifePause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Blue text for extra life
            ctx.font = 'bold 42px Arial';
            ctx.fillStyle = '#00aaff';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#00aaff';
            ctx.shadowBlur = 25;
            ctx.fillText('+1 LIFE', canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }
        
        function drawBossSpawnMessage() {
            if (!bossSpawnPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Warning text - same pink as start button
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 20;
            ctx.fillText('BOSS INCOMING!', canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }
        
        function drawLevelTransitionMessage() {
            if (!levelTransitionPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Victory text - same cyan as paddle
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#0ff';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 20;
            ctx.fillText(`LEVEL ${level} CLEAR!`, canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }

        function activatePowerUp(type) {
            switch(type) {
                case 'bigPaddle':
                    activePowerUps.bigPaddle.active = true;
                    // Base 12s + permanent big paddle duration bonus
                    activePowerUps.bigPaddle.timeLeft = 12 + permanentUpgrades.bigPaddleDurationBonus;
                    activePowerUps.bigPaddle.originalWidth = paddle.width;
                    // Animate paddle growing 70% bigger
                    animatePaddleSize(paddle.width * 1.7);
                    break;
                    
                case 'multiBall':
                    activePowerUps.multiBall.active = true;
                    // Base 2 bounces + permanent multiball bounce bonus
                    activePowerUps.multiBall.bouncesLeft = 2 + permanentUpgrades.multiBallBounceBonus;
                    break;
                    
                case 'crusher':
                    activePowerUps.crusher.active = true;
                    // Base 8s + permanent crusher duration bonus
                    activePowerUps.crusher.timeLeft = 8 + permanentUpgrades.crusherDurationBonus;
                    break;
                    
                case 'smallPaddle':
                    activePowerUps.smallPaddle.active = true;
                    activePowerUps.smallPaddle.timeLeft = 10;
                    activePowerUps.smallPaddle.originalWidth = paddle.width;
                    // Animate paddle shrinking 30% smaller
                    animatePaddleSize(paddle.width * 0.7);
                    break;
            }
        }

        let paddleAnimation = {
            active: false,
            startWidth: 0,
            targetWidth: 0,
            startTime: 0,
            duration: 300
        };

        function animatePaddleSize(targetWidth) {
            paddleAnimation.active = true;
            paddleAnimation.startWidth = paddle.width;
            paddleAnimation.targetWidth = targetWidth;
            paddleAnimation.startTime = frameTime; // Use frameTime
        }
        
        function updatePaddleAnimation() {
            if (!paddleAnimation.active) return;
            
            const elapsed = frameTime - paddleAnimation.startTime; // Use frameTime
            const progress = Math.min(elapsed / paddleAnimation.duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            const oldWidth = paddle.width;
            paddle.width = paddleAnimation.startWidth + (paddleAnimation.targetWidth - paddleAnimation.startWidth) * eased;
            
            // Adjust position to keep paddle centered during resize
            const widthDiff = paddle.width - oldWidth;
            paddle.x -= widthDiff / 2;
            paddle.targetX -= widthDiff / 2;
            
            // Clamp to canvas bounds
            if (paddle.x < 0) {
                paddle.x = 0;
                paddle.targetX = 0;
            }
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
                paddle.targetX = canvas.width - paddle.width;
            }
            
            if (progress >= 1) {
                paddleAnimation.active = false;
            }
        }

        let lastPowerUpTime = 0;
        
        function updatePowerUps() {
            const delta = (frameTime - lastPowerUpTime) / 1000; // Use frameTime
            lastPowerUpTime = frameTime;
            
            // Big paddle timer
            if (activePowerUps.bigPaddle.active) {
                activePowerUps.bigPaddle.timeLeft -= delta;
                if (activePowerUps.bigPaddle.timeLeft <= 0) {
                    activePowerUps.bigPaddle.active = false;
                    // Animate paddle shrinking back
                    animatePaddleSize(activePowerUps.bigPaddle.originalWidth);
                }
            }
            
            // Crusher timer
            if (activePowerUps.crusher.active) {
                activePowerUps.crusher.timeLeft -= delta;
                if (activePowerUps.crusher.timeLeft <= 0) {
                    activePowerUps.crusher.active = false;
                }
            }
            
            // Small paddle timer (debuff)
            if (activePowerUps.smallPaddle.active) {
                activePowerUps.smallPaddle.timeLeft -= delta;
                if (activePowerUps.smallPaddle.timeLeft <= 0) {
                    activePowerUps.smallPaddle.active = false;
                    // Animate paddle growing back
                    animatePaddleSize(activePowerUps.smallPaddle.originalWidth);
                }
            }
        }

        // Track last power-up bar content to avoid unnecessary DOM updates
        let lastPowerUpBarContent = '';
        
        function drawPowerUpTimers() {
            const flashOn = Math.sin(frameTime / 1000 * 6) > 0; // Use cached frameTime
            
            // Collect all active powerups with their display info
            const activePowerups = [];
            
            // Big paddle timer
            if (activePowerUps.bigPaddle.active) {
                const timeLeft = activePowerUps.bigPaddle.timeLeft;
                const isWarning = timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: timeLeft,
                    html: `<span style="color: #00cc66; text-shadow: 0 0 6px #00cc66; font-weight: bold; opacity: ${opacity};">‚Üî Huge Paddle: ${Math.ceil(timeLeft)}s ‚Üî</span>`
                });
            }
            
            // Crusher timer
            if (activePowerUps.crusher.active) {
                const timeLeft = activePowerUps.crusher.timeLeft;
                const isWarning = timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: timeLeft,
                    html: `<span style="color: #ff0028; text-shadow: 0 0 6px #ff0028; font-weight: bold; opacity: ${opacity};">‚ö° Crusher: ${Math.ceil(timeLeft)}s ‚ö°</span>`
                });
            }
            
            // Multiball bounces remaining (treat bounces as "time" for sorting - lower = sooner to expire)
            if (activePowerUps.multiBall.active) {
                const bouncesLeft = activePowerUps.multiBall.bouncesLeft;
                const isWarning = bouncesLeft === 1;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: bouncesLeft * 2, // Convert bounces to approximate seconds for sorting
                    html: `<span style="color: #ff6a00; text-shadow: 0 0 6px #ff6a00; font-weight: bold; opacity: ${opacity};">‚ú¶ Multi Ball: ${bouncesLeft} Bounce${bouncesLeft !== 1 ? 's' : ''} ‚ú¶</span>`
                });
            }
            
            // Small paddle timer (debuff)
            if (activePowerUps.smallPaddle.active) {
                const timeLeft = activePowerUps.smallPaddle.timeLeft;
                const isWarning = timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                activePowerups.push({
                    sortValue: timeLeft,
                    html: `<span style="color: #888888; text-shadow: 0 0 6px #888888; font-weight: bold; opacity: ${opacity};">‚ò† Small Paddle: ${Math.ceil(timeLeft)}s ‚ò†</span>`
                });
            }
            
            // Sort by time remaining (lowest first = closest to expiring on top)
            activePowerups.sort((a, b) => a.sortValue - b.sortValue);
            
            // Limit to 3 on mobile, 4 on desktop (hide extras via overflow:hidden in CSS)
            const maxTimers = isTrueMobile ? 3 : 4;
            const html = activePowerups.slice(0, maxTimers).map(p => p.html).join('');
            
            // Only update DOM if content changed (major optimization)
            if (html !== lastPowerUpBarContent) {
                powerUpBarEl.innerHTML = html;
                lastPowerUpBarContent = html;
            }
        }

        function nextLevel() {
            level++;
            levelEl.textContent = level;
            
            // Clear boss state for new level
            bossPhase = false;
            bosses = [];
            bossLasers = [];
            lastGlobalLaserTime = 0;
            bossesDropping = false;
            bossDropProgress = 0;
            bossDeathParticles = [];
            waitingForBossDeathAnimation = false;
            
            // Progressive difficulty - slower ramp early, faster later
            if (level <= 3) {
                ballTemplate.speed += 0.4;  // Gentle increase for first 3 levels
            } else {
                ballTemplate.speed += 0.6;  // Faster increase after that
            }
            
            // Shrink paddle slightly each level (min 66px)
            // Then apply permanent paddle size bonus
            const basePaddleWidth = Math.max(66, 107 - (level - 1) * 6);
            const bonusMultiplier = 1 + (permanentUpgrades.paddleSizeBonus / 100);
            paddle.width = Math.round(basePaddleWidth * bonusMultiplier);
            
            // Add more brick rows at higher levels (max 7)
            brickConfig.rows = Math.min(7, 4 + Math.floor(level / 2));
            
            // Reset power-ups on level change
            activePowerUps.bigPaddle = { active: false, timeLeft: 0, originalWidth: paddle.width };
            activePowerUps.multiBall = { active: false, bouncesLeft: 0 };
            activePowerUps.crusher = { active: false, timeLeft: 0 };
            activePowerUps.smallPaddle = { active: false, timeLeft: 0, originalWidth: paddle.width };
            
            createBricks();
            resetBall();
        }

        function resetBall() {
            // Apply permanent speed reduction bonus
            const speedMultiplier = 1 - (permanentUpgrades.speedReduction / 100);
            const speed = ballTemplate.speed * speedMultiplier;
            // Launch at 45-degree angle with NORMALIZED velocity
            // At 45¬∞: sin(45¬∞) = cos(45¬∞) = 0.707, so dx¬≤ + dy¬≤ = speed¬≤
            const angle = 0.707; // ‚àö2/2 for 45-degree launch
            const direction = Math.random() > 0.5 ? 1 : -1;
            balls = [createBall(
                paddle.x + paddle.width / 2,
                paddle.y - 8 - 5,
                speed * angle * direction,  // dx: ~70% of speed
                -speed * angle,              // dy: ~70% of speed (upward)
                speed
            )];
        }

        function gameOver() {
            gameRunning = false;
            
            // Keep buttons hidden until score modal is dismissed
            startBtn.style.visibility = 'hidden';
            leaderboardBtn.style.visibility = 'hidden';
            buttonContainer.style.display = 'none';
            
            powerUpBarEl.innerHTML = '';
            lastPowerUpBarContent = '';
            
            // Draw game over screen (will be visible after modal closes)
            drawGameOverScreen();
            
            // Show score submission modal after 2 second pause
            setTimeout(() => {
                showScoreModal(score, level);
            }, 2000);
        }
        
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 52px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = isMobile ? 15 : 25;
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);
            ctx.shadowBlur = 0;
            
            ctx.font = '24px Arial';
            ctx.fillStyle = '#0ff';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 15);
        }
        
        function showGameOverButtons() {
            startBtn.textContent = 'üéÆ Play Again üéÆ';
            startBtn.style.visibility = 'visible';
            leaderboardBtn.style.visibility = 'visible';
            buttonContainer.style.display = '';
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background glow effect
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw horizontal line at top (under HUD area) - matches border style
            const topLineY = 1;
            ctx.beginPath();
            ctx.moveTo(0, topLineY);
            ctx.lineTo(canvas.width, topLineY);
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 1;
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = isMobile ? 3 : 6;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw bricks only if not in boss phase
            if (!bossPhase) {
                drawBricks();
            }
            
            // Draw bosses if in boss phase
            if (bossPhase) {
                drawBosses();
                drawBossLasers();
            }
            
            // Draw boss death particles (always, even after boss phase ends)
            drawBossDeathParticles();
            
            drawPaddle();
            drawBall();
            
            // Draw life lost message overlay (on top of everything)
            drawLifeLostMessage();
        }

        // Delta time for consistent game speed across all frame rates
        let lastFrameTime = 0;
        const targetFrameTime = 1000 / 60; // Target 60fps as baseline for speed calculations
        
        // Single timestamp per frame (optimization)
        let frameTime = 0;
        let deltaMultiplier = 1; // Scales movement based on actual frame time

        function update(currentTime) {
            if (!gameRunning) return;
            
            // Calculate delta time for frame-rate independent movement
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            frameTime = currentTime;
            
            // Calculate speed multiplier (1.0 at 60fps, higher if slower, lower if faster)
            // Clamp to prevent huge jumps if tab was inactive
            deltaMultiplier = Math.min(deltaTime / targetFrameTime, 3);
            
            // Check if life lost pause is over
            if (lifeLostPause) {
                if (currentTime >= lifeLostPauseEnd) {
                    lifeLostPause = false;
                    resetBall();
                }
                // During pause, still draw but don't update game logic
                draw();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if boss spawn pause is over
            if (bossSpawnPause) {
                if (currentTime >= bossSpawnPauseEnd) {
                    bossSpawnPause = false;
                    createBosses();
                    resetBall();
                }
                // During pause, still draw but don't update game logic
                draw();
                drawBossSpawnMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if level transition pause is over
            if (levelTransitionPause) {
                if (currentTime >= levelTransitionPauseEnd) {
                    levelTransitionPause = false;
                    nextLevel();
                }
                // During pause, still draw but don't update game logic
                draw();
                drawLevelTransitionMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if extra life pause is over
            if (extraLifePause) {
                if (currentTime >= extraLifePauseEnd) {
                    extraLifePause = false;
                    // Now show upgrade selector
                    showUpgradeSelector();
                }
                // During pause, still draw but don't update game logic
                draw();
                drawExtraLifeMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if upgrade selection is active (pause game)
            if (upgradeSelectionActive) {
                draw();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if waiting for boss death animation (freeze ball but keep drawing)
            if (waitingForBossDeathAnimation) {
                // Update boss death particles for animation
                updateBossDeathParticles();
                
                // Check if animation is complete
                if (currentTime >= bossDeathAnimationEnd) {
                    waitingForBossDeathAnimation = false;
                    bossPhase = false;
                    startLevelTransition();
                }
                
                // Draw everything but don't move ball
                movePaddle();
                updatePaddleAnimation();
                updatePowerUps();
                drawPowerUpTimers();
                draw();
                requestAnimationFrame(update);
                return;
            }
            
            movePaddle();
            updatePaddleAnimation();
            moveBall();
            
            // Check if game ended during moveBall (lives ran out)
            if (!gameRunning) return;
            
            updatePowerUps();
            drawPowerUpTimers();
            draw();
            
            requestAnimationFrame(update);
        }

        function startGame() {
            score = 0;
            lives = 3;
            level = 1;
            ballTemplate.speed = 5.75; // Initial speed (5% slower)
            
            // Reset boss phase
            bossPhase = false;
            bosses = [];
            bossLasers = [];
            lastGlobalLaserTime = 0;
            bossesDropping = false;
            bossDropProgress = 0;
            bossDeathParticles = [];
            waitingForBossDeathAnimation = false;
            
            // Reset all pause states
            lifeLostPause = false;
            bossSpawnPause = false;
            levelTransitionPause = false;
            extraLifePause = false;
            upgradeSelectionActive = false;
            preBossUpgrade = false;
            upgradeOverlay.classList.remove('active');
            
            // Reset permanent upgrades
            permanentUpgrades = {
                paddleSizeBonus: 0,
                speedReduction: 0,
                crusherDurationBonus: 0,
                bigPaddleDurationBonus: 0,
                powerupSpawnBonus: 0,
                multiBallBounceBonus: 0
            };
            
            // Reset smart RNG history for upgrades
            upgradeDefinitions.forEach(u => { upgradeOfferHistory[u.id] = 3; });
            
            // Activate mouse control when starting game
            mouseControlActive = true;
            
            // Reset difficulty
            paddle.width = 107;
            brickConfig.rows = 4;
            
            // Reset power-ups
            activePowerUps.bigPaddle = { active: false, timeLeft: 0, originalWidth: 107 };
            activePowerUps.multiBall = { active: false, bouncesLeft: 0 };
            activePowerUps.crusher = { active: false, timeLeft: 0 };
            activePowerUps.smallPaddle = { active: false, timeLeft: 0, originalWidth: 107 };
            powerUpBarEl.innerHTML = '';
            lastPowerUpBarContent = '';
            permanentUpgradesBarEl.innerHTML = '';
            
            // Reset ball color to white
            ballColorTransition.currentR = 255;
            ballColorTransition.currentG = 255;
            ballColorTransition.currentB = 255;
            ballColorTransition.targetR = 255;
            ballColorTransition.targetG = 255;
            ballColorTransition.targetB = 255;
            
            // Reset skull tracking
            levelsSinceSkull = 0;
            lastLevelHadSkull = false;
            
            scoreEl.textContent = score;
            livesEl.textContent = lives;
            levelEl.textContent = level;
            
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.targetX = paddle.x;
            createBricks();
            resetBall();
            
            lastPowerUpTime = performance.now();
            lastFrameTime = performance.now();
            frameTime = performance.now();
            deltaMultiplier = 1; // Start with normal speed
            gameRunning = true;
            gameHasStarted = true;
            startBtn.style.visibility = 'hidden';
            leaderboardBtn.style.visibility = 'hidden';
            // Hide button container during gameplay
            buttonContainer.style.display = 'none';
            requestAnimationFrame(update);
        }

        // Controls (combined keyboard handler)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                paddle.dx = -paddle.speed;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                paddle.dx = paddle.speed;
            }
            if (e.key === 'Escape') {
                if (leaderboardOverlay.classList.contains('active')) {
                    hideLeaderboard();
                }
                if (scoreModal.classList.contains('active')) {
                    hideScoreModal();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') paddle.dx = 0;
        });

        // Track if mouse is controlling paddle (only when inside game area)
        let mouseControlActive = false;

        // Track mouse on document when control is active
        document.addEventListener('mousemove', (e) => {
            if (!mouseControlActive) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const mouseX = (e.clientX - rect.left) * scaleX;
            paddle.targetX = mouseX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
        });
        
        // Activate mouse control when clicking on canvas or game container
        const gameContainer = document.querySelector('.game-container');
        gameContainer.addEventListener('mousedown', () => {
            mouseControlActive = true;
        });
        
        // Deactivate mouse control when clicking outside game container
        document.addEventListener('mousedown', (e) => {
            if (!gameContainer.contains(e.target)) {
                mouseControlActive = false;
            }
        });

        // Touch input for mobile - canvas area
        function handleTouch(e) {
            // Only work during active gameplay
            if (!gameRunning || upgradeSelectionActive) return;
            
            if (e.touches.length === 0) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const touch = e.touches[0];
            const touchX = (touch.clientX - rect.left) * scaleX;
            paddle.targetX = touchX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
        }

        // Only add canvas touch listeners - they check gameRunning internally
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('touchmove', handleTouch, { passive: false });
        
        // Trackpad zone - maps touch X to paddle position during gameplay
        function handleTrackpad(e) {
            // Only work during active gameplay
            if (!gameRunning || upgradeSelectionActive) return;
            
            if (e.touches.length === 0) return;
            e.preventDefault();
            e.stopPropagation();
            
            const touch = e.touches[0];
            
            // Map touch X position to canvas coordinates
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const touchX = (touch.clientX - rect.left) * scaleX;
            
            // Move paddle to touch position (centered on touch)
            paddle.targetX = touchX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
        }
        
        // Trackpad zone handles touch events for paddle control
        trackpadZone.addEventListener('touchstart', handleTrackpad, { passive: false });
        trackpadZone.addEventListener('touchmove', handleTrackpad, { passive: false });
        
        // AGGRESSIVE scroll prevention - use capture phase on document
        // This fires BEFORE any element handlers and prevents scroll at the root
        
        // Notify parent frame of touch events (for DuckDuckGo browser UI prevention)
        function notifyParentTouchStart() {
            if (window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'gameTouch', action: 'start' }, '*');
                } catch(e) {}
            }
        }
        
        function notifyParentTouchEnd() {
            if (window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'gameTouch', action: 'end' }, '*');
                } catch(e) {}
            }
        }
        
        document.addEventListener('touchstart', (e) => {
            // Notify parent frame immediately
            notifyParentTouchStart();
            
            if (e.target.closest('.game-container')) {
                // Allow interactive elements to receive touch events normally
                const isInteractive = e.target.closest('button') ||
                                     e.target.closest('input') ||
                                     e.target.closest('.upgrade-slot') ||
                                     e.target.closest('.leaderboard-close');
                if (!isInteractive) {
                    e.preventDefault();
                }
            }
        }, { passive: false, capture: true });
        
        document.addEventListener('touchend', (e) => {
            // Notify parent frame
            notifyParentTouchEnd();
        }, { passive: true, capture: true });
        
        document.addEventListener('touchcancel', (e) => {
            // Notify parent frame
            notifyParentTouchEnd();
        }, { passive: true, capture: true });
        
        document.addEventListener('touchmove', (e) => {
            // Prevent scroll on game container and modals
            if (e.target.closest('.game-container') ||
                e.target.closest('.score-modal') ||
                e.target.closest('.leaderboard-overlay')) {
                // Allow leaderboard list scrolling only
                if (e.target.closest('.leaderboard-list')) {
                    return;
                }
                e.preventDefault();
            }
        }, { passive: false, capture: true });

        // Start button - support both click and touch with capture phase for priority
        startBtn.addEventListener('click', startGame);
        
        // Use capture phase to ensure button gets touch events first
        startBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.stopImmediatePropagation();
        }, { passive: true, capture: true });
        
        startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            startGame();
        }, { passive: false, capture: true });

        // Create display-only bricks (no power-ups or debuffs) for pre-game view
        function createDisplayBricks() {
            bricks = [];
            for (let row = 0; row < brickConfig.rows; row++) {
                bricks[row] = [];
                for (let col = 0; col < brickConfig.cols; col++) {
                    bricks[row][col] = {
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop,
                        alive: true,
                        color: neonColors[row % neonColors.length],
                        powerUp: null,
                        debuff: null,
                        twinkleOffset: Math.random() * Math.PI * 2
                    };
                }
            }
        }

        // Initial setup - show plain bricks before game starts
        // Ball velocity normalized: 5.75 * 0.707 ‚âà 4.07 for 45-degree angle
        balls = [createBall(320, 447, 4.07, -4.07, 5.75)];
        createDisplayBricks(); // Plain bricks for display
        draw();
        
        // ========== HIGH SCORE SYSTEM ==========
        
        // ===== FIREBASE CONFIGURATION =====
        // BOO Website Game Leaderboard
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase (only if config is set)
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ===== PROFANITY FILTER =====
        // Common slurs and profanity in English, Spanish, French, German
        // This list is intentionally obfuscated and comprehensive
        const blockedPatterns = [
            // English
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i, /\bc+h+i+n+k/i,
            /\bs+p+i+c+/i, /\bk+i+k+e/i, /\bg+o+o+k/i, /\bw+e+t+b+a+c+k/i, /\btr+a+n+n+y/i,
            /\bd+y+k+e/i, /\bp+a+k+i/i, /\bt+w+a+t/i, /\bw+a+n+k/i, /\bp+r+i+c+k/i,
            /\bb+o+l+l+o+c+k/i, /\ba+r+s+e/i, /\bb+u+g+g+e+r/i, /\bc+r+a+p/i, /\bd+a+m+n/i,
            // Spanish  
            /\bp+u+t+a/i, /\bm+i+e+r+d+a/i, /\bc+a+b+r+[o√≥]+n/i, /\bp+e+n+d+e+j+o/i,
            /\bc+h+i+n+g+a/i, /\bj+o+d+e+r/i, /\bc+o+[√±n]+o/i, /\bm+a+r+i+c+[o√≥]+n/i,
            /\bn+e+g+r+o+.+m+i+e+r+d+a/i, /\bp+i+n+c+h+e/i,
            // French
            /\bm+e+r+d+e/i, /\bp+u+t+a+i+n/i, /\bs+a+l+o+p/i, /\bb+o+r+d+e+l/i,
            /\be+n+c+u+l+[e√©]/i, /\bn+[i√Æ]+q+u+e/i, /\bc+o+n+n+a+r+d/i, /\bb+i+t+e/i,
            /\bn+[√®e]+g+r+e/i,
            // German
            /\bs+c+h+e+i+[s√ü]+e/i, /\bf+i+c+k/i, /\bh+u+r+e/i, /\ba+r+s+c+h/i,
            /\bw+i+c+h+s/i, /\bs+c+h+l+a+m+p+e/i, /\bn+e+g+e+r/i, /\bk+a+n+a+k/i,
            // Hindi/Indian
            /b+h*e+n+.?c+h+o+d/i, /m+a+d+a*r+.?c+h+o+d/i, /c+h+u+t+i+y+a/i,
            /g+a+n+d+u/i, /l+u+n+d/i, /r+a+n+d+i/i, /h+a+r+a+m+i/i,
            /b+h+o+s+d+/i, /c+h+u+t+/i, /g+a+a+n+d/i, /l+o+d+e/i,
            // Numeric/Leet substitutions
            /n+[1i]+g+/i, /f+[4a]+g+/i, /a+[5s]+[5s]+/i, /[5s]+h+[1i]+t/i,
            /\b6+9+\b/, /\b4+2+0+\b/,
            // Catch common evasions
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i, /b.?h.?e.?n.?c.?h.?o.?d/i
        ];
        
        // Additional blocked exact words
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'nip', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'anus', 'homo',
            'bc', 'mc', 'lodu', 'chut', 'gand', 'lund', 'randi'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            
            // Normalize: lowercase, remove special chars except alphanumeric
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            
            // Check exact matches
            if (blockedExact.has(normalized)) return true;
            
            // Check patterns against both normalized and original
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function sanitizeUsername(name) {
            // Remove leading/trailing whitespace, limit to 12 chars, uppercase
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ===== SCORE SUBMISSION =====
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const finalLevelDisplay = document.getElementById('finalLevelDisplay');
        
        let pendingScore = 0;
        let pendingLevel = 1;
        
        async function showScoreModal(finalScore, finalLevel) {
            pendingScore = finalScore;
            pendingLevel = finalLevel;
            finalScoreDisplay.textContent = finalScore;
            finalLevelDisplay.textContent = finalLevel;
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
            submitScoreBtn.disabled = false;
            
            // Check rank against existing scores
            let rank = await getScoreRank(finalScore);
            
            // Update title based on rank
            if (rank === 1) {
                scoreModalTitle.textContent = "üëë YOU'RE #1 üëë";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'HIGH SCORE';
            }
            
            scoreModal.classList.add('active');
            
            // Focus input after brief delay (for mobile keyboards)
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        // Get the rank this score would achieve
        async function getScoreRank(playerScore) {
            try {
                let scores = [];
                
                if (typeof db !== 'undefined' && firebaseConfig.apiKey !== "YOUR_API_KEY") {
                    // Fetch from Firebase
                    const snapshot = await db.collection('highscores')
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => {
                        scores.push(doc.data().score);
                    });
                } else {
                    // Use local scores
                    const localScores = getLocalScores();
                    scores = localScores.map(s => s.score);
                }
                
                // Find where this score would rank
                let rank = 1;
                for (const existingScore of scores) {
                    if (playerScore <= existingScore) {
                        rank++;
                    } else {
                        break;
                    }
                }
                
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999; // Default to non-top-10 on error
            }
        }
        
        // Prevent score modal touches from propagating
        scoreModal.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true });
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
            
            // Show buttons after score modal closes (game over screen already drawn)
            if (!gameRunning) {
                showGameOverButtons();
            }
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            // Validation
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection('highscores').add({
                        name: username,
                        score: pendingScore,
                        level: pendingLevel,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    scoreErrorMsg.textContent = '';
                } else {
                    // Offline mode - save to localStorage
                    saveLocalScore(username, pendingScore, pendingLevel);
                }
                
                hideScoreModal();
                
            } catch (e) {
                console.warn('Score submission failed:', e);
                // Fallback to local storage
                saveLocalScore(username, pendingScore, pendingLevel);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        // Local storage fallback
        function saveLocalScore(name, score, level) {
            try {
                const scores = JSON.parse(localStorage.getItem('brickbreaker_scores') || '[]');
                scores.push({ name, score, level, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem('brickbreaker_scores', JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem('brickbreaker_scores') || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Event listeners for score modal
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            submitScore();
        }, { passive: false, capture: true });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideScoreModal();
        }, { passive: false, capture: true });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitScore();
            }
            if (e.key === 'Escape') {
                hideScoreModal();
            }
        });
        
        // Clear error on input
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ===== LEADERBOARD =====
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            try {
                let scores = [];
                
                if (firebaseReady && db) {
                    // Fetch from Firebase
                    const snapshot = await db.collection('highscores')
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    
                    snapshot.forEach(doc => {
                        scores.push(doc.data());
                    });
                } else {
                    // Use local scores
                    scores = getLocalScores();
                }
                
                renderLeaderboard(scores);
                
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                // Fallback to local
                renderLeaderboard(getLocalScores());
            }
        }
        
        function renderLeaderboard(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            scores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                        <div class="leaderboard-level">Lv.${entry.level}</div>
                    </div>
                `;
            });
            
            leaderboardList.innerHTML = html;
        }
        
        // Cached element for HTML escaping
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        leaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardClose.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true, capture: true });
        
        // Touch handler for close button (iOS Safari needs this)
        leaderboardClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideLeaderboard();
        }, { passive: false, capture: true });
        
        // Close leaderboard on overlay click/touch (not content)
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) {
                hideLeaderboard();
            }
        });
        
        // Prevent leaderboard touches from propagating to game
        leaderboardOverlay.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true });
        
        leaderboardOverlay.addEventListener('touchend', (e) => {
            if (e.target === leaderboardOverlay) {
                e.preventDefault();
                hideLeaderboard();
            }
        }, { passive: false });
    </script>
</body>
</html>
