<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Clyde's Big Jump</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Tilt+Neon&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            font-family: 'Bebas Neue', sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            position: relative;
            border-top: 3px solid #0ff;
            border-right: 3px solid #0ff;
            border-bottom: 3px solid #0ff;
            border-left: 3px solid #0ff;
            border-radius: 4px;
            background: #0a0a0a;
            box-sizing: content-box;
            overflow: visible;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        #gameCanvas {
            display: block;
            border-radius: 2px;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Overlay screens */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 10, 0.85);
            z-index: 10;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title {
            font-family: 'Tilt Neon', cursive;
            font-size: 42px;
            color: #ffaa00;
            text-shadow: 
                0 0 10px #ffaa00,
                0 0 20px #ffaa00,
                0 0 40px #ff6600;
            margin-bottom: 20px;
            letter-spacing: 4px;
            padding-left: 4px;
            text-align: center;
            width: 100%;
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% {
                text-shadow: 
                    0 0 10px #ffaa00,
                    0 0 20px #ffaa00,
                    0 0 40px #ff6600;
            }
            50% {
                text-shadow: 
                    0 0 15px #ffaa00,
                    0 0 30px #ffaa00,
                    0 0 60px #ff6600,
                    0 0 80px #0ff;
            }
        }

        .subtitle {
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }

        .score-display {
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 15px #fff;
            margin-bottom: 10px;
        }

        .high-score {
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 30px;
        }

        .btn {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 20px;
            padding: 4px 28px;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 4px;
            cursor: pointer;
            letter-spacing: 3px;
            text-shadow: 0 0 8px #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.2s ease;
            animation: btnPulse 2.5s ease-in-out infinite;
            -webkit-tap-highlight-color: transparent;
        }
        
        @keyframes btnPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), 0 0 35px rgba(0, 255, 255, 0.2);
            }
        }

        .btn:hover, .btn:active {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        /* Play, Restart, and Intro buttons with psychedelic color cycling */
        #startBtn, #restartBtn, #introBtn {
            animation: psychedelicBtn 4s ease-in-out infinite;
        }
        
        /* Intro button nudged down and taller */
        #introBtn {
            margin-top: 10px;
            padding-top: 10px;
            padding-bottom: 10px;
        }
        
        @keyframes psychedelicBtn {
            0% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff, 0 0 15px #0ff;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            }
            25% {
                color: #f0f;
                border-color: #f0f;
                text-shadow: 0 0 8px #f0f, 0 0 15px #f0f;
                box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
            }
            50% {
                color: #ff6600;
                border-color: #ff6600;
                text-shadow: 0 0 8px #ff6600, 0 0 15px #ff6600;
                box-shadow: 0 0 15px rgba(255, 102, 0, 0.4);
            }
            75% {
                color: #00ffcc;
                border-color: #00ffcc;
                text-shadow: 0 0 8px #00ffcc, 0 0 15px #00ffcc;
                box-shadow: 0 0 15px rgba(0, 255, 204, 0.4);
            }
            100% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff, 0 0 15px #0ff;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            }
        }
        
        #startBtn:hover, #startBtn:active,
        #restartBtn:hover, #restartBtn:active,
        #introBtn:hover, #introBtn:active {
            animation: psychedelicBtnFast 1s ease-in-out infinite;
            transform: scale(1.05);
        }
        
        @keyframes psychedelicBtnFast {
            0% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 12px #0ff, 0 0 25px #0ff;
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            }
            25% {
                color: #f0f;
                border-color: #f0f;
                text-shadow: 0 0 12px #f0f, 0 0 25px #f0f;
                box-shadow: 0 0 25px rgba(255, 0, 255, 0.6);
            }
            50% {
                color: #ff6600;
                border-color: #ff6600;
                text-shadow: 0 0 12px #ff6600, 0 0 25px #ff6600;
                box-shadow: 0 0 25px rgba(255, 102, 0, 0.6);
            }
            75% {
                color: #00ffcc;
                border-color: #00ffcc;
                text-shadow: 0 0 12px #00ffcc, 0 0 25px #00ffcc;
                box-shadow: 0 0 25px rgba(0, 255, 204, 0.6);
            }
            100% {
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 12px #0ff, 0 0 25px #0ff;
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            }
        }
        
        .btn-secondary {
            font-size: 16px;
            padding: 6px 24px;
        }
        
        .btn-secondary:hover, .btn-secondary:active {
            opacity: 1;
        }

        /* In-game HUD */
        .hud {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 36px;
            color: #fff;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 20px #ff00ff;
            z-index: 5;
            pointer-events: none;
            transition: transform 0.1s ease-out, text-shadow 0.1s ease, opacity 0.2s ease;
        }
        
        .hud.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .hud.pop {
            transform: scale(1.3);
            text-shadow: 
                0 0 15px #00ffcc,
                0 0 30px #00ffcc,
                0 0 45px #00ffcc;
        }

        .instructions {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            max-width: 200px;
            line-height: 1.4;
            margin-top: -8px;
        }
        
        /* Intro screen styles */
        .intro-cauldron {
            font-size: 56px;
            margin-bottom: 10px;
            animation: cauldronBob 2s ease-in-out infinite;
        }
        
        @keyframes cauldronBob {
            0%, 100% { transform: translateY(0) rotate(-3deg); }
            50% { transform: translateY(-8px) rotate(3deg); }
        }
        
        .intro-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 32px;
            color: #ffaa00;
            text-shadow: 
                0 0 10px #ffaa00,
                0 0 20px #ffaa00,
                0 0 40px #ff6600;
            margin-bottom: 15px;
            letter-spacing: 3px;
            padding-left: 3px;
            text-align: center;
            width: 100%;
            flex-shrink: 0;
        }
        
        /* Intro overlay needs special handling for scrollable content */
        #introScreen {
            padding: 15px 10px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            /* Use flex-start instead of center to prevent content cutoff */
            justify-content: flex-start;
            padding-top: 20px;
            padding-bottom: 20px;
        }
        
        /* Wrapper to help center content vertically when space allows */
        .intro-content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            /* Auto margins center when space allows, collapse when not */
            margin-top: auto;
            margin-bottom: auto;
            /* Ensure content doesn't get clipped */
            flex-shrink: 0;
        }
        
        .intro-story {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            font-size: 14px;
            color: #ddd;
            text-align: center;
            max-width: 95%;
            width: 100%;
            line-height: 1.5;
            margin-bottom: 20px;
            padding: 0 10px;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
            flex-shrink: 0;
        }
        
        .intro-tip {
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 0 0 10px #ffaa00;
            display: block;
            margin-top: 10px;
        }
        
        /* Mobile-specific intro screen adjustments */
        @media (max-height: 550px), (max-width: 380px) {
            .intro-title {
                font-size: 24px;
                margin-bottom: 10px;
            }
            .intro-story {
                font-size: 12px;
                line-height: 1.4;
                margin-bottom: 15px;
                padding: 0 8px;
            }
            #introScreen .btn {
                font-size: 18px;
                padding: 10px 30px;
            }
        }
        
        @media (max-height: 480px) {
            .intro-title {
                font-size: 20px;
                margin-bottom: 8px;
            }
            .intro-story {
                font-size: 11px;
                line-height: 1.35;
                margin-bottom: 12px;
            }
            #introScreen .btn {
                font-size: 16px;
                padding: 8px 25px;
            }
        }
        
        /* Mobile performance optimizations */
        @media (hover: none), (max-width: 768px) {
            .title, .intro-title {
                animation: none !important;
            }
            .btn {
                animation: none !important;
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            }
            #startBtn, #restartBtn, #introBtn {
                animation: none !important;
                color: #0ff;
                border-color: #0ff;
                text-shadow: 0 0 8px #0ff;
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            }
            .btn:hover, .btn:active {
                transform: none;
            }
            .intro-cauldron {
                animation: none !important;
            }
        }
        
        /* GPU acceleration hints */
        .game-container, .overlay, canvas {
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        /* ========== SCORE MODAL ========== */
        .score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 38px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
            text-align: center;
            margin-bottom: 0;
        }
        
        .score-modal-score {
            font-size: 26px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            text-align: center;
            margin-top: -4px;
        }
        
        .score-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        
        .score-input-label {
            font-size: 14px;
            color: #fff;
            opacity: 0.9;
        }
        
        .score-input {
            width: 200px;
            padding: 10px 14px;
            font-size: 16px;
            font-family: 'Bebas Neue', sans-serif;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }
        
        .score-input:focus {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-input.error {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.15);
            animation: inputShake 0.4s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }
        
        .score-error-msg {
            font-size: 12px;
            color: #ff3366;
            text-shadow: 0 0 8px #ff3366;
            min-height: 16px;
            text-align: center;
        }
        
        .score-buttons {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }
        
        .score-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 2px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .score-btn:active {
            transform: scale(0.98);
        }
        
        .score-btn-submit {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 255, 0.2));
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .score-btn-submit:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }
        
        .score-btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .score-btn-skip {
            background: rgba(255, 255, 255, 0.05);
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #aaa;
        }
        
        /* ========== LEADERBOARD OVERLAY ========== */
        .leaderboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .leaderboard-title {
            font-family: 'Tilt Neon', cursive;
            font-size: 28px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
        }
        
        .leaderboard-close {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .leaderboard-close:hover {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        .leaderboard-close:active {
            transform: scale(0.95);
            border-color: #0ff;
            color: #0ff;
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 10px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 4px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .leaderboard-row.top-3 {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.15), rgba(255, 102, 0, 0.1));
            border: 1px solid rgba(255, 170, 0, 0.3);
        }
        
        .leaderboard-rank {
            width: 40px;
            font-size: 16px;
            font-weight: bold;
            color: #888;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            color: #ffaa00;
            text-shadow: 0 0 8px #ffaa00;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .leaderboard-score {
            font-size: 16px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            min-width: 60px;
            text-align: right;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 16px;
        }
        
        .leaderboard-loading {
            color: #0ff;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
        
        /* Leaderboard button */
        .btn-leaderboard {
            margin-top: 12px;
            font-size: 16px;
            padding: 8px 20px;
            border-color: #ffaa00;
            color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
            animation: none;
        }
        
        .btn-leaderboard:hover, .btn-leaderboard:active {
            background: rgba(255, 170, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
        }
        
        @media (max-width: 500px) {
            .score-modal-title { font-size: 32px; }
            .score-modal-score { font-size: 22px; }
            .score-input { width: 180px; font-size: 16px; }
            .score-btn { padding: 10px 20px; font-size: 14px; }
            .leaderboard-title { font-size: 24px; }
            .leaderboard-row { padding: 8px 10px; }
            .leaderboard-name { font-size: 13px; }
            .leaderboard-score { font-size: 14px; min-width: 50px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div class="hud" id="hud">0</div>
        
        <!-- Start Screen -->
        <div class="overlay" id="startScreen">
            <div class="title">CLYDE'S BIG JUMP</div>
            <div class="subtitle">TAP TO JUMP</div>
            <p class="instructions">Tap, click, or press space to help Clyde reach the lake</p>
            <div style="margin-top: 30px; display: flex; flex-direction: column; align-items: center; gap: 12px;">
                <button class="btn" id="startBtn">PLAY</button>
                <button class="btn btn-leaderboard" id="leaderboardBtn">üèÜ LEADERBOARD</button>
                <button class="btn btn-secondary" id="backToIntroBtn">BACK TO STORY</button>
            </div>
        </div>
        
        <!-- Game Over Screen -->
        <div class="overlay hidden" id="gameOverScreen">
            <div class="title">GAME OVER</div>
            <div class="score-display" id="finalScore">SCORE: 0</div>
            <div class="high-score" id="highScore">BEST: 0</div>
            <button class="btn" id="restartBtn">RETRY</button>
            <button class="btn btn-leaderboard" id="leaderboardBtn2">üèÜ LEADERBOARD</button>
            <button class="btn btn-secondary" id="backToIntroBtn2">BACK TO STORY</button>
        </div>
        
        <!-- Intro Screen -->
        <div class="overlay" id="introScreen">
            <div class="intro-content-wrapper">
                <div class="intro-title">CLYDE'S BIG JUMP</div>
                <div class="intro-story">
                    Clyde is Joe's golden retriever, and he's been waiting ALL DAY for this moment. The lake is right there, shimmering in the summer sun!<br><br>
                    Though... there was something kinda funky about that cookie he snagged off the counter earlier. Everything's looking SO colorful now, and are those... giant mushrooms?! üçÑ<br><br>
                    No time to think about that, time to make the biggest splash of his life! üí¶<br><br>
                    <span class="intro-tip">ü¶¥ Tap to help Clyde bounce to victory! ü¶¥</span>
                </div>
                <button class="btn" id="introBtn">LET'S JUMP!</button>
            </div>
        </div>
    </div>
    
    <!-- Score Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-title" id="scoreModalTitle">HIGH SCORE</div>
        <div class="score-modal-score">Jumps: <span id="finalScoreDisplay">0</span></div>
        <div class="score-input-container">
            <label class="score-input-label">Enter your name for the leaderboard:</label>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME" autocomplete="off" spellcheck="false">
            <div class="score-error-msg" id="scoreErrorMsg"></div>
        </div>
        <div class="score-buttons">
            <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title">üêï TOP 100</div>
                <button class="leaderboard-close" id="leaderboardClose">‚úï</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <div class="leaderboard-loading">Loading scores...</div>
            </div>
        </div>
    </div>

    <script>
        // ===== BROWSER COMPATIBILITY =====
        window.requestAnimationFrame = window.requestAnimationFrame 
            || window.webkitRequestAnimationFrame 
            || window.mozRequestAnimationFrame 
            || window.msRequestAnimationFrame 
            || function(callback) { return setTimeout(callback, 16); };
        
        window.cancelAnimationFrame = window.cancelAnimationFrame
            || window.webkitCancelAnimationFrame
            || window.mozCancelAnimationFrame
            || window.msCancelAnimationFrame
            || function(id) { clearTimeout(id); };
        
        if (!window.performance) window.performance = {};
        if (!window.performance.now) {
            window.performance.now = function() { return Date.now(); };
        }
        
        // ===== PERFORMANCE DETECTION (more aggressive) =====
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                      || window.matchMedia('(hover: none)').matches
                      || window.matchMedia('(pointer: coarse)').matches
                      || ('ontouchstart' in window);
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isOldDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
        const hasSlowConnection = navigator.connection && (navigator.connection.saveData || navigator.connection.effectiveType === '2g' || navigator.connection.effectiveType === 'slow-2g');
        const isLowPerf = isMobile || isSafari || isIOS || isOldDevice || hasSlowConnection;
        
        const PERF = {
            particleMultiplier: isLowPerf ? 0.4 : 1.0,
            maxParticles: isLowPerf ? 10 : 30
        };

        // Canvas setup with Safari optimizations
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,  // Opaque canvas is faster
            desynchronized: true  // Reduce latency on supported browsers
        });
        
        // Responsive sizing
        function resizeCanvas() {
            const maxWidth = Math.min(400, window.innerWidth - 20);
            const maxHeight = Math.min(600, window.innerHeight - 20);
            const ratio = 400 / 600;
            
            if (maxWidth / maxHeight > ratio) {
                canvas.height = maxHeight;
                canvas.width = maxHeight * ratio;
            } else {
                canvas.width = maxWidth;
                canvas.height = maxWidth / ratio;
            }
            
            canvas.parentElement.style.width = canvas.width + 'px';
            canvas.parentElement.style.height = canvas.height + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameState = 'intro'; // 'intro', 'start', 'playing', 'gameover'
        let score = 0;
        let highScore = parseInt(localStorage.getItem('clydesBigJumpHigh') || '0');
        
        // Scale factor for responsive game
        const getScale = () => canvas.width / 400;

        // Bird
        const bird = {
            x: 80,
            y: 280,
            width: 70,
            height: 42,
            velocity: 0,
            gravity: 0.10,
            jumpStrength: -4.5,
            rotation: 0,
            wingAngle: 0,
            wingDir: 1
        };

        // Pipes
        let pipes = [];
        const pipeWidth = 52;
        const pipeGap = 220;
        const pipeSpeed = 1.0;
        let pipeSpawnTimer = 0;
        const pipeSpawnInterval = 300;

        // Particles for trail effect
        let particles = [];

        // Animation timing
        let animTime = 0;
        let lastFrameTime = performance.now();
        let frameCount = 0; // For particle frame skipping
        
        // ===== CACHED BACKGROUND GRID =====
        let bgGridCanvas = null;
        function createBgGridCache() {
            bgGridCanvas = document.createElement('canvas');
            bgGridCanvas.width = 400;
            bgGridCanvas.height = 600;
            const bgCtx = bgGridCanvas.getContext('2d');
            
            // Draw background
            bgCtx.fillStyle = '#0a0a0a';
            bgCtx.fillRect(0, 0, 400, 600);
            
            // Draw grid once
            bgCtx.strokeStyle = 'rgba(0, 255, 255, 0.04)';
            bgCtx.lineWidth = 1;
            const gridSpacing = isLowPerf ? 60 : 30;
            for (let x = 0; x < 400; x += gridSpacing) {
                bgCtx.beginPath(); bgCtx.moveTo(x, 0); bgCtx.lineTo(x, 600); bgCtx.stroke();
            }
            for (let y = 0; y < 600; y += gridSpacing) {
                bgCtx.beginPath(); bgCtx.moveTo(0, y); bgCtx.lineTo(400, y); bgCtx.stroke();
            }
        }
        createBgGridCache();
        
        // Background stars (reduced for mobile/Safari performance)
        const stars = [];
        const starCount = isLowPerf ? 3 : 8;
        for (let i = 0; i < starCount; i++) {
            stars.push({
                x: Math.random() * 400,
                y: Math.random() * 600,
                size: Math.random() * 1.5 + 0.5,
                color: ['#0ff', '#ff00ff', '#ff6600', '#00ffcc'][Math.floor(Math.random() * 4)]
            });
        }
        
        // Score pop animation
        let scorePop = 0;
        
        // Play time tracker for instructions
        let playTime = 0;
        
        // Touch throttling
        let lastTouchTime = 0;
        const TOUCH_THROTTLE = 50;

        // DOM elements
        const hud = document.getElementById('hud');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const introScreen = document.getElementById('introScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const highScoreEl = document.getElementById('highScore');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const introBtn = document.getElementById('introBtn');
        const backToIntroBtn = document.getElementById('backToIntroBtn');
        const backToIntroBtn2 = document.getElementById('backToIntroBtn2');
        
        // Hide start screen initially (intro shows first)
        startScreen.classList.add('hidden');
        // Hide HUD during intro/start screens
        hud.classList.add('hidden');

        // Reset game
        function resetGame() {
            bird.y = 280;
            bird.velocity = 0;
            bird.rotation = 0;
            bird.wingAngle = 0;
            pipes = [];
            particles = [];
            score = 0;
            scorePop = 0;
            pipeSpawnTimer = 0;
            playTime = 0;
            capColorSequence = 0;
            lastMushroom = { capColorIndex: -1, stemColorIndex: -1, spotPattern: '', stalkType: '', stalkPattern: '' };
            hud.textContent = '0';
        }

        // Start game
        function startGame() {
            resetGame();
            gameState = 'playing';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
        }

        // Game over
        function endGame() {
            gameState = 'gameover';
            hud.classList.add('hidden');
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('clydesBigJumpHigh', highScore.toString());
            }
            finalScoreEl.textContent = 'SCORE: ' + score;
            highScoreEl.textContent = 'BEST: ' + highScore;
            
            // Show score modal for leaderboard submission
            showScoreModal(score);
        }

        // Jump/flap
        function flap() {
            if (gameState === 'playing') {
                bird.velocity = bird.jumpStrength;
                bird.wingAngle = -25; // Trigger ear flap
                // Dust puff effect (reduced for mobile)
                const dustColors = ['#e8e8e8', '#d0d0d0', '#f0f0f0'];
                const dustCount = Math.floor(3 * PERF.particleMultiplier);
                for (let i = 0; i < dustCount; i++) {
                    if (particles.length >= PERF.maxParticles) break;
                    const angle = Math.PI + (i - 1) * 0.4;
                    particles.push({
                        x: bird.x - 5,
                        y: bird.y + bird.height / 2 + (i - 1) * 6,
                        vx: Math.cos(angle) * (1 + i * 0.3),
                        vy: Math.sin(angle) * 0.8 + (i - 1) * 0.5,
                        life: 0.8,
                        color: dustColors[i % dustColors.length],
                        size: 8 - i
                    });
                }
            }
        }

        // Spawn pipe with intelligent variety - each mushroom different from last
        function spawnPipe() {
            const minY = 100;
            const maxY = 600 - pipeGap - 100;
            const gapY = Math.random() * (maxY - minY) + minY;
            
            // Get values different from last mushroom
            const pattern = getDifferentFrom(spotPatternIds, lastMushroom.spotPattern);
            const stalkType = getDifferentFrom(stalkTypeIds, lastMushroom.stalkType);
            const stalkPattern = getDifferentFrom(stalkPatternIds, lastMushroom.stalkPattern);
            const capColorIndex = getNextCapColor();
            const stemColorIndex = getDifferentStemColor();
            
            // Update last mushroom tracking
            lastMushroom = {
                capColorIndex: capColorIndex,
                stemColorIndex: stemColorIndex,
                spotPattern: pattern,
                stalkType: stalkType,
                stalkPattern: stalkPattern
            };
            
            pipes.push({
                x: 400,
                gapY: gapY,
                pattern: pattern,
                stalkType: stalkType,
                stalkPattern: stalkPattern,
                capColorIndex: capColorIndex,
                stemColorIndex: stemColorIndex,
                topSpots: Math.floor(Math.random() * 8) + 1,
                topSpotColor: Math.floor(Math.random() * topSpotColors.length),
                highlightCount: [1, 2, 2, 3, 3, 3, 5, 5][Math.floor(Math.random() * 8)],
                scored: false
            });
        }

        // Update game
        function update(dt = 0.016) {
            animTime += dt;
            
            // Animate Clyde's floppy ears
            bird.wingAngle *= 0.9;
            
            // Clyde bobbing on non-playing screens
            if (gameState !== 'playing') {
                bird.y = 280 + Math.sin(animTime * 1.2) * 8;
                bird.rotation = Math.sin(animTime * 0.8) * 4;
            }
            
            // Score pop decay
            if (scorePop > 0) scorePop *= 0.9;
            
            if (gameState !== 'playing') return;

            // Increment play time with actual delta
            playTime += dt;

            const scale = getScale();

            // Bird physics
            bird.velocity += bird.gravity;
            if (bird.velocity > 3) bird.velocity = 3;
            bird.y += bird.velocity;
            
            // Smoother rotation
            const targetRotation = Math.min(Math.max(bird.velocity * 5, -20), 45);
            bird.rotation += (targetRotation - bird.rotation) * 0.08;

            // Boundary check
            if (bird.y < 0) {
                bird.y = 0;
                bird.velocity = 0;
            }
            if (bird.y + bird.height > 600) {
                endGame();
                return;
            }

            // Spawn pipes
            pipeSpawnTimer++;
            if (pipeSpawnTimer >= pipeSpawnInterval) {
                spawnPipe();
                pipeSpawnTimer = 0;
            }

            // Update pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= pipeSpeed;

                // Score
                if (!pipe.scored && pipe.x + pipeWidth < bird.x) {
                    pipe.scored = true;
                    score++;
                    hud.textContent = score.toString();
                    hud.classList.add('pop');
                    setTimeout(() => hud.classList.remove('pop'), 100);
                }

                // Remove off-screen pipes
                if (pipe.x + pipeWidth < 0) {
                    pipes.splice(i, 1);
                    continue;
                }

                // Collision detection (forgiving hitbox)
                const hitboxPadding = 8;
                if (bird.x + bird.width - hitboxPadding > pipe.x && bird.x + hitboxPadding < pipe.x + pipeWidth) {
                    if (bird.y + hitboxPadding < pipe.gapY || bird.y + bird.height - hitboxPadding > pipe.gapY + pipeGap) {
                        endGame();
                        return;
                    }
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.03;
                p.vx *= 0.96;
                p.life -= 0.035;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Enforce particle limit
            if (particles.length > PERF.maxParticles) {
                particles.length = PERF.maxParticles;
            }
        }

        // Psychedelic mushroom color palette
        const mushroomPalette = {
            caps: ['#ff00ff', '#0ff', '#ff6600', '#00ffcc', '#ff1493', '#9b30ff', '#00ff88', '#ff3366'],
            spots: ['#fff', '#fffef0', '#f8f8ff', '#fffff0', '#fafafa'],
            stems: ['#f5e6d3', '#e8d4c0', '#d4e8d4', '#e0d0e8', '#d8e4f0']
        };
        
        // Pattern IDs
        const spotPatternIds = ['classic-4', 'many-small', 'few-large', 'scattered-mix', 'dense-dots', 'giant-spot', 'asymmetric', 'minimal'];
        const stalkTypeIds = ['straight', 'stocky', 'tapered', 'bulge', 'lean-left', 'lean-right', 'banana-left', 'banana-right', 's-curve', 'wave', 'snake'];
        const stalkPatternIds = ['plain', 'small-spots', 'large-spots', 'scattered-spots', 'dense-specks'];
        
        // Track last spawned mushroom
        let lastMushroom = {
            capColorIndex: -1,
            stemColorIndex: -1,
            spotPattern: '',
            stalkType: '',
            stalkPattern: ''
        };
        
        let capColorSequence = 0;
        
        function getDifferentFrom(arr, lastValue) {
            const available = arr.filter(item => item !== lastValue);
            return available[Math.floor(Math.random() * available.length)];
        }
        
        function getNextCapColor() {
            capColorSequence = (capColorSequence + 1) % mushroomPalette.caps.length;
            return capColorSequence;
        }
        
        function getDifferentStemColor() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * mushroomPalette.stems.length);
            } while (newIndex === lastMushroom.stemColorIndex && mushroomPalette.stems.length > 1);
            return newIndex;
        }
        
        function getMushroomColors(colorIndex, stemIndex) {
            const capColor = mushroomPalette.caps[colorIndex];
            const spotIndex = Math.floor(Math.random() * mushroomPalette.spots.length);
            return {
                cap: capColor,
                capDark: shadeColor(capColor, -35),
                capLight: shadeColor(capColor, 45),
                spot: mushroomPalette.spots[spotIndex],
                stem: mushroomPalette.stems[stemIndex],
                stemDark: shadeColor(mushroomPalette.stems[stemIndex], -20),
                outline: shadeColor(capColor, -50)
            };
        }
        
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        function drawSpots(ctx, pattern, x, y, width, height, spotColor, isTop) {
            ctx.fillStyle = spotColor;
            const flip = isTop ? 1 : -1;
            const baseY = isTop ? y + height * 0.28 : y + height * 0.72;
            
            // Simplified spots on mobile - just draw 2-3 basic circles
            if (isLowPerf) {
                ctx.beginPath(); ctx.arc(x - width * 0.15, baseY, 8, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + width * 0.18, baseY - height * 0.04 * flip, 7, 0, Math.PI * 2); ctx.fill();
                return;
            }
            
            switch(pattern) {
                case 'classic-4':
                    ctx.beginPath(); ctx.arc(x - width * 0.22, baseY - height * 0.02 * flip, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, baseY - height * 0.1 * flip, 7, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.02, baseY + height * 0.08 * flip, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, baseY + height * 0.02 * flip, 6, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'many-small':
                    const smallSpots = [[-0.28, -0.04, 4], [-0.14, -0.1, 3], [0.02, -0.06, 4], [0.18, -0.02, 3], [0.30, 0.04, 3], [-0.20, 0.08, 3], [0.0, 0.1, 4], [0.14, 0.08, 3], [-0.06, 0.02, 3]];
                    smallSpots.forEach(([ox, oy, r]) => { ctx.beginPath(); ctx.arc(x + width * ox, baseY + height * oy * flip, r, 0, Math.PI * 2); ctx.fill(); });
                    break;
                case 'few-large':
                    ctx.beginPath(); ctx.arc(x - width * 0.15, baseY, 12, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, baseY - height * 0.04 * flip, 11, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.02, baseY + height * 0.1 * flip, 9, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'scattered-mix':
                    ctx.beginPath(); ctx.arc(x - width * 0.18, baseY - height * 0.02 * flip, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.2, baseY + height * 0.04 * flip, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.02, baseY - height * 0.08 * flip, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.06, baseY + height * 0.1 * flip, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.30, baseY - height * 0.04 * flip, 4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'dense-dots':
                    const denseSpots = [[-0.26, -0.06, 3], [-0.16, -0.02, 3], [-0.06, -0.08, 3], [0.04, -0.04, 3], [0.14, 0.0, 3], [0.24, -0.06, 3], [-0.22, 0.06, 3], [-0.10, 0.1, 3], [0.0, 0.06, 3], [0.12, 0.1, 3], [0.22, 0.04, 3], [0.30, 0.08, 3]];
                    denseSpots.forEach(([ox, oy, r]) => { ctx.beginPath(); ctx.arc(x + width * ox, baseY + height * oy * flip, r, 0, Math.PI * 2); ctx.fill(); });
                    break;
                case 'giant-spot':
                    ctx.beginPath(); ctx.arc(x - width * 0.05, baseY, 14, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, baseY - height * 0.06 * flip, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.26, baseY + height * 0.06 * flip, 4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'asymmetric':
                    ctx.beginPath(); ctx.ellipse(x - width * 0.2, baseY - height * 0.04 * flip, 10, 7, 0.3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(x + width * 0.15, baseY + height * 0.02 * flip, 7, 9, -0.2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, baseY - height * 0.08 * flip, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.02, baseY + height * 0.1 * flip, 4, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'minimal':
                    ctx.beginPath(); ctx.arc(x - width * 0.12, baseY - height * 0.02 * flip, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.16, baseY + height * 0.04 * flip, 5, 0, Math.PI * 2); ctx.fill();
                    break;
            }
        }

        // Top spot colors
        const topSpotColors = ['#fff', '#9b30ff', '#ff3366', '#fff', '#ff00ff', '#fff'];
        
        // Draw cap highlights (shiny spots)
        function drawCapHighlights(ctx, centerX, capY, capWidth, capHeight, highlightCount, color, isTop) {
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5;
            
            const yOffset = isTop ? capHeight * 0.28 : capHeight * 0.22;
            
            switch(highlightCount) {
                case 1:
                    // Single highlight (original)
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.15, capY + yOffset, capWidth * 0.18, capHeight * 0.12, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 2:
                    // Two highlights
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.22, capY + yOffset, capWidth * 0.12, capHeight * 0.09, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.08, capY + yOffset - 2, capWidth * 0.1, capHeight * 0.08, 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 3:
                    // Three highlights
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.25, capY + yOffset, capWidth * 0.1, capHeight * 0.08, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.05, capY + yOffset - 3, capWidth * 0.12, capHeight * 0.09, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.18, capY + yOffset + 2, capWidth * 0.08, capHeight * 0.06, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 5:
                    // Five highlights scattered
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.28, capY + yOffset + 2, capWidth * 0.08, capHeight * 0.06, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.12, capY + yOffset - 2, capWidth * 0.1, capHeight * 0.08, -0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.02, capY + yOffset, capWidth * 0.07, capHeight * 0.05, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.15, capY + yOffset - 1, capWidth * 0.09, capHeight * 0.07, 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX + capWidth * 0.28, capY + yOffset + 3, capWidth * 0.06, capHeight * 0.05, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                default:
                    // Fallback single
                    ctx.beginPath();
                    ctx.ellipse(centerX - capWidth * 0.15, capY + yOffset, capWidth * 0.18, capHeight * 0.12, -0.3, 0, Math.PI * 2);
                    ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }
        
        function drawTopSpots(ctx, variant, x, capY, width, height, isTop, colorIndex) {
            if (variant === 0 || isLowPerf) return; // Skip on mobile for performance
            ctx.fillStyle = topSpotColors[colorIndex] || '#fff';
            const spotY = isTop ? capY + 8 : capY + height - 8;
            switch(variant) {
                case 1: // 2 spots
                    ctx.beginPath(); ctx.arc(x - width * 0.1, spotY, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.15, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 2: // 3 spots
                    ctx.beginPath(); ctx.arc(x - width * 0.18, spotY + 4, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.05, spotY, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, spotY + 5, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 3: // 1 big + 1 small
                    ctx.beginPath(); ctx.arc(x - width * 0.05, spotY + 2, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, spotY + 5, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 4: // 4 spots
                    ctx.beginPath(); ctx.arc(x - width * 0.2, spotY + 5, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.05, spotY, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.1, spotY + 6, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 5: // 5 spots scattered
                    ctx.beginPath(); ctx.arc(x - width * 0.25, spotY + 2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.1, spotY + 5, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.02, spotY + 1, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.15, spotY + 6, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    break;
                case 6: // 6 spots dense
                    ctx.beginPath(); ctx.arc(x - width * 0.22, spotY + 3, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.08, spotY, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.06, spotY + 5, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.18, spotY + 2, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x - width * 0.15, spotY + 7, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.28, spotY + 6, 2, 0, Math.PI * 2); ctx.fill();
                    break;
                case 7: // many tiny spots
                    for (let i = 0; i < 8; i++) {
                        const ox = (i - 3.5) * width * 0.08;
                        const oy = (i % 2) * 4 + 2;
                        ctx.beginPath(); ctx.arc(x + ox, spotY + oy, 2, 0, Math.PI * 2); ctx.fill();
                    }
                    break;
                case 8: // 3 big spots
                    ctx.beginPath(); ctx.arc(x - width * 0.15, spotY + 3, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.05, spotY + 1, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x + width * 0.22, spotY + 5, 4, 0, Math.PI * 2); ctx.fill();
                    break;
            }
        }

        function drawStalk(ctx, centerX, startY, endY, baseWidth, colors, stalkType, stalkPattern, isTop) {
            const w = baseWidth;
            const h = Math.abs(endY - startY);
            ctx.fillStyle = colors.stem;
            ctx.beginPath();
            
            // All stalks use simple quadratic curves - no complex shapes
            switch(stalkType) {
                case 'straight':
                    // Slight lean to the right
                    const slightR = w * 0.3;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX + slightR, (startY + endY) / 2, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX + slightR + w, (startY + endY) / 2, centerX + w/2, startY);
                    break;
                    
                case 'stocky':
                    // Wide chunky stalk with slight lean left
                    const wide = w * 1.6;
                    const slightL = wide * 0.2;
                    ctx.moveTo(centerX - wide/2, startY);
                    ctx.quadraticCurveTo(centerX - slightL, (startY + endY) / 2, centerX - wide/2, endY);
                    ctx.lineTo(centerX + wide/2, endY);
                    ctx.quadraticCurveTo(centerX - slightL + wide, (startY + endY) / 2, centerX + wide/2, startY);
                    break;
                    
                case 'tapered':
                    // Wider at cap, narrower at edge, with slight curve
                    const tapLean = w * 0.25;
                    if (isTop) {
                        ctx.moveTo(centerX - w/2 - 8, startY);
                        ctx.quadraticCurveTo(centerX - tapLean, (startY + endY) / 2, centerX - w/2, endY);
                        ctx.lineTo(centerX + w/2, endY);
                        ctx.quadraticCurveTo(centerX - tapLean + w + 8, (startY + endY) / 2, centerX + w/2 + 8, startY);
                    } else {
                        ctx.moveTo(centerX - w/2, startY);
                        ctx.quadraticCurveTo(centerX + tapLean, (startY + endY) / 2, centerX - w/2 - 8, endY);
                        ctx.lineTo(centerX + w/2 + 8, endY);
                        ctx.quadraticCurveTo(centerX + tapLean + w, (startY + endY) / 2, centerX + w/2, startY);
                    }
                    break;
                    
                case 'bulge':
                    // Bulges outward in middle
                    const bulge = w * 0.5;
                    const midY = (startY + endY) / 2;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX - w/2 - bulge, midY, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX + w/2 + bulge, midY, centerX + w/2, startY);
                    break;
                    
                case 'lean-left':
                    // Gentle lean to the left
                    const leanL = w * 0.5;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX - leanL, (startY + endY) / 2, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX - leanL + w, (startY + endY) / 2, centerX + w/2, startY);
                    break;
                    
                case 'lean-right':
                    // Gentle lean to the right
                    const leanR = w * 0.5;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX + leanR, (startY + endY) / 2, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX + leanR + w, (startY + endY) / 2, centerX + w/2, startY);
                    break;
                    
                case 'banana-left':
                    // Curve to the left
                    const bananaL = w * 1.5;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX - bananaL, (startY + endY) / 2, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX - bananaL + w, (startY + endY) / 2, centerX + w/2, startY);
                    break;
                    
                case 'banana-right':
                    // Curve to the right
                    const bananaR = w * 1.5;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX + bananaR, (startY + endY) / 2, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX + bananaR + w, (startY + endY) / 2, centerX + w/2, startY);
                    break;
                    
                case 's-curve':
                    // S-shaped curve - left then right
                    const sAmt = w * 1.0;
                    const third = h / 3;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX - sAmt, startY + third, centerX - w/2, startY + third * 1.5);
                    ctx.quadraticCurveTo(centerX + sAmt, startY + third * 2, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX + sAmt + w, startY + third * 2, centerX + w/2, startY + third * 1.5);
                    ctx.quadraticCurveTo(centerX - sAmt + w, startY + third, centerX + w/2, startY);
                    break;
                    
                case 'wave':
                    // Gentle wave - right then left
                    const wAmt = w * 0.8;
                    const wThird = h / 3;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX + wAmt, startY + wThird, centerX - w/2, startY + wThird * 1.5);
                    ctx.quadraticCurveTo(centerX - wAmt, startY + wThird * 2, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX - wAmt + w, startY + wThird * 2, centerX + w/2, startY + wThird * 1.5);
                    ctx.quadraticCurveTo(centerX + wAmt + w, startY + wThird, centerX + w/2, startY);
                    break;
                    
                case 'snake':
                    // Triple curve like a snake
                    const snk = w * 0.7;
                    const quarter = h / 4;
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.quadraticCurveTo(centerX - snk, startY + quarter * 0.5, centerX - w/2, startY + quarter);
                    ctx.quadraticCurveTo(centerX + snk, startY + quarter * 2, centerX - w/2, startY + quarter * 3);
                    ctx.quadraticCurveTo(centerX - snk, startY + quarter * 3.5, centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.quadraticCurveTo(centerX - snk + w, startY + quarter * 3.5, centerX + w/2, startY + quarter * 3);
                    ctx.quadraticCurveTo(centerX + snk + w, startY + quarter * 2, centerX + w/2, startY + quarter);
                    ctx.quadraticCurveTo(centerX - snk + w, startY + quarter * 0.5, centerX + w/2, startY);
                    break;
                    
                default:
                    // Fallback to straight
                    ctx.moveTo(centerX - w/2, startY);
                    ctx.lineTo(centerX - w/2, endY);
                    ctx.lineTo(centerX + w/2, endY);
                    ctx.lineTo(centerX + w/2, startY);
            }
            
            ctx.closePath();
            ctx.fill();
            
            // Draw stalk pattern (simplified on mobile)
            const stalkHeight = h;
            const stemWidth = w; // For pattern compatibility
            
            // Skip complex stalk patterns on mobile for performance
            if (isLowPerf && stalkPattern !== 'plain') {
                // Just use plain on mobile for performance
            } else {
                switch(stalkPattern) {
                    case 'plain': break;
                    case 'small-spots':
                        ctx.fillStyle = '#fff';
                        const smallCount = Math.floor(stalkHeight / 45);
                        for (let i = 0; i < smallCount; i++) { const spotY = startY + 20 + i * 45; const spotX = centerX + (i % 2 === 0 ? -5 : 5); ctx.beginPath(); ctx.arc(spotX, spotY, 3, 0, Math.PI * 2); ctx.fill(); }
                        break;
                    case 'large-spots':
                        ctx.fillStyle = '#fff';
                        const largeCount = Math.floor(stalkHeight / 70);
                        for (let i = 0; i < largeCount; i++) { const spotY = startY + 35 + i * 70; const spotX = centerX + (i % 2 === 0 ? -4 : 4); ctx.beginPath(); ctx.arc(spotX, spotY, 6, 0, Math.PI * 2); ctx.fill(); }
                        break;
                    case 'scattered-spots':
                        ctx.fillStyle = '#fff';
                        const scatterCount = Math.floor(stalkHeight / 35);
                        for (let i = 0; i < scatterCount; i++) { const spotY = startY + 15 + i * 35; const offsetX = ((i * 7) % 11) - 5; const size = 2 + (i % 3); ctx.beginPath(); ctx.arc(centerX + offsetX, spotY, size, 0, Math.PI * 2); ctx.fill(); }
                        break;
                    case 'dense-specks':
                        ctx.fillStyle = '#fff';
                        const speckCount = Math.floor(stalkHeight / 20);
                        for (let i = 0; i < speckCount; i++) { const spotY = startY + 10 + i * 20; const offsetX = ((i * 5) % 9) - 4; ctx.beginPath(); ctx.arc(centerX + offsetX, spotY, 2, 0, Math.PI * 2); ctx.fill(); }
                        break;
                }
            }
        }

        function drawPixelMushroom(ctx, x, gapY, pipe, isTop) {
            const capWidth = 95;
            const capHeight = 48;
            const stemWidth = 26;
            const colors = getMushroomColors(pipe.capColorIndex, pipe.stemColorIndex);
            const pattern = pipe.pattern || 'classic-4';
            const stalkType = pipe.stalkType || 'straight';
            const stalkPattern = pipe.stalkPattern || 'plain';
            const topSpots = pipe.topSpots || 0;
            const topSpotColor = pipe.topSpotColor || 0;
            const highlightCount = pipe.highlightCount || 1;
            const centerX = x + pipeWidth / 2;
            
            if (isTop) {
                const capY = gapY - capHeight;
                drawStalk(ctx, centerX, 0, capY + 12, stemWidth, colors, stalkType, stalkPattern, true);
                ctx.strokeStyle = colors.outline; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2, capWidth/2 + 2, capHeight/2 + 2, 0, 0, Math.PI * 2); ctx.stroke();
                ctx.fillStyle = colors.cap;
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/2, 0, 0, Math.PI); ctx.fill();
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/3, 0, Math.PI, Math.PI * 2); ctx.fill();
                ctx.fillStyle = colors.capDark;
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2 + 4, capWidth/2 - 4, 10, 0, 0, Math.PI); ctx.fill();
                drawSpots(ctx, pattern, centerX, capY, capWidth, capHeight, colors.spot, true);
                drawCapHighlights(ctx, centerX, capY, capWidth, capHeight, highlightCount, colors.capLight, true);
                drawTopSpots(ctx, topSpots, centerX, capY, capWidth, capHeight, true, topSpotColor);
            } else {
                const capY = gapY;
                drawStalk(ctx, centerX, capY + capHeight - 12, 600, stemWidth, colors, stalkType, stalkPattern, false);
                ctx.strokeStyle = colors.outline; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2, capWidth/2 + 2, capHeight/2 + 2, 0, 0, Math.PI * 2); ctx.stroke();
                ctx.fillStyle = colors.cap;
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/2, 0, Math.PI, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2, capWidth/2, capHeight/3, 0, 0, Math.PI); ctx.fill();
                ctx.fillStyle = colors.capDark;
                ctx.beginPath(); ctx.ellipse(centerX, capY + capHeight/2 + 4, capWidth/2 - 4, 10, 0, 0, Math.PI); ctx.fill();
                drawSpots(ctx, pattern, centerX, capY, capWidth, capHeight, colors.spot, false);
                drawCapHighlights(ctx, centerX, capY, capWidth, capHeight, highlightCount, colors.capLight, false);
                drawTopSpots(ctx, topSpots, centerX, capY, capWidth, capHeight, false, topSpotColor);
            }
        }

        // Draw game
        function draw() {
            const scale = getScale();
            ctx.save();
            ctx.scale(scale, scale);

            // Use cached background with grid (much faster than drawing every frame)
            ctx.drawImage(bgGridCanvas, 0, 0);
            
            // Stars
            ctx.globalAlpha = 0.6;
            stars.forEach(star => { ctx.fillStyle = star.color; ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill(); });
            ctx.globalAlpha = 1;

            // Particles - skip frames on mobile for performance
            if (!isLowPerf || frameCount % 2 === 0) {
                particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill(); });
                ctx.globalAlpha = 1;
            }

            // Mushrooms
            pipes.forEach((pipe) => {
                drawPixelMushroom(ctx, pipe.x, pipe.gapY, pipe, true);
                drawPixelMushroom(ctx, pipe.x, pipe.gapY + pipeGap, pipe, false);
            });

            // Draw Clyde
            ctx.save();
            ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
            ctx.rotate(bird.rotation * Math.PI / 180);
            ctx.scale(1.4, 1.4);

            const earFlap = bird.wingAngle * 2 + Math.sin(animTime * 3) * 3;
            
            // Tail
            const wagAngle = Math.sin(animTime * 10) * 20;
            ctx.save();
            ctx.translate(-24, 0);
            ctx.rotate((wagAngle - 50) * Math.PI / 180);
            ctx.fillStyle = '#d9a840';
            ctx.beginPath();
            ctx.moveTo(0, 6); ctx.quadraticCurveTo(-5, 2, -4, -6); ctx.quadraticCurveTo(-3, -12, -1, -18); ctx.quadraticCurveTo(0, -20, 1, -18); ctx.quadraticCurveTo(3, -12, 4, -6); ctx.quadraticCurveTo(5, 2, 0, 6);
            ctx.fill();
            ctx.restore();
            
            // Back legs
            ctx.fillStyle = '#d9a850';
            const legSwing = Math.sin(animTime * 4) * 6;
            
            ctx.save();
            ctx.translate(-14, 6);
            ctx.rotate((legSwing + 10) * Math.PI / 180);
            ctx.beginPath(); ctx.roundRect(-3, 0, 7, 18, 3); ctx.fill();
            ctx.fillStyle = '#d9a850'; ctx.beginPath(); ctx.ellipse(0, 20, 5, 4, 0, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
            
            ctx.fillStyle = '#d9a850';
            ctx.save();
            ctx.translate(-8, 6);
            ctx.rotate((-legSwing + 15) * Math.PI / 180);
            ctx.beginPath(); ctx.roundRect(-3, 0, 7, 18, 3); ctx.fill();
            ctx.fillStyle = '#d9a850'; ctx.beginPath(); ctx.ellipse(0, 20, 5, 4, 0, 0, Math.PI * 2); ctx.fill();
            ctx.restore();

            // Body
            ctx.fillStyle = '#e8b84a';
            ctx.beginPath(); ctx.ellipse(0, 4, 22, 12, 0, 0, Math.PI * 2); ctx.fill();
            
            // Front legs
            ctx.fillStyle = '#d9a850';
            const frontLegSwing = Math.sin(animTime * 4 + Math.PI) * 8;
            
            ctx.save();
            ctx.translate(8, 6);
            ctx.rotate((frontLegSwing - 5) * Math.PI / 180);
            ctx.beginPath(); ctx.roundRect(-3, 0, 7, 18, 3); ctx.fill();
            ctx.fillStyle = '#d9a850'; ctx.beginPath(); ctx.ellipse(0, 20, 5, 4, 0, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
            
            ctx.fillStyle = '#d9a850';
            ctx.save();
            ctx.translate(14, 6);
            ctx.rotate((-frontLegSwing - 5) * Math.PI / 180);
            ctx.beginPath(); ctx.roundRect(-3, 0, 7, 18, 3); ctx.fill();
            ctx.fillStyle = '#d9a850'; ctx.beginPath(); ctx.ellipse(0, 20, 5, 4, 0, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
            
            // Head
            ctx.fillStyle = '#e8b84a';
            ctx.beginPath(); ctx.ellipse(18, -6, 13, 12, 0.1, 0, Math.PI * 2); ctx.fill();
            
            // Snout
            ctx.fillStyle = '#f0c860';
            ctx.beginPath(); ctx.ellipse(30, -2, 9, 6, 0, 0, Math.PI * 2); ctx.fill();
            
            // Nose
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath(); ctx.ellipse(36, -3, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#555';
            ctx.beginPath(); ctx.ellipse(35, -4.5, 1.5, 1, 0, 0, Math.PI * 2); ctx.fill();
            
            // Mouth
            ctx.fillStyle = '#2a1a10';
            ctx.beginPath(); ctx.ellipse(32, 3, 5, 3, 0.1, 0, Math.PI); ctx.fill();
            
            // Tongue
            const tongueOut = (Math.sin(animTime * 2) + 1) * 0.5;
            const tongueLength = 4 + tongueOut * 5;
            ctx.save();
            ctx.translate(26, 3);
            ctx.rotate(-30 * Math.PI / 180);
            ctx.fillStyle = '#ff7b9a';
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.quadraticCurveTo(2, tongueLength * 0.5, 0, tongueLength); ctx.quadraticCurveTo(-3, tongueLength, -3, tongueLength * 0.5); ctx.quadraticCurveTo(-2, 0, 0, 0);
            ctx.fill();
            ctx.restore();
            
            ctx.fillStyle = '#f0c860';
            ctx.beginPath(); ctx.ellipse(30, 1, 6, 3, 0, 0, Math.PI); ctx.fill();
            
            // Eye
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.ellipse(22, -8, 4, 5, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#3d2010';
            ctx.beginPath(); ctx.ellipse(23, -7.5, 2.5, 3, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#1a0a00';
            ctx.beginPath(); ctx.ellipse(23.5, -7, 1.5, 2, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(24.5, -9, 1.5, 0, Math.PI * 2); ctx.fill();
            
            // Eyebrow
            ctx.strokeStyle = '#a86830'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(22, -12, 5, Math.PI * 1.2, Math.PI * 1.7); ctx.stroke();
            
            // Floppy ear
            ctx.fillStyle = '#c9874d';
            ctx.save();
            ctx.translate(10, -8);
            ctx.rotate((-earFlap + 15) * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.quadraticCurveTo(11, 7, 9, 16); ctx.quadraticCurveTo(6, 21, 1, 18); ctx.quadraticCurveTo(-4, 12, 0, 0);
            ctx.fill();
            ctx.fillStyle = '#a86830';
            ctx.beginPath();
            ctx.moveTo(1, 3); ctx.quadraticCurveTo(6, 8, 5, 13); ctx.quadraticCurveTo(4, 15, 2, 13); ctx.quadraticCurveTo(0, 9, 1, 3);
            ctx.fill();
            ctx.restore();

            ctx.restore();

            // Ground line
            ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, 598); ctx.lineTo(400, 598); ctx.stroke();
            
            // Instructions
            if (gameState === 'playing' && playTime < 5) {
                const fadeOpacity = playTime < 3 ? 1 : 1 - (playTime - 3) / 2;
                ctx.globalAlpha = fadeOpacity;
                ctx.fillStyle = '#fff';
                ctx.font = '24px "Bebas Neue", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('KEEP TAPPING...', bird.x + bird.width / 2, bird.y - 35);
                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }

        // Game loop with proper delta time
        function gameLoop(currentTime) {
            // Calculate delta time (capped to prevent huge jumps)
            const deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.1);
            lastFrameTime = currentTime;
            frameCount++;
            
            // Only do heavy updates/draws when actually playing
            if (gameState === 'playing') {
                update(deltaTime);
                draw();
            } else {
                update(deltaTime); // Still update for bobbing animation
                drawMenuBackground();
            }
            requestAnimationFrame(gameLoop);
        }
        
        // Lightweight background for menu screens
        function drawMenuBackground() {
            const scale = getScale();
            ctx.save();
            ctx.scale(scale, scale);
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 400, 600);
            
            // Just stars, no grid on menus
            ctx.globalAlpha = 0.6;
            stars.forEach(star => {
                ctx.fillStyle = star.color;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        // Event listeners
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        
        introBtn.addEventListener('click', () => {
            introScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            gameState = 'start';
        });
        
        backToIntroBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            introScreen.classList.remove('hidden');
            gameState = 'intro';
        });
        
        backToIntroBtn2.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            introScreen.classList.remove('hidden');
            gameState = 'intro';
        });

        // Input handlers with throttling
        function handleInput(e) {
            e.preventDefault();
            const now = performance.now();
            if (now - lastTouchTime < TOUCH_THROTTLE) return;
            lastTouchTime = now;
            if (gameState === 'playing') flap();
        }

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', handleInput, { passive: false });
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'intro') {
                    introScreen.classList.add('hidden');
                    startScreen.classList.remove('hidden');
                    gameState = 'start';
                } else if (gameState === 'start') {
                    startGame();
                } else if (gameState === 'playing') {
                    flap();
                } else if (gameState === 'gameover') {
                    startGame();
                }
            }
        });

        // Start loop
        requestAnimationFrame(gameLoop);
        
        // ========== FIREBASE LEADERBOARD SYSTEM ==========
        
        // Firebase Configuration (same project, different collection)
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Collection name for THIS game
        const COLLECTION_NAME = 'clydes_jump_scores';
        const LOCAL_STORAGE_KEY = 'clydes_jump_scores';
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ===== PROFANITY FILTER =====
        const blockedPatterns = [
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i, /\bc+h+i+n+k/i,
            /\bs+p+i+c+/i, /\bk+i+k+e/i, /\bg+o+o+k/i, /\bw+e+t+b+a+c+k/i, /\btr+a+n+n+y/i,
            /\bd+y+k+e/i, /\bp+a+k+i/i, /\bt+w+a+t/i, /\bw+a+n+k/i, /\bp+r+i+c+k/i,
            /\bb+o+l+l+o+c+k/i, /\ba+r+s+e/i, /\bb+u+g+g+e+r/i, /\bc+r+a+p/i, /\bd+a+m+n/i,
            /\bp+u+t+a/i, /\bm+i+e+r+d+a/i, /\bc+a+b+r+[o√≥]+n/i, /\bp+e+n+d+e+j+o/i,
            /\bc+h+i+n+g+a/i, /\bj+o+d+e+r/i, /\bm+a+r+i+c+[o√≥]+n/i,
            /\bm+e+r+d+e/i, /\bp+u+t+a+i+n/i, /\bs+a+l+o+p/i,
            /\bs+c+h+e+i+[s√ü]+e/i, /\bf+i+c+k/i, /\bh+u+r+e/i, /\ba+r+s+c+h/i,
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i
        ];
        
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'nip', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'anus', 'homo'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            if (blockedExact.has(normalized)) return true;
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) return true;
            }
            return false;
        }
        
        function sanitizeUsername(name) {
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ===== SCORE MODAL =====
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        
        let pendingScore = 0;
        
        async function showScoreModal(finalScore) {
            pendingScore = finalScore;
            finalScoreDisplay.textContent = finalScore;
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'Submit';
            
            // Check rank
            let rank = await getScoreRank(finalScore);
            
            if (rank === 1) {
                scoreModalTitle.textContent = "üêï TOP DOG! üêï";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'GOOD BOY!';
            }
            
            scoreModal.classList.add('active');
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        async function getScoreRank(playerScore) {
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data().score));
                } else {
                    scores = getLocalScores().map(s => s.score);
                }
                
                let rank = 1;
                for (const existingScore of scores) {
                    if (playerScore <= existingScore) rank++;
                    else break;
                }
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999;
            }
        }
        
        scoreModal.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
            gameOverScreen.classList.remove('hidden');
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection(COLLECTION_NAME).add({
                        name: username,
                        score: pendingScore,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } else {
                    saveLocalScore(username, pendingScore);
                }
                hideScoreModal();
            } catch (e) {
                console.warn('Score submission failed:', e);
                saveLocalScore(username, pendingScore);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        // Local storage fallback
        function saveLocalScore(name, score) {
            try {
                const scores = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
                scores.push({ name, score, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Score modal event listeners
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            submitScore();
        }, { passive: false, capture: true });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideScoreModal();
        }, { passive: false, capture: true });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); submitScore(); }
            if (e.key === 'Escape') { hideScoreModal(); }
        });
        
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ===== LEADERBOARD =====
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const leaderboardBtn2 = document.getElementById('leaderboardBtn2');
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data()));
                } else {
                    scores = getLocalScores();
                }
                renderLeaderboard(scores);
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                renderLeaderboard(getLocalScores());
            }
        }
        
        function renderLeaderboard(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            scores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                    </div>
                `;
            });
            leaderboardList.innerHTML = html;
        }
        
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        // Leaderboard button listeners
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardBtn2.addEventListener('click', showLeaderboard);
        leaderboardBtn2.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) hideLeaderboard();
        });
        
        leaderboardOverlay.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        leaderboardOverlay.addEventListener('touchend', (e) => {
            if (e.target === leaderboardOverlay) {
                e.preventDefault();
                hideLeaderboard();
            }
        }, { passive: false });
    </script>
</body>
</html>
