<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Brickbreaker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding-bottom: 8px;
            max-width: 100%;
            transform: translateZ(0);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Fixed-height container for button to prevent layout shift */
        .button-container {
            height: 42px; /* Fixed height matches button height */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #gameCanvas {
            border: 3px solid #0ff;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            max-width: 100%;
            height: auto;
            touch-action: none;
            /* GPU acceleration */
            transform: translateZ(0);
            will-change: contents;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* Mobile optimizations */
        @media (max-width: 800px), (hover: none) {
            #gameCanvas {
                box-shadow: 0 0 10px #0ff;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                transition-duration: 0.01ms !important;
            }
        }

        .power-up-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 4px;
            min-height: 60px; /* Fixed height for max 3 powerups */
            height: 60px;
            margin-top: -3px;
            overflow: hidden;
        }
        
        .power-up-bar span {
            display: block;
            white-space: nowrap;
            line-height: 1.2;
        }

        .hud {
            display: flex;
            gap: 25px;
            color: #fff;
            font-size: 16px;
            text-shadow: 0 0 10px #0ff;
        }

        .hud span {
            color: #0ff;
        }

        #startBtn {
            padding: 10px 30px;
            font-size: 16px;
            background: transparent;
            color: #f0f;
            border: 2px solid #f0f;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 0 8px #f0f;
            -webkit-tap-highlight-color: transparent;
        }

        #startBtn:hover, #startBtn:active {
            background: #f0f;
            color: #000;
            box-shadow: 0 0 12px #f0f;
        }
        
        /* Make button more tappable on mobile */
        @media (max-width: 800px), (hover: none) {
            #startBtn {
                padding: 14px 40px;
                font-size: 18px;
                min-height: 48px; /* Minimum touch target size */
                touch-action: manipulation;
            }
            .button-container {
                height: 56px;
                z-index: 200; /* Above any touch blockers */
                position: relative;
            }
        }

        .message {
            color: #fff;
            font-size: 12px;
            text-shadow: 0 0 5px #0ff;
            opacity: 0.7;
            text-align: center;
            padding: 0 10px;
            margin: 0;
        }
        
        /* Hide both by default, then show appropriate one via media queries */
        .desktop-instructions { display: none; }
        .mobile-instructions { display: none; }
        
        /* Desktop: show keyboard/mouse instructions */
        @media (min-width: 801px) {
            .desktop-instructions { display: block !important; }
            .mobile-instructions { display: none !important; }
        }

        /* Mobile: show touch instructions and adjust layout */
        @media (max-width: 800px) {
            .desktop-instructions { display: none !important; }
            .mobile-instructions { display: block !important; }
            .hud {
                gap: 20px;
                font-size: 16px;
            }
            .power-up-bar {
                gap: 3px;
                min-height: 54px;
                height: 54px;
            }
            .game-container {
                padding-bottom: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
        </div>
        <canvas id="gameCanvas" width="640" height="492"></canvas>
        <div class="power-up-bar" id="powerUpBar"></div>
        <div class="button-container">
            <button id="startBtn">Start Game</button>
        </div>
        <p class="message desktop-instructions">Use ← → arrow keys or mouse to move paddle</p>
        <p class="message mobile-instructions">Touch to move paddle</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimization: disable alpha for faster rendering
        const startBtn = document.getElementById('startBtn');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const powerUpBarEl = document.getElementById('powerUpBar'); // Cached DOM reference

        // Performance detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 800;
        const isLowPower = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : isMobile;
        const isVeryLowPower = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 2 : false;
        
        // Shadow blur values (tiered based on device capability)
        const shadowSettings = isVeryLowPower ? {
            // Very low power: no shadows at all
            paddle: 0,
            ball: 0,
            brick: 0,
            brickPowerUp: 0,
            brickPowerUpMax: 0,
            boss: 0
        } : isMobile ? {
            // Mobile: minimal shadows
            paddle: 0,
            ball: 0,
            brick: 0,
            brickPowerUp: 3,
            brickPowerUpMax: 6,
            boss: 10
        } : {
            // Desktop: reduced shadows
            paddle: 12,
            ball: 10,
            brick: 5,
            brickPowerUp: 8,
            brickPowerUpMax: 15,
            boss: 20
        };

        // Game state
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        
        // Life loss pause state
        let lifeLostPause = false;
        let lifeLostPauseEnd = 0;
        
        // Boss phase transition pause states
        let bossSpawnPause = false;
        let bossSpawnPauseEnd = 0;
        let levelTransitionPause = false;
        let levelTransitionPauseEnd = 0;
        let extraLifePause = false;
        let extraLifePauseEnd = 0;
        
        // Boss state
        let bossPhase = false; // True when fighting bosses
        let bosses = []; // Array of boss objects
        let bossesDropping = false; // True during drop animation
        let bossDropProgress = 0; // 0 to 1 for smooth drop
        let bossHitCooldownEnd = 0; // Global cooldown timer for boss damage
        const bossConfig = {
            width: 50,
            height: 25,
            speed: 2.25, // 10% slower than original 2.5
            dropDistance: 20,
            dropSpeed: 0.08, // How fast the drop animation plays (0-1 per frame)
            hitsRequired: 3,
            hitCooldown: 200, // Milliseconds between allowed hits
            colors: ['#ff0066', '#ff3300', '#ff00ff', '#00ffcc', '#ffcc00'], // Different colors per boss
            pointsPerHit: 30,
            pointsPerKill: 0
        };

        // Power-up state
        let activePowerUps = {
            bigPaddle: { active: false, timeLeft: 0, originalWidth: 107 },
            multiBall: { active: false, bouncesLeft: 0 },
            crusher: { active: false, timeLeft: 0 },
            smallPaddle: { active: false, timeLeft: 0, originalWidth: 107 }
        };
        let balls = []; // Array to hold multiple balls
        let levelsSinceSkull = 0; // Track levels since last skull brick
        let lastLevelHadSkull = false; // Track if previous level had skull
        
        // Ball color transition state
        let ballColorTransition = {
            currentR: 255, currentG: 255, currentB: 255,
            targetR: 255, targetG: 255, targetB: 255,
            speed: 0.1 // How fast to transition (0-1)
        };

        // Neon colors
        const neonColors = [
            '#ffaa00', // Yellow-orange (between yellow and orange)
            '#00ffff', // Cyan
            '#ff00ff', // Magenta
            '#00ffa0', // Blue-green (was pure green)
            '#bf00ff', // Neon Purple
            '#ffff00', // Yellow
        ];

        // Power-up types
        const powerUpTypes = [
            { type: 'bigPaddle', color: '#00cc66', symbol: '↔' },
            { type: 'multiBall', color: '#ff6a00', symbol: '✦' },
            { type: 'crusher', color: '#ff0028', symbol: '⚡' }
        ];
        
        // Debuff types
        const debuffTypes = [
            { type: 'smallPaddle', color: '#8800aa', symbol: '☠' }
        ];

        // Paddle
        const paddle = {
            width: 107,
            height: 11,
            x: 267,
            y: 459,
            speed: 8,
            color: '#0ff',
            dx: 0,
            targetX: 267,
            smoothing: 0.15
        };

        // Ball template
        const ballTemplate = {
            x: 320,
            y: 447,
            radius: 7,
            speed: 5.75,
            dx: 5.75,
            dy: -5.75,
            color: '#fff'
        };

        function createBall(x, y, dx, dy, speed) {
            return {
                x: x,
                y: y,
                radius: 7,
                speed: speed || ballTemplate.speed,
                dx: dx,
                dy: dy,
                color: '#fff'
            };
        }

        // Bricks - calculated for perfect centering
        // Scaled down from 780x600 to 640x492
        // 11 cols, 49px wide, 7px padding = 539 + 70 = 609, offset = (640-609)/2 ≈ 16
        const brickConfig = {
            rows: 4,
            cols: 11,
            width: 49,
            height: 16,
            padding: 7,
            offsetTop: 41,
            offsetLeft: 16
        };

        let bricks = [];

        function createBricks() {
            bricks = [];
            const totalBricks = brickConfig.rows * brickConfig.cols;
            const cols = brickConfig.cols;
            
            // Helper to get adjacent positions (including diagonals)
            function getAdjacentPositions(pos) {
                const row = Math.floor(pos / cols);
                const col = pos % cols;
                const adjacent = [];
                
                for (let r = row - 1; r <= row + 1; r++) {
                    for (let c = col - 1; c <= col + 1; c++) {
                        if (r >= 0 && r < brickConfig.rows && c >= 0 && c < cols) {
                            adjacent.push(r * cols + c);
                        }
                    }
                }
                return adjacent;
            }
            
            // Luck protection: guarantee 2+ power-ups per level, each unique
            // Max power-ups increases by 1 every 3 levels (3 at level 1-2, 4 at level 3-5, etc.)
            const minPowerUps = 2;
            const maxPowerUps = 3 + Math.floor(level / 3);
            const numPowerUps = Math.floor(Math.random() * (maxPowerUps - minPowerUps + 1)) + minPowerUps;
            
            // Pick random unique power-up types
            const availablePowerUps = [...powerUpTypes];
            const selectedPowerUps = [];
            for (let i = 0; i < numPowerUps && availablePowerUps.length > 0; i++) {
                const idx = Math.floor(Math.random() * availablePowerUps.length);
                selectedPowerUps.push(availablePowerUps.splice(idx, 1)[0]);
            }
            
            // Pick random brick positions for power-ups with at least 1 brick separation
            const powerUpPositions = new Map();
            const usedPositions = new Set();
            const blockedPositions = new Set(); // Positions adjacent to power-ups
            
            for (let i = 0; i < selectedPowerUps.length; i++) {
                let pos;
                let attempts = 0;
                do {
                    pos = Math.floor(Math.random() * totalBricks);
                    attempts++;
                    // Fallback after many attempts to avoid infinite loop
                    if (attempts > 100) break;
                } while (usedPositions.has(pos) || blockedPositions.has(pos));
                
                if (attempts <= 100) {
                    usedPositions.add(pos);
                    powerUpPositions.set(pos, selectedPowerUps[i]);
                    
                    // Block adjacent positions
                    getAdjacentPositions(pos).forEach(adj => blockedPositions.add(adj));
                }
            }
            
            // Skull brick logic: not on consecutive levels, but must appear within 3 levels
            // Only eligible starting at level 3
            const skullPositions = new Set();
            let addSkull = false;
            
            if (level >= 3) {
                if (lastLevelHadSkull) {
                    // Can't have skull two levels in a row
                    addSkull = false;
                } else if (levelsSinceSkull >= 2) {
                    // Must have skull if it's been 2+ levels
                    addSkull = true;
                } else {
                    // Random chance (roughly every 3 levels)
                    addSkull = Math.random() < 0.4;
                }
                
                if (addSkull) {
                    let skullPos;
                    let attempts = 0;
                    do {
                        skullPos = Math.floor(Math.random() * totalBricks);
                        attempts++;
                        if (attempts > 100) break;
                    } while (usedPositions.has(skullPos) || blockedPositions.has(skullPos));
                    
                    if (attempts <= 100) {
                        skullPositions.add(skullPos);
                        usedPositions.add(skullPos);
                    }
                    lastLevelHadSkull = true;
                    levelsSinceSkull = 0;
                } else {
                    lastLevelHadSkull = false;
                    levelsSinceSkull++;
                }
            }
            
            let brickIndex = 0;
            for (let row = 0; row < brickConfig.rows; row++) {
                bricks[row] = [];
                for (let col = 0; col < brickConfig.cols; col++) {
                    let powerUp = null;
                    let debuff = null;
                    
                    if (powerUpPositions.has(brickIndex)) {
                        powerUp = powerUpPositions.get(brickIndex);
                    } else if (skullPositions.has(brickIndex)) {
                        debuff = debuffTypes[0];
                    }
                    
                    bricks[row][col] = {
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop,
                        alive: true,
                        color: powerUp ? powerUp.color : (debuff ? debuff.color : neonColors[row % neonColors.length]),
                        powerUp: powerUp,
                        debuff: debuff,
                        twinkleOffset: Math.random() * Math.PI * 2 // For twinkle animation
                    };
                    brickIndex++;
                }
            }
        }

        // ========== BOSS SYSTEM ==========
        function createBosses() {
            bosses = [];
            const numBosses = level; // Level 1 = 1 boss, Level 2 = 2 bosses, etc.
            const spacing = canvas.width / (numBosses + 1);
            
            for (let i = 0; i < numBosses; i++) {
                bosses.push({
                    x: spacing * (i + 1) - bossConfig.width / 2,
                    y: 50,
                    width: bossConfig.width,
                    height: bossConfig.height,
                    hits: 0,
                    alive: true,
                    direction: 1, // 1 = right, -1 = left
                    color: bossConfig.colors[i % bossConfig.colors.length],
                    flashUntil: 0 // Timestamp when flash effect ends
                });
            }
            bossPhase = true;
        }
        
        function drawBosses() {
            if (!bossPhase) return;
            
            ctx.shadowBlur = shadowSettings.boss;
            const now = frameTime;
            
            for (let i = 0; i < bosses.length; i++) {
                const boss = bosses[i];
                if (!boss.alive) continue;
                
                // Check if boss is flashing from damage
                const isFlashing = now < boss.flashUntil;
                let displayColor = boss.color;
                
                if (isFlashing) {
                    // Rapid flash between white and original color
                    const flashPhase = Math.floor((boss.flashUntil - now) / 30) % 2;
                    displayColor = flashPhase === 0 ? '#ffffff' : boss.color;
                }
                
                // Draw boss body with glow
                ctx.beginPath();
                ctx.roundRect(boss.x, boss.y, boss.width, boss.height, 8);
                ctx.fillStyle = displayColor;
                ctx.shadowColor = isFlashing ? '#ffffff' : boss.color;
                ctx.fill();
                
                // Draw hit indicator (3 teeth showing remaining health)
                // Order: left tooth removed first, then right, then center last
                const hitsRemaining = bossConfig.hitsRequired - boss.hits;
                const dotSpacing = boss.width / 4;
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                
                // Teeth removal order: left first, right second, center last
                // At 0 hits (3 remaining): show left, right, center
                // At 1 hit (2 remaining): hide left, show right and center
                // At 2 hits (1 remaining): hide left and right, show only center
                
                // Draw center tooth (position 2) - always shown unless dead
                if (hitsRemaining >= 1) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 2, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Draw right tooth (position 3) - shown if 2+ hits remaining
                if (hitsRemaining >= 2) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 3, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Draw left tooth (position 1) - only shown if all 3 hits remaining
                if (hitsRemaining >= 3) {
                    ctx.beginPath();
                    ctx.arc(boss.x + dotSpacing * 1, boss.y + boss.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw menacing eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(boss.x + 15, boss.y + 10, 5, 0, Math.PI * 2);
                ctx.arc(boss.x + boss.width - 15, boss.y + 10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = shadowSettings.boss;
            }
            ctx.shadowBlur = 0;
        }
        
        function moveBosses() {
            if (!bossPhase || bosses.length === 0) return;
            
            // If currently dropping, animate the drop
            if (bossesDropping) {
                bossDropProgress += bossConfig.dropSpeed * deltaMultiplier;
                
                if (bossDropProgress >= 1) {
                    // Drop complete
                    bossDropProgress = 0;
                    bossesDropping = false;
                    
                    // Finalize positions and flip direction
                    bosses.forEach(boss => {
                        if (!boss.alive) return;
                        boss.y = boss.targetY;
                        boss.direction *= -1;
                    });
                } else {
                    // Smooth easing for drop animation
                    const easeProgress = 1 - Math.pow(1 - bossDropProgress, 2); // Ease out quad
                    bosses.forEach(boss => {
                        if (!boss.alive) return;
                        boss.y = boss.startY + (boss.targetY - boss.startY) * easeProgress;
                    });
                }
                return; // Don't move horizontally while dropping
            }
            
            // Check if any boss needs to change direction
            let needsDrop = false;
            bosses.forEach(boss => {
                if (!boss.alive) return;
                
                // Check if boss hits edge
                if (boss.direction === 1 && boss.x + boss.width >= canvas.width - 10) {
                    needsDrop = true;
                } else if (boss.direction === -1 && boss.x <= 10) {
                    needsDrop = true;
                }
            });
            
            // Start drop animation
            if (needsDrop) {
                bossesDropping = true;
                bossDropProgress = 0;
                bosses.forEach(boss => {
                    if (!boss.alive) return;
                    boss.startY = boss.y;
                    boss.targetY = boss.y + bossConfig.dropDistance;
                });
            } else {
                // Normal horizontal movement (frame-rate independent)
                bosses.forEach(boss => {
                    if (!boss.alive) return;
                    boss.x += bossConfig.speed * boss.direction * deltaMultiplier;
                });
            }
            
            // Check if bosses reached the bottom (game over condition)
            bosses.forEach(boss => {
                if (boss.alive && boss.y + boss.height >= paddle.y - 20) {
                    lives--;
                    livesEl.textContent = lives;
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        // Reset bosses to top and show life lost message
                        showLifeLostMessage();
                        resetBossPositions();
                    }
                }
            });
        }
        
        function resetBossPositions() {
            const numBosses = bosses.filter(b => b.alive).length;
            const aliveBosses = bosses.filter(b => b.alive);
            const spacing = canvas.width / (numBosses + 1);
            
            // Reset drop animation state
            bossesDropping = false;
            bossDropProgress = 0;
            
            aliveBosses.forEach((boss, i) => {
                boss.x = spacing * (i + 1) - boss.width / 2;
                boss.y = 50;
                boss.direction = 1;
            });
        }
        
        function checkBossCollisions() {
            if (!bossPhase) return;
            
            // Check if we're still in cooldown
            const now = performance.now();
            if (now < bossHitCooldownEnd) return;
            
            balls.forEach(ball => {
                bosses.forEach(boss => {
                    if (!boss.alive) return;
                    
                    // Double-check cooldown (in case multiple balls)
                    if (performance.now() < bossHitCooldownEnd) return;
                    
                    // Simple rectangle collision
                    if (ball.x + ball.radius > boss.x &&
                        ball.x - ball.radius < boss.x + boss.width &&
                        ball.y + ball.radius > boss.y &&
                        ball.y - ball.radius < boss.y + boss.height) {
                        
                        // Set cooldown
                        bossHitCooldownEnd = performance.now() + bossConfig.hitCooldown;
                        
                        // Bounce the ball
                        ball.dy = Math.abs(ball.dy); // Always bounce down
                        
                        // Damage the boss and trigger flash
                        boss.hits++;
                        boss.flashUntil = performance.now() + 150; // Flash for 150ms
                        score += bossConfig.pointsPerHit;
                        scoreEl.textContent = score;
                        
                        // Check if boss is destroyed
                        if (boss.hits >= bossConfig.hitsRequired) {
                            boss.alive = false;
                            score += bossConfig.pointsPerKill;
                            scoreEl.textContent = score;
                        }
                        
                        // Check if all bosses defeated
                        if (bosses.every(b => !b.alive)) {
                            bossPhase = false;
                            startLevelTransition();
                        }
                    }
                });
            });
        }

        function drawPaddle() {
            // Determine paddle color - green when big paddle active
            let paddleColor = paddle.color; // default cyan
            if (activePowerUps.bigPaddle.active) {
                paddleColor = '#00cc66'; // green
            } else if (activePowerUps.smallPaddle.active) {
                paddleColor = '#8800aa'; // purple for debuff
            }
            
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 7);
            ctx.fillStyle = paddleColor;
            ctx.shadowColor = paddleColor;
            ctx.shadowBlur = shadowSettings.paddle;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawBall() {
            // Determine target ball color based on active power-ups (excluding big paddle)
            let targetR = 255, targetG = 255, targetB = 255;
            
            if (activePowerUps.crusher.active) {
                // #ff0028
                targetR = 255; targetG = 0; targetB = 40;
            } else if (activePowerUps.multiBall.active) {
                // #ff6a00
                targetR = 255; targetG = 106; targetB = 0;
            }
            
            // Smoothly transition current color toward target
            ballColorTransition.currentR += (targetR - ballColorTransition.currentR) * ballColorTransition.speed;
            ballColorTransition.currentG += (targetG - ballColorTransition.currentG) * ballColorTransition.speed;
            ballColorTransition.currentB += (targetB - ballColorTransition.currentB) * ballColorTransition.speed;
            
            const r = Math.round(ballColorTransition.currentR);
            const g = Math.round(ballColorTransition.currentG);
            const b = Math.round(ballColorTransition.currentB);
            const ballColor = `rgb(${r}, ${g}, ${b})`;
            
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                
                ctx.fillStyle = ballColor;
                ctx.shadowColor = ballColor;
                ctx.shadowBlur = shadowSettings.ball;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        function drawBricks() {
            // Calculate twinkle once per frame, not per brick
            const twinkle = isMobile ? 0.5 : (Math.sin(frameTime / 250) * 0.5 + 0.5);
            const twinkleShadow = shadowSettings.brickPowerUp + twinkle * (shadowSettings.brickPowerUpMax - shadowSettings.brickPowerUp);
            const twinkleAlpha = 0.8 + twinkle * 0.2;
            
            // Pre-calculate brick dimensions
            const brickW = brickConfig.width;
            const brickH = brickConfig.height;
            
            // Draw all regular bricks first (batched by similar state)
            ctx.shadowBlur = shadowSettings.brick;
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (brick.alive && !brick.powerUp && !brick.debuff) {
                        ctx.beginPath();
                        ctx.roundRect(brick.x, brick.y, brickW, brickH, 5);
                        ctx.fillStyle = brick.color;
                        ctx.shadowColor = brick.color;
                        ctx.fill();
                    }
                }
            }
            
            // Draw power-up/debuff bricks (with twinkle effect)
            ctx.shadowBlur = twinkleShadow;
            ctx.globalAlpha = twinkleAlpha;
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (brick.alive && (brick.powerUp || brick.debuff)) {
                        ctx.beginPath();
                        ctx.roundRect(brick.x, brick.y, brickW, brickH, 5);
                        ctx.fillStyle = brick.color;
                        ctx.shadowColor = brick.color;
                        ctx.fill();
                    }
                }
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Draw symbols on special bricks (separate pass for text rendering)
            const symbolShadow = isMobile ? 0 : 5;
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const brick = bricks[row][col];
                    if (!brick.alive) continue;
                    
                    const centerX = brick.x + brickW / 2;
                    const centerY = brick.y + brickH / 2;
                    
                    // Draw symbol on power-up bricks
                    if (brick.powerUp) {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = symbolShadow;
                        ctx.shadowColor = '#fff';
                        
                        if (brick.powerUp.type === 'crusher') {
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, 7, 0, Math.PI * 2);
                            ctx.fillStyle = '#fff';
                            ctx.shadowBlur = 0;
                            ctx.fill();
                            ctx.font = 'bold 14px Arial';
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        } else if (brick.powerUp.type === 'multiBall') {
                            ctx.fillStyle = '#fff';
                            ctx.shadowBlur = symbolShadow;
                            ctx.beginPath();
                            ctx.arc(centerX - 5, centerY, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(centerX + 5, centerY, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (brick.powerUp.type === 'bigPaddle') {
                            ctx.font = '900 18px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 1;
                            ctx.strokeText(brick.powerUp.symbol, centerX, centerY);
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        } else {
                            ctx.font = 'bold 14px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.fillText(brick.powerUp.symbol, centerX, centerY);
                        }
                    }
                    
                    // Draw symbol on debuff bricks
                    if (brick.debuff) {
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = isMobile ? 3 : 5;
                        ctx.shadowColor = '#fff';
                        ctx.fillText(brick.debuff.symbol, centerX, centerY);
                    }
                }
            }
            ctx.shadowBlur = 0;
        }

        function movePaddle() {
            // Smooth keyboard movement (frame-rate independent)
            paddle.targetX += paddle.dx * deltaMultiplier;
            
            // Clamp target
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
            
            // Smooth interpolation (adjust for frame rate)
            const smoothFactor = 1 - Math.pow(1 - paddle.smoothing, deltaMultiplier);
            paddle.x += (paddle.targetX - paddle.x) * smoothFactor;
        }

        function moveBall() {
            let ballsToRemove = [];
            let levelChanged = false;
            
            for (let ballIndex = 0; ballIndex < balls.length; ballIndex++) {
                if (levelChanged) break;
                const ball = balls[ballIndex];
                
                // Apply delta time for frame-rate independent movement
                ball.x += ball.dx * deltaMultiplier;
                ball.y += ball.dy * deltaMultiplier;

                // Wall collision - FIXED: Reposition ball to prevent getting stuck
                // Left wall
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius; // Reposition inside
                    ball.dx = Math.abs(ball.dx); // Force moving right
                }
                // Right wall
                if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius; // Reposition inside
                    ball.dx = -Math.abs(ball.dx); // Force moving left
                }
                // Top wall
                if (ball.y - ball.radius < 0) {
                    ball.y = ball.radius; // Reposition inside
                    ball.dy = Math.abs(ball.dy); // Force moving down
                }

                // Bottom - remove ball
                if (ball.y + ball.radius > canvas.height) {
                    ballsToRemove.push(ballIndex);
                    continue;
                }

                // Paddle collision
                if (ball.y + ball.radius > paddle.y &&
                    ball.y - ball.radius < paddle.y + paddle.height &&
                    ball.x > paddle.x &&
                    ball.x < paddle.x + paddle.width) {
                    
                    ball.y = paddle.y - ball.radius;
                    
                    // Angle based on where ball hits paddle (-0.8 to 0.8 range for max angle)
                    let hitPoint = (ball.x - paddle.x) / paddle.width;
                    let angle = (hitPoint - 0.5) * 1.6; // Max angle ~38 degrees
                    
                    // Normalize velocity to maintain consistent speed
                    ball.dx = ball.speed * Math.sin(angle * Math.PI / 2);
                    ball.dy = -ball.speed * Math.cos(angle * Math.PI / 2);
                    
                    // Ensure ball always moves upward
                    if (ball.dy > -ball.speed * 0.3) {
                        ball.dy = -ball.speed * 0.3;
                        // Renormalize dx to maintain speed
                        const dxMax = Math.sqrt(ball.speed * ball.speed - ball.dy * ball.dy);
                        ball.dx = Math.sign(ball.dx) * Math.min(Math.abs(ball.dx), dxMax);
                    }
                    
                    // Multiball: spawn new ball on paddle hit
                    if (activePowerUps.multiBall.active && activePowerUps.multiBall.bouncesLeft > 0) {
                        activePowerUps.multiBall.bouncesLeft--;
                        
                        // Spawn a new ball at random angle (normalized velocity)
                        const spawnAngle = (Math.random() - 0.5) * Math.PI * 0.6; // -54° to +54°
                        const newBall = createBall(
                            ball.x,
                            ball.y - 10,
                            ball.speed * Math.sin(spawnAngle),
                            -ball.speed * Math.cos(spawnAngle),
                            ball.speed
                        );
                        balls.push(newBall);
                        
                        if (activePowerUps.multiBall.bouncesLeft <= 0) {
                            activePowerUps.multiBall.active = false;
                        }
                    }
                }

                // Brick collision - only during brick phase
                if (!bossPhase) {
                    // Early exit: skip if ball is clearly outside brick area
                    const brickAreaBottom = brickConfig.offsetTop + brickConfig.rows * (brickConfig.height + brickConfig.padding);
                    if (ball.y - ball.radius <= brickAreaBottom && ball.y + ball.radius >= brickConfig.offsetTop) {
                        for (let row = 0; row < brickConfig.rows; row++) {
                            if (levelChanged) break;
                            
                            // Skip rows that ball can't possibly touch
                            const rowY = brickConfig.offsetTop + row * (brickConfig.height + brickConfig.padding);
                            if (ball.y + ball.radius < rowY) break; // Ball above this row and all below
                            if (ball.y - ball.radius > rowY + brickConfig.height) continue; // Ball below this row
                            
                            for (let col = 0; col < brickConfig.cols; col++) {
                                if (levelChanged) break;
                                const brick = bricks[row][col];
                                if (brick.alive) {
                                    // Check collision with ball radius on all sides
                                    if (ball.x + ball.radius > brick.x &&
                                        ball.x - ball.radius < brick.x + brickConfig.width &&
                                        ball.y + ball.radius > brick.y &&
                                        ball.y - ball.radius < brick.y + brickConfig.height) {
                                        
                                        // Only bounce if crusher is not active
                                        if (!activePowerUps.crusher.active) {
                                            // Determine which side was hit for proper bounce direction
                                            const overlapLeft = (ball.x + ball.radius) - brick.x;
                                            const overlapRight = (brick.x + brickConfig.width) - (ball.x - ball.radius);
                                            const overlapTop = (ball.y + ball.radius) - brick.y;
                                            const overlapBottom = (brick.y + brickConfig.height) - (ball.y - ball.radius);
                                            
                                            const minOverlapX = Math.min(overlapLeft, overlapRight);
                                            const minOverlapY = Math.min(overlapTop, overlapBottom);
                                            
                                            if (minOverlapX < minOverlapY) {
                                                ball.dx *= -1;
                                            } else {
                                                ball.dy *= -1;
                                            }
                                        }
                                        
                                        brick.alive = false;
                                        score += 1;
                                        scoreEl.textContent = score;
                                    
                                    // Activate power-up if brick had one
                                    if (brick.powerUp) {
                                        activatePowerUp(brick.powerUp.type);
                                    }
                                    
                                    // Activate debuff if brick had one
                                    if (brick.debuff) {
                                        activatePowerUp(brick.debuff.type);
                                    }

                                    // Check win - triggers boss phase
                                    if (checkWin() && !bossPhase) {
                                        startBossPhase();
                                        levelChanged = true;
                                    }
                                }
                            }
                        }
                    }
                    } // End early exit check
                }
            }
            
            if (levelChanged) return;
            
            // Boss phase logic
            if (bossPhase) {
                moveBosses();
                checkBossCollisions();
            }
            
            // Remove balls that fell off screen (using filter is faster than splice)
            if (ballsToRemove.length > 0) {
                balls = balls.filter((_, index) => !ballsToRemove.includes(index));
            }
            
            // If no balls left, lose a life
            if (balls.length === 0) {
                lives--;
                livesEl.textContent = lives;
                if (lives <= 0) {
                    gameOver();
                } else {
                    showLifeLostMessage();
                }
            }
        }

        // Show life lost message and pause briefly
        function showLifeLostMessage() {
            lifeLostPause = true;
            lifeLostPauseEnd = performance.now() + 1275; // 1.275 second pause (15% shorter)
        }
        
        function drawLifeLostMessage() {
            if (!lifeLostPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Magenta text (matches game over)
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 20;
            ctx.fillText(`${lives} ${lives === 1 ? 'LIFE' : 'LIVES'} REMAINING`, canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }

        function checkWin() {
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    if (bricks[row][col].alive) return false;
                }
            }
            return true;
        }
        
        function startBossPhase() {
            // Pause before bosses appear
            bossSpawnPause = true;
            bossSpawnPauseEnd = performance.now() + 1200; // 1.2 second pause
        }
        
        function startLevelTransition() {
            // Check if player earns an extra life (every 5 levels)
            if (level % 5 === 0) {
                lives++;
                livesEl.textContent = lives;
                // Show extra life message first, then level clear
                extraLifePause = true;
                extraLifePauseEnd = performance.now() + 1200; // 1.2 second pause
            } else {
                // Normal level transition
                levelTransitionPause = true;
                levelTransitionPauseEnd = performance.now() + 1200; // 1.2 second pause
            }
        }
        
        function drawExtraLifeMessage() {
            if (!extraLifePause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Blue text for extra life
            ctx.font = 'bold 42px Arial';
            ctx.fillStyle = '#00aaff';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#00aaff';
            ctx.shadowBlur = 25;
            ctx.fillText('+1 LIFE', canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }
        
        function drawBossSpawnMessage() {
            if (!bossSpawnPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Warning text - same pink as start button
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 20;
            ctx.fillText('BOSS INCOMING!', canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }
        
        function drawLevelTransitionMessage() {
            if (!levelTransitionPause) return;
            
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Victory text - same cyan as paddle
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#0ff';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 20;
            ctx.fillText(`LEVEL ${level} CLEAR!`, canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
        }

        function activatePowerUp(type) {
            switch(type) {
                case 'bigPaddle':
                    activePowerUps.bigPaddle.active = true;
                    activePowerUps.bigPaddle.timeLeft = 20;
                    activePowerUps.bigPaddle.originalWidth = paddle.width;
                    // Animate paddle growing 50% bigger
                    animatePaddleSize(paddle.width * 1.5);
                    break;
                    
                case 'multiBall':
                    activePowerUps.multiBall.active = true;
                    activePowerUps.multiBall.bouncesLeft = 3;
                    break;
                    
                case 'crusher':
                    activePowerUps.crusher.active = true;
                    activePowerUps.crusher.timeLeft = 12;
                    break;
                    
                case 'smallPaddle':
                    activePowerUps.smallPaddle.active = true;
                    activePowerUps.smallPaddle.timeLeft = 10;
                    activePowerUps.smallPaddle.originalWidth = paddle.width;
                    // Animate paddle shrinking 30% smaller
                    animatePaddleSize(paddle.width * 0.7);
                    break;
            }
        }

        let paddleAnimation = {
            active: false,
            startWidth: 0,
            targetWidth: 0,
            startTime: 0,
            duration: 300
        };

        function animatePaddleSize(targetWidth) {
            paddleAnimation.active = true;
            paddleAnimation.startWidth = paddle.width;
            paddleAnimation.targetWidth = targetWidth;
            paddleAnimation.startTime = frameTime; // Use frameTime
        }
        
        function updatePaddleAnimation() {
            if (!paddleAnimation.active) return;
            
            const elapsed = frameTime - paddleAnimation.startTime; // Use frameTime
            const progress = Math.min(elapsed / paddleAnimation.duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            const oldWidth = paddle.width;
            paddle.width = paddleAnimation.startWidth + (paddleAnimation.targetWidth - paddleAnimation.startWidth) * eased;
            
            // Adjust position to keep paddle centered during resize
            const widthDiff = paddle.width - oldWidth;
            paddle.x -= widthDiff / 2;
            paddle.targetX -= widthDiff / 2;
            
            // Clamp to canvas bounds
            if (paddle.x < 0) {
                paddle.x = 0;
                paddle.targetX = 0;
            }
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
                paddle.targetX = canvas.width - paddle.width;
            }
            
            if (progress >= 1) {
                paddleAnimation.active = false;
            }
        }

        let lastPowerUpTime = 0;
        
        function updatePowerUps() {
            const delta = (frameTime - lastPowerUpTime) / 1000; // Use frameTime
            lastPowerUpTime = frameTime;
            
            // Big paddle timer
            if (activePowerUps.bigPaddle.active) {
                activePowerUps.bigPaddle.timeLeft -= delta;
                if (activePowerUps.bigPaddle.timeLeft <= 0) {
                    activePowerUps.bigPaddle.active = false;
                    // Animate paddle shrinking back
                    animatePaddleSize(activePowerUps.bigPaddle.originalWidth);
                }
            }
            
            // Crusher timer
            if (activePowerUps.crusher.active) {
                activePowerUps.crusher.timeLeft -= delta;
                if (activePowerUps.crusher.timeLeft <= 0) {
                    activePowerUps.crusher.active = false;
                }
            }
            
            // Small paddle timer (debuff)
            if (activePowerUps.smallPaddle.active) {
                activePowerUps.smallPaddle.timeLeft -= delta;
                if (activePowerUps.smallPaddle.timeLeft <= 0) {
                    activePowerUps.smallPaddle.active = false;
                    // Animate paddle growing back
                    animatePaddleSize(activePowerUps.smallPaddle.originalWidth);
                }
            }
        }

        // Track last power-up bar content to avoid unnecessary DOM updates
        let lastPowerUpBarContent = '';
        
        function drawPowerUpTimers() {
            let html = '';
            const flashOn = Math.sin(frameTime / 1000 * 6) > 0; // Use cached frameTime
            
            // Big paddle timer
            if (activePowerUps.bigPaddle.active) {
                const timeLeft = Math.ceil(activePowerUps.bigPaddle.timeLeft);
                const isWarning = activePowerUps.bigPaddle.timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                html += `<span style="color: #00cc66; text-shadow: 0 0 10px #00cc66; font-weight: bold; font-size: 16px; opacity: ${opacity}; transition: opacity 0.1s;">↔&nbsp;&nbsp;BIG PADDLE: ${timeLeft}s&nbsp;&nbsp;↔</span>`;
            }
            
            // Crusher timer
            if (activePowerUps.crusher.active) {
                const timeLeft = Math.ceil(activePowerUps.crusher.timeLeft);
                const isWarning = activePowerUps.crusher.timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                html += `<span style="color: #ff0028; text-shadow: 0 0 10px #ff0028; font-weight: bold; font-size: 16px; opacity: ${opacity}; transition: opacity 0.1s;">⚡&nbsp;&nbsp;CRUSHER: ${timeLeft}s&nbsp;&nbsp;⚡</span>`;
            }
            
            // Multiball bounces remaining
            if (activePowerUps.multiBall.active) {
                const isWarning = activePowerUps.multiBall.bouncesLeft === 1;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                html += `<span style="color: #ff6a00; text-shadow: 0 0 10px #ff6a00; font-weight: bold; font-size: 16px; opacity: ${opacity}; transition: opacity 0.1s;">✦&nbsp;&nbsp;MULTIBALL: ${activePowerUps.multiBall.bouncesLeft} bounce${activePowerUps.multiBall.bouncesLeft !== 1 ? 's' : ''}&nbsp;&nbsp;✦</span>`;
            }
            
            // Small paddle timer (debuff)
            if (activePowerUps.smallPaddle.active) {
                const timeLeft = Math.ceil(activePowerUps.smallPaddle.timeLeft);
                const isWarning = activePowerUps.smallPaddle.timeLeft <= 3;
                const opacity = (isWarning && !flashOn) ? '0.5' : '1';
                html += `<span style="color: #8800aa; text-shadow: 0 0 10px #8800aa; font-weight: bold; font-size: 16px; opacity: ${opacity}; transition: opacity 0.1s;">☠&nbsp;&nbsp;SMALL PADDLE: ${timeLeft}s&nbsp;&nbsp;☠</span>`;
            }
            
            // Only update DOM if content changed (major optimization)
            if (html !== lastPowerUpBarContent) {
                powerUpBarEl.innerHTML = html;
                lastPowerUpBarContent = html;
            }
        }

        function nextLevel() {
            level++;
            levelEl.textContent = level;
            
            // Clear boss state for new level
            bossPhase = false;
            bosses = [];
            bossesDropping = false;
            bossDropProgress = 0;
            
            // Progressive difficulty - slower ramp early, faster later
            if (level <= 3) {
                ballTemplate.speed += 0.4;  // Gentle increase for first 3 levels
            } else {
                ballTemplate.speed += 0.6;  // Faster increase after that
            }
            
            // Shrink paddle slightly each level (min 66px)
            paddle.width = Math.max(66, 107 - (level - 1) * 6);
            
            // Add more brick rows at higher levels (max 7)
            brickConfig.rows = Math.min(7, 4 + Math.floor(level / 2));
            
            // Reset power-ups on level change
            activePowerUps.bigPaddle = { active: false, timeLeft: 0, originalWidth: paddle.width };
            activePowerUps.multiBall = { active: false, bouncesLeft: 0 };
            activePowerUps.crusher = { active: false, timeLeft: 0 };
            activePowerUps.smallPaddle = { active: false, timeLeft: 0, originalWidth: paddle.width };
            
            createBricks();
            resetBall();
        }

        function resetBall() {
            const speed = ballTemplate.speed;
            // Launch at 45-degree angle with NORMALIZED velocity
            // At 45°: sin(45°) = cos(45°) = 0.707, so dx² + dy² = speed²
            const angle = 0.707; // √2/2 for 45-degree launch
            const direction = Math.random() > 0.5 ? 1 : -1;
            balls = [createBall(
                paddle.x + paddle.width / 2,
                paddle.y - 8 - 5,
                speed * angle * direction,  // dx: ~70% of speed
                -speed * angle,              // dy: ~70% of speed (upward)
                speed
            )];
        }

        function gameOver() {
            gameRunning = false;
            startBtn.textContent = 'Play Again';
            startBtn.style.visibility = 'visible';
            powerUpBarEl.innerHTML = '';
            lastPowerUpBarContent = '';
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 52px Arial';
            ctx.fillStyle = '#f0f';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = isMobile ? 15 : 25;
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
            ctx.shadowBlur = 0;
            
            ctx.font = '24px Arial';
            ctx.fillStyle = '#0ff';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background glow effect
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw bricks only if not in boss phase
            if (!bossPhase) {
                drawBricks();
            }
            
            // Draw bosses if in boss phase
            if (bossPhase) {
                drawBosses();
            }
            
            drawPaddle();
            drawBall();
            
            // Draw life lost message overlay (on top of everything)
            drawLifeLostMessage();
        }

        // Delta time for consistent game speed across all frame rates
        let lastFrameTime = 0;
        const targetFrameTime = 1000 / 60; // Target 60fps as baseline for speed calculations
        
        // Single timestamp per frame (optimization)
        let frameTime = 0;
        let deltaMultiplier = 1; // Scales movement based on actual frame time

        function update(currentTime) {
            if (!gameRunning) return;
            
            // Calculate delta time for frame-rate independent movement
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            frameTime = currentTime;
            
            // Calculate speed multiplier (1.0 at 60fps, higher if slower, lower if faster)
            // Clamp to prevent huge jumps if tab was inactive
            deltaMultiplier = Math.min(deltaTime / targetFrameTime, 3);
            
            // Check if life lost pause is over
            if (lifeLostPause) {
                if (currentTime >= lifeLostPauseEnd) {
                    lifeLostPause = false;
                    resetBall();
                }
                // During pause, still draw but don't update game logic
                draw();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if boss spawn pause is over
            if (bossSpawnPause) {
                if (currentTime >= bossSpawnPauseEnd) {
                    bossSpawnPause = false;
                    createBosses();
                    resetBall();
                }
                // During pause, still draw but don't update game logic
                draw();
                drawBossSpawnMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if level transition pause is over
            if (levelTransitionPause) {
                if (currentTime >= levelTransitionPauseEnd) {
                    levelTransitionPause = false;
                    nextLevel();
                }
                // During pause, still draw but don't update game logic
                draw();
                drawLevelTransitionMessage();
                requestAnimationFrame(update);
                return;
            }
            
            // Check if extra life pause is over
            if (extraLifePause) {
                if (currentTime >= extraLifePauseEnd) {
                    extraLifePause = false;
                    // Now show level clear message
                    levelTransitionPause = true;
                    levelTransitionPauseEnd = performance.now() + 1200;
                }
                // During pause, still draw but don't update game logic
                draw();
                drawExtraLifeMessage();
                requestAnimationFrame(update);
                return;
            }
            
            movePaddle();
            updatePaddleAnimation();
            moveBall();
            
            // Check if game ended during moveBall (lives ran out)
            if (!gameRunning) return;
            
            updatePowerUps();
            drawPowerUpTimers();
            draw();
            
            requestAnimationFrame(update);
        }

        function startGame() {
            score = 0;
            lives = 3;
            level = 1;
            ballTemplate.speed = 5.75; // Initial speed (5% slower)
            
            // Reset boss phase
            bossPhase = false;
            bosses = [];
            bossesDropping = false;
            bossDropProgress = 0;
            
            // Reset all pause states
            lifeLostPause = false;
            bossSpawnPause = false;
            levelTransitionPause = false;
            extraLifePause = false;
            
            // Activate mouse control when starting game
            mouseControlActive = true;
            
            // Reset difficulty
            paddle.width = 107;
            brickConfig.rows = 4;
            
            // Reset power-ups
            activePowerUps.bigPaddle = { active: false, timeLeft: 0, originalWidth: 107 };
            activePowerUps.multiBall = { active: false, bouncesLeft: 0 };
            activePowerUps.crusher = { active: false, timeLeft: 0 };
            activePowerUps.smallPaddle = { active: false, timeLeft: 0, originalWidth: 107 };
            powerUpBarEl.innerHTML = '';
            lastPowerUpBarContent = '';
            
            // Reset skull tracking
            levelsSinceSkull = 0;
            lastLevelHadSkull = false;
            
            scoreEl.textContent = score;
            livesEl.textContent = lives;
            levelEl.textContent = level;
            
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.targetX = paddle.x;
            createBricks();
            resetBall();
            
            lastPowerUpTime = performance.now();
            lastFrameTime = performance.now();
            frameTime = performance.now();
            deltaMultiplier = 1; // Start with normal speed
            gameRunning = true;
            startBtn.style.visibility = 'hidden';
            requestAnimationFrame(update);
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                paddle.dx = -paddle.speed;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                paddle.dx = paddle.speed;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') paddle.dx = 0;
        });

        // Track if mouse is controlling paddle (only when inside game area)
        let mouseControlActive = false;

        canvas.addEventListener('mousemove', (e) => {
            if (!mouseControlActive) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const mouseX = (e.clientX - rect.left) * scaleX;
            paddle.targetX = mouseX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
        });

        // Track mouse on document only when control is active
        document.addEventListener('mousemove', (e) => {
            if (!mouseControlActive) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const mouseX = (e.clientX - rect.left) * scaleX;
            paddle.targetX = mouseX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
        });
        
        // Activate mouse control when clicking on canvas or game container
        const gameContainer = document.querySelector('.game-container');
        gameContainer.addEventListener('mousedown', () => {
            mouseControlActive = true;
        });
        
        // Deactivate mouse control when clicking outside game container
        document.addEventListener('mousedown', (e) => {
            if (!gameContainer.contains(e.target)) {
                mouseControlActive = false;
            }
        });

        // Touch input for mobile
        function handleTouch(e) {
            e.preventDefault();
            if (e.touches.length === 0) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const touch = e.touches[0];
            const touchX = (touch.clientX - rect.left) * scaleX;
            paddle.targetX = touchX - paddle.width / 2;
            if (paddle.targetX < 0) paddle.targetX = 0;
            if (paddle.targetX + paddle.width > canvas.width) paddle.targetX = canvas.width - paddle.width;
        }

        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('touchmove', handleTouch, { passive: false });
        
        // Prevent page scrolling when touching game container (but NOT on button)
        gameContainer.addEventListener('touchstart', (e) => {
            // Allow button clicks through
            if (e.target.id === 'startBtn' || e.target.closest('.button-container')) {
                return; // Don't prevent default on button
            }
            e.preventDefault();
        }, { passive: false });
        gameContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Start button - support both click and touch
        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation(); // Prevent container from catching this
        }, { passive: true });
        startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startGame();
        });

        // Create display-only bricks (no power-ups or debuffs) for pre-game view
        function createDisplayBricks() {
            bricks = [];
            for (let row = 0; row < brickConfig.rows; row++) {
                bricks[row] = [];
                for (let col = 0; col < brickConfig.cols; col++) {
                    bricks[row][col] = {
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop,
                        alive: true,
                        color: neonColors[row % neonColors.length],
                        powerUp: null,
                        debuff: null,
                        twinkleOffset: Math.random() * Math.PI * 2
                    };
                }
            }
        }

        // Initial setup - show plain bricks before game starts
        // Ball velocity normalized: 5.75 * 0.707 ≈ 4.07 for 45-degree angle
        balls = [createBall(320, 447, 4.07, -4.07, 5.75)];
        createDisplayBricks(); // Plain bricks for display
        draw();
    </script>
</body>
</html>
