<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Dig</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600;700;800&family=Exo+2:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --cyan: #00f0ff;
            --cyan-dim: #00a0aa;
            --magenta: #ff00ff;
            --magenta-dim: #aa00aa;
            --orange: #ff9500;
            --green: #00ff88;
            --bg-deep: #020408;
            --bg-card: rgba(8, 12, 20, 0.85);
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100%;
            background: var(--bg-deep);
            font-family: 'Exo 2', sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: 
                linear-gradient(90deg, rgba(0, 240, 255, 0.02) 1px, transparent 1px),
                linear-gradient(rgba(0, 240, 255, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: -1;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: fit-content;
            max-width: 100%;
            transform: translateZ(0);
            touch-action: none;
            position: relative;
            overflow: hidden;
            border-radius: 16px;
            background: linear-gradient(160deg, rgba(10, 15, 25, 0.95) 0%, rgba(5, 8, 15, 0.98) 100%);
            box-shadow: 
                0 0 0 1px rgba(0, 240, 255, 0.15),
                0 0 60px rgba(0, 240, 255, 0.08),
                0 0 120px rgba(255, 0, 255, 0.05),
                0 25px 50px rgba(0, 0, 0, 0.5);
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 16px;
            padding: 1px;
            background: linear-gradient(135deg, var(--cyan), transparent 40%, transparent 60%, var(--magenta));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0.5;
            pointer-events: none;
        }

        #gameCanvas {
            border-radius: 12px 12px 0 0;
            max-width: 100%;
            height: auto;
            touch-action: none;
            transform: translateZ(0);
        }

        .hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 14px 20px;
            background: linear-gradient(180deg, rgba(0, 15, 25, 0.9) 0%, rgba(0, 10, 18, 0.95) 100%);
            border-bottom: 1px solid rgba(0, 240, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .hud-item { display: flex; flex-direction: column; gap: 2px; }

        .hud-label {
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .hud-value {
            color: var(--cyan);
            font-family: 'Oxanium', monospace;
            font-size: 20px;
            font-weight: 700;
            text-shadow: 0 0 20px var(--cyan);
            letter-spacing: -0.5px;
        }

        .hud-value.score { color: var(--magenta); text-shadow: 0 0 20px var(--magenta); }

        .fuel-container { display: flex; flex-direction: column; gap: 6px; align-items: flex-end; }

        .fuel-bar-wrapper { position: relative; width: 110px; height: 10px; }

        .fuel-bar {
            width: 100%; height: 100%;
            background: rgba(255, 150, 0, 0.1);
            border: 1px solid rgba(255, 150, 0, 0.25);
            border-radius: 5px;
            overflow: hidden;
        }

        .fuel-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4400, #ff9500, #ffcc00);
            box-shadow: 0 0 15px rgba(255, 150, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
        }

        .fuel-bar.critical .fuel-fill {
            background: linear-gradient(90deg, #ff0033, #ff4400);
            animation: criticalPulse 0.6s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 15px rgba(255, 0, 50, 0.5); }
            50% { opacity: 0.7; box-shadow: 0 0 25px rgba(255, 0, 50, 0.8); }
        }

        .fuel-percent {
            position: absolute;
            right: 6px; top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            color: rgba(0, 0, 0, 0.6);
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .button-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 14px;
            z-index: 400;
        }

        .menu-buttons { display: flex; flex-direction: column; gap: 10px; align-items: center; }

        .game-btn {
            position: relative;
            background: linear-gradient(165deg, rgba(0, 50, 60, 0.8) 0%, rgba(0, 25, 35, 0.9) 100%);
            border: 1px solid rgba(0, 240, 255, 0.4);
            color: var(--cyan);
            padding: 16px 40px;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Oxanium', monospace;
            letter-spacing: 3px;
            cursor: pointer;
            border-radius: 8px;
            text-shadow: 0 0 15px var(--cyan);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 220px;
            text-transform: uppercase;
            overflow: hidden;
        }

        .game-btn::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.08) 0%, transparent 50%);
            pointer-events: none;
        }

        .game-btn::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 50%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .game-btn:hover {
            background: linear-gradient(165deg, rgba(0, 70, 85, 0.9) 0%, rgba(0, 35, 50, 0.95) 100%);
            border-color: var(--cyan);
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.3), 0 0 60px rgba(0, 240, 255, 0.1);
            transform: translateY(-2px);
        }

        .game-btn:hover::after { left: 100%; }
        .game-btn:active { transform: translateY(0) scale(0.98); }

        .game-btn.secondary {
            background: linear-gradient(165deg, rgba(40, 20, 50, 0.7) 0%, rgba(25, 10, 35, 0.85) 100%);
            border-color: rgba(255, 0, 255, 0.35);
            color: var(--magenta);
            text-shadow: 0 0 12px var(--magenta);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.1);
            font-size: 12px;
            padding: 12px 30px;
            letter-spacing: 2px;
        }

        .game-btn.secondary:hover {
            border-color: var(--magenta);
            box-shadow: 0 0 35px rgba(255, 0, 255, 0.25);
        }

        .control-zone {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            height: 130px;
            min-height: 130px;
            padding: 14px 20px 18px;
            touch-action: none;
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(5, 12, 20, 0.9) 0%, rgba(2, 8, 15, 0.95) 100%);
            border-top: 1px solid rgba(0, 240, 255, 0.08);
        }

        .control-instructions {
            font-size: 10px;
            color: rgba(0, 240, 255, 0.3);
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .permanent-upgrades {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            pointer-events: none;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 240, 255, 0.08);
        }

        .perm-upgrade {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 38px; height: 38px;
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.08) 0%, rgba(0, 240, 255, 0.02) 100%);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 10px;
        }

        .perm-icon { font-size: 18px; filter: drop-shadow(0 0 6px currentColor); }

        .perm-stack {
            position: absolute;
            bottom: -3px; right: -3px;
            font-size: 9px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: #fff;
            background: rgba(0, 0, 0, 0.85);
            padding: 2px 5px;
            border-radius: 6px;
            border: 1px solid currentColor;
            line-height: 1;
        }

        .upgrade-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(5, 15, 30, 0.97) 0%, rgba(2, 5, 12, 0.99) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
            touch-action: manipulation;
            pointer-events: none;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .upgrade-overlay.active { display: flex; pointer-events: auto; }

        .upgrade-header { text-align: center; margin-bottom: 24px; }

        .upgrade-title {
            font-size: 26px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: var(--cyan);
            text-shadow: 0 0 40px var(--cyan), 0 0 80px var(--cyan);
            letter-spacing: 6px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        .upgrade-subtitle {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 8px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        @keyframes titlePulse {
            0%, 100% { opacity: 1; filter: brightness(1); }
            50% { opacity: 0.9; filter: brightness(1.2); }
        }

        .upgrade-slots { display: flex; gap: 14px; }

        .upgrade-slot {
            width: 125px; height: 165px;
            background: linear-gradient(170deg, rgba(15, 20, 35, 0.95) 0%, rgba(8, 10, 20, 0.98) 100%);
            border: 1px solid rgba(60, 70, 100, 0.3);
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.03);
            -webkit-tap-highlight-color: transparent;
        }

        .upgrade-slot::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 40%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02) 0%, transparent 100%);
            pointer-events: none;
        }

        .upgrade-slot.rolling { pointer-events: none; }
        .upgrade-slot.rolling .upgrade-content { animation: slotRoll 0.12s ease-in-out infinite; }

        @keyframes slotRoll {
            0%, 100% { opacity: 0.4; transform: translateY(0) scale(0.98); }
            50% { opacity: 0.8; transform: translateY(-3px) scale(1); }
        }

        .upgrade-slot.revealed {
            border-color: rgba(0, 240, 255, 0.5);
            box-shadow: 0 0 35px rgba(0, 240, 255, 0.2), 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .upgrade-slot.revealed:hover {
            transform: translateY(-10px) scale(1.03);
            border-color: var(--cyan);
            box-shadow: 0 0 50px rgba(0, 240, 255, 0.35), 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .upgrade-slot.selected {
            border-color: var(--green);
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.5);
            transform: scale(1.05);
        }

        .upgrade-slot.legendary { border-color: rgba(255, 0, 255, 0.5); box-shadow: 0 0 40px rgba(255, 0, 255, 0.25); }
        .upgrade-slot.legendary.revealed:hover { box-shadow: 0 0 55px rgba(255, 0, 255, 0.45); }
        .upgrade-overlay.legendary .upgrade-title { color: var(--magenta); text-shadow: 0 0 40px var(--magenta), 0 0 80px var(--magenta); }

        .upgrade-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 18px 10px;
            width: 100%; height: 100%;
            position: relative;
            z-index: 1;
        }

        .upgrade-icon { font-size: 38px; margin-bottom: 12px; filter: drop-shadow(0 0 15px currentColor); }
        .upgrade-name { font-size: 12px; font-weight: 700; font-family: 'Oxanium', monospace; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255,255,255,0.4); }
        .upgrade-desc { font-size: 10px; color: rgba(255, 255, 255, 0.5); line-height: 1.4; }

        @media (max-width: 500px) {
            .upgrade-slot { width: 100px; height: 145px; }
            .upgrade-icon { font-size: 30px; }
            .upgrade-name { font-size: 10px; }
            .upgrade-desc { font-size: 9px; }
            .upgrade-title { font-size: 20px; letter-spacing: 4px; }
            .upgrade-slots { gap: 8px; }
            .hud { padding: 12px 14px; }
            .hud-value { font-size: 18px; }
            .control-zone { height: 115px; min-height: 115px; }
            .game-btn { padding: 14px 28px; font-size: 13px; min-width: 180px; }
        }

        .modal-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(5, 15, 30, 0.98) 0%, rgba(2, 5, 12, 0.99) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 600;
            pointer-events: none;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
        }

        .modal-overlay.active { display: flex; pointer-events: auto; }

        .modal-content {
            background: linear-gradient(170deg, rgba(12, 18, 30, 0.98) 0%, rgba(6, 10, 18, 0.99) 100%);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 16px;
            padding: 28px;
            max-width: 340px;
            width: 90%;
            box-shadow: 0 0 60px rgba(0, 240, 255, 0.15), 0 25px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-content.magenta { border-color: rgba(255, 0, 255, 0.35); box-shadow: 0 0 60px rgba(255, 0, 255, 0.15); }

        .modal-title {
            font-size: 20px;
            font-weight: 800;
            font-family: 'Oxanium', monospace;
            color: var(--cyan);
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 25px var(--cyan);
            letter-spacing: 3px;
        }

        .modal-content.magenta .modal-title { color: var(--magenta); text-shadow: 0 0 25px var(--magenta); }

        .score-value {
            font-size: 28px;
            font-family: 'Oxanium', monospace;
            color: #fff;
            font-weight: 800;
            text-align: center;
            margin-bottom: 24px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }

        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            border-bottom: 1px solid rgba(0, 240, 255, 0.08);
            color: rgba(255, 255, 255, 0.75);
            font-size: 13px;
            font-weight: 500;
        }

        .leaderboard-row.top-3 { background: linear-gradient(90deg, rgba(0, 240, 255, 0.06) 0%, transparent 100%); }
        .leaderboard-rank-1 { color: #ffd700; text-shadow: 0 0 12px #ffd700; }
        .leaderboard-rank-2 { color: #e0e0e0; text-shadow: 0 0 10px #c0c0c0; }
        .leaderboard-rank-3 { color: #cd9a5a; text-shadow: 0 0 10px #cd7f32; }

        .leaderboard-list { max-height: 280px; overflow-y: auto; margin-bottom: 16px; }
        .leaderboard-list::-webkit-scrollbar { width: 4px; }
        .leaderboard-list::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 2px; }
        .leaderboard-list::-webkit-scrollbar-thumb { background: rgba(0, 240, 255, 0.3); border-radius: 2px; }

        .score-input {
            width: 100%;
            padding: 14px 18px;
            font-size: 16px;
            font-family: 'Exo 2', sans-serif;
            font-weight: 600;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 10px;
            color: #fff;
            text-align: center;
            margin-bottom: 16px;
            outline: none;
            transition: all 0.3s;
        }

        .score-input:focus { border-color: var(--cyan); box-shadow: 0 0 25px rgba(0, 240, 255, 0.2); background: rgba(0, 0, 0, 0.5); }
        .score-input::placeholder { color: rgba(255, 255, 255, 0.25); }

        .score-buttons { display: flex; gap: 10px; justify-content: center; }

        .score-btn {
            padding: 12px 24px;
            font-size: 12px;
            font-family: 'Oxanium', monospace;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        .score-btn.submit {
            background: linear-gradient(165deg, rgba(0, 60, 70, 0.85) 0%, rgba(0, 35, 45, 0.9) 100%);
            border: 1px solid rgba(0, 240, 255, 0.5);
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan);
        }

        .score-btn.submit:hover { box-shadow: 0 0 30px rgba(0, 240, 255, 0.3); border-color: var(--cyan); }

        .score-btn.skip {
            background: linear-gradient(165deg, rgba(30, 30, 35, 0.8) 0%, rgba(15, 15, 20, 0.85) 100%);
            border: 1px solid rgba(100, 100, 110, 0.4);
            color: rgba(255, 255, 255, 0.45);
        }

        .score-btn.skip:hover { border-color: rgba(150, 150, 160, 0.5); color: rgba(255, 255, 255, 0.6); }

        .score-error { color: #ff4466; font-size: 11px; text-align: center; margin-top: 8px; min-height: 16px; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="hud">
            <div class="hud-item">
                <div class="hud-label">Depth</div>
                <div class="hud-value"><span id="depth">0</span>m</div>
            </div>
            <div class="hud-item" style="align-items: center;">
                <div class="hud-label">Score</div>
                <div class="hud-value score" id="score">0</div>
            </div>
            <div class="hud-item">
                <div class="fuel-container">
                    <div class="hud-label">Fuel</div>
                    <div class="fuel-bar-wrapper">
                        <div class="fuel-bar" id="fuelBarContainer">
                            <div class="fuel-fill" id="fuelBar" style="width: 100%"></div>
                        </div>
                        <span class="fuel-percent" id="fuelPercent">100</span>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas" width="448" height="560"></canvas>

        <div class="control-zone" id="controlZone">
            <div class="button-container" id="buttonContainer">
                <div class="menu-buttons">
                    <button class="game-btn" id="startBtn">START DIGGING</button>
                    <button class="game-btn secondary" id="leaderboardBtn">LEADERBOARD</button>
                </div>
            </div>
            <div class="control-instructions">Arrow Keys / WASD â€¢ Swipe on mobile</div>
            <div class="permanent-upgrades" id="permUpgrades"></div>
        </div>

        <div class="upgrade-overlay" id="upgradeOverlay">
            <div class="upgrade-header">
                <div class="upgrade-title">UPGRADE</div>
                <div class="upgrade-subtitle">Choose your enhancement</div>
            </div>
            <div class="upgrade-slots">
                <div class="upgrade-slot" id="slot1"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
                <div class="upgrade-slot" id="slot2"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
                <div class="upgrade-slot" id="slot3"><div class="upgrade-content"><div class="upgrade-icon">?</div><div class="upgrade-name">???</div><div class="upgrade-desc">???</div></div></div>
            </div>
        </div>

        <div class="modal-overlay" id="leaderboardOverlay">
            <div class="modal-content">
                <div class="modal-title">HIGH SCORES</div>
                <div class="leaderboard-list" id="leaderboardList"></div>
                <button class="game-btn" style="width: 100%;" id="leaderboardClose">CLOSE</button>
            </div>
        </div>

        <div class="modal-overlay" id="scoreModal">
            <div class="modal-content magenta">
                <div class="modal-title">RUN COMPLETE</div>
                <div class="score-value" id="finalScore">0</div>
                <input type="text" class="score-input" id="usernameInput" placeholder="Enter your name" maxlength="12">
                <div class="score-error" id="scoreError"></div>
                <div class="score-buttons">
                    <button class="score-btn submit" id="submitScoreBtn">SAVE</button>
                    <button class="score-btn skip" id="skipScoreBtn">SKIP</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';
        
        // ==================== CONSTANTS ====================
        const TILE_SIZE = 28;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
        const MAX_PARTICLES = 150;
        const MAX_FLOATING_TEXTS = 30;
        const WORLD_BUFFER_ROWS = 60;
        const WORLD_TRIM_THRESHOLD = 100;
        
        // Tile types
        const TILE = Object.freeze({
            AIR: 0, DIRT: 1, ROCK: 2, HARD_ROCK: 3,
            GEM_COMMON: 4, GEM_RARE: 5, GEM_EPIC: 6,
            LAVA: 7, GAS: 8, FUEL: 9,
            BOMB: 10, CHEST: 11, UNSTABLE: 12
        });
        
        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const depthEl = document.getElementById('depth');
        const scoreEl = document.getElementById('score');
        const fuelBar = document.getElementById('fuelBar');
        const fuelBarContainer = document.getElementById('fuelBarContainer');
        const fuelPercent = document.getElementById('fuelPercent');
        const startBtn = document.getElementById('startBtn');
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const buttonContainer = document.getElementById('buttonContainer');
        const controlZone = document.getElementById('controlZone');
        const permUpgradesEl = document.getElementById('permUpgrades');
        const upgradeOverlay = document.getElementById('upgradeOverlay');
        const slots = [document.getElementById('slot1'), document.getElementById('slot2'), document.getElementById('slot3')];
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        const scoreModal = document.getElementById('scoreModal');
        const finalScoreEl = document.getElementById('finalScore');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreError = document.getElementById('scoreError');
        
        const WORLD_WIDTH = Math.floor(canvas.width / TILE_SIZE);
        
        // ==================== GAME STATE ====================
        let gameRunning = false;
        let score = 0;
        let depth = 0;
        let fuel = 100;
        let maxFuel = 100;
        let lastUpgradeDepth = 0;
        let upgradeSelectionActive = false;
        let upgradeSelected = false;
        let isLegendaryUpgrade = false;
        let lastFrameTime = 0;
        let deltaMultiplier = 1;
        let screenShake = 0;
        let depthColorShift = 0;
        let globalTime = 0;
        let worldRowOffset = 0;
        
        // ==================== COMBO & FEVER SYSTEM ====================
        let comboCount = 0;
        let comboTimer = 0;
        const COMBO_DECAY_TIME = 270; // frames (~4.5 sec at 60fps)
        let feverMode = false;
        let feverTimer = 0;
        const FEVER_DURATION = 480; // frames (~8 sec)
        const FEVER_COMBO_THRESHOLD = 8;
        
        // ==================== VISUAL EFFECTS ====================
        let screenFlash = { active: false, color: '#ffffff', alpha: 0, duration: 0 };
        let speedLines = [];
        let unstableTiles = []; // Track tiles that are about to collapse
        
        // Upgrade intervals for cleanup
        let activeRollIntervals = [];
        let activeRollTimeouts = [];
        
        // ==================== UPGRADE DEFINITIONS ====================
        // BUG FIX: Cap percentages to prevent exceeding 100%
        const permanentUpgrades = {
            digSpeed: 0,
            fuelCapacity: 0,
            gemMagnet: 0,
            armor: 0,
            fuelEfficiency: 0,
            gemValue: 0,
            climbSpeed: 0,
            drillPower: 0
        };
        
        // Helper to get effective values with caps
        function getEffectiveUpgrade(key, maxPercent = 90) {
            return Math.min(permanentUpgrades[key], maxPercent);
        }
        
        const upgradeDefinitions = [
            { id: 'digSpeed', name: 'Turbo Drill', icon: 'âš¡', desc: '+15% dig speed', apply: () => permanentUpgrades.digSpeed += 15 },
            { id: 'fuelCapacity', name: 'Fuel Tank', icon: 'â›½', desc: '+20% fuel capacity', apply: () => { permanentUpgrades.fuelCapacity += 20; maxFuel = 100 * (1 + permanentUpgrades.fuelCapacity / 100); } },
            { id: 'gemMagnet', name: 'Gem Magnet', icon: 'ðŸ§²', desc: '+1 attraction range', apply: () => permanentUpgrades.gemMagnet += 1 },
            { id: 'fuelEfficiency', name: 'Eco Mode', icon: 'ðŸŒ¿', desc: '-10% fuel usage', apply: () => permanentUpgrades.fuelEfficiency += 10 },
            { id: 'gemValue', name: 'Appraiser', icon: 'ðŸ’°', desc: '+15% gem value', apply: () => permanentUpgrades.gemValue += 15 },
            { id: 'climbSpeed', name: 'Grapple', icon: 'ðŸª', desc: '+20% climb speed', apply: () => permanentUpgrades.climbSpeed += 20 },
            { id: 'drillPower', name: 'Diamond Tip', icon: 'ðŸ’Ž', desc: '+10% instant break', apply: () => permanentUpgrades.drillPower += 10 }
        ];
        
        const legendaryUpgradeDefinitions = [
            { id: 'armor', name: 'Titanium Hull', icon: 'ðŸ›¡ï¸', desc: '-25% hazard damage', apply: () => permanentUpgrades.armor += 25 },
            { id: 'doubleGems', name: 'Lucky Strike', icon: 'ðŸ€', desc: '2x gems this run', apply: () => permanentUpgrades.gemValue += 100 },
            { id: 'megaTank', name: 'Mega Tank', icon: 'ðŸ›¢ï¸', desc: '+50% fuel + refill', apply: () => { permanentUpgrades.fuelCapacity += 50; maxFuel = 100 * (1 + permanentUpgrades.fuelCapacity / 100); fuel = maxFuel; } }
        ];
        
        let upgradeOfferHistory = {};
        let currentUpgradeChoices = [];
        
        // ==================== WORLD ====================
        let world = [];
        let cameraY = 0;
        
        // ==================== PLAYER ====================
        const player = {
            x: canvas.width / 2 - 12,
            y: 60,
            width: 24,
            height: 28,
            speed: 3,
            digging: false,
            digProgress: 0,
            digTarget: null,
            thrusterFlicker: 0
        };
        
        // ==================== PARTICLES (Object Pool) ====================
        let particles = [];
        let floatingTexts = [];
        let ambientParticles = [];
        let bgStars = [];
        
        const keys = { left: false, right: false, up: false, down: false };
        
        // ==================== CACHED GRADIENTS ====================
        let cachedScanlinePattern = null;
        
        function createScanlinePattern() {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 4;
            patternCanvas.height = 6;
            const pctx = patternCanvas.getContext('2d');
            pctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            pctx.fillRect(0, 0, 4, 1);
            pctx.fillRect(0, 3, 4, 1);
            cachedScanlinePattern = ctx.createPattern(patternCanvas, 'repeat');
        }
        
        // ==================== INITIALIZATION ====================
        function initBgStars() {
            bgStars = [];
            for (let i = 0; i < 40; i++) {
                bgStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * 2000,
                    size: 0.5 + Math.random() * 1.5,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }
        
        function initAmbientParticles() {
            ambientParticles = [];
            for (let i = 0; i < 20; i++) {
                ambientParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 3,
                    size: 1 + Math.random() * 2,
                    speed: 0.15 + Math.random() * 0.4,
                    alpha: 0.1 + Math.random() * 0.2,
                    hue: Math.random() < 0.5 ? 180 : 300
                });
            }
        }
        
        // ==================== WORLD GENERATION ====================
        // Biome types for variety
        const BIOME = {
            NORMAL: 0,
            CRYSTAL_CAVE: 1,
            LAVA_ZONE: 2,
            ANCIENT_RUINS: 3,
            FUEL_DEPOSIT: 4,
            GEM_VEIN: 5
        };
        
        let currentBiome = BIOME.NORMAL;
        let biomeStartY = 0;
        let biomeLength = 0;
        
        function generateWorld() {
            world = [];
            worldRowOffset = 0;
            currentBiome = BIOME.NORMAL;
            biomeStartY = 0;
            biomeLength = 50;
            
            for (let y = 0; y < 200; y++) {
                const row = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    row.push(generateTile(x, y));
                }
                world.push(row);
            }
        }
        
        function selectNewBiome(y) {
            // Deeper = more interesting biomes
            const depthTier = Math.floor(y / 100);
            const rand = Math.random();
            
            if (depthTier === 0) {
                // Early game: mostly normal with occasional crystal caves
                if (rand < 0.15) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.25) return BIOME.FUEL_DEPOSIT;
                return BIOME.NORMAL;
            } else if (depthTier === 1) {
                // Mid game: introduce lava and gems
                if (rand < 0.12) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.22) return BIOME.LAVA_ZONE;
                if (rand < 0.32) return BIOME.FUEL_DEPOSIT;
                if (rand < 0.42) return BIOME.GEM_VEIN;
                return BIOME.NORMAL;
            } else {
                // Deep game: all biomes, more special ones
                if (rand < 0.10) return BIOME.CRYSTAL_CAVE;
                if (rand < 0.22) return BIOME.LAVA_ZONE;
                if (rand < 0.32) return BIOME.ANCIENT_RUINS;
                if (rand < 0.44) return BIOME.FUEL_DEPOSIT;
                if (rand < 0.56) return BIOME.GEM_VEIN;
                return BIOME.NORMAL;
            }
        }
        
        function generateTile(x, y) {
            if (y < 3) return TILE.AIR;
            
            // Check for biome transition
            if (y >= biomeStartY + biomeLength) {
                biomeStartY = y;
                biomeLength = 15 + Math.floor(Math.random() * 25); // 15-40 rows per biome
                currentBiome = selectNewBiome(y);
            }
            
            const depthFactor = Math.min(y / 150, 1);
            const rand = Math.random();
            
            // Guaranteed fuel every ~12-18 rows (scattered)
            if ((y + x * 7) % 15 === 0 && x % 3 === Math.floor(y / 5) % 3) {
                return TILE.FUEL;
            }
            
            // Generate based on current biome
            switch (currentBiome) {
                case BIOME.CRYSTAL_CAVE:
                    return generateCrystalCave(x, y, rand, depthFactor);
                case BIOME.LAVA_ZONE:
                    return generateLavaZone(x, y, rand, depthFactor);
                case BIOME.ANCIENT_RUINS:
                    return generateAncientRuins(x, y, rand, depthFactor);
                case BIOME.FUEL_DEPOSIT:
                    return generateFuelDeposit(x, y, rand, depthFactor);
                case BIOME.GEM_VEIN:
                    return generateGemVein(x, y, rand, depthFactor);
                default:
                    return generateNormalTile(x, y, rand, depthFactor);
            }
        }
        
        function generateNormalTile(x, y, rand, depthFactor) {
            // Rare special tiles
            if (rand < 0.008 + depthFactor * 0.004) return TILE.CHEST; // Treasure chest
            if (rand < 0.015 + depthFactor * 0.008) return TILE.BOMB;  // Bomb block
            if (rand < 0.04 + depthFactor * 0.03) return TILE.UNSTABLE; // Unstable rock
            
            if (rand < 0.07 + depthFactor * 0.08) return TILE.HARD_ROCK;
            if (rand < 0.18 + depthFactor * 0.08) return TILE.ROCK;
            if (rand < 0.24) {
                const gemRand = Math.random();
                if (gemRand < 0.1 + depthFactor * 0.15) return TILE.GEM_EPIC;
                if (gemRand < 0.35 + depthFactor * 0.1) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (y > 30 && rand < 0.27 + depthFactor * 0.02) {
                return Math.random() < 0.6 ? TILE.LAVA : TILE.GAS;
            }
            if (rand < 0.32) return TILE.FUEL;
            return TILE.DIRT;
        }
        
        function generateCrystalCave(x, y, rand, depthFactor) {
            // More gems, more air pockets, less rock
            if (rand < 0.02) return TILE.CHEST; // More chests in crystal caves
            if (rand < 0.04) return TILE.BOMB;
            if (rand < 0.16) return TILE.AIR; // Cave pockets
            if (rand < 0.42) {
                const gemRand = Math.random();
                if (gemRand < 0.15 + depthFactor * 0.2) return TILE.GEM_EPIC;
                if (gemRand < 0.45 + depthFactor * 0.15) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.50) return TILE.FUEL;
            if (rand < 0.58) return TILE.ROCK;
            return TILE.DIRT;
        }
        
        function generateLavaZone(x, y, rand, depthFactor) {
            // Dangerous but rewarding - more lava but also epic gems and fuel
            if (rand < 0.015) return TILE.CHEST; // Rare but valuable
            if (rand < 0.04) return TILE.BOMB;   // Explosions in lava zone!
            if (rand < 0.08) return TILE.UNSTABLE; // Unstable near lava
            if (rand < 0.28) return TILE.LAVA;
            if (rand < 0.34) return TILE.GAS;
            if (rand < 0.48) {
                // Higher chance of epic gems as reward for danger
                const gemRand = Math.random();
                if (gemRand < 0.35) return TILE.GEM_EPIC;
                if (gemRand < 0.65) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.58) return TILE.FUEL; // Extra fuel to survive
            if (rand < 0.68) return TILE.HARD_ROCK;
            return TILE.ROCK;
        }
        
        function generateAncientRuins(x, y, rand, depthFactor) {
            // Structured patterns with guaranteed loot
            const patternX = x % 5;
            const patternY = (y - biomeStartY) % 5;
            
            // Create room-like structures
            if (patternX === 0 || patternX === 4) return TILE.HARD_ROCK; // Walls
            if (patternY === 0 && patternX > 0 && patternX < 4) return TILE.HARD_ROCK; // Ceiling
            if (patternY === 4 && patternX === 2) return TILE.AIR; // Doorway
            
            // Inside rooms
            if (patternX >= 1 && patternX <= 3 && patternY >= 1 && patternY <= 3) {
                if (patternX === 2 && patternY === 2) {
                    // Center treasure - higher chest chance in ruins
                    const treasureRand = Math.random();
                    if (treasureRand < 0.4) return TILE.CHEST;
                    if (treasureRand < 0.7) return TILE.GEM_EPIC;
                    return TILE.FUEL;
                }
                if (rand < 0.25) return TILE.AIR;
                if (rand < 0.45) {
                    return Math.random() < 0.4 ? TILE.GEM_RARE : TILE.GEM_COMMON;
                }
                if (rand < 0.5) return TILE.BOMB; // Trapped rooms
                return TILE.AIR;
            }
            
            if (rand < 0.08) return TILE.UNSTABLE; // Crumbling ruins
            return rand < 0.35 ? TILE.ROCK : TILE.DIRT;
        }
        
        function generateFuelDeposit(x, y, rand, depthFactor) {
            // Fuel-rich area with easy digging
            if (rand < 0.01) return TILE.CHEST;
            if (rand < 0.03) return TILE.BOMB;
            if (rand < 0.35) return TILE.FUEL;
            if (rand < 0.44) {
                const gemRand = Math.random();
                if (gemRand < 0.2) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.52) return TILE.AIR; // Easy to navigate
            if (rand < 0.62) return TILE.ROCK;
            return TILE.DIRT;
        }
        
        function generateGemVein(x, y, rand, depthFactor) {
            // Dense gem clusters with moderate difficulty
            if (rand < 0.025) return TILE.CHEST; // Gem veins have treasure
            if (rand < 0.05) return TILE.BOMB;
            if (rand < 0.45) {
                const gemRand = Math.random();
                if (gemRand < 0.20 + depthFactor * 0.15) return TILE.GEM_EPIC;
                if (gemRand < 0.55 + depthFactor * 0.1) return TILE.GEM_RARE;
                return TILE.GEM_COMMON;
            }
            if (rand < 0.55) return TILE.FUEL;
            if (rand < 0.68) return TILE.ROCK;
            if (rand < 0.78) return TILE.HARD_ROCK;
            if (rand < 0.82) return TILE.UNSTABLE;
            return TILE.DIRT;
        }
        
        function extendWorld() {
            const neededRows = Math.floor(cameraY / TILE_SIZE) + WORLD_BUFFER_ROWS - worldRowOffset;
            while (world.length < neededRows) {
                const y = world.length + worldRowOffset;
                const row = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    row.push(generateTile(x, y));
                }
                world.push(row);
            }
            
            // MEMORY OPTIMIZATION: Trim old rows that are far above camera
            const trimThreshold = Math.floor(cameraY / TILE_SIZE) - WORLD_TRIM_THRESHOLD;
            if (trimThreshold > worldRowOffset + 50) {
                const rowsToTrim = trimThreshold - worldRowOffset - 20;
                if (rowsToTrim > 0) {
                    world.splice(0, rowsToTrim);
                    worldRowOffset += rowsToTrim;
                }
            }
        }
        
        function getWorldRow(absoluteY) {
            return absoluteY - worldRowOffset;
        }
        
        function getTile(worldX, worldY) {
            const tx = Math.floor(worldX / TILE_SIZE);
            const ty = getWorldRow(Math.floor(worldY / TILE_SIZE));
            if (tx < 0 || tx >= WORLD_WIDTH || ty < 0 || ty >= world.length) return TILE.ROCK;
            return world[ty][tx];
        }
        
        function setTile(tx, absoluteTy, value) {
            const ty = getWorldRow(absoluteTy);
            if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < world.length) {
                world[ty][tx] = value;
            }
        }
        
        function checkCollision(x, y, width, height) {
            const points = [
                [x + 3, y + 3],
                [x + width - 3, y + 3],
                [x + 3, y + height - 3],
                [x + width - 3, y + height - 3],
                [x + width / 2, y + height - 3]
            ];
            for (const [px, py] of points) {
                if (getTile(px, py) !== TILE.AIR) return true;
            }
            return false;
        }
        
        // ==================== DIGGING ====================
        function dig(tx, absoluteTy) {
            const ty = getWorldRow(absoluteTy);
            if (ty < 0 || ty >= world.length || tx < 0 || tx >= WORLD_WIDTH) return;
            
            const tile = world[ty][tx];
            if (tile === TILE.AIR) return;
            
            // Speed multipliers
            const speedMultiplier = 1 + getEffectiveUpgrade('digSpeed', 300) / 100;
            const feverBonus = feverMode ? 1.5 : 1;
            const totalSpeed = speedMultiplier * feverBonus;
            
            let digTime = 0.25 / totalSpeed; // Base dig time
            
            if (tile === TILE.ROCK) digTime = 0.4 / totalSpeed;
            if (tile === TILE.HARD_ROCK) {
                const drillChance = getEffectiveUpgrade('drillPower', 90);
                digTime = Math.random() * 100 < drillChance ? 0.08 : 0.7 / totalSpeed;
            }
            if (tile === TILE.UNSTABLE) {
                digTime = 0.5 / totalSpeed; // Takes a bit to break
                // Start collapse timer if not already started
                const existing = unstableTiles.find(u => u.tx === tx && u.absoluteTy === absoluteTy);
                if (!existing) {
                    startUnstableTimer(tx, absoluteTy);
                }
            }
            if (tile === TILE.BOMB) digTime = 0.15 / totalSpeed; // Quick to trigger
            if (tile === TILE.CHEST) digTime = 0.35 / totalSpeed; // Satisfying open time
            
            player.digging = true;
            player.digTarget = { x: tx, y: absoluteTy, time: digTime };
            player.digProgress = 0;
        }
        
        // Track last dig direction for continuous digging
        let lastDigDirection = null; // 'down', 'left', 'right'
        
        // ==================== COMBO & EFFECTS FUNCTIONS ====================
        function addCombo() {
            comboCount++;
            comboTimer = COMBO_DECAY_TIME;
            
            // Check for fever mode activation
            if (comboCount >= FEVER_COMBO_THRESHOLD && !feverMode) {
                activateFeverMode();
            }
        }
        
        function getComboMultiplier() {
            if (comboCount < 2) return 1;
            if (comboCount < 5) return 2;
            if (comboCount < 10) return 3;
            if (comboCount < 20) return 4;
            return 5;
        }
        
        function activateFeverMode() {
            feverMode = true;
            feverTimer = FEVER_DURATION;
            triggerScreenFlash('#ff00ff', 0.4, 20);
            screenShake = 10;
            createFloatingText('ðŸ”¥ FEVER MODE! ðŸ”¥', player.x + player.width/2, player.y - 30, '#ff00ff');
        }
        
        function triggerScreenFlash(color, alpha, duration) {
            screenFlash = { active: true, color: color, alpha: alpha, duration: duration };
        }
        
        function createSpeedLine() {
            if (speedLines.length < 20) {
                speedLines.push({
                    x: Math.random() * canvas.width,
                    y: -20,
                    length: 30 + Math.random() * 50,
                    speed: 15 + Math.random() * 10,
                    alpha: 0.3 + Math.random() * 0.4
                });
            }
        }
        
        function explodeBomb(centerTX, centerAbsTY) {
            // 3x3 explosion
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const tx = centerTX + dx;
                    const absoluteTy = centerAbsTY + dy;
                    const ty = getWorldRow(absoluteTy);
                    
                    if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < world.length) {
                        const tile = world[ty][tx];
                        
                        // Don't destroy hard rock with bombs
                        if (tile !== TILE.AIR && tile !== TILE.HARD_ROCK) {
                            // Collect any gems caught in explosion
                            if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                                let value = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                                value = Math.floor(value * (1 + permanentUpgrades.gemValue / 100) * getComboMultiplier());
                                score += value;
                                addCombo();
                            }
                            if (tile === TILE.FUEL) {
                                fuel = Math.min(fuel + 30, maxFuel);
                            }
                            
                            world[ty][tx] = TILE.AIR;
                            createParticles(tx * TILE_SIZE + TILE_SIZE/2, absoluteTy * TILE_SIZE + TILE_SIZE/2, '#ff6600', 4);
                        }
                    }
                }
            }
            
            // Big explosion effects
            const cx = centerTX * TILE_SIZE + TILE_SIZE/2;
            const cy = centerAbsTY * TILE_SIZE + TILE_SIZE/2;
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                particles.push({
                    x: cx, y: cy,
                    vx: Math.cos(angle) * (5 + Math.random() * 5),
                    vy: Math.sin(angle) * (5 + Math.random() * 5),
                    size: 4 + Math.random() * 6,
                    color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00',
                    life: 1,
                    type: 'explosion'
                });
            }
            
            triggerScreenFlash('#ff6600', 0.5, 15);
            screenShake = 12;
            scoreEl.textContent = score;
            updateFuelBar();
        }
        
        function openChest(tx, absoluteTy) {
            // Huge gem payout!
            const baseValue = 150 + Math.floor(Math.random() * 100);
            const value = Math.floor(baseValue * (1 + permanentUpgrades.gemValue / 100) * getComboMultiplier());
            score += value;
            
            // Also give some fuel
            fuel = Math.min(fuel + 50, maxFuel);
            
            const worldY = absoluteTy * TILE_SIZE;
            createFloatingText(`ðŸ’Ž +${value}! ðŸ’Ž`, tx * TILE_SIZE + TILE_SIZE/2, worldY, '#ffd700');
            
            // Shower of particles
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 5;
                particles.push({
                    x: tx * TILE_SIZE + TILE_SIZE/2,
                    y: worldY + TILE_SIZE/2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 3,
                    size: 3 + Math.random() * 5,
                    color: ['#ffd700', '#ff9500', '#00f0ff', '#ff00ff'][Math.floor(Math.random() * 4)],
                    life: 1.2,
                    type: 'gem'
                });
            }
            
            triggerScreenFlash('#ffd700', 0.4, 25);
            screenShake = 8;
            addCombo();
            scoreEl.textContent = score;
            updateFuelBar();
        }
        
        function startUnstableTimer(tx, absoluteTy) {
            // Add to unstable tiles list with a timer
            unstableTiles.push({
                tx: tx,
                absoluteTy: absoluteTy,
                timer: 45, // ~0.75 seconds to break before collapse
                warned: false
            });
        }
        
        function completeDig(fromMagnet = false) {
            if (!player.digTarget) return;
            
            const { x: tx, y: absoluteTy } = player.digTarget;
            const ty = getWorldRow(absoluteTy);
            if (ty < 0 || ty >= world.length) {
                player.digging = false;
                player.digTarget = null;
                return;
            }
            
            const tile = world[ty][tx];
            const worldY = absoluteTy * TILE_SIZE;
            const tileCenterX = tx * TILE_SIZE + TILE_SIZE/2;
            const tileCenterY = worldY + TILE_SIZE/2;
            
            // Apply fever mode speed bonus
            const feverMultiplier = feverMode ? 1.5 : 1;
            
            // ===== GEMS =====
            if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                let baseValue = tile === TILE.GEM_EPIC ? 50 : tile === TILE.GEM_RARE ? 25 : 10;
                addCombo();
                const multiplier = getComboMultiplier();
                let value = Math.floor(baseValue * (1 + permanentUpgrades.gemValue / 100) * multiplier);
                
                // Fever mode bonus
                if (feverMode) value = Math.floor(value * 1.5);
                
                score += value;
                scoreEl.textContent = score;
                
                const color = tile === TILE.GEM_EPIC ? '#ff9500' : tile === TILE.GEM_RARE ? '#ff00ff' : '#00f0ff';
                const text = multiplier > 1 ? `+${value} x${multiplier}!` : `+${value}`;
                createFloatingText(text, tileCenterX, worldY - 5, color);
                createGemParticles(tileCenterX, tileCenterY, color);
                
                // Epic gem screen flash
                if (tile === TILE.GEM_EPIC) {
                    triggerScreenFlash('#ff9500', 0.3, 12);
                    screenShake = 5;
                } else {
                    screenShake = 3;
                }
            }
            
            // ===== FUEL =====
            if (tile === TILE.FUEL) {
                const fuelGain = feverMode ? 45 : 30;
                fuel = Math.min(fuel + fuelGain, maxFuel);
                updateFuelBar();
                createFloatingText(`+${fuelGain}`, tileCenterX, worldY - 5, '#ff9500');
                createParticles(tileCenterX, tileCenterY, '#ff9500', 8);
            }
            
            // ===== BOMB =====
            if (tile === TILE.BOMB) {
                world[ty][tx] = TILE.AIR; // Clear bomb first
                explodeBomb(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return; // Skip normal completion
            }
            
            // ===== CHEST =====
            if (tile === TILE.CHEST) {
                world[ty][tx] = TILE.AIR;
                openChest(tx, absoluteTy);
                player.digging = false;
                player.digTarget = null;
                if (!fromMagnet && lastDigDirection) {
                    tryDigInDirection(lastDigDirection);
                }
                return;
            }
            
            // ===== UNSTABLE ROCK =====
            if (tile === TILE.UNSTABLE) {
                // Successfully mined before collapse - bonus gems!
                const value = Math.floor(20 * (1 + permanentUpgrades.gemValue / 100) * getComboMultiplier());
                score += value;
                scoreEl.textContent = score;
                createFloatingText(`+${value}`, tileCenterX, worldY - 5, '#aaaaff');
                createParticles(tileCenterX, tileCenterY, '#8888aa', 10);
                addCombo();
                
                // Remove from unstable tracking
                unstableTiles = unstableTiles.filter(u => !(u.tx === tx && u.absoluteTy === absoluteTy));
            }
            
            // ===== HAZARDS =====
            if (tile === TILE.LAVA || tile === TILE.GAS) {
                const baseDamage = tile === TILE.LAVA ? 20 : 10;
                const damage = baseDamage * (1 - getEffectiveUpgrade('armor', 90) / 100);
                fuel -= damage;
                comboCount = 0; // Break combo on damage
                comboTimer = 0;
                createFloatingText(`-${Math.floor(damage)}`, player.x + 12, player.y, '#ff3355');
                createParticles(player.x + 12, player.y + 14 + cameraY, '#ff3355', 8);
                triggerScreenFlash('#ff0000', 0.25, 8);
                screenShake = 6;
            }
            
            // Don't charge fuel for magnet-collected gems
            if (!fromMagnet) {
                let fuelCost = 0.5 * (1 - getEffectiveUpgrade('fuelEfficiency', 90) / 100);
                if (feverMode) fuelCost *= 0.5; // Half fuel cost in fever mode
                fuel -= fuelCost;
            }
            
            updateFuelBar();
            
            // Clear tile
            world[ty][tx] = TILE.AIR;
            createDigParticles(tileCenterX, absoluteTy * TILE_SIZE + TILE_SIZE/2, tile);
            
            player.digging = false;
            player.digTarget = null;
            
            // Continue digging if direction key still held
            if (!fromMagnet && lastDigDirection) {
                tryDigInDirection(lastDigDirection);
            }
        }
        
        // Attempt to dig in a specific direction
        function tryDigInDirection(direction) {
            let targetTX, targetAbsTY;
            
            if (direction === 'down') {
                targetTX = Math.floor((player.x + player.width / 2) / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height) / TILE_SIZE);
            } else if (direction === 'left') {
                targetTX = Math.floor(player.x / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
            } else if (direction === 'right') {
                targetTX = Math.floor((player.x + player.width) / TILE_SIZE);
                targetAbsTY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
            } else {
                return false;
            }
            
            const ty = getWorldRow(targetAbsTY);
            if (ty >= 0 && ty < world.length && targetTX >= 0 && targetTX < WORLD_WIDTH) {
                const tile = world[ty][targetTX];
                if (tile !== TILE.AIR) {
                    // Start unstable timer when we begin digging unstable rock
                    if (tile === TILE.UNSTABLE) {
                        const existing = unstableTiles.find(u => u.tx === targetTX && u.absoluteTy === targetAbsTY);
                        if (!existing) {
                            startUnstableTimer(targetTX, targetAbsTY);
                        }
                    }
                    dig(targetTX, targetAbsTY);
                    return true;
                }
            }
            return false;
        }
        
        // ==================== PARTICLES ====================
        function createParticles(x, y, color, count) {
            // OPTIMIZATION: Limit particle count
            const available = MAX_PARTICLES - particles.length;
            const toCreate = Math.min(count, available);
            
            for (let i = 0; i < toCreate; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5 - 2,
                    size: 2 + Math.random() * 3,
                    color: color,
                    life: 1,
                    type: 'normal'
                });
            }
        }
        
        function createGemParticles(x, y, color) {
            const available = MAX_PARTICLES - particles.length;
            const count = Math.min(10, available);
            
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (3 + Math.random() * 2),
                    vy: Math.sin(angle) * (3 + Math.random() * 2),
                    size: 3 + Math.random() * 4,
                    color: color,
                    life: 1,
                    type: 'gem'
                });
            }
        }
        
        function createDigParticles(x, y, tile) {
            const colors = {
                [TILE.DIRT]: ['#5a4535', '#3d2d20'],
                [TILE.ROCK]: ['#555', '#444'],
                [TILE.HARD_ROCK]: ['#3a3a50', '#2a2a40']
            };
            const colorSet = colors[tile] || ['#555'];
            
            const available = MAX_PARTICLES - particles.length;
            const count = Math.min(5, available);
            
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 10,
                    y: y + (Math.random() - 0.5) * 10,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 3 - 1,
                    size: 2 + Math.random() * 4,
                    color: colorSet[Math.floor(Math.random() * colorSet.length)],
                    life: 1,
                    type: 'debris',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }
        
        function createFloatingText(text, x, worldY, color) {
            // OPTIMIZATION: Limit floating texts
            if (floatingTexts.length >= MAX_FLOATING_TEXTS) {
                floatingTexts.shift();
            }
            floatingTexts.push({
                text: text,
                x: x,
                y: worldY,
                vy: -2.5,
                life: 1,
                color: color,
                scale: 1.3
            });
        }
        
        function updateParticles() {
            // OPTIMIZATION: Filter in place to reduce allocations
            let writeIndex = 0;
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                p.x += p.vx * deltaMultiplier;
                p.y += p.vy * deltaMultiplier;
                p.vy += 0.15 * deltaMultiplier;
                p.vx *= 0.98;
                p.life -= 0.025 * deltaMultiplier;
                if (p.rotation !== undefined) {
                    p.rotation += p.rotationSpeed * deltaMultiplier;
                }
                if (p.life > 0) {
                    particles[writeIndex++] = p;
                }
            }
            particles.length = writeIndex;
            
            writeIndex = 0;
            for (let i = 0; i < floatingTexts.length; i++) {
                const t = floatingTexts[i];
                t.y -= 1.5 * deltaMultiplier;
                t.vy *= 0.94;
                t.life -= 0.018 * deltaMultiplier;
                t.scale = 0.8 + t.life * 0.5;
                if (t.life > 0) {
                    floatingTexts[writeIndex++] = t;
                }
            }
            floatingTexts.length = writeIndex;
            
            // Update ambient particles
            for (let i = 0; i < ambientParticles.length; i++) {
                const p = ambientParticles[i];
                p.y -= p.speed * deltaMultiplier;
                if (p.y < cameraY - 50) {
                    p.y = cameraY + canvas.height + 50;
                    p.x = Math.random() * canvas.width;
                }
            }
        }
        
        // ==================== UPDATE ====================
        function update() {
            if (!gameRunning || upgradeSelectionActive) return;
            
            extendWorld();
            
            // OPTIMIZATION: Wrap globalTime to prevent overflow
            globalTime = (globalTime + deltaMultiplier) % 100000;
            
            if (screenShake > 0) {
                screenShake *= 0.85;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            // ===== COMBO TIMER DECAY =====
            if (comboTimer > 0) {
                comboTimer -= deltaMultiplier;
                if (comboTimer <= 0) {
                    comboCount = 0;
                    comboTimer = 0;
                }
            }
            
            // ===== FEVER MODE UPDATE =====
            if (feverMode) {
                feverTimer -= deltaMultiplier;
                if (feverTimer <= 0) {
                    feverMode = false;
                    feverTimer = 0;
                    createFloatingText('Fever ended!', player.x + player.width/2, player.y - 20, '#888888');
                }
                // Fever mode speed lines
                if (Math.random() < 0.3) createSpeedLine();
            }
            
            // ===== SCREEN FLASH UPDATE =====
            if (screenFlash.active) {
                screenFlash.duration -= deltaMultiplier;
                if (screenFlash.duration <= 0) {
                    screenFlash.active = false;
                }
            }
            
            // ===== SPEED LINES UPDATE =====
            speedLines = speedLines.filter(line => {
                line.y += line.speed * deltaMultiplier;
                return line.y < canvas.height + 50;
            });
            
            // ===== UNSTABLE TILES UPDATE =====
            unstableTiles = unstableTiles.filter(unstable => {
                unstable.timer -= deltaMultiplier;
                
                // Warning shake when low
                if (unstable.timer < 20 && !unstable.warned) {
                    unstable.warned = true;
                }
                
                // Collapse!
                if (unstable.timer <= 0) {
                    const ty = getWorldRow(unstable.absoluteTy);
                    if (ty >= 0 && ty < world.length && world[ty][unstable.tx] === TILE.UNSTABLE) {
                        // Collapse damages player if nearby
                        const tileCX = unstable.tx * TILE_SIZE + TILE_SIZE/2;
                        const tileCY = unstable.absoluteTy * TILE_SIZE + TILE_SIZE/2;
                        const playerCX = player.x + player.width/2;
                        const playerCY = player.y + player.height/2;
                        const dist = Math.sqrt(Math.pow(tileCX - playerCX, 2) + Math.pow(tileCY - playerCY, 2));
                        
                        if (dist < TILE_SIZE * 2) {
                            const damage = 15 * (1 - getEffectiveUpgrade('armor', 90) / 100);
                            fuel -= damage;
                            comboCount = 0;
                            comboTimer = 0;
                            createFloatingText(`-${Math.floor(damage)}`, player.x + 12, player.y, '#ff3355');
                            triggerScreenFlash('#ff0000', 0.2, 6);
                            screenShake = 8;
                            updateFuelBar();
                        }
                        
                        // Turn into rubble (just air with particles)
                        world[ty][unstable.tx] = TILE.AIR;
                        createParticles(tileCX, unstable.absoluteTy * TILE_SIZE + TILE_SIZE/2, '#666688', 12);
                        
                        // Cancel dig if we were digging this tile
                        if (player.digTarget && player.digTarget.x === unstable.tx && player.digTarget.y === unstable.absoluteTy) {
                            player.digging = false;
                            player.digTarget = null;
                        }
                    }
                    return false;
                }
                return true;
            });
            
            player.thrusterFlicker = Math.sin(globalTime * 0.3) * 0.3 + 0.7;
            
            // ===== DIG CANCELLATION WHEN KEY RELEASED =====
            if (player.digging && player.digTarget) {
                // Check if the direction key for current dig is still held
                let keyStillHeld = false;
                if (lastDigDirection === 'down' && keys.down) keyStillHeld = true;
                if (lastDigDirection === 'left' && keys.left) keyStillHeld = true;
                if (lastDigDirection === 'right' && keys.right) keyStillHeld = true;
                
                if (!keyStillHeld && lastDigDirection !== null) {
                    // Key released - cancel dig
                    player.digging = false;
                    player.digTarget = null;
                } else {
                    player.digProgress += (1/60) * deltaMultiplier;
                    if (player.digProgress >= player.digTarget.time) {
                        completeDig(false);
                    }
                }
            } else {
                let dx = 0, dy = 0;
                
                // Apply fever mode speed bonus
                const moveSpeed = player.speed * (feverMode ? 1.3 : 1);
                
                if (keys.left) dx = -moveSpeed;
                if (keys.right) dx = moveSpeed;
                if (keys.up) {
                    dy = -moveSpeed * 0.7 * (1 + permanentUpgrades.climbSpeed / 100);
                }
                
                if (keys.down && !player.digging) {
                    lastDigDirection = 'down';
                    const tx = Math.floor((player.x + player.width / 2) / TILE_SIZE);
                    const absoluteTy = Math.floor((player.y + player.height) / TILE_SIZE);
                    const ty = getWorldRow(absoluteTy);
                    if (ty >= 0 && ty < world.length && world[ty][tx] !== TILE.AIR) {
                        dig(tx, absoluteTy);
                    }
                }
                
                if (dx !== 0) {
                    const newX = player.x + dx * deltaMultiplier;
                    if (newX >= 0 && newX + player.width <= canvas.width) {
                        const checkX = dx > 0 ? newX + player.width : newX;
                        const midY = player.y + player.height / 2;
                        if (getTile(checkX, midY) === TILE.AIR) {
                            player.x = newX;
                            // Speed lines when moving fast in fever mode
                            if (feverMode && Math.random() < 0.2) createSpeedLine();
                        } else if (!player.digging) {
                            lastDigDirection = dx > 0 ? 'right' : 'left';
                            const tx = Math.floor(checkX / TILE_SIZE);
                            const absoluteTy = Math.floor(midY / TILE_SIZE);
                            dig(tx, absoluteTy);
                        }
                    }
                }
                
                if (dy < 0) {
                    const newY = player.y + dy * deltaMultiplier;
                    if (!checkCollision(player.x, newY, player.width, player.height)) {
                        player.y = newY;
                        let climbCost = 0.1 * (1 - getEffectiveUpgrade('fuelEfficiency', 90) / 100);
                        if (feverMode) climbCost *= 0.5;
                        fuel -= climbCost * deltaMultiplier;
                        updateFuelBar();
                        
                        // Thruster particles
                        if (Math.random() < 0.4 && particles.length < MAX_PARTICLES) {
                            const color = feverMode ? '#ff00ff' : '#ff6600';
                            particles.push({
                                x: player.x + player.width / 2 + (Math.random() - 0.5) * 8,
                                y: player.y + player.height + cameraY,
                                vx: (Math.random() - 0.5) * 2,
                                vy: 2 + Math.random() * 2,
                                size: 3 + Math.random() * 3,
                                color: color,
                                life: 0.5,
                                type: 'thruster'
                            });
                        }
                    }
                }
                
                // Gravity
                if (!keys.up) {
                    const newY = player.y + 3 * deltaMultiplier;
                    if (!checkCollision(player.x, newY, player.width, player.height)) {
                        player.y = newY;
                    }
                }
            }
            
            // Clear dig direction when keys released (checked every frame, even while digging)
            if (!keys.down && lastDigDirection === 'down') lastDigDirection = null;
            if (!keys.left && lastDigDirection === 'left') lastDigDirection = null;
            if (!keys.right && lastDigDirection === 'right') lastDigDirection = null;
            
            // Gem magnet
            if (permanentUpgrades.gemMagnet > 0) {
                const magnetRange = permanentUpgrades.gemMagnet * TILE_SIZE;
                const pcx = player.x + player.width / 2;
                const pcy = player.y + player.height / 2;
                
                const startTX = Math.max(0, Math.floor((pcx - magnetRange) / TILE_SIZE));
                const endTX = Math.min(WORLD_WIDTH - 1, Math.floor((pcx + magnetRange) / TILE_SIZE));
                const startAbsTY = Math.floor((pcy - magnetRange) / TILE_SIZE);
                const endAbsTY = Math.floor((pcy + magnetRange) / TILE_SIZE);
                
                for (let absoluteTy = startAbsTY; absoluteTy <= endAbsTY; absoluteTy++) {
                    const ty = getWorldRow(absoluteTy);
                    if (ty < 0 || ty >= world.length) continue;
                    
                    for (let tx = startTX; tx <= endTX; tx++) {
                        const tile = world[ty][tx];
                        if (tile >= TILE.GEM_COMMON && tile <= TILE.GEM_EPIC) {
                            const gemX = tx * TILE_SIZE + TILE_SIZE / 2;
                            const gemY = absoluteTy * TILE_SIZE + TILE_SIZE / 2;
                            const dist = Math.sqrt(Math.pow(gemX - pcx, 2) + Math.pow(gemY - pcy, 2));
                            
                            if (dist < magnetRange) {
                                // BUG FIX: Pass true to indicate magnet collection (no fuel cost)
                                player.digTarget = { x: tx, y: absoluteTy, time: 0 };
                                completeDig(true);
                            }
                        }
                    }
                }
            }
            
            // Camera follow
            const targetCameraY = Math.max(0, player.y - canvas.height * 0.3);
            cameraY += (targetCameraY - cameraY) * 0.08 * deltaMultiplier;
            
            // Depth tracking
            const newDepth = Math.floor((player.y - 60) / TILE_SIZE);
            if (newDepth > depth) {
                depth = newDepth;
                depthEl.textContent = depth;
                depthColorShift = Math.min(depth / 200, 1);
                
                const milestone = Math.floor(depth / 100) * 100;
                if (milestone > lastUpgradeDepth && milestone > 0) {
                    lastUpgradeDepth = milestone;
                    showUpgradeSelector(milestone % 500 === 0);
                }
            }
            
            updateParticles();
            
            if (fuel <= 0) {
                gameOver();
            }
        }
        
        function updateFuelBar() {
            const percent = Math.max(0, (fuel / maxFuel) * 100);
            fuelBar.style.width = percent + '%';
            fuelPercent.textContent = Math.round(percent);
            fuelBarContainer.classList.toggle('critical', percent < 25);
        }
        
        // ==================== DRAWING ====================
        function draw() {
            ctx.save();
            
            if (screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake * 2,
                    (Math.random() - 0.5) * screenShake * 2
                );
            }
            
            // Background
            const hue1 = 220 - depthColorShift * 40;
            const hue2 = 240 - depthColorShift * 50;
            const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            
            // Fever mode tints background magenta
            if (feverMode) {
                const feverPulse = 0.5 + Math.sin(globalTime * 0.1) * 0.2;
                bgGrad.addColorStop(0, `hsl(300, 50%, ${4 * feverPulse}%)`);
                bgGrad.addColorStop(0.5, `hsl(280, 45%, ${3 * feverPulse}%)`);
                bgGrad.addColorStop(1, `hsl(260, 55%, ${2 * feverPulse}%)`);
            } else {
                bgGrad.addColorStop(0, `hsl(${hue1}, 40%, 3%)`);
                bgGrad.addColorStop(0.5, `hsl(${hue2}, 35%, 2%)`);
                bgGrad.addColorStop(1, `hsl(${hue2 - 10}, 45%, 1%)`);
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Background stars (simplified)
            ctx.globalAlpha = 0.35;
            const starTime = globalTime * 0.05;
            for (let i = 0; i < bgStars.length; i++) {
                const star = bgStars[i];
                const sy = star.y - cameraY * 0.3;
                const modY = ((sy % canvas.height) + canvas.height) % canvas.height;
                const twinkle = 0.5 + Math.sin(starTime + star.twinkle) * 0.5;
                ctx.fillStyle = feverMode ? `rgba(255, 150, 255, ${twinkle * 0.6})` : `rgba(200, 220, 255, ${twinkle * 0.5})`;
                ctx.fillRect(star.x - star.size/2, modY - star.size/2, star.size, star.size);
            }
            ctx.globalAlpha = 1;
            
            // ===== SPEED LINES =====
            if (speedLines.length > 0) {
                ctx.strokeStyle = feverMode ? 'rgba(255, 100, 255, 0.6)' : 'rgba(100, 200, 255, 0.4)';
                ctx.lineWidth = 2;
                for (const line of speedLines) {
                    ctx.globalAlpha = line.alpha;
                    ctx.beginPath();
                    ctx.moveTo(line.x, line.y);
                    ctx.lineTo(line.x, line.y + line.length);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Ambient particles
            for (let i = 0; i < ambientParticles.length; i++) {
                const p = ambientParticles[i];
                const sy = p.y - cameraY;
                if (sy > -10 && sy < canvas.height + 10) {
                    const hue = feverMode ? 300 : p.hue;
                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${p.alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, sy, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw world
            const startRow = Math.max(0, Math.floor(cameraY / TILE_SIZE) - worldRowOffset);
            const endRow = Math.min(world.length - 1, Math.ceil((cameraY + canvas.height) / TILE_SIZE) - worldRowOffset);
            
            for (let y = startRow; y <= endRow; y++) {
                const absoluteY = y + worldRowOffset;
                const screenY = absoluteY * TILE_SIZE - cameraY;
                
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    const tile = world[y][x];
                    if (tile !== TILE.AIR) {
                        drawTile(tile, x * TILE_SIZE, screenY, x, absoluteY);
                    }
                }
            }
            
            drawParticles();
            drawPlayer();
            drawFloatingTexts();
            
            // Vignette (stronger during fever mode)
            const vignette = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.25,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.85
            );
            if (feverMode) {
                vignette.addColorStop(0, 'rgba(50, 0, 50, 0)');
                vignette.addColorStop(0.6, 'rgba(80, 0, 80, 0.15)');
                vignette.addColorStop(1, 'rgba(100, 0, 100, 0.4)');
            } else {
                vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0.15)');
                vignette.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            }
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // OPTIMIZATION: Use cached scanline pattern
            if (cachedScanlinePattern) {
                ctx.fillStyle = cachedScanlinePattern;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // ===== SCREEN FLASH =====
            if (screenFlash.active) {
                const flashAlpha = screenFlash.alpha * (screenFlash.duration / 20);
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = flashAlpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }
            
            // ===== COMBO METER UI =====
            if (comboCount > 0) {
                const comboX = 10;
                const comboY = canvas.height - 50;
                const meterWidth = 100;
                const meterHeight = 8;
                const progress = comboTimer / COMBO_DECAY_TIME;
                const multiplier = getComboMultiplier();
                
                // Meter background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(comboX, comboY + 20, meterWidth, meterHeight);
                
                // Meter fill
                const meterColor = multiplier >= 4 ? '#ff00ff' : multiplier >= 3 ? '#ff9500' : multiplier >= 2 ? '#00f0ff' : '#00ff88';
                ctx.fillStyle = meterColor;
                ctx.fillRect(comboX, comboY + 20, meterWidth * progress, meterHeight);
                
                // Meter border
                ctx.strokeStyle = meterColor;
                ctx.lineWidth = 1;
                ctx.strokeRect(comboX, comboY + 20, meterWidth, meterHeight);
                
                // Combo text
                const comboScale = 1 + (multiplier - 1) * 0.1;
                ctx.font = `bold ${Math.floor(16 * comboScale)}px Oxanium, monospace`;
                ctx.fillStyle = meterColor;
                ctx.textAlign = 'left';
                ctx.shadowColor = meterColor;
                ctx.shadowBlur = 10;
                ctx.fillText(`${comboCount} COMBO`, comboX, comboY + 14);
                
                if (multiplier > 1) {
                    ctx.font = `bold ${Math.floor(20 * comboScale)}px Oxanium, monospace`;
                    ctx.fillText(`x${multiplier}`, comboX + meterWidth + 10, comboY + 26);
                }
                ctx.shadowBlur = 0;
            }
            
            // ===== FEVER MODE INDICATOR =====
            if (feverMode) {
                const feverProgress = feverTimer / FEVER_DURATION;
                const feverX = canvas.width - 110;
                const feverY = canvas.height - 35;
                
                // Pulsing "FEVER" text
                const feverPulse = 1 + Math.sin(globalTime * 0.2) * 0.1;
                ctx.font = `bold ${Math.floor(18 * feverPulse)}px Oxanium, monospace`;
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'right';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 15;
                ctx.fillText('ðŸ”¥ FEVER!', canvas.width - 10, feverY);
                ctx.shadowBlur = 0;
                
                // Timer bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(feverX, feverY + 5, 100, 6);
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(feverX, feverY + 5, 100 * feverProgress, 6);
            }
            
            ctx.restore();
        }
        
        function drawTile(tile, x, y, tx, ty) {
            const s = TILE_SIZE;
            const time = globalTime * 0.02;
            
            switch(tile) {
                case TILE.DIRT:
                    ctx.fillStyle = '#3d2d20';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = '#4a3828';
                    ctx.fillRect(x, y, s, s * 0.4);
                    ctx.fillStyle = 'rgba(0,0,0,0.15)';
                    ctx.fillRect(x + ((tx * 7) % s), y + ((ty * 11) % s), 2, 2);
                    ctx.fillRect(x + ((tx * 7 + 13) % s), y + ((ty * 11 + 7) % s), 2, 2);
                    break;
                    
                case TILE.ROCK:
                    ctx.fillStyle = '#404040';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(x, y, s, 1);
                    ctx.fillRect(x, y, 1, s);
                    break;
                    
                case TILE.HARD_ROCK:
                    ctx.fillStyle = '#252530';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = 'rgba(80, 100, 150, 0.2)';
                    ctx.beginPath();
                    ctx.moveTo(x + 3, y + s/2);
                    ctx.lineTo(x + s/2, y + 3);
                    ctx.lineTo(x + s - 3, y + s/2);
                    ctx.lineTo(x + s/2, y + s - 3);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case TILE.GEM_COMMON:
                case TILE.GEM_RARE:
                case TILE.GEM_EPIC:
                    ctx.fillStyle = '#1a1a22';
                    ctx.fillRect(x, y, s, s);
                    
                    const gemColors = {
                        [TILE.GEM_COMMON]: ['#00f0ff', '#00b0bb'],
                        [TILE.GEM_RARE]: ['#ff00ff', '#bb00bb'],
                        [TILE.GEM_EPIC]: ['#ff9500', '#cc7700']
                    };
                    const colors = gemColors[tile];
                    const pulse = 0.85 + Math.sin(time * 3 + tx + ty) * 0.15;
                    
                    // OPTIMIZATION: Reduced shadow usage
                    ctx.fillStyle = colors[1];
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + s/2 - 7 * pulse);
                    ctx.lineTo(x + s/2 + 6 * pulse, y + s/2);
                    ctx.lineTo(x + s/2, y + s/2 + 7 * pulse);
                    ctx.lineTo(x + s/2 - 6 * pulse, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = colors[0];
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + s/2 - 3 * pulse);
                    ctx.lineTo(x + s/2 + 2 * pulse, y + s/2);
                    ctx.lineTo(x + s/2, y + s/2 + 3 * pulse);
                    ctx.lineTo(x + s/2 - 2 * pulse, y + s/2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case TILE.LAVA:
                    const lavaIntensity = 0.5 + Math.sin(time * 3 + tx) * 0.3;
                    ctx.fillStyle = `rgb(${180 + lavaIntensity * 75}, ${30 + lavaIntensity * 40}, 0)`;
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + s * 0.3, y + (Math.sin(time * 2 + tx * 2) + 1) * s / 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff5500';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
                    break;
                    
                case TILE.GAS:
                    const gasAlpha = 0.35 + Math.sin(time * 2 + tx + ty) * 0.15;
                    ctx.fillStyle = '#101a10';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = `rgba(80, 220, 80, ${gasAlpha})`;
                    ctx.fillRect(x, y, s, s);
                    break;
                    
                case TILE.FUEL:
                    ctx.fillStyle = '#1a1815';
                    ctx.fillRect(x, y, s, s);
                    ctx.fillStyle = '#ff7700';
                    ctx.fillRect(x + 4, y + 3, s - 8, s - 6);
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${Math.floor(s * 0.4)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('F', x + s/2, y + s/2 + 4);
                    break;
                    
                case TILE.BOMB:
                    // Dark background
                    ctx.fillStyle = '#1a1515';
                    ctx.fillRect(x, y, s, s);
                    
                    // Bomb body (pulsing)
                    const bombPulse = 0.9 + Math.sin(time * 5 + tx + ty) * 0.1;
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.arc(x + s/2, y + s/2 + 2, (s/2 - 4) * bombPulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bomb highlight
                    ctx.fillStyle = '#555555';
                    ctx.beginPath();
                    ctx.arc(x + s/2 - 3, y + s/2 - 1, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fuse
                    ctx.strokeStyle = '#aa6600';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, y + 4);
                    ctx.quadraticCurveTo(x + s/2 + 4, y + 2, x + s/2 + 6, y + 5);
                    ctx.stroke();
                    
                    // Spark
                    const sparkAlpha = 0.5 + Math.sin(time * 10) * 0.5;
                    ctx.fillStyle = `rgba(255, 200, 50, ${sparkAlpha})`;
                    ctx.beginPath();
                    ctx.arc(x + s/2 + 6, y + 4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case TILE.CHEST:
                    // Dark background
                    ctx.fillStyle = '#1a1510';
                    ctx.fillRect(x, y, s, s);
                    
                    // Chest body (golden)
                    const chestGlow = 0.8 + Math.sin(time * 2 + tx) * 0.2;
                    ctx.fillStyle = `rgb(${Math.floor(180 * chestGlow)}, ${Math.floor(140 * chestGlow)}, 50)`;
                    ctx.fillRect(x + 3, y + s/2 - 2, s - 6, s/2);
                    
                    // Chest lid
                    ctx.fillStyle = `rgb(${Math.floor(200 * chestGlow)}, ${Math.floor(160 * chestGlow)}, 60)`;
                    ctx.beginPath();
                    ctx.moveTo(x + 2, y + s/2 - 2);
                    ctx.lineTo(x + s/2, y + 4);
                    ctx.lineTo(x + s - 2, y + s/2 - 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lock/clasp
                    ctx.fillStyle = '#ffdd00';
                    ctx.fillRect(x + s/2 - 3, y + s/2 - 1, 6, 4);
                    
                    // Sparkles
                    ctx.fillStyle = `rgba(255, 255, 200, ${0.3 + Math.sin(time * 4 + tx * 2) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x + 6, y + 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + s - 6, y + 10, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case TILE.UNSTABLE:
                    // Check if this tile is about to collapse
                    const unstableData = unstableTiles.find(u => u.tx === tx && u.absoluteTy === ty);
                    const isWarning = unstableData && unstableData.timer < 25;
                    const shakeAmount = isWarning ? Math.sin(time * 20) * 2 : 0;
                    
                    // Cracked rock appearance
                    ctx.fillStyle = isWarning ? '#4a3535' : '#3a3545';
                    ctx.fillRect(x + shakeAmount, y, s, s);
                    
                    // Crack lines
                    ctx.strokeStyle = isWarning ? '#ff6666' : '#555566';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x + s/4 + shakeAmount, y);
                    ctx.lineTo(x + s/3 + shakeAmount, y + s/2);
                    ctx.lineTo(x + s/5 + shakeAmount, y + s);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + s*0.7 + shakeAmount, y);
                    ctx.lineTo(x + s*0.6 + shakeAmount, y + s/3);
                    ctx.lineTo(x + s*0.8 + shakeAmount, y + s*0.7);
                    ctx.stroke();
                    
                    // Warning glow
                    if (isWarning) {
                        ctx.fillStyle = `rgba(255, 100, 100, ${0.2 + Math.sin(time * 15) * 0.2})`;
                        ctx.fillRect(x, y, s, s);
                    }
                    break;
            }
            
            // Grid lines (simplified)
            if (tile !== TILE.AIR && tile < TILE.LAVA) {
                ctx.strokeStyle = 'rgba(0,0,0,0.08)';
                ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
            }
        }
        
        function drawPlayer() {
            const screenY = player.y - cameraY;
            const cx = player.x + player.width / 2;
            
            // ===== FEVER MODE AURA =====
            if (feverMode) {
                const auraSize = 30 + Math.sin(globalTime * 0.15) * 8;
                const auraGrad = ctx.createRadialGradient(cx, screenY + player.height/2, 5, cx, screenY + player.height/2, auraSize);
                auraGrad.addColorStop(0, 'rgba(255, 0, 255, 0.4)');
                auraGrad.addColorStop(0.5, 'rgba(255, 0, 255, 0.15)');
                auraGrad.addColorStop(1, 'rgba(255, 0, 255, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(cx, screenY + player.height/2, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Thruster glow
            if (keys.up) {
                const thrusterColor = feverMode ? 'rgba(255, 0, 255,' : 'rgba(255, 100, 0,';
                ctx.fillStyle = `${thrusterColor} ${0.4 * player.thrusterFlicker})`;
                ctx.beginPath();
                ctx.ellipse(cx, screenY + player.height + 8, 10, 15, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Body (tinted magenta in fever mode)
            ctx.fillStyle = feverMode ? '#d000d8' : '#00d0d8';
            ctx.beginPath();
            ctx.roundRect(player.x + 2, screenY + 4, player.width - 4, player.height - 10, 5);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = feverMode ? '#ff00ff' : '#00f0ff';
            ctx.fillRect(player.x + 4, screenY + 5, player.width - 8, 3);
            
            // Cockpit
            ctx.fillStyle = feverMode ? '#150015' : '#001015';
            ctx.beginPath();
            ctx.roundRect(player.x + 5, screenY + 7, player.width - 10, 10, 3);
            ctx.fill();
            
            ctx.fillStyle = feverMode ? 'rgba(255, 0, 255, 0.7)' : 'rgba(0, 240, 255, 0.7)';
            ctx.beginPath();
            ctx.roundRect(player.x + 6, screenY + 8, player.width - 12, 8, 2);
            ctx.fill();
            
            // Drill (more animated in fever mode)
            ctx.fillStyle = feverMode ? '#ff00ff' : '#ffaa00';
            ctx.save();
            ctx.translate(cx, screenY + player.height);
            if (player.digging) {
                const spinSpeed = feverMode ? 0.8 : 0.5;
                ctx.rotate(Math.sin(globalTime * spinSpeed) * 0.15);
            }
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.lineTo(8, -4);
            ctx.lineTo(3, 10);
            ctx.lineTo(0, 14);
            ctx.lineTo(-3, 10);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = feverMode ? '#aa00aa' : '#cc7700';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-4, 0);
            ctx.lineTo(0, 10);
            ctx.moveTo(4, 0);
            ctx.lineTo(0, 10);
            ctx.stroke();
            ctx.restore();
            
            // Thrusters
            ctx.fillStyle = feverMode ? '#450045' : '#004550';
            ctx.fillRect(player.x - 1, screenY + 12, 4, 8);
            ctx.fillRect(player.x + player.width - 3, screenY + 12, 4, 8);
            
            // Dig progress indicator
            if (player.digging && player.digTarget) {
                const progress = player.digProgress / player.digTarget.time;
                const barColor = feverMode ? 'rgba(255, 0, 255,' : 'rgba(0, 240, 255,';
                ctx.fillStyle = `${barColor} 0.8)`;
                ctx.fillRect(player.x, screenY - 6, player.width * progress, 3);
                ctx.strokeStyle = `${barColor} 0.4)`;
                ctx.strokeRect(player.x, screenY - 6, player.width, 3);
            }
        }
        
        function drawParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const screenY = p.y - cameraY;
                
                // Skip off-screen particles
                if (screenY < -20 || screenY > canvas.height + 20) continue;
                
                ctx.globalAlpha = p.life;
                
                if (p.type === 'gem') {
                    // Glowing gem particles with trail
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'explosion') {
                    // Bright explosion particles
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    // Trail effect
                    ctx.globalAlpha = p.life * 0.5;
                    ctx.beginPath();
                    ctx.arc(p.x - p.vx * 2, screenY - p.vy * 2, p.size * p.life * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'thruster') {
                    // Fiery thruster particles
                    const gradient = ctx.createRadialGradient(p.x, screenY, 0, p.x, screenY, p.size);
                    gradient.addColorStop(0, p.color);
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'debris' && p.rotation !== undefined) {
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(p.x, screenY);
                    ctx.rotate(p.rotation);
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                    ctx.restore();
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }
        
        function drawFloatingTexts() {
            for (let i = 0; i < floatingTexts.length; i++) {
                const t = floatingTexts[i];
                const screenY = t.y - cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) continue;
                
                ctx.globalAlpha = t.life;
                ctx.font = `800 ${Math.round(16 * t.scale)}px Oxanium, monospace`;
                ctx.fillStyle = t.color;
                ctx.textAlign = 'center';
                ctx.shadowColor = t.color;
                ctx.shadowBlur = 8;
                ctx.fillText(t.text, t.x, screenY);
                ctx.shadowBlur = 0;
            }
            ctx.globalAlpha = 1;
        }
        
        // ==================== UPGRADE SYSTEM ====================
        function showUpgradeSelector(legendary = false) {
            upgradeSelectionActive = true;
            upgradeSelected = false;
            isLegendaryUpgrade = legendary;
            
            const definitions = legendary ? legendaryUpgradeDefinitions : upgradeDefinitions;
            currentUpgradeChoices = legendary ? [...definitions] : weightedRandomSelect(definitions, 3);
            
            upgradeOverlay.classList.toggle('legendary', legendary);
            
            slots.forEach((slot, i) => {
                if (i < currentUpgradeChoices.length) {
                    slot.className = legendary ? 'upgrade-slot rolling legendary' : 'upgrade-slot rolling';
                    slot.style.display = '';
                    slot.querySelector('.upgrade-icon').textContent = '?';
                    slot.querySelector('.upgrade-name').textContent = '???';
                    slot.querySelector('.upgrade-desc').textContent = '???';
                } else {
                    slot.style.display = 'none';
                }
            });
            
            upgradeOverlay.classList.add('active');
            rollSlots();
        }
        
        function weightedRandomSelect(available, count) {
            const selected = [];
            const pool = [...available];
            
            for (let i = 0; i < count && pool.length > 0; i++) {
                const weights = pool.map(u => Math.pow(upgradeOfferHistory[u.id] || 1, 2));
                const total = weights.reduce((a, b) => a + b, 0);
                let r = Math.random() * total;
                let idx = 0;
                
                for (let j = 0; j < weights.length; j++) {
                    r -= weights[j];
                    if (r <= 0) { idx = j; break; }
                }
                selected.push(pool.splice(idx, 1)[0]);
            }
            
            available.forEach(u => {
                upgradeOfferHistory[u.id] = selected.some(c => c.id === u.id) ? 0 : Math.min((upgradeOfferHistory[u.id] || 0) + 1, 5);
            });
            
            return selected;
        }
        
        function rollSlots() {
            // MEMORY LEAK FIX: Clear any existing intervals/timeouts
            clearRollTimers();
            
            const rollDuration = isLegendaryUpgrade ? 1800 : 1500;
            const staggerDelay = isLegendaryUpgrade ? 400 : 300;
            const rollDefs = isLegendaryUpgrade ? legendaryUpgradeDefinitions : upgradeDefinitions;
            
            slots.forEach((slot, i) => {
                if (i >= currentUpgradeChoices.length) return;
                
                const rollInterval = setInterval(() => {
                    const r = rollDefs[Math.floor(Math.random() * rollDefs.length)];
                    slot.querySelector('.upgrade-icon').textContent = r.icon;
                    slot.querySelector('.upgrade-name').textContent = r.name;
                    slot.querySelector('.upgrade-desc').textContent = r.desc;
                }, 100);
                
                activeRollIntervals.push(rollInterval);
                
                const timeout = setTimeout(() => {
                    clearInterval(rollInterval);
                    const choice = currentUpgradeChoices[i];
                    slot.className = isLegendaryUpgrade ? 'upgrade-slot revealed legendary' : 'upgrade-slot revealed';
                    slot.querySelector('.upgrade-icon').textContent = choice.icon;
                    slot.querySelector('.upgrade-name').textContent = choice.name;
                    slot.querySelector('.upgrade-desc').textContent = choice.desc;
                    slot.onclick = () => selectUpgrade(i);
                    slot.ontouchend = (e) => { e.preventDefault(); e.stopPropagation(); selectUpgrade(i); };
                }, rollDuration + i * staggerDelay);
                
                activeRollTimeouts.push(timeout);
            });
        }
        
        function clearRollTimers() {
            activeRollIntervals.forEach(clearInterval);
            activeRollTimeouts.forEach(clearTimeout);
            activeRollIntervals = [];
            activeRollTimeouts = [];
        }
        
        function selectUpgrade(index) {
            if (!upgradeSelectionActive || upgradeSelected) return;
            upgradeSelected = true;
            
            slots.forEach((slot, i) => {
                if (i === index) {
                    slot.classList.add('selected');
                } else {
                    slot.style.opacity = '0.25';
                    slot.style.pointerEvents = 'none';
                }
            });
            
            currentUpgradeChoices[index].apply();
            updatePermanentUpgradesDisplay();
            
            setTimeout(() => {
                upgradeSelectionActive = false;
                upgradeOverlay.classList.remove('active', 'legendary');
                slots.forEach(s => {
                    s.style.opacity = '';
                    s.style.pointerEvents = '';
                    s.classList.remove('selected', 'legendary');
                    s.onclick = null;
                    s.ontouchend = null;
                });
                isLegendaryUpgrade = false;
            }, 600);
        }
        
        function updatePermanentUpgradesDisplay() {
            const icons = {
                digSpeed: { icon: 'âš¡', color: '#ff9500', div: 15 },
                fuelCapacity: { icon: 'â›½', color: '#ff6600', div: 20 },
                gemMagnet: { icon: 'ðŸ§²', color: '#00f0ff', div: 1 },
                armor: { icon: 'ðŸ›¡ï¸', color: '#8888aa', div: 25 },
                fuelEfficiency: { icon: 'ðŸŒ¿', color: '#00ff88', div: 10 },
                gemValue: { icon: 'ðŸ’°', color: '#ffd700', div: 15 },
                climbSpeed: { icon: 'ðŸª', color: '#ff00ff', div: 20 },
                drillPower: { icon: 'ðŸ’Ž', color: '#00f0ff', div: 10 }
            };
            
            let html = '';
            for (const [k, v] of Object.entries(permanentUpgrades)) {
                if (v > 0 && icons[k]) {
                    const stacks = Math.max(1, Math.floor(v / icons[k].div));
                    html += `<div class="perm-upgrade" style="color: ${icons[k].color}; border-color: ${icons[k].color}30;">
                        <span class="perm-icon">${icons[k].icon}</span>
                        <span class="perm-stack" style="border-color: ${icons[k].color};">Ã—${stacks}</span>
                    </div>`;
                }
            }
            permUpgradesEl.innerHTML = html;
        }
        
        // ==================== GAME OVER ====================
        function gameOver() {
            gameRunning = false;
            clearRollTimers();
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.88)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = '800 36px Oxanium, monospace';
            ctx.fillStyle = '#ff00ff';
            ctx.textAlign = 'center';
            ctx.fillText('OUT OF FUEL', canvas.width / 2, canvas.height / 2 - 45);
            
            ctx.font = '600 20px "Exo 2", sans-serif';
            ctx.fillStyle = '#00f0ff';
            ctx.fillText(`Depth: ${depth}m`, canvas.width / 2, canvas.height / 2 + 5);
            ctx.fillStyle = '#ff9500';
            ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 35);
            
            setTimeout(showScoreModal, 1500);
        }
        
        // ==================== SCORE SYSTEM ====================
        function showScoreModal() {
            finalScoreEl.textContent = `${score} pts â€¢ ${depth}m`;
            scoreModal.classList.add('active');
            usernameInput.value = '';
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            showGameOverButtons();
        }
        
        function showGameOverButtons() {
            startBtn.textContent = 'DIG AGAIN';
            startBtn.style.visibility = 'visible';
            leaderboardBtn.style.visibility = 'visible';
            buttonContainer.style.display = '';
        }
        
        function saveLocalScore(name, scoreVal, depthVal) {
            try {
                const scores = JSON.parse(localStorage.getItem('neon_dig_scores') || '[]');
                scores.push({ name: name, score: scoreVal, depth: depthVal, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem('neon_dig_scores', JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Failed to save score:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem('neon_dig_scores') || '[]');
            } catch (e) {
                return [];
            }
        }
        
        function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            const scores = getLocalScores();
            
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.4); padding: 40px 20px; font-size: 13px;">No scores yet.<br><br>Start digging!</div>';
                return;
            }
            
            leaderboardList.innerHTML = scores.slice(0, 20).map((e, i) => {
                const rankClass = i < 3 ? `top-3 leaderboard-rank-${i + 1}` : '';
                return `<div class="leaderboard-row ${rankClass}">
                    <span style="width: 30px; font-weight: 700;">#${i + 1}</span>
                    <span style="flex: 1;">${e.name}</span>
                    <span style="width: 60px; text-align: right; font-family: 'Oxanium', monospace;">${e.score}</span>
                    <span style="width: 50px; text-align: right; opacity: 0.5;">${e.depth}m</span>
                </div>`;
            }).join('');
        }
        
        // ==================== INPUT HANDLING ====================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
        });
        
        let touchStartX = 0, touchStartY = 0;
        
        controlZone.addEventListener('touchstart', (e) => {
            if (upgradeSelectionActive) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        controlZone.addEventListener('touchmove', (e) => {
            if (upgradeSelectionActive) return;
            e.preventDefault();
            const dx = e.touches[0].clientX - touchStartX;
            const dy = e.touches[0].clientY - touchStartY;
            keys.left = dx < -15;
            keys.right = dx > 15;
            keys.up = dy < -15;
            keys.down = dy > 15;
        }, { passive: false });
        
        controlZone.addEventListener('touchend', () => {
            keys.left = keys.right = keys.up = keys.down = false;
        });
        
        // ==================== EVENT LISTENERS ====================
        submitScoreBtn.addEventListener('click', () => {
            const name = usernameInput.value.trim();
            if (name.length < 2) {
                scoreError.textContent = 'Name must be at least 2 characters';
                return;
            }
            saveLocalScore(name, score, depth);
            hideScoreModal();
        });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') submitScoreBtn.click();
            if (e.key === 'Escape') hideScoreModal();
        });
        
        usernameInput.addEventListener('input', () => {
            scoreError.textContent = '';
        });
        
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardClose.addEventListener('click', () => leaderboardOverlay.classList.remove('active'));
        
        // ==================== GAME START ====================
        function startGame() {
            // Clear any lingering timers
            clearRollTimers();
            
            gameRunning = true;
            score = 0;
            depth = 0;
            fuel = 100;
            maxFuel = 100;
            lastUpgradeDepth = 0;
            cameraY = 0;
            upgradeOfferHistory = {};
            screenShake = 0;
            depthColorShift = 0;
            globalTime = 0;
            
            // Reset combo and fever systems
            comboCount = 0;
            comboTimer = 0;
            feverMode = false;
            feverTimer = 0;
            
            // Reset visual effects
            screenFlash = { active: false, color: '#ffffff', alpha: 0, duration: 0 };
            speedLines = [];
            unstableTiles = [];
            
            // Reset upgrades
            Object.keys(permanentUpgrades).forEach(k => permanentUpgrades[k] = 0);
            
            // Reset dig direction
            lastDigDirection = null;
            
            player.x = canvas.width / 2 - 12;
            player.y = 60;
            player.digging = false;
            player.digTarget = null;
            player.digProgress = 0;
            
            particles = [];
            floatingTexts = [];
            
            generateWorld();
            initAmbientParticles();
            initBgStars();
            
            depthEl.textContent = '0';
            scoreEl.textContent = '0';
            updateFuelBar();
            updatePermanentUpgradesDisplay();
            
            buttonContainer.style.display = 'none';
        }
        
        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); }, { passive: false });
        
        // ==================== GAME LOOP ====================
        function gameLoop(timestamp) {
            if (lastFrameTime === 0) lastFrameTime = timestamp;
            const delta = timestamp - lastFrameTime;
            deltaMultiplier = Math.min(delta / TARGET_FRAME_TIME, 3);
            lastFrameTime = timestamp;
            
            update();
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== INITIALIZATION ====================
        createScanlinePattern();
        generateWorld();
        initAmbientParticles();
        initBgStars();
        draw();
        
        // Title screen
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = '800 30px Oxanium, monospace';
        ctx.fillStyle = '#00f0ff';
        ctx.textAlign = 'center';
        ctx.fillText('NEON DIG', canvas.width / 2, canvas.height / 2 - 35);
        ctx.font = '400 13px "Exo 2", sans-serif';
        ctx.fillStyle = '#ff00ff';
        ctx.fillText('Dig Deep  â€¢  Collect Gems  â€¢  Survive', canvas.width / 2, canvas.height / 2 + 5);
        
        requestAnimationFrame(gameLoop);
    })();
    </script>
</body>
</html>
