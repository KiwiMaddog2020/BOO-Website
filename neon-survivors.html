<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Survivors</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            width: 100%;
            height: 100%;
            position: fixed;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: none;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 8px;
        }

        #gameCanvas {
            border: 3px solid #0ff;
            box-shadow: 0 0 20px #0ff, inset 0 0 15px rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            background: #0a0a0a;
        }

        /* HUD Overlay */
        .hud {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            color: #fff;
            font-size: 14px;
            text-shadow: 0 0 10px #0ff;
            z-index: 100;
            pointer-events: none;
        }

        .hud-row {
            display: flex;
            gap: 20px;
        }

        .hud span {
            color: #0ff;
        }

        .hud .hp-bar {
            width: 150px;
            height: 12px;
            background: rgba(255, 0, 100, 0.2);
            border: 1px solid #f0f;
            border-radius: 3px;
            overflow: hidden;
        }

        .hud .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f0f, #ff1493);
            box-shadow: 0 0 8px #f0f;
            transition: width 0.2s;
        }

        .hud .xp-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            border-radius: 3px;
            overflow: hidden;
        }

        .hud .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffcc, #0ff);
            box-shadow: 0 0 6px #0ff;
            transition: width 0.15s;
        }

        /* Weapon icons display */
        .weapons-display {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 100;
            pointer-events: none;
        }

        .weapon-icon {
            width: 36px;
            height: 36px;
            border: 2px solid;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            position: relative;
        }

        .weapon-level {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 10px;
            background: #000;
            padding: 1px 4px;
            border-radius: 3px;
            color: #fff;
        }

        /* Upgrade Selection Overlay */
        .upgrade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .upgrade-overlay.active {
            display: flex;
        }

        .upgrade-title {
            font-size: 28px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            margin-bottom: 30px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .upgrade-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 600px;
        }

        .upgrade-card {
            width: 160px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .upgrade-card:hover {
            transform: scale(1.05);
        }

        .upgrade-card .icon {
            font-size: 32px;
        }

        .upgrade-card .name {
            font-size: 14px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .upgrade-card .desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
        }

        /* Shrine Power-up Overlay */
        .shrine-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .shrine-overlay.active {
            display: flex;
        }

        .shrine-title {
            font-size: 24px;
            color: #00aaff;
            text-shadow: 0 0 20px #00aaff;
            margin-bottom: 10px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .shrine-subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 25px;
        }

        /* Slot machine reels */
        .slot-machine {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .slot-reel {
            width: 100px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00aaff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.3);
        }

        .slot-reel.spinning .slot-content {
            animation: slotSpin 0.1s linear infinite;
        }

        .slot-reel.stopped {
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        @keyframes slotSpin {
            0% { transform: translateY(0); }
            100% { transform: translateY(-40px); }
        }

        .slot-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 10px;
        }

        .slot-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .slot-name {
            font-size: 11px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .slot-value {
            font-size: 10px;
            color: #0ff;
            text-align: center;
        }

        .shrine-options {
            display: flex;
            gap: 15px;
        }

        .shrine-card {
            width: 100px;
            padding: 15px 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00aaff;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transform: scale(0.8);
        }

        .shrine-card.revealed {
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.3s, transform 0.3s;
        }

        .shrine-card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border-color: #0ff;
        }

        .shrine-card .icon {
            font-size: 28px;
        }

        .shrine-card .name {
            font-size: 11px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .shrine-card .value {
            font-size: 10px;
            color: #0ff;
        }

        /* Shrine charge indicator */
        .shrine-charge-bar {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00aaff;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 150;
        }

        .shrine-charge-bar.active {
            display: block;
        }

        .shrine-charge-fill {
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #0ff);
            box-shadow: 0 0 10px #0ff;
            transition: width 0.1s linear;
        }

        .shrine-charge-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 11px;
            text-shadow: 0 0 5px #000;
            letter-spacing: 1px;
        }

        /* Start/Game Over Screen */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
        }

        .menu-overlay.hidden {
            display: none;
        }

        .game-title {
            font-size: 48px;
            color: #f0f;
            text-shadow: 0 0 30px #f0f, 0 0 60px #ff1493;
            margin-bottom: 10px;
            letter-spacing: 5px;
            text-transform: uppercase;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 30px #f0f, 0 0 60px #ff1493; }
            50% { text-shadow: 0 0 40px #f0f, 0 0 80px #ff1493, 0 0 100px #0ff; }
        }

        .game-subtitle {
            font-size: 14px;
            color: #0ff;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }

        .menu-btn {
            padding: 15px 40px;
            font-size: 16px;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            margin: 10px;
        }

        .menu-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 25px #0ff;
        }

        .final-stats {
            color: #fff;
            text-align: center;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.8;
        }

        .final-stats span {
            color: #ff6600;
        }

        /* Mobile controls */
        .joystick-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 200;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid #0ff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #0ff;
        }

        @media (hover: none), (pointer: coarse) {
            .joystick-zone {
                display: block;
            }
        }

        /* Timer display */
        .timer {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ff6600;
            text-shadow: 0 0 15px #ff6600;
            z-index: 100;
            pointer-events: none;
            letter-spacing: 2px;
        }

        /* Kill counter */
        .kills {
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 14px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            z-index: 100;
            pointer-events: none;
        }

        .kills span {
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div class="hud">
            <div class="hud-row">
                HP: <div class="hp-bar"><div class="hp-fill" id="hpFill"></div></div>
            </div>
            <div class="hud-row">
                LV <span id="levelDisplay">1</span>
            </div>
            <div class="xp-bar"><div class="xp-fill" id="xpFill"></div></div>
        </div>

        <!-- Weapons Display -->
        <div class="weapons-display" id="weaponsDisplay"></div>

        <!-- Timer -->
        <div class="timer" id="timer">0:00</div>

        <!-- Kills -->
        <div class="kills">KILLS: <span id="killCount">0</span></div>

        <!-- Upgrade Selection -->
        <div class="upgrade-overlay" id="upgradeOverlay">
            <div class="upgrade-title">LEVEL UP!</div>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>

        <!-- Shrine Power-up Selection -->
        <div class="shrine-overlay" id="shrineOverlay">
            <div class="shrine-title">âœ¨ SHRINE ACTIVATED âœ¨</div>
            <div class="shrine-subtitle">Choose your blessing</div>
            <div class="slot-machine" id="slotMachine"></div>
            <div class="shrine-options" id="shrineOptions"></div>
        </div>

        <!-- Shrine Charge Bar -->
        <div class="shrine-charge-bar" id="shrineChargeBar">
            <div class="shrine-charge-fill" id="shrineChargeFill"></div>
            <div class="shrine-charge-text">CHANNELING...</div>
        </div>

        <!-- Start/Game Over Menu -->
        <div class="menu-overlay" id="menuOverlay">
            <div class="game-title">NEON SURVIVORS</div>
            <div class="game-subtitle">Survive the neon horde</div>
            <button class="menu-btn" id="startBtn">START</button>
            <div class="final-stats" id="finalStats" style="display: none;"></div>
        </div>

        <!-- Mobile Joystick -->
        <div class="joystick-zone" id="joystickZone">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>

    <script>
        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 20, 600);
            const maxHeight = Math.min(window.innerHeight - 20, 450);
            const aspect = 4 / 3;
            
            if (maxWidth / maxHeight > aspect) {
                canvas.height = maxHeight;
                canvas.width = Math.floor(maxHeight * aspect);
            } else {
                canvas.width = maxWidth;
                canvas.height = Math.floor(maxWidth / aspect);
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== NEON COLOR PALETTE =====
        const COLORS = {
            cyan: '#0ff',
            magenta: '#f0f',
            pink: '#ff1493',
            orange: '#ff6600',
            purple: '#9b30ff',
            teal: '#00ffcc',
            blue: '#00aaff',
            yellow: '#ffff00'
        };

        // ===== WORLD & CAMERA =====
        const WORLD = {
            width: 6000,
            height: 6000
        };
        
        const camera = {
            x: 0,
            y: 0,
            
            update() {
                // Center camera on player
                this.x = player.x - canvas.width / 2;
                this.y = player.y - canvas.height / 2;
                
                // Clamp to world bounds
                this.x = Math.max(0, Math.min(WORLD.width - canvas.width, this.x));
                this.y = Math.max(0, Math.min(WORLD.height - canvas.height, this.y));
            },
            
            // Convert world coords to screen coords
            screenX(worldX) { return worldX - this.x; },
            screenY(worldY) { return worldY - this.y; },
            
            // Check if world position is visible
            isVisible(x, y, margin = 50) {
                return x > this.x - margin && 
                       x < this.x + canvas.width + margin &&
                       y > this.y - margin && 
                       y < this.y + canvas.height + margin;
            }
        };

        // ===== GAME STATE =====
        let gameRunning = false;
        let gamePaused = false;
        let gameTime = 0;
        let kills = 0;
        let player = null;
        let enemies = [];
        let projectiles = [];
        let xpGems = [];
        let damageNumbers = [];
        let particles = [];
        let shrines = [];

        // Entity limits for performance
        const LIMITS = {
            particles: 200,
            damageNumbers: 50,
            projectiles: 100,
            enemies: 150
        };

        // ===== WEAPON DEFINITIONS =====
        const WEAPONS = {
            energyBolt: {
                name: 'Energy Bolt',
                icon: 'âš¡',
                color: COLORS.cyan,
                desc: 'Auto-fires at nearest enemy',
                baseDamage: 10,
                baseFireRate: 700,  // Buffed from 800ms
                baseProjectiles: 1,
                type: 'projectile'
            },
            plasmaOrbit: {
                name: 'Plasma Orbit',
                icon: 'ðŸ”®',
                color: COLORS.purple,
                desc: 'Orbs rotate around you',
                baseDamage: 15,
                baseOrbs: 2,
                type: 'orbit'
            },
            neonWave: {
                name: 'Neon Wave',
                icon: 'ðŸŒŠ',
                color: COLORS.teal,
                desc: 'Damages all nearby enemies',
                baseDamage: 10,  // Buffed from 8
                baseRadius: 90,  // Buffed from 80
                baseFireRate: 1400,  // Buffed from 1500ms
                type: 'aoe'
            },
            laserBeam: {
                name: 'Laser Beam',
                icon: 'ðŸ“¡',
                color: COLORS.pink,
                desc: 'Piercing laser shots',
                baseDamage: 25,
                baseFireRate: 1100,  // Buffed from 1200ms
                pierce: 4,  // Buffed from 3
                type: 'laser'
            },
            shockField: {
                name: 'Shock Field',
                icon: 'ðŸ’«',
                color: COLORS.yellow,
                desc: 'Zaps random enemies',
                baseDamage: 14,  // Buffed from 12
                baseFireRate: 550,  // Buffed from 600ms
                baseTargets: 2,
                type: 'chain'
            }
        };

        // ===== PASSIVE UPGRADES =====
        const PASSIVES = {
            speed: { name: 'Speed Boost', icon: 'ðŸ‘Ÿ', color: COLORS.teal, desc: '+12% move speed' },
            maxHp: { name: 'Vitality', icon: 'â¤ï¸', color: COLORS.pink, desc: '+25 max HP' },
            damage: { name: 'Power Up', icon: 'ðŸ’ª', color: COLORS.orange, desc: '+12% damage' },
            pickupRange: { name: 'Magnet', icon: 'ðŸ§²', color: COLORS.blue, desc: '+30% pickup range' },
            regen: { name: 'Regen', icon: 'ðŸ’š', color: COLORS.teal, desc: 'Heal 1.5 HP/sec' }
        };

        // ===== SHRINE POWER-UPS =====
        const SHRINE_POWERUPS = {
            damage: { name: 'Power', icon: 'âš”ï¸', color: COLORS.orange, desc: '+12% Damage', stat: 'damageBonus', value: 0.12 },
            speed: { name: 'Swiftness', icon: 'ðŸ’¨', color: COLORS.teal, desc: '+10% Speed', stat: 'speedBonus', value: 0.10 },
            attackSpeed: { name: 'Haste', icon: 'âš¡', color: COLORS.yellow, desc: '+12% Attack Speed', stat: 'attackSpeedBonus', value: 0.12 },
            regen: { name: 'Vitality', icon: 'ðŸ’š', color: COLORS.teal, desc: '+1.0 HP/sec', stat: 'regenBonus', value: 1.0 },
            lifesteal: { name: 'Vampirism', icon: 'ðŸ©¸', color: COLORS.pink, desc: '+5% Lifesteal', stat: 'lifesteal', value: 0.05 },
            critChance: { name: 'Precision', icon: 'ðŸŽ¯', color: COLORS.cyan, desc: '+6% Crit Chance', stat: 'critChance', value: 0.06 },
            critMultiplier: { name: 'Lethality', icon: 'ðŸ’€', color: COLORS.purple, desc: '+15% Crit Damage', stat: 'critMultiplier', value: 0.15 },
            armor: { name: 'Fortitude', icon: 'ðŸ›¡ï¸', color: COLORS.blue, desc: '+8% Damage Reduction', stat: 'armor', value: 0.08 }
        };

        // ===== PLAYER CLASS =====
        class Player {
            constructor() {
                this.x = WORLD.width / 2;
                this.y = WORLD.height / 2;
                this.radius = 12;
                this.baseSpeed = 3.0;  // Buffed from 2.5
                this.speed = this.baseSpeed;
                this.maxHp = 120;      // Buffed from 100
                this.hp = this.maxHp;
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 10;
                this.weapons = {};
                this.passives = {};
                this.pickupRange = 50;
                this.damageMultiplier = 1;
                this.regenRate = 0;
                this.invincible = 0;
                this.invincibilityDuration = 600; // Buffed from 500ms
                
                // New stats for shrine system
                this.critChance = 0.05;      // 5% base crit chance
                this.critMultiplier = 2.0;   // 2x base crit damage
                this.armor = 0;              // % damage reduction
                this.lifesteal = 0;          // % of damage healed
                this.attackSpeedMultiplier = 1;
                
                // Shrine bonuses (stacking)
                this.shrineBonuses = {
                    damageBonus: 0,
                    speedBonus: 0,
                    attackSpeedBonus: 0,
                    regenBonus: 0,
                    lifesteal: 0,
                    critChance: 0,
                    critMultiplier: 0,
                    armor: 0
                };
                
                // Give starting weapon
                this.addWeapon('energyBolt');
            }

            addWeapon(weaponId) {
                if (!this.weapons[weaponId]) {
                    this.weapons[weaponId] = {
                        level: 1,
                        lastFire: 0,
                        angle: 0  // for orbit weapons
                    };
                } else {
                    this.weapons[weaponId].level = Math.min(this.weapons[weaponId].level + 1, 5);
                }
            }

            addPassive(passiveId) {
                if (!this.passives[passiveId]) {
                    this.passives[passiveId] = 1;
                } else {
                    this.passives[passiveId]++;
                }
                this.applyPassives();
            }

            applyPassives() {
                // Base passives from level-up (updated values)
                const baseSpeedMult = 1 + (this.passives.speed || 0) * 0.12;  // 12% per level
                const shrineSpeedMult = 1 + this.shrineBonuses.speedBonus;
                this.speed = this.baseSpeed * baseSpeedMult * shrineSpeedMult;
                
                this.maxHp = 120 + (this.passives.maxHp || 0) * 25;  // +25 HP per level
                this.hp = Math.min(this.hp, this.maxHp);
                
                // Damage multiplier combines passive and shrine bonuses
                const baseDamageMult = 1 + (this.passives.damage || 0) * 0.12;  // 12% per level
                this.damageMultiplier = baseDamageMult * (1 + this.shrineBonuses.damageBonus);
                
                this.pickupRange = 50 * (1 + (this.passives.pickupRange || 0) * 0.30);  // 30% per level
                
                // Regen from passives + shrine (1.5 per passive level)
                this.regenRate = (this.passives.regen || 0) * 1.5 + this.shrineBonuses.regenBonus;
                
                // Attack speed from shrine
                this.attackSpeedMultiplier = 1 + this.shrineBonuses.attackSpeedBonus;
                
                // Crit stats (base + shrine)
                this.critChance = 0.05 + this.shrineBonuses.critChance;
                this.critMultiplier = 2.0 + this.shrineBonuses.critMultiplier;
                
                // Lifesteal and armor from shrine
                this.lifesteal = this.shrineBonuses.lifesteal;
                this.armor = this.shrineBonuses.armor;
            }
            
            addShrineBonus(stat, value) {
                if (this.shrineBonuses.hasOwnProperty(stat)) {
                    this.shrineBonuses[stat] += value;
                    this.applyPassives();
                }
            }
            
            // Calculate damage with crit
            calcDamage(baseDamage) {
                let damage = baseDamage * this.damageMultiplier;
                let isCrit = false;
                
                if (Math.random() < this.critChance) {
                    damage *= this.critMultiplier;
                    isCrit = true;
                }
                
                return { damage, isCrit };
            }
            
            // Apply lifesteal
            onDealDamage(damage) {
                if (this.lifesteal > 0) {
                    const healAmount = damage * this.lifesteal;
                    this.hp = Math.min(this.maxHp, this.hp + healAmount);
                }
            }

            gainXP(amount) {
                this.xp += amount;
                while (this.xp >= this.xpToNext) {
                    this.xp -= this.xpToNext;
                    this.level++;
                    this.xpToNext = Math.floor(this.xpToNext * 1.3) + 5;
                    showUpgradeSelection();
                }
            }

            takeDamage(amount) {
                if (this.invincible > 0) return;
                
                // Apply armor damage reduction
                const reducedDamage = amount * (1 - this.armor);
                this.hp -= reducedDamage;
                this.invincible = this.invincibilityDuration;
                
                // Screen flash
                spawnParticles(this.x, this.y, COLORS.pink, 15);
                
                if (this.hp <= 0) {
                    gameOver();
                }
            }

            update(dt, input) {
                // Movement
                let dx = 0, dy = 0;
                if (input.left) dx -= 1;
                if (input.right) dx += 1;
                if (input.up) dy -= 1;
                if (input.down) dy += 1;
                
                // Joystick input
                if (input.joystickX || input.joystickY) {
                    dx = input.joystickX;
                    dy = input.joystickY;
                }
                
                // Normalize diagonal
                if (dx && dy) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                // World bounds
                this.x = Math.max(this.radius, Math.min(WORLD.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD.height - this.radius, this.y));
                
                // Invincibility timer
                if (this.invincible > 0) this.invincible -= dt;
                
                // Regen
                if (this.regenRate > 0) {
                    this.hp = Math.min(this.maxHp, this.hp + this.regenRate * dt / 1000);
                }
                
                // Fire weapons
                this.fireWeapons(dt);
            }

            fireWeapons(dt) {
                const now = Date.now();
                
                for (const [weaponId, weaponState] of Object.entries(this.weapons)) {
                    const weaponDef = WEAPONS[weaponId];
                    const level = weaponState.level;
                    
                    switch (weaponDef.type) {
                        case 'projectile':
                            this.fireProjectile(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'orbit':
                            this.updateOrbit(weaponId, weaponDef, weaponState, level, dt);
                            break;
                        case 'aoe':
                            this.fireAOE(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'laser':
                            this.fireLaser(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'chain':
                            this.fireChain(weaponId, weaponDef, weaponState, level, now);
                            break;
                    }
                }
            }

            fireProjectile(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.9, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const projectileCount = def.baseProjectiles + Math.floor(level / 2);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.3);
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const spread = 0.2;
                
                for (let i = 0; i < projectileCount; i++) {
                    const a = angle + (i - (projectileCount - 1) / 2) * spread;
                    projectiles.push(new Projectile(
                        this.x, this.y, a, 8, baseDamage, def.color, 'bolt'
                    ));
                }
            }

            updateOrbit(id, def, state, level, dt) {
                const orbCount = def.baseOrbs + level - 1;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.25);
                const radius = 50 + level * 10;
                
                state.angle += dt * 0.003 * this.attackSpeedMultiplier;
                
                for (let i = 0; i < orbCount; i++) {
                    const angle = state.angle + (Math.PI * 2 / orbCount) * i;
                    const ox = this.x + Math.cos(angle) * radius;
                    const oy = this.y + Math.sin(angle) * radius;
                    
                    // Check collision with enemies
                    for (const enemy of enemies) {
                        if (enemy.dead) continue; // Skip dead enemies
                        const dist = Math.hypot(enemy.x - ox, enemy.y - oy);
                        if (dist < enemy.radius + 10 && enemy.orbHitCooldown <= 0) {
                            const { damage, isCrit } = this.calcDamage(baseDamage);
                            enemy.takeDamage(damage, isCrit);
                            this.onDealDamage(damage);
                            enemy.orbHitCooldown = 300;
                            spawnParticles(ox, oy, def.color, 5);
                        }
                    }
                }
                
                // Store for rendering
                state.orbCount = orbCount;
                state.radius = radius;
            }

            fireAOE(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.92, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                state.lastFire = now;
                const radius = def.baseRadius + level * 15;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.2);
                
                // Visual wave
                state.waveRadius = 0;
                state.waveMaxRadius = radius;
                state.waveActive = true;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue; // Skip dead enemies
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        enemy.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
            }

            fireLaser(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.9, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.35);
                const pierce = def.pierce + Math.floor(level / 2);
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                projectiles.push(new Projectile(
                    this.x, this.y, angle, 12, baseDamage, def.color, 'laser', pierce
                ));
            }

            fireChain(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.92, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Filter out dead enemies
                const aliveEnemies = enemies.filter(e => !e.dead);
                if (aliveEnemies.length === 0) return;
                
                state.lastFire = now;
                const targetCount = def.baseTargets + Math.floor(level / 2);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.25);
                
                // Efficient random sample instead of full shuffle
                const targets = randomSample(aliveEnemies, targetCount);
                for (const enemy of targets) {
                    const { damage, isCrit } = this.calcDamage(baseDamage);
                    enemy.takeDamage(damage, isCrit);
                    this.onDealDamage(damage);
                    
                    // Visual lightning (with cleanup)
                    if (!state.chainTargets) state.chainTargets = [];
                    state.chainTargets.push({ x: enemy.x, y: enemy.y, time: now });
                    spawnParticles(enemy.x, enemy.y, def.color, 8);
                }
                
                // Clean up old chain targets (older than 100ms)
                if (state.chainTargets) {
                    state.chainTargets = state.chainTargets.filter(t => now - t.time < 100);
                }
            }

            draw() {
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                
                ctx.save();
                
                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.invincible > 0 ? COLORS.pink : COLORS.cyan;
                
                // Body
                ctx.fillStyle = this.invincible > 0 && Math.floor(Date.now() / 50) % 2 
                    ? 'transparent' : COLORS.cyan;
                ctx.beginPath();
                ctx.arc(sx, sy, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner glow
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(sx, sy, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw orbit weapons
                for (const [weaponId, state] of Object.entries(this.weapons)) {
                    const def = WEAPONS[weaponId];
                    if (def.type === 'orbit' && state.orbCount) {
                        ctx.fillStyle = def.color;
                        ctx.shadowColor = def.color;
                        for (let i = 0; i < state.orbCount; i++) {
                            const angle = state.angle + (Math.PI * 2 / state.orbCount) * i;
                            const ox = sx + Math.cos(angle) * state.radius;
                            const oy = sy + Math.sin(angle) * state.radius;
                            ctx.beginPath();
                            ctx.arc(ox, oy, 8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // AOE wave visual
                    if (def.type === 'aoe' && state.waveActive) {
                        state.waveRadius += 8;
                        if (state.waveRadius >= state.waveMaxRadius) {
                            state.waveActive = false;
                        } else {
                            ctx.strokeStyle = def.color;
                            ctx.lineWidth = 3;
                            ctx.globalAlpha = 1 - state.waveRadius / state.waveMaxRadius;
                            ctx.beginPath();
                            ctx.arc(sx, sy, state.waveRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        }
                    }
                }
                
                ctx.restore();
            }
        }

        // ===== ENEMY CLASS =====
        class Enemy {
            constructor(type, x, y) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.orbHitCooldown = 0;
                
                // Scaling factor based on game time
                // HP: +10% every 30 seconds (was 15%)
                const hpScale = 1 + Math.floor(gameTime / 30) * 0.10;
                // Damage: +8% every 45 seconds (was 10% per 60s)
                const dmgScale = 1 + Math.floor(gameTime / 45) * 0.08;
                
                switch (type) {
                    case 'basic':
                        this.radius = 10;
                        this.speed = 1.2;
                        this.maxHp = Math.floor(15 * hpScale);
                        this.baseDamage = 8;  // Reduced from 10
                        this.color = COLORS.magenta;
                        this.xpValue = 1;
                        break;
                    case 'fast':
                        this.radius = 8;
                        this.speed = 2.5;
                        this.maxHp = Math.floor(10 * hpScale);  // Buffed from 8
                        this.baseDamage = 6;  // Reduced from 8
                        this.color = COLORS.orange;
                        this.xpValue = 1;
                        break;
                    case 'tank':
                        this.radius = 18;
                        this.speed = 0.7;
                        this.maxHp = Math.floor(50 * hpScale);  // Reduced from 60
                        this.baseDamage = 15;  // Reduced from 20
                        this.color = COLORS.purple;
                        this.xpValue = 3;
                        break;
                    case 'swarm':
                        this.radius = 6;
                        this.speed = 1.8;
                        this.maxHp = Math.floor(6 * hpScale);  // Buffed from 5
                        this.baseDamage = 4;  // Reduced from 5
                        this.color = COLORS.teal;
                        this.xpValue = 1;
                        break;
                }
                
                // Apply damage scaling
                this.damage = Math.floor(this.baseDamage * dmgScale);
                this.hp = this.maxHp;
                
                // XP scales slightly with time to keep leveling relevant
                const xpScale = 1 + Math.floor(gameTime / 120) * 0.5; // +50% XP every 2 min
                this.xpValue = Math.ceil(this.xpValue * xpScale);
            }

            update(dt) {
                // Move toward player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                
                // Collision with player
                if (dist < this.radius + player.radius) {
                    player.takeDamage(this.damage);
                }
                
                // Orbit cooldown
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }

            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                if (this.dead) return; // Prevent double death
                this.dead = true;
                kills++;
                DOM.killCount.textContent = kills;
                
                // Spawn XP gem
                xpGems.push(new XPGem(this.x, this.y, this.xpValue));
                
                // Death particles
                spawnParticles(this.x, this.y, this.color, 12);
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                
                // Hexagon shape for variety
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    const x = sx + Math.cos(angle) * this.radius;
                    const y = sy + Math.sin(angle) * this.radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // HP bar for tanks
                if (this.type === 'tank' && this.hp < this.maxHp) {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(sx - 15, sy - this.radius - 8, 30, 4);
                    ctx.fillStyle = this.color;
                    ctx.fillRect(sx - 15, sy - this.radius - 8, 30 * (this.hp / this.maxHp), 4);
                }
                
                ctx.restore();
            }
        }

        // ===== PROJECTILE CLASS =====
        class Projectile {
            constructor(x, y, angle, speed, damage, color, type, pierce = 1) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.damage = damage;
                this.color = color;
                this.type = type;
                this.pierce = pierce;
                this.radius = type === 'laser' ? 4 : 6;
                this.trail = [];
                this.hitEnemies = new Set(); // Track which enemies we've hit
            }

            update() {
                // Store trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 8) this.trail.shift();
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Check collision with enemies
                for (const enemy of enemies) {
                    // Skip if dead or already hit this enemy
                    if (enemy.dead || this.hitEnemies.has(enemy)) continue;
                    
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < enemy.radius + this.radius) {
                        // Mark as hit
                        this.hitEnemies.add(enemy);
                        
                        // Calculate crit damage
                        const { damage, isCrit } = player.calcDamage(this.damage);
                        enemy.takeDamage(damage, isCrit);
                        player.onDealDamage(damage);
                        this.pierce--;
                        spawnParticles(this.x, this.y, this.color, 5);
                        if (this.pierce <= 0) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                // Out of bounds (world)
                if (this.x < -20 || this.x > WORLD.width + 20 ||
                    this.y < -20 || this.y > WORLD.height + 20) {
                    this.dead = true;
                }
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                
                // Trail
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.type === 'laser' ? 3 : 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    const t = this.trail[i];
                    const tsx = camera.screenX(t.x);
                    const tsy = camera.screenY(t.y);
                    if (i === 0) ctx.moveTo(tsx, tsy);
                    else ctx.lineTo(tsx, tsy);
                }
                ctx.lineTo(sx, sy);
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Head
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(sx, sy, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // ===== XP GEM CLASS =====
        class XPGem {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.radius = 5 + value;
                this.color = COLORS.teal;
                this.pulse = 0;
            }

            update() {
                this.pulse += 0.1;
                
                // Magnet toward player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                // Guard against division by zero
                if (dist > 1 && dist < player.pickupRange) {
                    const speed = 5 * (1 - dist / player.pickupRange) + 1;
                    this.x += (dx / dist) * speed;
                    this.y += (dy / dist) * speed;
                }
                
                // Collect
                if (dist < player.radius + this.radius) {
                    player.gainXP(this.value);
                    this.dead = true;
                }
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                
                ctx.save();
                const glow = 8 + Math.sin(this.pulse) * 3;
                ctx.shadowBlur = glow;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                
                // Diamond shape
                ctx.beginPath();
                ctx.moveTo(sx, sy - this.radius);
                ctx.lineTo(sx + this.radius * 0.7, sy);
                ctx.lineTo(sx, sy + this.radius);
                ctx.lineTo(sx - this.radius * 0.7, sy);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        // ===== SHRINE CLASS =====
        class Shrine {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 60;
                this.innerRadius = 50;
                this.chargeTime = 0;
                this.chargeRequired = 5000; // Reduced from 6000ms (5 seconds)
                this.activated = false;
                this.pulse = Math.random() * Math.PI * 2;
                this.color = COLORS.blue;
            }

            update(dt) {
                if (this.activated) return;
                
                this.pulse += dt * 0.002;
                
                // Check if player is inside
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                
                if (dist < this.innerRadius) {
                    this.chargeTime += dt;
                    
                    // Update charge bar (using DOM cache)
                    DOM.shrineChargeBar.classList.add('active');
                    DOM.shrineChargeFill.style.width = `${(this.chargeTime / this.chargeRequired) * 100}%`;
                    
                    // Spawn particles while charging
                    if (Math.random() < 0.1) {
                        const angle = Math.random() * Math.PI * 2;
                        const pr = this.radius + 10;
                        spawnParticles(
                            this.x + Math.cos(angle) * pr,
                            this.y + Math.sin(angle) * pr,
                            this.color, 1
                        );
                    }
                    
                    if (this.chargeTime >= this.chargeRequired) {
                        this.activate();
                    }
                } else {
                    // Decay charge when player leaves
                    this.chargeTime = Math.max(0, this.chargeTime - dt * 0.5);
                    
                    if (this.chargeTime === 0) {
                        DOM.shrineChargeBar.classList.remove('active');
                    }
                }
            }

            activate() {
                this.activated = true;
                DOM.shrineChargeBar.classList.remove('active');
                
                // Burst particles
                spawnParticles(this.x, this.y, this.color, 30);
                spawnParticles(this.x, this.y, COLORS.cyan, 20);
                
                // Show shrine power-up selection
                showShrinePowerups();
            }

            draw() {
                if (!camera.isVisible(this.x, this.y, this.radius + 20)) return;
                if (this.activated) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                
                ctx.save();
                
                // Outer glow ring
                const glowIntensity = 0.3 + Math.sin(this.pulse) * 0.15;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = glowIntensity;
                
                ctx.beginPath();
                ctx.arc(sx, sy, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner ring
                ctx.lineWidth = 2;
                ctx.globalAlpha = glowIntensity * 0.7;
                ctx.beginPath();
                ctx.arc(sx, sy, this.innerRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Charge progress arc
                if (this.chargeTime > 0) {
                    const progress = this.chargeTime / this.chargeRequired;
                    ctx.strokeStyle = COLORS.cyan;
                    ctx.lineWidth = 6;
                    ctx.shadowColor = COLORS.cyan;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(sx, sy, this.radius - 5, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                    ctx.stroke();
                }
                
                // Center symbol
                ctx.globalAlpha = glowIntensity;
                ctx.fillStyle = this.color;
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âš¡', sx, sy);
                
                ctx.restore();
            }
        }

        // ===== SHRINE POWER-UP SYSTEM =====
        let shrineSlotResults = [];
        
        function showShrinePowerups() {
            gamePaused = true;
            
            DOM.shrineOverlay.classList.add('active');
            DOM.slotMachine.innerHTML = '';
            DOM.slotMachine.style.display = 'flex'; // Reset visibility
            DOM.shrineOptions.innerHTML = '';
            
            // Pick 3 random powerups
            const powerupKeys = Object.keys(SHRINE_POWERUPS);
            const shuffled = powerupKeys.sort(() => Math.random() - 0.5).slice(0, 3);
            shrineSlotResults = shuffled.map(key => ({ key, ...SHRINE_POWERUPS[key] }));
            
            // Create slot reels
            for (let i = 0; i < 3; i++) {
                const reel = document.createElement('div');
                reel.className = 'slot-reel spinning';
                reel.id = `reel${i}`;
                
                const content = document.createElement('div');
                content.className = 'slot-content';
                content.innerHTML = `
                    <div class="slot-icon">â“</div>
                    <div class="slot-name">???</div>
                    <div class="slot-value">???</div>
                `;
                
                reel.appendChild(content);
                DOM.slotMachine.appendChild(reel);
            }
            
            // Animate slot machine reveal
            shrineSlotResults.forEach((powerup, i) => {
                setTimeout(() => {
                    const reel = document.getElementById(`reel${i}`);
                    reel.classList.remove('spinning');
                    reel.classList.add('stopped');
                    
                    const content = reel.querySelector('.slot-content');
                    content.innerHTML = `
                        <div class="slot-icon">${powerup.icon}</div>
                        <div class="slot-name">${powerup.name}</div>
                        <div class="slot-value">${powerup.desc}</div>
                    `;
                    content.style.color = powerup.color;
                    reel.style.borderColor = powerup.color;
                    reel.style.boxShadow = `0 0 20px ${powerup.color}50`;
                    
                    // Show clickable card after last reel
                    if (i === 2) {
                        setTimeout(() => showShrineCards(), 300);
                    }
                }, 400 + i * 500);
            });
        }
        
        function showShrineCards() {
            // Hide slot machine to avoid duplicate icons
            DOM.slotMachine.style.display = 'none';
            
            DOM.shrineOptions.innerHTML = '';
            
            shrineSlotResults.forEach((powerup, i) => {
                const card = document.createElement('div');
                card.className = 'shrine-card';
                card.style.borderColor = powerup.color;
                
                card.innerHTML = `
                    <div class="icon">${powerup.icon}</div>
                    <div class="name">${powerup.name}</div>
                    <div class="value">${powerup.desc}</div>
                `;
                
                card.onclick = () => selectShrinePowerup(powerup);
                DOM.shrineOptions.appendChild(card);
                
                // Animate reveal
                setTimeout(() => card.classList.add('revealed'), i * 100);
            });
        }
        
        function selectShrinePowerup(powerup) {
            player.addShrineBonus(powerup.stat, powerup.value);
            
            DOM.shrineOverlay.classList.remove('active');
            gamePaused = false;
            
            // Visual feedback
            spawnParticles(player.x, player.y, powerup.color, 20);
        }
        
        // ===== SHRINE SPAWNING =====
        function spawnShrines() {
            shrines = [];
            const shrineCount = 50; // 30% less density than before, scaled for 4x map
            const minDist = 700; // Scaled for larger map
            const edgeBuffer = 400; // Scaled for larger map
            
            for (let i = 0; i < shrineCount; i++) {
                let attempts = 0;
                let validPosition = false;
                let x, y;
                
                while (!validPosition && attempts < 100) {
                    x = edgeBuffer + Math.random() * (WORLD.width - edgeBuffer * 2);
                    y = edgeBuffer + Math.random() * (WORLD.height - edgeBuffer * 2);
                    
                    // Check distance from other shrines
                    validPosition = true;
                    for (const shrine of shrines) {
                        if (Math.hypot(shrine.x - x, shrine.y - y) < minDist) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    // Check distance from center (player spawn)
                    if (Math.hypot(WORLD.width/2 - x, WORLD.height/2 - y) < minDist) {
                        validPosition = false;
                    }
                    
                    attempts++;
                }
                
                if (validPosition) {
                    shrines.push(new Shrine(x, y));
                }
            }
        }

        // ===== PARTICLES & EFFECTS =====
        function spawnParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color,
                    life: 1,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function spawnDamageNumber(x, y, damage, isCrit = false) {
            damageNumbers.push({
                x: x + (Math.random() - 0.5) * 20,
                y,
                damage,
                isCrit,
                life: 1,
                vy: isCrit ? -3 : -2,
                scale: isCrit ? 1.5 : 1
            });
        }

        // ===== HELPERS =====
        function findNearestEnemy(x, y) {
            let nearest = null;
            let minDist = Infinity;
            for (const enemy of enemies) {
                if (enemy.dead) continue; // Skip dead enemies
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }
            return nearest;
        }
        
        // Efficient in-place array cleanup (swap-and-pop)
        function cleanupArray(arr, shouldRemove) {
            for (let i = arr.length - 1; i >= 0; i--) {
                if (shouldRemove(arr[i])) {
                    arr[i] = arr[arr.length - 1];
                    arr.pop();
                }
            }
        }
        
        // Random sample without full shuffle (O(k) instead of O(n))
        function randomSample(arr, count) {
            const result = [];
            const indices = new Set();
            const max = Math.min(count, arr.length);
            while (result.length < max) {
                const idx = Math.floor(Math.random() * arr.length);
                if (!indices.has(idx)) {
                    indices.add(idx);
                    result.push(arr[idx]);
                }
            }
            return result;
        }

        // ===== SPAWNING =====
        let spawnTimer = 0;
        const spawnInterval = 1500;

        function spawnEnemies(dt) {
            spawnTimer += dt;
            
            // Balanced spawn rate over time
            // Floor raised to 400ms (was 300), slower scaling
            const currentInterval = Math.max(400, spawnInterval - gameTime * 1.5);
            
            if (spawnTimer >= currentInterval) {
                spawnTimer = 0;
                
                // Determine enemy type based on time
                const types = ['basic'];
                if (gameTime > 30) types.push('fast');
                if (gameTime > 60) types.push('tank');
                if (gameTime > 90) types.push('swarm', 'swarm');
                
                // Spawn count increases slower: every 45s instead of 30s
                const count = 1 + Math.floor(gameTime / 45);
                
                for (let i = 0; i < count; i++) {
                    // Enforce enemy limit
                    if (enemies.length >= LIMITS.enemies) break;
                    
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    // Spawn just outside visible area, around the player
                    let x, y;
                    const spawnDist = Math.max(canvas.width, canvas.height) / 2 + 50;
                    const angle = Math.random() * Math.PI * 2;
                    
                    x = player.x + Math.cos(angle) * spawnDist;
                    y = player.y + Math.sin(angle) * spawnDist;
                    
                    // Clamp to world bounds
                    x = Math.max(20, Math.min(WORLD.width - 20, x));
                    y = Math.max(20, Math.min(WORLD.height - 20, y));
                    
                    enemies.push(new Enemy(type, x, y));
                }
            }
        }

        // ===== UPGRADE SELECTION =====
        function showUpgradeSelection() {
            gamePaused = true;
            DOM.upgradeOverlay.classList.add('active');
            DOM.upgradeOptions.innerHTML = '';
            
            // Generate 3 random upgrades
            const available = [];
            
            // Add weapon upgrades
            for (const [id, def] of Object.entries(WEAPONS)) {
                const level = player.weapons[id]?.level || 0;
                if (level < 5) {
                    available.push({
                        type: 'weapon',
                        id,
                        ...def,
                        currentLevel: level
                    });
                }
            }
            
            // Add passive upgrades
            for (const [id, def] of Object.entries(PASSIVES)) {
                const level = player.passives[id] || 0;
                if (level < 5) {
                    available.push({
                        type: 'passive',
                        id,
                        ...def,
                        currentLevel: level
                    });
                }
            }
            
            // Pick 3 random
            const shuffled = available.sort(() => Math.random() - 0.5).slice(0, 3);
            
            for (const upgrade of shuffled) {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.style.borderColor = upgrade.color;
                card.style.boxShadow = `0 0 15px ${upgrade.color}40`;
                
                const levelText = upgrade.currentLevel > 0 
                    ? ` (Lv ${upgrade.currentLevel} â†’ ${upgrade.currentLevel + 1})` 
                    : ' (NEW)';
                
                card.innerHTML = `
                    <div class="icon">${upgrade.icon}</div>
                    <div class="name">${upgrade.name}${levelText}</div>
                    <div class="desc">${upgrade.desc}</div>
                `;
                
                card.onclick = () => selectUpgrade(upgrade);
                DOM.upgradeOptions.appendChild(card);
            }
        }

        function selectUpgrade(upgrade) {
            if (upgrade.type === 'weapon') {
                player.addWeapon(upgrade.id);
            } else {
                player.addPassive(upgrade.id);
            }
            
            DOM.upgradeOverlay.classList.remove('active');
            gamePaused = false;
            updateWeaponsDisplay();
        }

        function updateWeaponsDisplay() {
            DOM.weaponsDisplay.innerHTML = '';
            
            for (const [id, state] of Object.entries(player.weapons)) {
                const def = WEAPONS[id];
                const div = document.createElement('div');
                div.className = 'weapon-icon';
                div.style.borderColor = def.color;
                div.style.boxShadow = `0 0 10px ${def.color}`;
                div.innerHTML = `
                    ${def.icon}
                    <span class="weapon-level">${state.level}</span>
                `;
                DOM.weaponsDisplay.appendChild(div);
            }
        }

        // ===== INPUT HANDLING =====
        const input = {
            left: false, right: false, up: false, down: false,
            joystickX: 0, joystickY: 0
        };

        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w') input.up = true;
            if (e.key === 'ArrowDown' || e.key === 's') input.down = true;
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w') input.up = false;
            if (e.key === 'ArrowDown' || e.key === 's') input.down = false;
        });

        // Mobile joystick
        const joystickZone = document.getElementById('joystickZone');
        const joystickKnob = document.getElementById('joystickKnob');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };

        joystickZone.addEventListener('touchstart', e => {
            e.preventDefault();
            joystickActive = true;
            const rect = joystickZone.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        });

        document.addEventListener('touchmove', e => {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const dx = touch.clientX - joystickCenter.x;
            const dy = touch.clientY - joystickCenter.y;
            const dist = Math.min(40, Math.hypot(dx, dy));
            const angle = Math.atan2(dy, dx);
            
            input.joystickX = Math.cos(angle) * (dist / 40);
            input.joystickY = Math.sin(angle) * (dist / 40);
            
            joystickKnob.style.transform = `translate(calc(-50% + ${Math.cos(angle) * dist}px), calc(-50% + ${Math.sin(angle) * dist}px))`;
        }, { passive: false });

        document.addEventListener('touchend', e => {
            joystickActive = false;
            input.joystickX = 0;
            input.joystickY = 0;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        });

        // ===== GAME LOOP =====
        let lastTime = performance.now(); // Fix: Initialize properly to avoid first-frame spike

        // Cache DOM elements for performance
        const DOM = {
            hpFill: document.getElementById('hpFill'),
            xpFill: document.getElementById('xpFill'),
            levelDisplay: document.getElementById('levelDisplay'),
            timer: document.getElementById('timer'),
            killCount: document.getElementById('killCount'),
            shrineChargeBar: document.getElementById('shrineChargeBar'),
            shrineChargeFill: document.getElementById('shrineChargeFill'),
            upgradeOverlay: document.getElementById('upgradeOverlay'),
            upgradeOptions: document.getElementById('upgradeOptions'),
            shrineOverlay: document.getElementById('shrineOverlay'),
            slotMachine: document.getElementById('slotMachine'),
            shrineOptions: document.getElementById('shrineOptions'),
            menuOverlay: document.getElementById('menuOverlay'),
            finalStats: document.getElementById('finalStats'),
            startBtn: document.getElementById('startBtn'),
            weaponsDisplay: document.getElementById('weaponsDisplay')
        };

        function gameLoop(timestamp) {
            const dt = Math.min(timestamp - lastTime, 50); // Cap dt to prevent spiral of death
            lastTime = timestamp;
            
            if (gameRunning && !gamePaused) {
                gameTime += dt / 1000;
                
                // Update
                player.update(dt, input);
                camera.update();
                spawnEnemies(dt);
                
                for (const enemy of enemies) {
                    if (!enemy.dead) enemy.update(dt);
                }
                for (const proj of projectiles) proj.update();
                for (const gem of xpGems) gem.update();
                for (const shrine of shrines) shrine.update(dt);
                
                // Clean up dead entities (in-place for performance)
                cleanupArray(enemies, e => e.dead);
                cleanupArray(projectiles, p => p.dead);
                cleanupArray(xpGems, g => g.dead);
                
                // Update particles with limit
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.03;
                    if (p.life <= 0) {
                        particles[i] = particles[particles.length - 1];
                        particles.pop();
                    }
                }
                // Enforce particle limit
                if (particles.length > LIMITS.particles) {
                    particles.length = LIMITS.particles;
                }
                
                // Update damage numbers with limit
                for (let i = damageNumbers.length - 1; i >= 0; i--) {
                    const d = damageNumbers[i];
                    d.y += d.vy;
                    d.life -= 0.02;
                    if (d.life <= 0) {
                        damageNumbers[i] = damageNumbers[damageNumbers.length - 1];
                        damageNumbers.pop();
                    }
                }
                if (damageNumbers.length > LIMITS.damageNumbers) {
                    damageNumbers.length = LIMITS.damageNumbers;
                }
                
                // Update HUD (using cached DOM elements)
                DOM.hpFill.style.width = `${(player.hp / player.maxHp) * 100}%`;
                DOM.xpFill.style.width = `${(player.xp / player.xpToNext) * 100}%`;
                DOM.levelDisplay.textContent = player.level;
                
                // Timer
                const minutes = Math.floor(gameTime / 60);
                const seconds = Math.floor(gameTime % 60);
                DOM.timer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Render
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid background (scrolls with camera)
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 40;
            
            // Calculate grid offset based on camera
            const offsetX = -(camera.x % gridSize);
            const offsetY = -(camera.y % gridSize);
            
            for (let x = offsetX; x < canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = offsetY; y < canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // World boundary indicator
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
            ctx.lineWidth = 4;
            ctx.strokeRect(
                camera.screenX(0), 
                camera.screenY(0), 
                WORLD.width, 
                WORLD.height
            );
            
            if (!gameRunning) return;
            
            // Draw shrines first (under everything)
            for (const shrine of shrines) shrine.draw();
            
            // Draw entities
            for (const gem of xpGems) gem.draw();
            for (const enemy of enemies) {
                if (!enemy.dead) enemy.draw();
            }
            for (const proj of projectiles) proj.draw();
            player.draw();
            
            // Particles (batched rendering)
            ctx.save();
            for (const p of particles) {
                if (!camera.isVisible(p.x, p.y, 20)) continue;
                const sx = camera.screenX(p.x);
                const sy = camera.screenY(p.y);
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(sx, sy, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Damage numbers (batched rendering)
            ctx.save();
            for (const d of damageNumbers) {
                if (!camera.isVisible(d.x, d.y, 30)) continue;
                const sx = camera.screenX(d.x);
                const sy = camera.screenY(d.y);
                ctx.globalAlpha = d.life;
                
                if (d.isCrit) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = COLORS.yellow;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = COLORS.orange;
                    ctx.fillText(d.damage + '!', sx, sy);
                } else {
                    ctx.font = 'bold 14px sans-serif';
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = COLORS.orange;
                    ctx.fillText(d.damage, sx, sy);
                }
            }
            ctx.restore();
            
            // Minimap
            drawMinimap();
        }

        // ===== MINIMAP =====
        function drawMinimap() {
            const mapSize = 120;
            const mapX = canvas.width - mapSize - 10;
            const mapY = canvas.height - mapSize - 10;
            const scale = mapSize / WORLD.width;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(mapX, mapY, mapSize, mapSize);
            
            // Border
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(mapX, mapY, mapSize, mapSize);
            
            // Viewport indicator
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.strokeRect(
                mapX + camera.x * scale,
                mapY + camera.y * scale,
                canvas.width * scale,
                canvas.height * scale
            );
            
            // Enemies (as small dots)
            ctx.fillStyle = COLORS.magenta;
            for (const enemy of enemies) {
                if (enemy.dead) continue;
                const ex = mapX + enemy.x * scale;
                const ey = mapY + enemy.y * scale;
                ctx.fillRect(ex - 1, ey - 1, 2, 2);
            }
            
            // XP gems
            ctx.fillStyle = COLORS.teal;
            for (const gem of xpGems) {
                const gx = mapX + gem.x * scale;
                const gy = mapY + gem.y * scale;
                ctx.fillRect(gx, gy, 1, 1);
            }
            
            // Shrines (as blue circles)
            ctx.fillStyle = COLORS.blue;
            for (const shrine of shrines) {
                if (shrine.activated) continue;
                const shx = mapX + shrine.x * scale;
                const shy = mapY + shrine.y * scale;
                ctx.beginPath();
                ctx.arc(shx, shy, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Player
            ctx.fillStyle = COLORS.cyan;
            ctx.shadowBlur = 5;
            ctx.shadowColor = COLORS.cyan;
            const px = mapX + player.x * scale;
            const py = mapY + player.y * scale;
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // ===== GAME START/END =====
        function startGame() {
            gameRunning = true;
            gamePaused = false;
            gameTime = 0;
            kills = 0;
            enemies = [];
            projectiles = [];
            xpGems = [];
            particles = [];
            damageNumbers = [];
            shrines = [];
            
            player = new Player();
            spawnShrines();
            
            DOM.menuOverlay.classList.add('hidden');
            DOM.killCount.textContent = '0';
            DOM.finalStats.style.display = 'none';
            DOM.shrineChargeBar.classList.remove('active');
            updateWeaponsDisplay();
        }

        function gameOver() {
            gameRunning = false;
            
            DOM.menuOverlay.classList.remove('hidden');
            DOM.menuOverlay.querySelector('.game-title').textContent = 'GAME OVER';
            DOM.menuOverlay.querySelector('.game-subtitle').textContent = 'You have fallen...';
            DOM.startBtn.textContent = 'TRY AGAIN';
            
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            const shrinesActivated = shrines.filter(s => s.activated).length;
            
            DOM.finalStats.innerHTML = `
                Survived: <span>${minutes}:${seconds.toString().padStart(2, '0')}</span><br>
                Level: <span>${player.level}</span><br>
                Kills: <span>${kills}</span><br>
                Shrines: <span>${shrinesActivated}</span>
            `;
            DOM.finalStats.style.display = 'block';
        }

        // ===== INIT =====
        DOM.startBtn.onclick = startGame;
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
