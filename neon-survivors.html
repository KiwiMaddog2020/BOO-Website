<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Survivors</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 6px;
            width: fit-content;
            /* Fill available height in iframe */
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            transform: translateZ(0);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
            overflow: visible;
            border: 3px solid #0ff;
            box-shadow: 0 0 15px #0ff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            border-radius: 8px;
            background: #0a0a0a;
        }

        #gameCanvas {
            border-radius: 3px;
            max-width: 100%;
            display: block;
            touch-action: none;
        }

        /* HUD Overlay - Centered, symmetrical layout */
        .hud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: #fff;
            font-size: 12px;
            text-shadow: 0 0 10px #0ff;
            z-index: 100;
            pointer-events: none;
        }

        .hud-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .hud span {
            color: #0ff;
        }

        .hud .hp-bar {
            width: 200px;
            height: 10px;
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid #39ff9f;
            border-radius: 3px;
            overflow: hidden;
        }

        .hud .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #39ff9f, #00ff66);
            box-shadow: 0 0 10px #39ff9f;
            transition: width 0.2s;
        }

        .hud .xp-bar {
            width: 140px;
            height: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            border-radius: 3px;
            overflow: hidden;
        }

        .hud .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffcc, #0ff);
            box-shadow: 0 0 6px #0ff;
            transition: width 0.15s;
        }

        /* Top-Left HUD Overlay */
        .hud-overlay {
            position: absolute;
            top: 16px;
            left: 8px;
            display: flex;
            flex-direction: column;
            pointer-events: none;
            z-index: 50;
            opacity: 0.9;
        }
        
        .hud-stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 140px;
            margin-bottom: 6px;
        }
        
        .hud-stat {
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 6px #0ff;
            white-space: nowrap;
        }
        
        .hud-stat span {
            color: #0ff;
            font-weight: bold;
        }
        
        #goldDisplay {
            color: #ffd700;
            text-shadow: 0 0 6px #ffd700;
        }
        
        #goldDisplay span {
            color: #ffd700;
        }
        
        .hud-hp-bar {
            width: 140px;
            height: 12px;
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid #39ff9f;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .hud-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #39ff9f, #00ff66);
            box-shadow: 0 0 6px #39ff9f;
            transition: width 0.2s;
        }

        /* Weapon icons display - grows left to right */
        .weapons-display {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 160px;
            justify-content: flex-start;
        }

        .weapon-icon {
            width: 28px;
            height: 28px;
            border: 2px solid;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            position: relative;
        }

        .weapon-level {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 9px;
            background: #000;
            padding: 1px 3px;
            border-radius: 3px;
            color: #fff;
        }

        /* Upgrade Selection Overlay */
        .upgrade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .upgrade-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }

        .upgrade-title {
            font-size: 32px;
            color: #0ff;
            text-shadow: 0 0 25px #0ff;
            margin-bottom: 15px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .upgrade-subtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 30px;
        }

        .upgrade-slot-machine {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }

        .upgrade-slot-machine .slot-reel {
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .upgrade-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .upgrade-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            touch-action: manipulation;
            z-index: 10;
            position: relative;
        }

        .upgrade-card.revealed {
            opacity: 1;
            transform: scale(1);
        }

        .upgrade-card:hover {
            transform: scale(1.08);
        }

        .upgrade-card .icon {
            font-size: 36px;
        }

        .upgrade-card .name {
            font-size: 14px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .upgrade-card .desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
        }

        /* Shrine Power-up Overlay */
        .shrine-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .shrine-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }

        /* Chest overlay */
        .chest-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.88);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 510;
        }
        
        .chest-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }
        
        .chest-title {
            font-size: 28px;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            margin-bottom: 10px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        .chest-title.silver {
            color: #c0c0c0;
            text-shadow: 0 0 20px #c0c0c0;
        }
        
        .chest-cost {
            font-size: 18px;
            color: #ffd700;
            margin-bottom: 20px;
        }
        
        .chest-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd700;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 10px;
        }
        
        .chest-card.silver {
            border-color: #c0c0c0;
        }
        
        .chest-card:hover {
            transform: scale(1.08);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
        }
        
        .chest-card .icon {
            font-size: 36px;
        }
        
        .chest-card .name {
            font-size: 14px;
            font-weight: bold;
        }
        
        .chest-card .value {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .chest-buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        
        .chest-btn {
            padding: 10px 25px;
            font-size: 14px;
            border: 2px solid;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            background: transparent;
        }
        
        .chest-btn-accept {
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .chest-btn-accept:hover {
            background: #00ff00;
            color: #000;
        }
        
        .chest-btn-accept:disabled {
            border-color: #666;
            color: #666;
            cursor: not-allowed;
        }
        
        .chest-btn-skip {
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .chest-btn-skip:hover {
            background: #ff4444;
            color: #fff;
        }

        .shrine-title {
            font-size: 32px;
            color: #e040ff;
            text-shadow: 0 0 25px #e040ff;
            margin-bottom: 15px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .shrine-subtitle {
            font-size: 17px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 30px;
        }

        /* Slot machine reels - shared style */
        .slot-machine {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }

        .slot-reel {
            width: 140px;
            height: 170px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #e040ff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 20px rgba(224, 64, 255, 0.3);
        }

        .slot-reel.spinning .slot-content {
            animation: slotSpin 0.1s linear infinite;
        }

        .slot-reel.stopped {
            border-color: #e040ff;
            box-shadow: 0 0 25px rgba(224, 64, 255, 0.5);
        }

        @keyframes slotSpin {
            0% { transform: translateY(0); }
            100% { transform: translateY(-40px); }
        }

        .slot-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px 15px;
            gap: 10px;
        }

        .slot-icon {
            font-size: 36px;
        }

        .slot-name {
            font-size: 13px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .slot-value {
            font-size: 12px;
            color: #fff;
            text-align: center;
        }

        .shrine-options {
            display: flex;
            gap: 20px;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .shrine-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #e040ff;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            touch-action: manipulation;
        }

        .shrine-card.revealed {
            opacity: 1;
            transform: scale(1);
        }

        .shrine-card:hover {
            transform: scale(1.08);
            box-shadow: 0 0 25px rgba(224, 64, 255, 0.5);
            border-color: #ff66ff;
        }

        .shrine-card .icon {
            font-size: 36px;
        }

        .shrine-card .name {
            font-size: 14px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }

        .shrine-card .value {
            font-size: 12px;
            color: #fff;
        }

        /* Legendary upgrade overlay */
        .legendary-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
        }

        .legendary-overlay.active {
            display: flex;
            pointer-events: auto !important;
            touch-action: auto !important;
        }

        .legendary-title {
            font-size: 36px;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700, 0 0 60px #32cd32;
            margin-bottom: 10px;
            letter-spacing: 4px;
            animation: legendaryPulse 1s ease-in-out infinite;
        }

        @keyframes legendaryPulse {
            0%, 100% { text-shadow: 0 0 30px #ffd700, 0 0 60px #32cd32; }
            50% { text-shadow: 0 0 50px #ffd700, 0 0 100px #32cd32, 0 0 150px #ffd700; }
        }

        .legendary-subtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
        }

        .legendary-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .legendary-card {
            width: 140px;
            padding: 20px 15px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .legendary-card:hover {
            transform: scale(1.08);
        }

        .legendary-icon {
            font-size: 36px;
        }

        .legendary-name {
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        }

        .legendary-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }

        .legendary-effect {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-style: italic;
        }

        @media (max-width: 500px) {
            .legendary-title { font-size: 24px; margin-bottom: 6px; }
            .legendary-subtitle { font-size: 13px; margin-bottom: 20px; }
            .legendary-options { gap: 10px; }
            .legendary-card { width: 100px; padding: 14px 10px; gap: 6px; }
            .legendary-icon { font-size: 28px; }
            .legendary-name { font-size: 11px; }
            .legendary-desc { font-size: 9px; }
            .legendary-effect { font-size: 8px; }
            
            .chest-title { font-size: 22px; }
            .chest-cost { font-size: 14px; }
            .chest-card { width: 100px; padding: 14px 10px; gap: 6px; }
            .chest-card .icon { font-size: 28px; }
            .chest-card .name { font-size: 11px; }
            .chest-card .value { font-size: 9px; }
        }

        /* Shrine charge indicator */
        .shrine-charge-bar {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #e040ff;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 150;
        }

        .shrine-charge-bar.active {
            display: block;
        }

        .shrine-charge-fill {
            height: 100%;
            background: linear-gradient(90deg, #c020ff, #e040ff);
            box-shadow: 0 0 10px #e040ff;
            transition: width 0.1s linear;
        }

        .shrine-charge-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 11px;
            text-shadow: 0 0 5px #000;
            letter-spacing: 1px;
        }

        /* Start/Game Over Screen */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
            touch-action: manipulation;
        }

        .menu-overlay.hidden {
            display: none;
            pointer-events: none;
        }

        .game-title {
            font-size: 48px;
            color: #f0f;
            text-shadow: 0 0 30px #f0f, 0 0 60px #ff1493;
            margin-bottom: 10px;
            letter-spacing: 5px;
            text-transform: uppercase;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 30px #f0f, 0 0 60px #ff1493; }
            50% { text-shadow: 0 0 40px #f0f, 0 0 80px #ff1493, 0 0 100px #0ff; }
        }

        .game-subtitle {
            font-size: 14px;
            color: #0ff;
            margin-bottom: 80px;
            letter-spacing: 2px;
        }

        .menu-btn {
            padding: 12px 20px;
            font-size: 16px;
            background: transparent;
            color: #f0f;
            border: 2px solid #0ff;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            margin: 12px;
            touch-action: manipulation;
            height: 56px;
            width: 245px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.5);
            color: #fff;
            box-shadow: 0 0 25px #0ff;
            -webkit-text-stroke: 1px #fff;
        }

        .final-stats {
            color: #fff;
            text-align: center;
            margin: 20px 0;
            font-size: 18px;
            line-height: 2;
        }

        .final-stats span {
            color: #39ff9f;
            font-weight: bold;
        }

        /* ========== UNIFIED TRACKPAD ZONE ========== */
        /* Contains: active buffs + spacer + instructions */
        .trackpad-zone {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            /* Responsive height - use flex-grow to fill available space */
            height: auto;
            min-height: 180px;
            flex: 1 1 auto;
            padding: 0px 12px 8px 12px;
            box-sizing: border-box;
            /* Touch control */
            touch-action: none;
            pointer-events: auto;
            /* Visual styling */
            border-top: 1px solid rgba(0, 255, 255, 0.15);
            background: linear-gradient(to bottom, rgba(0, 255, 255, 0.06), transparent);
            border-radius: 0 0 5px 5px;
            /* Needed for joystick positioning */
            position: relative;
            overflow: hidden;
        }
        
        /* Active buffs display - centered between divider lines */
        .active-buffs {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 8px;
            height: 48px;
            min-height: 48px;
            width: 100%;
            pointer-events: none;
            flex-shrink: 0;
            flex-wrap: wrap;
        }
        
        /* Always show divider lines even when empty */
        .active-buffs-wrapper {
            display: none;
        }
        
        .buff-item {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 44px;
            height: 44px;
        }
        
        .buff-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 4px currentColor);
        }
        
        .buff-stack {
            position: absolute;
            bottom: 0px;
            right: -2px;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 4px #000, 0 0 4px #000;
        }
        
        /* Stats timers container - fixed 4 rows */
        .stats-display {
            display: none;
        }
        
        /* Minimap wrapper for centering */
        .minimap-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            flex-shrink: 0;
        }
        
        /* Minimap container - positioned top-right of game canvas */
        .minimap-container {
            position: absolute;
            top: 16px;
            right: 8px;
            pointer-events: none;
            z-index: 50;
            opacity: 0.85;
        }
        
        /* XP bar at top of game frame */
        .game-xp-bar {
            position: absolute;
            top: 4px;
            left: 4px;
            width: calc(100% - 8px);
            height: 7px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            border-radius: 3px;
            overflow: hidden;
            z-index: 50;
        }
        
        .game-xp-fill {
            height: 100%;
            background: #a8b8c8;
            box-shadow: 0 0 4px rgba(168, 184, 200, 0.5);
            transition: width 0.15s;
        }
        
        /* Minimap canvas in trackpad */
        .minimap-canvas {
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            flex-shrink: 0;
        }
        
        .stats-display span {
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            height: 17px;
            min-height: 17px;
            max-height: 17px;
            line-height: 17px;
            font-size: 13px;
            padding: 0 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            box-sizing: border-box;
            pointer-events: none;
            flex-shrink: 0;
        }
        
        /* Spacer - grows to fill remaining space */
        .trackpad-spacer {
            flex: 1;
            min-height: 60px;
            width: 100%;
            pointer-events: none;
        }
        
        /* Instructions at bottom of trackpad */
        .trackpad-instructions {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 24px;
            min-height: 24px;
            width: 100%;
            font-size: 11px;
            color: rgba(0, 255, 255, 0.7);
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            pointer-events: none;
            flex-shrink: 0;
        }
        
        /* Show different text on hover-capable devices */
        @media (hover: hover) and (pointer: fine) {
            .trackpad-instructions::after {
                content: ' (OR WASD / ARROWS)';
            }
        }
        
        /* Dynamic joystick overlay */
        .joystick-overlay {
            position: absolute;
            width: 120px;
            height: 120px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
            display: none;
            z-index: 300;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .joystick-overlay.active {
            display: block;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #0ff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #0ff;
            pointer-events: none;
        }

        /* Timer display - part of bottom bar now */
        .timer {
            font-size: 16px;
            color: #fff;
            text-shadow: 0 0 12px #0ff;
            letter-spacing: 1px;
        }

        /* Kill counter - part of top bar now */
        .kills {
            font-size: 12px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }

        .kills span {
            color: #fff;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 600px) {
            .hud .hp-bar { width: 160px; height: 8px; }
            .hud .xp-bar { width: 110px; height: 6px; }
            .hud { font-size: 10px; gap: 3px; }
            .timer { font-size: 14px; }
            .kills { font-size: 10px; }
            .weapon-icon { width: 28px; height: 28px; font-size: 14px; }
            .weapons-display { max-width: 100px; gap: 3px; }
            
            /* Hide minimap on mobile */
            .minimap-container {
                display: none !important;
            }
            
            /* Center HUD overlay */
            .hud-overlay {
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                align-items: center;
            }
            
            .hud-stats-row {
                width: auto;
                gap: 12px;
                margin-bottom: 4px;
                justify-content: center;
            }
            
            .hud-stat {
                font-size: 10px;
            }
            
            .hud-hp-bar {
                width: 180px;
                height: 10px;
                margin-bottom: 6px;
            }
            
            /* Scale XP bar */
            .game-xp-bar {
                height: 5px;
            }
            
            /* Compact trackpad zone */
            .trackpad-zone {
                min-height: 140px;
                padding: 4px 8px 4px 8px;
            }
            
            .trackpad-spacer {
                min-height: 30px;
            }
            
            .trackpad-instructions {
                height: 20px;
                min-height: 20px;
                font-size: 10px;
            }
            
            /* Compact bottom bar */
            .bottom-bar {
                padding: 0 2px;
            }
            
            .bottom-hp-bar {
                width: 120px;
            }
            
            .game-level-indicator {
                font-size: 11px;
                margin-top: 3px;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 400px) {
            /* Keep HUD centered */
            .hud-overlay {
                top: 8px;
            }
            
            .hud-stats-row {
                gap: 8px;
                margin-bottom: 3px;
            }
            
            .hud-stat {
                font-size: 9px;
            }
            
            .hud-hp-bar {
                width: 150px;
                height: 8px;
                margin-bottom: 4px;
            }
            
            .game-xp-bar {
                height: 4px;
            }
            
            .trackpad-zone {
                min-height: 120px;
            }
            
            .bottom-hp-bar {
                width: 100px;
            }
            
            .timer { font-size: 12px; }
            .kills { font-size: 9px; }
            .weapon-icon { width: 24px; height: 24px; font-size: 12px; }
        }
        
        /* ========== SCORE MODAL ========== */
        .score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .score-modal.active {
            display: flex;
        }
        
        .score-modal-title {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 38px;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 40px #ff1493;
            text-align: center;
            margin-bottom: 0;
        }
        
        .score-modal-score {
            font-size: 26px;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            text-align: center;
            margin-top: -4px;
        }
        
        .score-modal-level {
            font-size: 18px;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            text-align: center;
            margin-top: -8px;
        }
        
        .score-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        
        .score-input-label {
            font-size: 14px;
            color: #fff;
            opacity: 0.9;
        }
        
        .score-input {
            width: 200px;
            padding: 10px 14px;
            font-size: 16px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 8px;
            color: #fff;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }
        
        .score-input:focus {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .score-input.error {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.15);
            animation: inputShake 0.4s ease;
        }
        
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }
        
        .score-error-msg {
            font-size: 12px;
            color: #ff3366;
            text-shadow: 0 0 8px #ff3366;
            min-height: 16px;
            text-align: center;
        }
        
        .score-buttons {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }
        
        .score-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 2px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            background: transparent;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .score-btn:active {
            transform: scale(0.98);
        }
        
        .score-btn-submit {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 255, 0.2));
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .score-btn-submit:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }
        
        .score-btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .score-btn-skip {
            background: rgba(255, 255, 255, 0.05);
            border-color: #666;
            color: #888;
        }
        
        .score-btn-skip:hover {
            border-color: #999;
            color: #aaa;
        }
        
        /* ========== LEADERBOARD OVERLAY ========== */
        .leaderboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            touch-action: manipulation;
            pointer-events: auto;
        }
        
        .leaderboard-overlay.active {
            display: flex;
        }
        
        .leaderboard-container {
            width: 100%;
            max-width: 450px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .leaderboard-title {
            font-size: 28px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ff6600;
        }
        
        .leaderboard-close {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .leaderboard-close:hover {
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        .leaderboard-close:active {
            transform: scale(0.95);
            border-color: #f0f;
            color: #f0f;
        }
        
        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            background: rgba(10, 10, 20, 0.8);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 10px;
        }
        
        .leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 4px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .leaderboard-row.top-3 {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.15), rgba(0, 255, 255, 0.1));
            border: 1px solid rgba(255, 0, 255, 0.3);
        }
        
        .leaderboard-rank {
            width: 40px;
            font-size: 16px;
            font-weight: bold;
            color: #888;
        }
        
        .leaderboard-row.top-3 .leaderboard-rank {
            color: #f0f;
            text-shadow: 0 0 8px #f0f;
        }
        
        .leaderboard-rank-1 { color: #ffd700 !important; }
        .leaderboard-rank-2 { color: #c0c0c0 !important; }
        .leaderboard-rank-3 { color: #cd7f32 !important; }
        
        .leaderboard-name {
            flex: 1;
            font-size: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .leaderboard-score {
            font-size: 16px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            min-width: 70px;
            text-align: right;
        }
        
        .leaderboard-level {
            font-size: 12px;
            color: #ffaa00;
            text-shadow: 0 0 6px #ff6600;
            min-width: 45px;
            text-align: right;
            margin-left: 10px;
        }
        
        .leaderboard-loading,
        .leaderboard-empty,
        .leaderboard-error {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 16px;
        }
        
        .leaderboard-loading {
            color: #0ff;
        }
        
        .leaderboard-error {
            color: #ff3366;
        }
        
        /* Leaderboard button */
        .btn-leaderboard {
            font-size: 16px;
            padding: 12px 20px;
            border-color: #ffaa00;
            color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }
        
        .btn-leaderboard:hover {
            background: rgba(255, 170, 0, 0.5);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.6);
        }
        
        @media (max-width: 500px) {
            .score-modal-title { font-size: 32px; }
            .score-modal-score { font-size: 22px; }
            .score-modal-level { font-size: 16px; }
            .score-input { width: 180px; font-size: 16px; }
            .score-btn { padding: 10px 20px; font-size: 14px; }
            .leaderboard-title { font-size: 24px; }
            .leaderboard-row { padding: 8px 10px; }
            .leaderboard-name { font-size: 13px; }
            .leaderboard-score { font-size: 14px; min-width: 60px; }
            .leaderboard-level { font-size: 11px; min-width: 40px; }
            
            /* Mobile: Weapon icons - smaller and constrained */
            .weapons-display {
                max-width: 100px;
                gap: 3px;
            }
            .weapon-icon {
                width: 22px;
                height: 22px;
                font-size: 12px;
                border-width: 1.5px;
            }
            .weapon-level {
                font-size: 7px;
                padding: 0px 2px;
                bottom: -1px;
                right: -1px;
            }
            
            /* Mobile: HUD overlay smaller */
            .hud-overlay {
                top: 14px;
                left: 4px;
            }
            .hud-stats-row {
                width: 100px;
                margin-bottom: 4px;
            }
            .hud-hp-bar {
                width: 100px;
                height: 10px;
                margin-bottom: 6px;
            }
            .hud-stat {
                font-size: 8px;
            }
            
            /* Mobile: Minimap smaller */
            .minimap-container {
                top: 14px;
                right: 4px;
            }
            .minimap-canvas {
                width: 90px !important;
                height: 90px !important;
            }
            
            /* Mobile: Upgrade overlay */
            .upgrade-title {
                font-size: 22px;
                margin-bottom: 8px;
                letter-spacing: 2px;
            }
            .upgrade-subtitle {
                font-size: 13px;
                margin-bottom: 15px;
            }
            .upgrade-slot-machine {
                gap: 8px;
                margin-bottom: 15px;
            }
            .upgrade-slot-machine .slot-reel {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                border-width: 2px;
            }
            .upgrade-slot-machine .slot-content {
                padding: 0;
                gap: 0;
            }
            .upgrade-slot-machine .slot-icon {
                font-size: 24px;
            }
            .upgrade-slot-machine .slot-name,
            .upgrade-slot-machine .slot-value {
                display: none;
            }
            .upgrade-options {
                gap: 10px;
            }
            .upgrade-card {
                width: 105px;
                padding: 12px 8px;
                gap: 6px;
                border-radius: 8px;
            }
            .upgrade-card .icon {
                font-size: 28px;
            }
            .upgrade-card .name {
                font-size: 11px;
            }
            .upgrade-card .desc {
                font-size: 9px;
            }
            
            /* Mobile: Shrine overlay */
            .shrine-title {
                font-size: 22px;
                margin-bottom: 8px;
                letter-spacing: 2px;
            }
            .shrine-subtitle {
                font-size: 13px;
                margin-bottom: 15px;
            }
            .slot-machine {
                gap: 8px;
                margin-bottom: 15px;
            }
            .slot-reel {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                border-width: 2px;
            }
            .slot-content {
                padding: 0;
                gap: 0;
            }
            .slot-icon {
                font-size: 24px;
            }
            .slot-name,
            .slot-value {
                display: none;
            }
            .shrine-options {
                gap: 10px;
            }
            .shrine-card {
                width: 105px;
                padding: 18px 8px;
                gap: 10px;
                border-radius: 8px;
            }
            .shrine-card .icon {
                font-size: 28px;
            }
            .shrine-card .name {
                font-size: 11px;
            }
            .shrine-card .value {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Minimap - top-right of game area -->
        <div class="minimap-container">
            <canvas id="minimapCanvas" class="minimap-canvas" width="156" height="156"></canvas>
        </div>
        
        <!-- Shrine Charge Bar -->
        <div class="shrine-charge-bar" id="shrineChargeBar">
            <div class="shrine-charge-fill" id="shrineChargeFill"></div>
            <div class="shrine-charge-text">CHANNELING...</div>
        </div>
        
        <!-- Top-Left HUD Overlay -->
        <div class="hud-overlay">
            <div class="hud-stats-row">
                <div class="hud-stat" id="timer">0:00</div>
                <div class="hud-stat">KILLS: <span id="killCount">0</span></div>
                <div class="hud-stat" id="goldDisplay">ü™ô <span id="goldCount">0</span></div>
                <div class="hud-stat">LV <span id="levelDisplay">1</span></div>
            </div>
            <div class="hud-hp-bar">
                <div class="hud-hp-fill" id="trackpadHpFill"></div>
            </div>
            <div class="weapons-display" id="weaponsDisplay"></div>
        </div>
        
        <!-- XP bar at top -->
        <div class="game-xp-bar">
            <div class="game-xp-fill" id="trackpadXpFill"></div>
        </div>

        <!-- Trackpad Zone -->
        <div class="trackpad-zone" id="trackpadZone">
            <div class="stats-display" id="statsDisplay"></div>
            <div class="trackpad-spacer">&nbsp;</div>
            <div class="trackpad-instructions">
                ‚Üê TAP AND DRAG TO MOVE ‚Üí
            </div>
            <div class="active-buffs-wrapper">
                <div class="active-buffs" id="activeBuffsBar"></div>
            </div>
            <!-- Dynamic joystick -->
            <div class="joystick-overlay" id="joystickOverlay">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
        </div>
    </div>
    
    <!-- Upgrade Selection - OUTSIDE game-container for touch events -->
    <div class="upgrade-overlay" id="upgradeOverlay">
        <div class="upgrade-title">‚ú® LEVEL UP! ‚ú®</div>
        <div class="upgrade-subtitle">Choose your upgrade</div>
        <div class="upgrade-slot-machine" id="upgradeSlotMachine"></div>
        <div class="upgrade-options" id="upgradeOptions"></div>
    </div>

    <!-- Shrine Power-up Selection - OUTSIDE game-container for touch events -->
    <div class="shrine-overlay" id="shrineOverlay">
        <div class="shrine-title">‚ú® SHRINE ACTIVATED ‚ú®</div>
        <div class="shrine-subtitle">Choose your blessing</div>
        <div class="slot-machine" id="slotMachine"></div>
        <div class="shrine-options" id="shrineOptions"></div>
    </div>

    <!-- Chest Loot Selection -->
    <div class="chest-overlay" id="chestOverlay">
        <div class="chest-title" id="chestTitle">üì¶ TREASURE FOUND! üì¶</div>
        <div class="chest-cost" id="chestCost"></div>
        <div class="chest-card" id="chestCard">
            <div class="icon" id="chestIcon"></div>
            <div class="name" id="chestName"></div>
            <div class="value" id="chestValue"></div>
        </div>
        <div class="chest-buttons">
            <button class="chest-btn chest-btn-accept" id="chestAccept">TAKE</button>
            <button class="chest-btn chest-btn-skip" id="chestSkip">LEAVE</button>
        </div>
    </div>

    <!-- Start/Game Over Menu -->
    <div class="menu-overlay" id="menuOverlay">
        <div class="game-title">NEON SURVIVORS</div>
        <div class="game-subtitle">Survive the neon horde</div>
        <button class="menu-btn" id="startBtn">üéÆ START GAME üéÆ</button>
        <button class="menu-btn btn-leaderboard" id="leaderboardBtn">üèÜ LEADERBOARD üèÜ</button>
        <div class="final-stats" id="finalStats" style="display: none;"></div>
    </div>
    
    <!-- Score Modal -->
    <div class="score-modal" id="scoreModal">
        <div class="score-modal-title" id="scoreModalTitle">FALLEN WARRIOR</div>
        <div class="score-modal-score">Kills: <span id="finalKillsDisplay">0</span></div>
        <div class="score-modal-level">Time: <span id="finalTimeDisplay">0:00</span></div>
        <div class="score-input-container">
            <label class="score-input-label">Enter your name for the leaderboard:</label>
            <input type="text" class="score-input" id="usernameInput" maxlength="12" placeholder="YOUR NAME" autocomplete="off" spellcheck="false">
            <div class="score-error-msg" id="scoreErrorMsg"></div>
        </div>
        <div class="score-buttons">
            <button class="score-btn score-btn-submit" id="submitScoreBtn">Submit</button>
            <button class="score-btn score-btn-skip" id="skipScoreBtn">Skip</button>
        </div>
    </div>
    
    <!-- Leaderboard Overlay -->
    <div class="leaderboard-overlay" id="leaderboardOverlay">
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="leaderboard-title">üèÜ TOP 100</div>
                <button class="leaderboard-close" id="leaderboardClose">‚úï</button>
            </div>
            <div class="leaderboard-list" id="leaderboardList">
                <div class="leaderboard-loading">Loading scores...</div>
            </div>
        </div>
    </div>

    <script>
        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing based on available space
        function resizeCanvas() {
            // Calculate available space more accurately for iframe context
            const containerPadding = 12; // game-container padding
            const bottomBarHeight = 50; // bottom bar approximate height
            const xpBarHeight = 10;
            const minTrackpadHeight = 140; // minimum for touch controls
            
            // Available width (container width minus padding and border)
            const availableWidth = Math.min(window.innerWidth - containerPadding * 2 - 6, 800);
            
            // Available height for canvas (leave room for bottom bar, xp bar, trackpad)
            const controlsHeight = bottomBarHeight + xpBarHeight + minTrackpadHeight + 20;
            const availableHeight = Math.min(window.innerHeight - controlsHeight, 600);
            
            const aspect = 4 / 3;
            
            // Size canvas to fit available space while maintaining aspect ratio
            if (availableWidth / availableHeight > aspect) {
                canvas.height = Math.max(200, availableHeight);
                canvas.width = canvas.height * aspect;
            } else {
                canvas.width = Math.max(270, availableWidth);
                canvas.height = canvas.width / aspect;
            }
            
            // Ensure canvas doesn't exceed available width
            if (canvas.width > availableWidth) {
                canvas.width = availableWidth;
                canvas.height = canvas.width / aspect;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== NEON COLOR PALETTE =====
        const COLORS = {
            cyan: '#0ff',
            magenta: '#f0f',
            pink: '#ff1493',
            orange: '#ff6600',
            purple: '#9b30ff',
            teal: '#00ffcc',
            blue: '#00aaff',
            yellow: '#ffff00',
            shrine: '#e040ff',  // Bright neon purple for shrines
            gold: '#ffd700',    // Leprechaun gold
            green: '#32cd32',   // Leprechaun green
            burn: '#ff4400',    // Status: burn
            freeze: '#00bfff',  // Status: freeze
            shock: '#ffff00'    // Status: shock
        };

        // ===== WORLD & CAMERA =====
        const WORLD = {
            width: 4320,
            height: 4320
        };
        
        // Target visible world area - consistent across all devices
        // Desktop baseline: 800x600 canvas at 0.665 zoom shows ~1203x903 world units
        const TARGET_VISIBLE_WIDTH = 1203;
        const TARGET_VISIBLE_HEIGHT = 903;
        const BASE_ZOOM = 0.665; // Reference zoom level
        
        const camera = {
            x: 0,
            y: 0,
            zoom: 0.665, // Will be recalculated based on canvas size
            
            // Recalculate zoom to show consistent world area
            // Uses the larger of width or height ratio to ensure player appears same size
            updateZoom() {
                // Calculate zoom needed to fit target visible area
                const zoomForWidth = canvas.width / TARGET_VISIBLE_WIDTH;
                const zoomForHeight = canvas.height / TARGET_VISIBLE_HEIGHT;
                
                // Use the LARGER zoom to keep player consistently sized
                // This means on smaller screens, you see less of the world but player is same size
                this.zoom = Math.max(zoomForWidth, zoomForHeight);
                
                // Ensure minimum zoom so things don't get too small
                this.zoom = Math.max(this.zoom, 0.35);
            },
            
            update() {
                // Center camera on player (accounting for zoom)
                this.x = player.x - (canvas.width / this.zoom) / 2;
                this.y = player.y - (canvas.height / this.zoom) / 2;
                
                // Clamp to world bounds
                this.x = Math.max(0, Math.min(WORLD.width - canvas.width / this.zoom, this.x));
                this.y = Math.max(0, Math.min(WORLD.height - canvas.height / this.zoom, this.y));
            },
            
            // Convert world coords to screen coords
            screenX(worldX) { return (worldX - this.x) * this.zoom; },
            screenY(worldY) { return (worldY - this.y) * this.zoom; },
            
            // Scale a size value for zoom
            scale(size) { return size * this.zoom; },
            
            // Check if world position is visible
            isVisible(x, y, margin = 50) {
                return x > this.x - margin && 
                       x < this.x + canvas.width / this.zoom + margin &&
                       y > this.y - margin && 
                       y < this.y + canvas.height / this.zoom + margin;
            }
        };
        
        // Initialize camera zoom and update on resize
        camera.updateZoom();
        window.addEventListener('resize', () => camera.updateZoom());

        // ===== GAME STATE =====
        let gameRunning = false;
        let gamePaused = false;
        let gameTime = 0;
        let kills = 0;
        let player = null;
        let enemies = [];
        let projectiles = [];
        let xpGems = [];
        let damageNumbers = [];
        let particles = [];
        let shrines = [];
        let magnetPulseActive = false; // Is magnet pulse currently active
        
        // Fog of War system - tracks explored areas
        const FOG_CELL_SIZE = 100; // Each cell is 100x100 world units
        const FOG_GRID_SIZE = Math.ceil(WORLD.width / FOG_CELL_SIZE);
        let fogGrid = []; // 2D array: true = explored, false = unexplored
        
        function initFogGrid() {
            fogGrid = [];
            for (let y = 0; y < FOG_GRID_SIZE; y++) {
                fogGrid[y] = [];
                for (let x = 0; x < FOG_GRID_SIZE; x++) {
                    fogGrid[y][x] = false;
                }
            }
        }
        
        function updateFogOfWar() {
            if (!player) return;
            
            // Calculate visible range (based on camera view)
            const viewRadius = Math.max(canvas.width, canvas.height) / camera.zoom / 2 + 100;
            
            // Mark cells within view as explored
            const minCellX = Math.max(0, Math.floor((player.x - viewRadius) / FOG_CELL_SIZE));
            const maxCellX = Math.min(FOG_GRID_SIZE - 1, Math.floor((player.x + viewRadius) / FOG_CELL_SIZE));
            const minCellY = Math.max(0, Math.floor((player.y - viewRadius) / FOG_CELL_SIZE));
            const maxCellY = Math.min(FOG_GRID_SIZE - 1, Math.floor((player.y + viewRadius) / FOG_CELL_SIZE));
            
            for (let cy = minCellY; cy <= maxCellY; cy++) {
                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    // Check if cell center is within circular view
                    const cellCenterX = (cx + 0.5) * FOG_CELL_SIZE;
                    const cellCenterY = (cy + 0.5) * FOG_CELL_SIZE;
                    const dist = Math.hypot(cellCenterX - player.x, cellCenterY - player.y);
                    if (dist < viewRadius) {
                        fogGrid[cy][cx] = true;
                    }
                }
            }
        }
        
        function isExplored(worldX, worldY) {
            const cellX = Math.floor(worldX / FOG_CELL_SIZE);
            const cellY = Math.floor(worldY / FOG_CELL_SIZE);
            if (cellX < 0 || cellX >= FOG_GRID_SIZE || cellY < 0 || cellY >= FOG_GRID_SIZE) {
                return false;
            }
            return fogGrid[cellY][cellX];
        }
        
        // Leprechaun system
        let leprechauns = [];
        let rainbows = [];
        let leprechaunSpawnTimer = 0;
        let leprechaunSpawnInterval = 90000; // First spawn at 90s, then every 2 minutes
        let nextLeprechaunSpawn = 90000;
        
        // Player legendary elemental effects
        let legendaryEffects = {
            burn: { chance: 0, damage: 0 },
            freeze: { chance: 0, slowAmount: 0 },
            shock: { chance: 0, damage: 0 },
            timeSlow: { active: false, cooldownEnd: 0, isSlowed: false, effectEnd: 0, regenBoostEnd: 0 },
            holyBook: { active: false, maxHpBonus: 0, regenBonus: 0 },
            stillness: { active: false, lifestealBonus: 0 },
            xpMagnet: { active: false, lastPulse: 0, interval: 30000 },
            ghostStrike: { active: false }
        };
        
        // Ghost entities for Vengeful Spirits
        let ghosts = [];
        
        // Treasure chests
        let chests = [];
        let legendaryCount = 0; // Track legendaries acquired this run
        const MAX_LEGENDARIES = 4;
        let lastLegendaryTime = 0; // When player last got a legendary
        let guaranteedLegendaryNext = false; // Bad luck protection flag
        
        // Gold currency
        let playerGold = 0;
        let nextChestCost = 5; // First paid chest costs 5, doubles each time
        let pendingChest = null; // Currently open chest offer
        
        // Time slow effect multiplier (1 = normal, 0.4 = 60% slower)
        let timeSlowMultiplier = 1;
        
        // Boss system
        let bosses = [];
        let nextBossTime = 150; // First boss at 2.5 mins (150s)
        let bossCount = 0; // Track how many bosses spawned
        
        // Swarm system (1 min before boss, lasts 30s)
        let swarmActive = false;
        let swarmEndTime = 0;
        let swarmTriggeredForBoss = 0; // Which boss # triggered the current swarm

        // Entity limits for performance
        const LIMITS = {
            particles: 200,
            damageNumbers: 50,
            projectiles: 150,
            enemies: 150
        };

        // ===== WEAPON DEFINITIONS =====
        const WEAPONS = {
            energyBolt: {
                name: 'Energy Bolt',
                icon: '‚ö°',
                color: COLORS.cyan,
                desc: 'Auto-fires at nearest enemy',
                baseDamage: 10,
                baseFireRate: 600,
                baseProjectiles: 1,
                type: 'projectile'
            },
            plasmaOrbit: {
                name: 'Plasma Shield',
                icon: 'üõ°Ô∏è',
                color: COLORS.purple,
                desc: 'Rotating shield damages enemies',
                baseDamage: 12,
                baseOrbs: 3,
                type: 'orbit'
            },
            neonWave: {
                name: 'Neon Wave',
                icon: 'üåä',
                color: COLORS.teal,
                desc: 'Damages all nearby enemies',
                baseDamage: 10,
                baseRadius: 130,
                baseFireRate: 1200,
                type: 'aoe'
            },
            laserBeam: {
                name: 'Laser Beam',
                icon: 'üì°',
                color: COLORS.pink,
                desc: 'Piercing laser shots',
                baseDamage: 25,
                baseFireRate: 900,
                pierce: 4,
                type: 'laser'
            },
            shockField: {
                name: 'Shock Field',
                icon: 'üí´',
                color: COLORS.yellow,
                desc: 'Zaps random enemies',
                baseDamage: 14,
                baseFireRate: 500,
                baseTargets: 2,
                type: 'chain'
            },
            // NEW WEAPONS
            voidDaggers: {
                name: 'Void Daggers',
                icon: 'üó°Ô∏è',
                color: '#9400d3',
                desc: 'Fast daggers in all directions',
                baseDamage: 8,
                baseFireRate: 800,
                baseDaggers: 4,
                type: 'daggers'
            },
            flameThrower: {
                name: 'Flame Thrower',
                icon: 'üî•',
                color: COLORS.orange,
                desc: 'Cone of fire damage',
                baseDamage: 6,
                baseFireRate: 120,
                baseAngle: 0.7,
                baseRange: 160,
                type: 'flame'
            },
            boomerang: {
                name: 'Spectral Glaive',
                icon: 'ü™É',
                color: '#00ff88',
                desc: 'Returns to you, hits twice',
                baseDamage: 18,
                baseFireRate: 1200,
                baseCount: 1,
                type: 'boomerang'
            },
            thunderStrike: {
                name: 'Lightning Strike',
                icon: 'üå©Ô∏è',
                color: '#ffff00',
                desc: 'Lightning from above',
                baseDamage: 35,
                baseFireRate: 1000,
                baseStrikes: 1,
                type: 'thunder'
            },
            toxicAura: {
                name: 'Toxic Aura',
                icon: '‚ò†Ô∏è',
                color: '#32cd32',
                desc: 'Poison nearby enemies',
                baseDamage: 3,
                baseRadius: 110,
                tickRate: 350,
                type: 'aura'
            }
        };

        // ===== PASSIVE UPGRADES =====
        const PASSIVES = {
            speed: { name: 'Speed Boost', icon: 'üëü', color: COLORS.teal, desc: '+12% move speed' },
            maxHp: { name: 'Vitality', icon: '‚ù§Ô∏è', color: COLORS.pink, desc: '+25 max HP' },
            damage: { name: 'Power Up', icon: 'üí™', color: COLORS.orange, desc: '+12% damage' },
            pickupRange: { name: 'Magnet', icon: 'üß≤', color: COLORS.blue, desc: '+30% pickup range' },
            regen: { name: 'Regen', icon: 'üíö', color: COLORS.teal, desc: 'Heal 1.5 HP/sec' }
        };

        // ===== SHRINE POWER-UPS =====
        const SHRINE_POWERUPS = {
            damage: { name: 'Power', icon: '‚öîÔ∏è', color: COLORS.orange, desc: '+12% Damage', stat: 'damageBonus', value: 0.12 },
            speed: { name: 'Swiftness', icon: 'üí®', color: COLORS.teal, desc: '+10% Speed', stat: 'speedBonus', value: 0.10 },
            attackSpeed: { name: 'Haste', icon: '‚ö°', color: COLORS.yellow, desc: '+12% Attack Speed', stat: 'attackSpeedBonus', value: 0.12 },
            regen: { name: 'Vitality', icon: 'üíö', color: COLORS.teal, desc: '+1.0 HP/sec', stat: 'regenBonus', value: 1.0 },
            lifesteal: { name: 'Vampirism', icon: 'ü©∏', color: COLORS.pink, desc: '+5% Lifesteal', stat: 'lifesteal', value: 0.05 },
            critChance: { name: 'Precision', icon: 'üéØ', color: COLORS.cyan, desc: '+6% Crit Chance', stat: 'critChance', value: 0.06 },
            critMultiplier: { name: 'Lethality', icon: 'üíÄ', color: COLORS.purple, desc: '+15% Crit Damage', stat: 'critMultiplier', value: 0.15 },
            armor: { name: 'Fortitude', icon: 'üõ°Ô∏è', color: COLORS.blue, desc: '+8% Damage Reduction', stat: 'armor', value: 0.08 }
        };

        // ===== PLAYER CLASS =====
        class Player {
            constructor() {
                this.x = WORLD.width / 2;
                this.y = WORLD.height / 2;
                this.radius = 21;
                this.baseSpeed = 2.4;  // 20% slower (was 3.0)
                this.speed = this.baseSpeed;
                this.maxHp = 120;      // Buffed from 100
                this.hp = this.maxHp;
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 10;
                this.weapons = {};
                this.passives = {};
                this.pickupRange = 50;
                this.damageMultiplier = 1;
                this.regenRate = 0;
                this.invincible = 0;
                this.invincibilityDuration = 600; // Buffed from 500ms
                
                // New stats for shrine system
                this.critChance = 0.05;      // 5% base crit chance
                this.critMultiplier = 2.0;   // 2x base crit damage
                this.armor = 0;              // % damage reduction
                this.lifesteal = 0;          // % of damage healed
                this.attackSpeedMultiplier = 1;
                
                // Shrine bonuses (stacking)
                this.shrineBonuses = {
                    damageBonus: 0,
                    speedBonus: 0,
                    attackSpeedBonus: 0,
                    regenBonus: 0,
                    lifesteal: 0,
                    critChance: 0,
                    critMultiplier: 0,
                    armor: 0
                };
                
                // Give starting weapon
                this.addWeapon('energyBolt');
            }

            addWeapon(weaponId) {
                if (!this.weapons[weaponId]) {
                    this.weapons[weaponId] = {
                        level: 1,
                        lastFire: 0,
                        angle: 0  // for orbit weapons
                    };
                } else {
                    this.weapons[weaponId].level = Math.min(this.weapons[weaponId].level + 1, 5);
                }
            }

            addPassive(passiveId) {
                if (!this.passives[passiveId]) {
                    this.passives[passiveId] = 1;
                } else {
                    this.passives[passiveId]++;
                }
                this.applyPassives();
            }

            applyPassives() {
                // Base passives from level-up (updated values)
                const baseSpeedMult = 1 + (this.passives.speed || 0) * 0.12;  // 12% per level
                const shrineSpeedMult = 1 + this.shrineBonuses.speedBonus;
                this.speed = this.baseSpeed * baseSpeedMult * shrineSpeedMult;
                
                this.maxHp = 120 + (this.passives.maxHp || 0) * 25;  // +25 HP per level
                this.hp = Math.min(this.hp, this.maxHp);
                
                // Damage multiplier combines passive and shrine bonuses
                const baseDamageMult = 1 + (this.passives.damage || 0) * 0.12;  // 12% per level
                this.damageMultiplier = baseDamageMult * (1 + this.shrineBonuses.damageBonus);
                
                this.pickupRange = 50 * (1 + (this.passives.pickupRange || 0) * 0.30);  // 30% per level
                
                // Regen from passives + shrine (1.5 per passive level)
                this.regenRate = (this.passives.regen || 0) * 1.5 + this.shrineBonuses.regenBonus;
                
                // Attack speed from shrine
                this.attackSpeedMultiplier = 1 + this.shrineBonuses.attackSpeedBonus;
                
                // Crit stats (base + shrine)
                this.critChance = 0.05 + this.shrineBonuses.critChance;
                this.critMultiplier = 2.0 + this.shrineBonuses.critMultiplier;
                
                // Lifesteal and armor from shrine
                this.lifesteal = this.shrineBonuses.lifesteal;
                this.armor = this.shrineBonuses.armor;
            }
            
            addShrineBonus(stat, value) {
                if (this.shrineBonuses.hasOwnProperty(stat)) {
                    this.shrineBonuses[stat] += value;
                    this.applyPassives();
                }
            }
            
            // Calculate damage with crit
            calcDamage(baseDamage) {
                let damage = baseDamage * this.damageMultiplier;
                let isCrit = false;
                
                if (Math.random() < this.critChance) {
                    damage *= this.critMultiplier;
                    isCrit = true;
                }
                
                return { damage, isCrit };
            }
            
            // Apply lifesteal
            onDealDamage(damage) {
                // Base lifesteal from shrines
                let totalLifesteal = this.lifesteal;
                
                // Add stillness lifesteal bonus
                if (legendaryEffects.stillness.active) {
                    totalLifesteal += legendaryEffects.stillness.lifestealBonus;
                }
                
                if (totalLifesteal > 0) {
                    const healAmount = damage * totalLifesteal;
                    this.heal(healAmount);
                }
            }
            
            // Centralized healing method for holy book radiation
            heal(amount) {
                if (this.hp >= this.maxHp) return;
                
                const oldHp = this.hp;
                this.hp = Math.min(this.maxHp, this.hp + amount);
                const actualHeal = this.hp - oldHp;
                
                // Holy Book radiation - damage nearby enemies when healing
                if (legendaryEffects.holyBook.active && actualHeal > 0) {
                    const radiusRange = 120;
                    const radiationDamage = actualHeal * 0.5; // 50% of heal as damage
                    
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                        if (dist < radiusRange) {
                            enemy.takeDamage(radiationDamage, false);
                        }
                    }
                    
                    // Visual effect
                    if (Math.random() < 0.3) {
                        spawnParticles(this.x, this.y, '#ffffaa', 5);
                    }
                }
            }

            gainXP(amount) {
                this.xp += amount;
                while (this.xp >= this.xpToNext) {
                    this.xp -= this.xpToNext;
                    this.level++;
                    this.xpToNext = Math.floor(this.xpToNext * 1.3) + 5;
                    
                    showUpgradeSelection();
                }
            }

            takeDamage(amount) {
                if (this.invincible > 0) return;
                
                // Apply armor damage reduction
                const reducedDamage = amount * (1 - this.armor);
                this.hp -= reducedDamage;
                this.invincible = this.invincibilityDuration;
                
                // Screen flash
                spawnParticles(this.x, this.y, COLORS.pink, 15);
                
                if (this.hp <= 0) {
                    gameOver();
                }
            }

            update(dt, inputObj) {
                // Movement
                let dx = 0, dy = 0;
                if (inputObj.left) dx -= 1;
                if (inputObj.right) dx += 1;
                if (inputObj.up) dy -= 1;
                if (inputObj.down) dy += 1;
                
                // Joystick input
                if (inputObj.joystickX !== 0 || inputObj.joystickY !== 0) {
                    dx = inputObj.joystickX;
                    dy = inputObj.joystickY;
                }
                
                // Normalize diagonal
                if (dx && dy) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                // World bounds
                this.x = Math.max(this.radius, Math.min(WORLD.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD.height - this.radius, this.y));
                
                // Terrain collision - push player out of lakes/mountains/trees
                const terrain = isInTerrain(this.x, this.y, this.radius);
                if (terrain) {
                    if (terrain.type === 'tree') {
                        // Circular collision for trees
                        const dx2 = this.x - terrain.x;
                        const dy2 = this.y - terrain.y;
                        const dist = Math.hypot(dx2, dy2);
                        
                        if (dist > 0) {
                            const pushDist = terrain.radius + this.radius + 2;
                            this.x = terrain.x + (dx2 / dist) * pushDist;
                            this.y = terrain.y + (dy2 / dist) * pushDist;
                        }
                    } else {
                        // Ellipse collision for lakes/mountains
                        const dx2 = this.x - terrain.x;
                        const dy2 = this.y - terrain.y;
                        
                        // Normalize by ellipse radii
                        const normX = dx2 / terrain.radiusX;
                        const normY = dy2 / terrain.radiusY;
                        const dist = Math.sqrt(normX * normX + normY * normY);
                        
                        if (dist > 0) {
                            // Push to edge of terrain + player radius
                            const pushX = (normX / dist) * (terrain.radiusX + this.radius + 5);
                            const pushY = (normY / dist) * (terrain.radiusY + this.radius + 5);
                            this.x = terrain.x + pushX;
                            this.y = terrain.y + pushY;
                        }
                    }
                }
                
                // Invincibility timer
                if (this.invincible > 0) this.invincible -= dt;
                
                // Regen (uses heal() for holy book radiation)
                if (this.regenRate > 0) {
                    let regenMultiplier = 1;
                    // Temporal Shield: 150% regen boost during effect
                    if (legendaryEffects.timeSlow.active && Date.now() < legendaryEffects.timeSlow.regenBoostEnd) {
                        regenMultiplier = 2.5; // 150% bonus = 250% total
                    }
                    this.heal(this.regenRate * regenMultiplier * dt / 1000);
                }
                
                // Fire weapons
                this.fireWeapons(dt);
            }

            fireWeapons(dt) {
                const now = Date.now();
                
                for (const [weaponId, weaponState] of Object.entries(this.weapons)) {
                    const weaponDef = WEAPONS[weaponId];
                    const level = weaponState.level;
                    
                    switch (weaponDef.type) {
                        case 'projectile':
                            this.fireProjectile(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'orbit':
                            this.updateOrbit(weaponId, weaponDef, weaponState, level, dt);
                            break;
                        case 'aoe':
                            this.fireAOE(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'laser':
                            this.fireLaser(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'chain':
                            this.fireChain(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'daggers':
                            this.fireDaggers(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'flame':
                            this.updateFlame(weaponId, weaponDef, weaponState, level, now, dt);
                            break;
                        case 'boomerang':
                            this.fireBoomerang(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'thunder':
                            this.fireThunder(weaponId, weaponDef, weaponState, level, now);
                            break;
                        case 'aura':
                            this.updateAura(weaponId, weaponDef, weaponState, level, now);
                            break;
                    }
                }
            }

            fireProjectile(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.9, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const projectileCount = def.baseProjectiles + Math.floor(level / 2);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.3);
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const spread = 0.2;
                
                for (let i = 0; i < projectileCount; i++) {
                    const a = angle + (i - (projectileCount - 1) / 2) * spread;
                    projectiles.push(new Projectile(
                        this.x, this.y, a, 4, baseDamage, def.color, 'bolt'
                    ));
                }
            }

            updateOrbit(id, def, state, level, dt) {
                const orbCount = def.baseOrbs + Math.floor(level / 2);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.25);
                const radius = 70 + level * 12;
                
                // Initialize angle if needed
                if (state.angle === undefined) state.angle = 0;
                state.angle += dt * 0.004 * this.attackSpeedMultiplier;
                
                for (let i = 0; i < orbCount; i++) {
                    const angle = state.angle + (Math.PI * 2 / orbCount) * i;
                    const ox = this.x + Math.cos(angle) * radius;
                    const oy = this.y + Math.sin(angle) * radius;
                    
                    // Check collision with enemies
                    for (const enemy of enemies) {
                        if (enemy.dead) continue;
                        const dist = Math.hypot(enemy.x - ox, enemy.y - oy);
                        if (dist < enemy.radius + 14 && enemy.orbHitCooldown <= 0) {
                            const { damage, isCrit } = this.calcDamage(baseDamage);
                            enemy.takeDamage(damage, isCrit);
                            this.onDealDamage(damage);
                            applyStatusEffects(enemy, damage);
                            enemy.orbHitCooldown = 250;
                            spawnParticles(ox, oy, def.color, 6);
                        }
                    }
                    
                    // Check collision with leprechauns
                    for (const lep of leprechauns) {
                        if (lep.dead) continue;
                        const dist = Math.hypot(lep.x - ox, lep.y - oy);
                        if (dist < lep.radius + 14 && lep.orbHitCooldown <= 0) {
                            const { damage, isCrit } = this.calcDamage(baseDamage);
                            lep.takeDamage(damage, isCrit);
                            this.onDealDamage(damage);
                            lep.orbHitCooldown = 250;
                            spawnParticles(ox, oy, COLORS.gold, 6);
                        }
                    }
                    
                    // Check collision with bosses
                    for (const boss of bosses) {
                        if (boss.dead) continue;
                        const dist = Math.hypot(boss.x - ox, boss.y - oy);
                        if (dist < boss.radius + 14 && boss.orbHitCooldown <= 0) {
                            const { damage, isCrit } = this.calcDamage(baseDamage);
                            boss.takeDamage(damage, isCrit);
                            this.onDealDamage(damage);
                            boss.orbHitCooldown = 250;
                            spawnParticles(ox, oy, boss.color, 6);
                        }
                    }
                }
                
                // Store for rendering
                state.orbCount = orbCount;
                state.radius = radius;
            }

            fireAOE(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.92, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                state.lastFire = now;
                const radius = def.baseRadius + level * 25;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.2);
                
                // Visual wave
                state.waveRadius = 0;
                state.waveMaxRadius = radius;
                state.waveActive = true;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue; // Skip dead enemies
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        enemy.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                        applyStatusEffects(enemy, damage);
                    }
                }
                
                // Also hit leprechauns
                for (const lep of leprechauns) {
                    if (lep.dead) continue;
                    const dist = Math.hypot(lep.x - this.x, lep.y - this.y);
                    if (dist < radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        lep.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
                
                // Also hit bosses
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist < radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        boss.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
            }

            fireLaser(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.9, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.35);
                const pierce = def.pierce + Math.floor(level / 2);
                
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                projectiles.push(new Projectile(
                    this.x, this.y, angle, 6, baseDamage, def.color, 'laser', pierce
                ));
            }

            fireChain(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.92, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Filter out dead enemies and include bosses
                const aliveEnemies = enemies.filter(e => !e.dead);
                const aliveBosses = bosses.filter(b => !b.dead);
                const allTargets = [...aliveEnemies, ...aliveBosses];
                if (allTargets.length === 0) return;
                
                state.lastFire = now;
                const targetCount = def.baseTargets + Math.floor(level / 2);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.25);
                
                // Efficient random sample instead of full shuffle
                const targets = randomSample(allTargets, targetCount);
                for (const target of targets) {
                    const { damage, isCrit } = this.calcDamage(baseDamage);
                    target.takeDamage(damage, isCrit);
                    this.onDealDamage(damage);
                    
                    // Visual lightning (with cleanup)
                    if (!state.chainTargets) state.chainTargets = [];
                    state.chainTargets.push({ x: target.x, y: target.y, time: now });
                    spawnParticles(target.x, target.y, def.color, 8);
                }
                
                // Clean up old chain targets (older than 100ms)
                if (state.chainTargets) {
                    state.chainTargets = state.chainTargets.filter(t => now - t.time < 180);
                }
            }

            // === NEW WEAPON METHODS ===
            
            fireDaggers(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.88, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                state.lastFire = now;
                const daggerCount = def.baseDaggers + level;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.2);
                
                // Fire daggers in all directions
                for (let i = 0; i < daggerCount; i++) {
                    const angle = (Math.PI * 2 / daggerCount) * i;
                    projectiles.push(new Projectile(
                        this.x, this.y, angle, 7, baseDamage, def.color, 'dagger', 1
                    ));
                }
            }
            
            updateFlame(id, def, state, level, now, dt) {
                const fireRate = def.baseFireRate / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                state.lastFire = now;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.15);
                const range = def.baseRange + level * 28;
                const coneAngle = def.baseAngle + level * 0.1;
                
                // Get facing direction (towards nearest enemy or last move direction)
                const target = findNearestEnemy(this.x, this.y);
                let facing = state.facing || 0;
                if (target) {
                    facing = Math.atan2(target.y - this.y, target.x - this.x);
                    state.facing = facing;
                }
                
                // Store for rendering
                state.flameAngle = facing;
                state.flameRange = range;
                state.flameCone = coneAngle;
                state.flameActive = now;
                
                // Damage enemies in cone
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist > range) continue;
                    
                    const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                    let angleDiff = Math.abs(angleToEnemy - facing);
                    if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                    
                    if (angleDiff < coneAngle / 2) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        enemy.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
                
                // Damage bosses in cone
                for (const boss of bosses) {
                    if (boss.dead) continue;
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist > range) continue;
                    
                    const angleToBoss = Math.atan2(boss.y - this.y, boss.x - this.x);
                    let angleDiff = Math.abs(angleToBoss - facing);
                    if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                    
                    if (angleDiff < coneAngle / 2) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        boss.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
            }
            
            fireBoomerang(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.9, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                const target = findNearestEnemy(this.x, this.y);
                if (!target) return;
                
                state.lastFire = now;
                const count = def.baseCount + Math.floor(level / 3);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.3);
                
                for (let i = 0; i < count; i++) {
                    const angleOffset = count > 1 ? (i - (count - 1) / 2) * 0.4 : 0;
                    const angle = Math.atan2(target.y - this.y, target.x - this.x) + angleOffset;
                    
                    // Create boomerang projectile
                    const boom = new Projectile(this.x, this.y, angle, 5, baseDamage, def.color, 'boomerang', 999);
                    boom.startX = this.x;
                    boom.startY = this.y;
                    boom.maxDist = 250 + level * 30;
                    boom.returning = false;
                    boom.spinAngle = 0;
                    projectiles.push(boom);
                }
            }
            
            fireThunder(id, def, state, level, now) {
                const fireRate = def.baseFireRate * Math.pow(0.9, level - 1) / this.attackSpeedMultiplier;
                if (now - state.lastFire < fireRate) return;
                
                // Include bosses as potential targets
                const aliveEnemies = enemies.filter(e => !e.dead);
                const aliveBosses = bosses.filter(b => !b.dead);
                const allTargets = [...aliveEnemies, ...aliveBosses];
                if (allTargets.length === 0) return;
                
                state.lastFire = now;
                const strikeCount = def.baseStrikes + Math.floor(level / 2);
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.35);
                
                // Store strikes for rendering
                if (!state.strikes) state.strikes = [];
                
                const targets = randomSample(allTargets, strikeCount);
                for (const target of targets) {
                    const { damage, isCrit } = this.calcDamage(baseDamage);
                    target.takeDamage(damage, isCrit);
                    this.onDealDamage(damage);
                    
                    // Visual lightning strike
                    state.strikes.push({ 
                        x: target.x, 
                        y: target.y, 
                        time: now,
                        segments: generateLightning(target.x, target.y - 400, target.x, target.y)
                    });
                    spawnParticles(target.x, target.y, def.color, 12);
                }
                
                // Cleanup old strikes
                state.strikes = state.strikes.filter(s => now - s.time < 350);
            }
            
            updateAura(id, def, state, level, now) {
                const tickRate = def.tickRate / this.attackSpeedMultiplier;
                if (now - (state.lastTick || 0) < tickRate) return;
                
                state.lastTick = now;
                const radius = def.baseRadius + level * 25;
                const baseDamage = def.baseDamage * (1 + (level - 1) * 0.2);
                
                // Store for rendering
                state.auraRadius = radius;
                state.auraPulse = now;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < radius + enemy.radius) {
                        const { damage, isCrit } = this.calcDamage(baseDamage);
                        enemy.takeDamage(damage, isCrit);
                        this.onDealDamage(damage);
                    }
                }
            }

            draw() {
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                
                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.invincible > 0 ? COLORS.pink : COLORS.cyan;
                
                // Body
                ctx.fillStyle = this.invincible > 0 && Math.floor(Date.now() / 50) % 2 
                    ? 'transparent' : COLORS.cyan;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner glow
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw orbit weapons
                for (const [weaponId, state] of Object.entries(this.weapons)) {
                    const def = WEAPONS[weaponId];
                    if (def.type === 'orbit' && state.orbCount) {
                        const orbitR = camera.scale(state.radius);
                        
                        // Draw faint connecting ring
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(sx, sy, orbitR, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        
                        // Draw orbs
                        ctx.fillStyle = def.color;
                        ctx.shadowColor = def.color;
                        ctx.shadowBlur = 15;
                        for (let i = 0; i < state.orbCount; i++) {
                            const angle = state.angle + (Math.PI * 2 / state.orbCount) * i;
                            const ox = sx + Math.cos(angle) * orbitR;
                            const oy = sy + Math.sin(angle) * orbitR;
                            ctx.beginPath();
                            ctx.arc(ox, oy, camera.scale(12), 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Inner bright core
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
                            ctx.arc(ox, oy, camera.scale(4), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = def.color;
                        }
                        ctx.shadowBlur = 0;
                    }
                    
                    // AOE wave visual
                    if (def.type === 'aoe' && state.waveActive) {
                        state.waveRadius += 12;
                        if (state.waveRadius >= state.waveMaxRadius) {
                            state.waveActive = false;
                        } else {
                            ctx.strokeStyle = def.color;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = def.color;
                            ctx.lineWidth = 4;
                            ctx.globalAlpha = 1 - state.waveRadius / state.waveMaxRadius;
                            ctx.beginPath();
                            ctx.arc(sx, sy, camera.scale(state.waveRadius), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // Flame thrower visual
                    if (def.type === 'flame' && state.flameActive && Date.now() - state.flameActive < 200) {
                        const flameRange = camera.scale(state.flameRange);
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = COLORS.orange;
                        const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, flameRange);
                        grad.addColorStop(0, 'rgba(255, 150, 0, 0.7)');
                        grad.addColorStop(0.5, 'rgba(255, 80, 0, 0.4)');
                        grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.arc(sx, sy, flameRange, state.flameAngle - state.flameCone/2, state.flameAngle + state.flameCone/2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Inner bright cone
                        ctx.fillStyle = 'rgba(255, 220, 100, 0.5)';
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.arc(sx, sy, flameRange * 0.6, state.flameAngle - state.flameCone/3, state.flameAngle + state.flameCone/3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    // Thunder strike visual
                    if (def.type === 'thunder' && state.strikes) {
                        const now = Date.now();
                        ctx.strokeStyle = def.color;
                        ctx.shadowColor = def.color;
                        ctx.shadowBlur = 20;
                        ctx.lineWidth = 4;
                        
                        for (const strike of state.strikes) {
                            const age = now - strike.time;
                            if (age > 350) continue;
                            ctx.globalAlpha = 1 - age / 350;
                            
                            for (const seg of strike.segments) {
                                ctx.beginPath();
                                ctx.moveTo(camera.screenX(seg.x1), camera.screenY(seg.y1));
                                ctx.lineTo(camera.screenX(seg.x2), camera.screenY(seg.y2));
                                ctx.stroke();
                            }
                            
                            // Impact flash
                            ctx.fillStyle = 'rgba(255, 255, 100, ' + (0.6 - age/600) + ')';
                            ctx.beginPath();
                            ctx.arc(camera.screenX(strike.x), camera.screenY(strike.y), camera.scale(30 - age/12), 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                    
                    // Toxic aura visual
                    if (def.type === 'aura' && state.auraRadius) {
                        const auraR = camera.scale(state.auraRadius);
                        const pulseT = (Date.now() - (state.auraPulse || 0)) / 350;
                        const pulseAlpha = Math.max(0, 0.5 - pulseT * 0.3);
                        
                        // Constant outer glow
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = def.color;
                        const grad = ctx.createRadialGradient(sx, sy, auraR * 0.3, sx, sy, auraR);
                        grad.addColorStop(0, 'rgba(50, 205, 50, 0.25)');
                        grad.addColorStop(1, 'rgba(50, 205, 50, 0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(sx, sy, auraR, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Pulse ring
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = pulseAlpha;
                        ctx.beginPath();
                        ctx.arc(sx, sy, auraR * (0.6 + pulseT * 0.4), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                    
                    // Chain lightning visual
                    if (def.type === 'chain' && state.chainTargets) {
                        ctx.strokeStyle = def.color;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = def.color;
                        const now = Date.now();
                        
                        for (const target of state.chainTargets) {
                            const age = now - target.time;
                            if (age > 180) continue;
                            ctx.globalAlpha = 1 - age / 180;
                            ctx.beginPath();
                            ctx.moveTo(sx, sy);
                            ctx.lineTo(camera.screenX(target.x), camera.screenY(target.y));
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }
                }
                
                // Mini health bar above player (only when damaged)
                if (this.hp < this.maxHp) {
                    ctx.shadowBlur = 0;
                    const hpBarWidth = camera.scale(39);
                    const hpBarHeight = camera.scale(3);
                    const hpBarY = sy - r - camera.scale(12);
                    
                    // Background (unfilled/damaged portion)
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(sx - hpBarWidth/2, hpBarY, hpBarWidth, hpBarHeight);
                    
                    // Fill (remaining health) - clamp between 0 and 1
                    const hpPercent = Math.max(0, Math.min(1, this.hp / this.maxHp));
                    ctx.fillStyle = '#39ff9f';
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = '#39ff9f';
                    ctx.fillRect(sx - hpBarWidth/2, hpBarY, hpBarWidth * hpPercent, hpBarHeight);
                    
                    // Border
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#00ff66';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(sx - hpBarWidth/2, hpBarY, hpBarWidth, hpBarHeight);
                }
                
                ctx.restore();
            }
        }

        // ===== ENEMY CLASS =====
        class Enemy {
            constructor(type, x, y) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.orbHitCooldown = 0;
                
                // Status effects
                this.burnDamage = 0;
                this.burnTicks = 0;
                this.burnTickTimer = 0;
                this.freezeTimer = 0;
                this.freezeSlowAmount = 0;
                this.shockTimer = 0;
                this.baseSpeed = 0; // Set after switch
                
                // Scaling factor based on game time
                // HP: +10% every 30 seconds (was 15%)
                const hpScale = 1 + Math.floor(gameTime / 30) * 0.10;
                // Damage: +8% every 45 seconds (was 10% per 60s)
                const dmgScale = 1 + Math.floor(gameTime / 45) * 0.08;
                
                switch (type) {
                    case 'basic':
                        this.radius = 12;
                        this.speed = 1.2;
                        this.maxHp = Math.floor(15 * hpScale);
                        this.baseDamage = 16;
                        this.color = COLORS.magenta;
                        this.xpValue = 1;
                        break;
                    case 'fast':
                        this.radius = 9;
                        this.speed = 2.5;
                        this.maxHp = Math.floor(10 * hpScale);
                        this.baseDamage = 10;  // Reduced from 12
                        this.color = COLORS.orange;
                        this.xpValue = 1;
                        break;
                    case 'tank':
                        this.radius = 21;
                        this.speed = 0.7;
                        this.maxHp = Math.floor(50 * hpScale);
                        this.baseDamage = 24;  // Reduced from 30
                        this.color = COLORS.purple;
                        this.xpValue = 3;
                        break;
                    case 'swarm':
                        this.radius = 7;
                        this.speed = 1.8;
                        this.maxHp = Math.floor(6 * hpScale);
                        this.baseDamage = 6;   // Reduced from 8
                        this.color = COLORS.teal;
                        this.xpValue = 1;
                        break;
                }
                
                // Apply damage scaling
                this.damage = Math.floor(this.baseDamage * dmgScale);
                this.hp = this.maxHp;
                this.baseSpeed = this.speed; // Store for freeze effect
                
                // XP scales slightly with time to keep leveling relevant
                const xpScale = 1 + Math.floor(gameTime / 120) * 0.5; // +50% XP every 2 min
                this.xpValue = Math.ceil(this.xpValue * xpScale);
            }
            
            // Status effect methods
            applyBurn(damage) {
                if (this.burnTicks < 3) { // Don't stack burns, but refresh
                    this.burnDamage = damage;
                    this.burnTicks = 3;
                    this.burnTickTimer = 0;
                    // Initial burn damage
                    this.takeDamage(damage, false);
                    spawnParticles(this.x, this.y, COLORS.burn, 5);
                }
            }
            
            applyFreeze(slowAmount) {
                this.freezeTimer = 6000; // 6 seconds
                this.freezeSlowAmount = slowAmount;
                spawnParticles(this.x, this.y, COLORS.freeze, 8);
            }
            
            applyShock(damage) {
                this.shockTimer = 3000; // 3 seconds
                this.takeDamage(damage, false);
                spawnParticles(this.x, this.y, COLORS.shock, 10);
            }

            update(dt) {
                // Status effect updates
                // Burn ticks
                if (this.burnTicks > 0) {
                    this.burnTickTimer += dt;
                    if (this.burnTickTimer >= 666) { // ~3 ticks over 2 seconds
                        this.burnTickTimer = 0;
                        this.burnTicks--;
                        const tickDamage = this.burnDamage * 0.5;
                        this.hp -= tickDamage;
                        spawnDamageNumber(this.x, this.y, Math.round(tickDamage), false);
                        spawnParticles(this.x, this.y, COLORS.burn, 3);
                        if (this.hp <= 0 && !this.dead) this.die();
                    }
                }
                
                // Freeze timer
                if (this.freezeTimer > 0) {
                    this.freezeTimer -= dt;
                    if (this.freezeTimer <= 0) {
                        this.freezeTimer = 0;
                        this.freezeSlowAmount = 0;
                    }
                }
                
                // Shock timer (stunned - no movement or damage)
                if (this.shockTimer > 0) {
                    this.shockTimer -= dt;
                    if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
                    return; // Skip movement and damage while shocked
                }
                
                // Calculate effective speed
                let effectiveSpeed = this.baseSpeed;
                if (this.freezeSlowAmount > 0) {
                    effectiveSpeed *= (1 - this.freezeSlowAmount);
                }
                
                // Move toward player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    const newX = this.x + (dx / dist) * effectiveSpeed;
                    const newY = this.y + (dy / dist) * effectiveSpeed;
                    
                    // Check terrain collision
                    const terrain = isInTerrain(newX, newY, this.radius);
                    if (!terrain) {
                        this.x = newX;
                        this.y = newY;
                    } else {
                        // Try to slide around obstacle
                        if (!isInTerrain(newX, this.y, this.radius)) {
                            this.x = newX;
                        } else if (!isInTerrain(this.x, newY, this.radius)) {
                            this.y = newY;
                        }
                        // If both blocked, enemy stays in place
                    }
                }
                
                // Collision with player
                if (dist < this.radius + player.radius) {
                    player.takeDamage(this.damage);
                }
                
                // Orbit cooldown
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }

            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                if (this.dead) return; // Prevent double death
                this.dead = true;
                kills++;
                DOM.killCount.textContent = kills;
                
                // Spawn XP gem - find valid position outside terrain
                let gemX = this.x;
                let gemY = this.y;
                const terrain = isInTerrain(gemX, gemY, 10);
                if (terrain) {
                    // Push gem outside of terrain
                    if (terrain.type === 'tree') {
                        const dx = gemX - terrain.x;
                        const dy = gemY - terrain.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 0) {
                            gemX = terrain.x + (dx / dist) * (terrain.radius + 15);
                            gemY = terrain.y + (dy / dist) * (terrain.radius + 15);
                        }
                    } else {
                        const dx = gemX - terrain.x;
                        const dy = gemY - terrain.y;
                        const normX = dx / terrain.radiusX;
                        const normY = dy / terrain.radiusY;
                        const dist = Math.sqrt(normX * normX + normY * normY);
                        if (dist > 0) {
                            gemX = terrain.x + (normX / dist) * (terrain.radiusX + 15);
                            gemY = terrain.y + (normY / dist) * (terrain.radiusY + 15);
                        }
                    }
                }
                xpGems.push(new XPGem(gemX, gemY, this.xpValue));
                
                // Drop gold (1-3 based on xp value)
                const goldDrop = Math.max(1, Math.floor(this.xpValue / 2));
                playerGold += goldDrop;
                updateGoldDisplay();
                
                // Death particles
                spawnParticles(this.x, this.y, this.color, 12);
                
                // Vengeful Spirits - spawn ghost on kill
                if (legendaryEffects.ghostStrike.active) {
                    ghosts.push(new Ghost(this.x, this.y));
                }
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                
                // Status effect color overlays
                let mainColor = this.color;
                if (this.shockTimer > 0) {
                    mainColor = COLORS.shock;
                } else if (this.freezeTimer > 0) {
                    mainColor = COLORS.freeze;
                }
                
                ctx.shadowBlur = 15;
                ctx.shadowColor = mainColor;
                ctx.fillStyle = mainColor;
                
                // Hexagon shape for variety
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    const x = sx + Math.cos(angle) * r;
                    const y = sy + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Burn effect - flickering flames
                if (this.burnTicks > 0) {
                    ctx.fillStyle = COLORS.burn;
                    ctx.shadowColor = COLORS.burn;
                    ctx.shadowBlur = 10;
                    const flicker = Math.random() * 0.3 + 0.7;
                    ctx.globalAlpha = flicker;
                    for (let i = 0; i < 3; i++) {
                        const flameAngle = (Date.now() * 0.01 + i * 2) % (Math.PI * 2);
                        const fx = sx + Math.cos(flameAngle) * r * 0.6;
                        const fy = sy + Math.sin(flameAngle) * r * 0.6 - camera.scale(5);
                        ctx.beginPath();
                        ctx.moveTo(fx, fy);
                        ctx.lineTo(fx - camera.scale(3), fy + camera.scale(8));
                        ctx.lineTo(fx + camera.scale(3), fy + camera.scale(8));
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Freeze effect - ice crystals
                if (this.freezeTimer > 0) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = COLORS.freeze;
                    ctx.globalAlpha = 0.8;
                    for (let i = 0; i < 4; i++) {
                        const iceAngle = i * Math.PI / 2;
                        const ix = sx + Math.cos(iceAngle) * r * 1.2;
                        const iy = sy + Math.sin(iceAngle) * r * 1.2;
                        ctx.beginPath();
                        ctx.moveTo(ix, iy - camera.scale(4));
                        ctx.lineTo(ix, iy + camera.scale(4));
                        ctx.moveTo(ix - camera.scale(3), iy);
                        ctx.lineTo(ix + camera.scale(3), iy);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Shock effect - electric sparks
                if (this.shockTimer > 0) {
                    ctx.strokeStyle = COLORS.shock;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = COLORS.shock;
                    const sparkCount = 3;
                    for (let i = 0; i < sparkCount; i++) {
                        const angle = (Date.now() * 0.02 + i * Math.PI * 2 / sparkCount) % (Math.PI * 2);
                        const startR = r * 0.5;
                        const endR = r * 1.3;
                        ctx.beginPath();
                        ctx.moveTo(sx + Math.cos(angle) * startR, sy + Math.sin(angle) * startR);
                        // Jagged line
                        const midAngle = angle + (Math.random() - 0.5) * 0.5;
                        ctx.lineTo(sx + Math.cos(midAngle) * (startR + endR) / 2, sy + Math.sin(midAngle) * (startR + endR) / 2);
                        ctx.lineTo(sx + Math.cos(angle) * endR, sy + Math.sin(angle) * endR);
                        ctx.stroke();
                    }
                }
                
                // HP bar for tanks
                if (this.type === 'tank' && this.hp < this.maxHp) {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(sx - camera.scale(15), sy - r - camera.scale(8), camera.scale(30), camera.scale(4));
                    ctx.fillStyle = this.color;
                    ctx.fillRect(sx - camera.scale(15), sy - r - camera.scale(8), camera.scale(30) * (this.hp / this.maxHp), camera.scale(4));
                }
                
                ctx.restore();
            }
        }

        // ===== LEPRECHAUN CLASS =====
        class Leprechaun {
            constructor(x, y, guardX, guardY) {
                this.x = x;
                this.y = y;
                this.guardX = guardX; // Pot of gold location to guard
                this.guardY = guardY;
                this.radius = 16;
                this.speed = 2.0;
                this.maxHp = 300; // Beefy guardian
                this.hp = this.maxHp;
                this.color = COLORS.green;
                this.dead = false;
                this.orbHitCooldown = 0;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.knockbackCooldown = 0;
                this.knockbackRange = 80;
                this.aggroRange = 150; // Distance at which leprechaun reacts
            }

            update(dt) {
                if (this.dead) return;
                
                const dxToPlayer = player.x - this.x;
                const dyToPlayer = player.y - this.y;
                const distToPlayer = Math.hypot(dxToPlayer, dyToPlayer);
                
                const dxToPot = this.guardX - this.x;
                const dyToPot = this.guardY - this.y;
                const distToPot = Math.hypot(dxToPot, dyToPot);
                
                const playerDistToPot = Math.hypot(player.x - this.guardX, player.y - this.guardY);
                
                // Behavior: Stay between player and pot, push player away
                if (playerDistToPot < this.aggroRange) {
                    // Player is close to pot - intercept!
                    // Move toward player to push them away
                    if (distToPlayer > this.radius + player.radius + 10) {
                        this.x += (dxToPlayer / distToPlayer) * this.speed * 1.5;
                        this.y += (dyToPlayer / distToPlayer) * this.speed * 1.5;
                    }
                } else if (distToPot > 50) {
                    // Return to guarding position near pot
                    this.x += (dxToPot / distToPot) * this.speed * 0.8;
                    this.y += (dyToPot / distToPot) * this.speed * 0.8;
                }
                
                // Clamp to world
                this.x = Math.max(30, Math.min(WORLD.width - 30, this.x));
                this.y = Math.max(30, Math.min(WORLD.height - 30, this.y));
                
                // Knockback attack when player gets close
                if (this.knockbackCooldown <= 0 && distToPlayer < this.knockbackRange) {
                    this.performKnockback();
                    this.knockbackCooldown = 2000; // 2 second cooldown
                }
                
                // Collision damage
                if (distToPlayer < this.radius + player.radius) {
                    player.takeDamage(15);
                }
                
                if (this.knockbackCooldown > 0) this.knockbackCooldown -= dt;
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }
            
            performKnockback() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    // Push player away
                    const knockbackForce = 120;
                    player.x += (dx / dist) * knockbackForce;
                    player.y += (dy / dist) * knockbackForce;
                    
                    // Clamp player to world
                    player.x = Math.max(player.radius, Math.min(WORLD.width - player.radius, player.x));
                    player.y = Math.max(player.radius, Math.min(WORLD.height - player.radius, player.y));
                    
                    // Visual effect
                    spawnParticles(this.x, this.y, COLORS.gold, 15);
                    spawnParticles(player.x, player.y, '#ffffff', 8);
                    
                    // Small damage
                    player.takeDamage(10);
                }
            }

            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                spawnParticles(this.x, this.y, COLORS.green, 5);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                if (this.dead) return;
                this.dead = true;
                kills++;
                DOM.killCount.textContent = kills;
                
                // Burst of particles (no reward - pot gives reward)
                spawnParticles(this.x, this.y, COLORS.green, 20);
                spawnParticles(this.x, this.y, COLORS.gold, 10);
                
                // Drop some gold
                playerGold += 25;
                updateGoldDisplay();
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const bob = Math.sin(Date.now() * 0.005 + this.bobOffset) * camera.scale(2);
                
                ctx.save();
                
                // Knockback charge indicator
                if (this.knockbackCooldown <= 0) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff6600';
                } else {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = COLORS.green;
                }
                
                // Body (green circle)
                ctx.fillStyle = COLORS.green;
                ctx.beginPath();
                ctx.arc(sx, sy + bob, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Hat (gold triangle on top)
                ctx.fillStyle = COLORS.gold;
                ctx.shadowColor = COLORS.gold;
                ctx.beginPath();
                ctx.moveTo(sx, sy + bob - r - camera.scale(10));
                ctx.lineTo(sx - camera.scale(10), sy + bob - r + camera.scale(2));
                ctx.lineTo(sx + camera.scale(10), sy + bob - r + camera.scale(2));
                ctx.closePath();
                ctx.fill();
                
                // Hat brim
                ctx.fillRect(sx - camera.scale(12), sy + bob - r + camera.scale(1), camera.scale(24), camera.scale(4));
                
                // Angry eyes (white with red pupils when ready to knockback)
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(sx - camera.scale(5), sy + bob - camera.scale(2), camera.scale(3), 0, Math.PI * 2);
                ctx.arc(sx + camera.scale(5), sy + bob - camera.scale(2), camera.scale(3), 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = this.knockbackCooldown <= 0 ? '#ff0000' : '#000';
                ctx.beginPath();
                ctx.arc(sx - camera.scale(5), sy + bob - camera.scale(2), camera.scale(1.5), 0, Math.PI * 2);
                ctx.arc(sx + camera.scale(5), sy + bob - camera.scale(2), camera.scale(1.5), 0, Math.PI * 2);
                ctx.fill();
                
                // Frown
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy + bob + camera.scale(5), camera.scale(4), 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();
                
                // HP bar
                if (this.hp < this.maxHp) {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(sx - camera.scale(20), sy - r - camera.scale(18) + bob, camera.scale(40), camera.scale(5));
                    ctx.fillStyle = COLORS.green;
                    ctx.fillRect(sx - camera.scale(20), sy - r - camera.scale(18) + bob, camera.scale(40) * (this.hp / this.maxHp), camera.scale(5));
                }
                
                ctx.restore();
            }
        }

        // ===== RAINBOW/POT OF GOLD CLASS =====
        class Rainbow {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.potRadius = 25; // Interaction radius
                this.spawnTime = Date.now();
                this.fadeOutStart = 0;
                this.fading = false;
                this.dead = false;
                this.claimed = false; // Whether reward has been claimed
                this.linkedLeprechaun = null;
            }

            startFadeOut() {
                this.fading = true;
                this.fadeOutStart = Date.now();
            }

            update() {
                if (this.fading) {
                    if (Date.now() - this.fadeOutStart > 2000) {
                        this.dead = true;
                    }
                    return;
                }
                
                if (this.claimed) return;
                
                // Check if player touches the pot
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < this.potRadius + player.radius) {
                    this.claimReward();
                }
            }
            
            claimReward() {
                if (this.claimed) return;
                this.claimed = true;
                
                // Visual celebration
                spawnParticles(this.x, this.y, COLORS.gold, 30);
                spawnParticles(this.x, this.y, '#ffffff', 20);
                
                // Give 50 gold
                playerGold += 50;
                updateGoldDisplay();
                
                // Show pot reward sequence (3 chest offers)
                showPotOfGoldReward();
                
                // Start fading out
                this.startFadeOut();
            }

            draw() {
                if (!camera.isVisible(this.x, this.y, 300)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                
                // Calculate opacity
                let alpha = 1;
                if (this.fading) {
                    alpha = 1 - (Date.now() - this.fadeOutStart) / 2000;
                } else {
                    // Fade in
                    alpha = Math.min(1, (Date.now() - this.spawnTime) / 500);
                }
                
                ctx.save();
                ctx.globalAlpha = alpha * 0.7;
                
                // Pot of gold at bottom
                const potX = sx;
                const potY = sy;
                
                // Pulsing glow when unclaimed
                const pulseGlow = this.claimed ? 10 : 15 + Math.sin(Date.now() * 0.005) * 10;
                ctx.shadowBlur = pulseGlow;
                ctx.shadowColor = COLORS.gold;
                
                // Pot (dark)
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(potX, potY, camera.scale(22), camera.scale(14), 0, 0, Math.PI);
                ctx.fill();
                ctx.fillRect(potX - camera.scale(18), potY - camera.scale(10), camera.scale(36), camera.scale(10));
                
                // Gold coins on top (more coins, bigger)
                ctx.fillStyle = this.claimed ? '#888' : COLORS.gold;
                ctx.beginPath();
                ctx.arc(potX - camera.scale(8), potY - camera.scale(12), camera.scale(6), 0, Math.PI * 2);
                ctx.arc(potX + camera.scale(8), potY - camera.scale(12), camera.scale(6), 0, Math.PI * 2);
                ctx.arc(potX, potY - camera.scale(16), camera.scale(6), 0, Math.PI * 2);
                ctx.arc(potX - camera.scale(4), potY - camera.scale(20), camera.scale(5), 0, Math.PI * 2);
                ctx.arc(potX + camera.scale(4), potY - camera.scale(20), camera.scale(5), 0, Math.PI * 2);
                ctx.fill();
                
                // "LOOT" indicator if unclaimed
                if (!this.claimed && !this.fading) {
                    ctx.fillStyle = COLORS.gold;
                    ctx.font = `bold ${camera.scale(12)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10;
                    ctx.fillText('‚ú® LOOT ‚ú®', potX, potY - camera.scale(35));
                }
                
                // Vertical rainbow beam shooting up from pot
                if (!this.claimed) {
                    const rainbowColors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff', '#8800ff'];
                    const beamHeight = camera.scale(150);
                    const bandWidth = camera.scale(5);
                    const totalWidth = bandWidth * rainbowColors.length;
                    
                    // Shimmer effect
                    const shimmer = Math.sin(Date.now() * 0.003) * 0.15 + 0.85;
                    ctx.globalAlpha = alpha * 0.6 * shimmer;
                    
                    for (let i = 0; i < rainbowColors.length; i++) {
                        const bandX = potX - totalWidth / 2 + i * bandWidth + bandWidth / 2;
                        
                        // Create gradient for each band
                        const grad = ctx.createLinearGradient(bandX, potY - camera.scale(20), bandX, potY - beamHeight);
                        grad.addColorStop(0, rainbowColors[i]);
                        grad.addColorStop(0.7, rainbowColors[i]);
                        grad.addColorStop(1, 'transparent');
                        
                        ctx.strokeStyle = grad;
                        ctx.lineWidth = bandWidth;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = rainbowColors[i];
                        ctx.beginPath();
                        ctx.moveTo(bandX, potY - camera.scale(20));
                        ctx.lineTo(bandX, potY - beamHeight);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
        }
        
        // Pot of Gold reward system - 3 chest offers in a row
        let potRewardQueue = [];
        let potRewardIndex = 0;
        
        function showPotOfGoldReward() {
            gamePaused = true;
            potRewardQueue = [];
            potRewardIndex = 0;
            
            // Generate 3 rewards with higher legendary chance (8% base)
            for (let i = 0; i < 3; i++) {
                let legendaryChance = 0.08 + (gameTime / 60) * 0.01;
                legendaryChance = Math.min(legendaryChance, 0.25);
                
                if (guaranteedLegendaryNext && legendaryCount < MAX_LEGENDARIES) {
                    legendaryChance = 1.0;
                }
                if (legendaryCount >= MAX_LEGENDARIES) {
                    legendaryChance = 0;
                }
                
                if (Math.random() < legendaryChance) {
                    const legendaryKeys = Object.keys(LEGENDARY_UPGRADES);
                    const randomKey = legendaryKeys[Math.floor(Math.random() * legendaryKeys.length)];
                    const legendary = LEGENDARY_UPGRADES[randomKey];
                    potRewardQueue.push({ 
                        type: 'legendary', 
                        id: randomKey,
                        icon: legendary.icon, 
                        name: '‚≠ê ' + legendary.name + ' ‚≠ê', 
                        desc: legendary.desc,
                        color: legendary.color 
                    });
                } else {
                    const powerupIds = Object.keys(SHRINE_POWERUPS);
                    const randomId = powerupIds[Math.floor(Math.random() * powerupIds.length)];
                    const powerup = SHRINE_POWERUPS[randomId];
                    potRewardQueue.push({ 
                        type: 'shrine', 
                        id: randomId,
                        icon: powerup.icon,
                        name: powerup.name,
                        desc: powerup.desc,
                        color: powerup.color
                    });
                }
            }
            
            showNextPotReward();
        }
        
        function showNextPotReward() {
            if (potRewardIndex >= potRewardQueue.length) {
                // All rewards claimed
                gamePaused = false;
                return;
            }
            
            const reward = potRewardQueue[potRewardIndex];
            
            // Reuse chest overlay
            DOM.chestTitle.textContent = `üçÄ POT OF GOLD (${potRewardIndex + 1}/3) üçÄ`;
            DOM.chestTitle.className = 'chest-title';
            DOM.chestCost.textContent = 'FREE REWARD!';
            DOM.chestCost.style.color = '#00ff00';
            
            DOM.chestCard.className = 'chest-card';
            DOM.chestCard.style.borderColor = reward.color || COLORS.gold;
            
            DOM.chestIcon.textContent = reward.icon;
            DOM.chestName.textContent = reward.name;
            DOM.chestName.style.color = reward.color || COLORS.gold;
            DOM.chestValue.textContent = reward.desc;
            
            DOM.chestAccept.disabled = false;
            DOM.chestAccept.textContent = potRewardIndex < 2 ? 'TAKE & NEXT' : 'TAKE';
            
            // Hide skip button for pot rewards (forced accept)
            DOM.chestSkip.style.display = 'none';
            
            DOM.chestOverlay.classList.add('active');
            
            // Override accept behavior for pot rewards
            pendingChest = { isPotReward: true, reward: reward };
        }
        
        function acceptPotReward() {
            const reward = potRewardQueue[potRewardIndex];
            
            if (reward.type === 'legendary') {
                legendaryCount++;
                lastLegendaryTime = gameTime;
                guaranteedLegendaryNext = false;
                DOM.chestOverlay.classList.remove('active');
                showLegendaryUpgrade();
                // After legendary selection, continue pot rewards
                // This is handled by the legendary selection callback
            } else {
                const powerup = SHRINE_POWERUPS[reward.id];
                player.addShrineBonus(powerup.stat, powerup.value);
                updateBuffsBar();
                
                potRewardIndex++;
                DOM.chestOverlay.classList.remove('active');
                
                // Small delay before next reward
                setTimeout(() => {
                    showNextPotReward();
                }, 300);
            }
        }

        // ===== GHOST CLASS (Vengeful Spirits) =====
        class Ghost {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.speed = 5;
                this.damage = 25 + player.level * 5;
                this.dead = false;
                this.alpha = 0.8;
                this.target = null;
                this.lifetime = 5000; // 5 seconds max
                this.spawnTime = Date.now();
                
                // Find nearest enemy
                this.acquireTarget();
            }
            
            acquireTarget() {
                let nearest = null;
                let minDist = Infinity;
                
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                }
                
                this.target = nearest;
            }
            
            update(dt) {
                if (this.dead) return;
                
                // Check lifetime
                if (Date.now() - this.spawnTime > this.lifetime) {
                    this.dead = true;
                    spawnParticles(this.x, this.y, '#aaccff', 8);
                    return;
                }
                
                // Re-acquire target if current is dead
                if (!this.target || this.target.dead) {
                    this.acquireTarget();
                }
                
                // Move toward target
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 0) {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                    
                    // Collision - kamikaze!
                    if (dist < this.radius + this.target.radius) {
                        this.target.takeDamage(this.damage, false);
                        spawnParticles(this.x, this.y, '#aaccff', 15);
                        spawnParticles(this.x, this.y, '#ffffff', 10);
                        this.dead = true;
                    }
                } else {
                    // No target - fade out
                    this.alpha -= 0.02;
                    if (this.alpha <= 0) {
                        this.dead = true;
                    }
                }
            }
            
            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                ctx.globalAlpha = this.alpha * (0.7 + Math.sin(Date.now() * 0.01) * 0.3);
                
                // Ghost body (translucent circle with wispy effect)
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#aaccff';
                
                // Wispy trail
                const trail = Math.sin(Date.now() * 0.008) * camera.scale(3);
                ctx.fillStyle = 'rgba(170, 204, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(sx, sy + trail, r * 1.2, r * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Main body
                ctx.fillStyle = '#aaccff';
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.8, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(sx - camera.scale(3), sy - camera.scale(2), camera.scale(2), 0, Math.PI * 2);
                ctx.arc(sx + camera.scale(3), sy - camera.scale(2), camera.scale(2), 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // ===== MINI BOSS CLASS =====
        class MiniBoss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 35;
                this.speed = 1.2;
                this.maxHp = 800 + bossCount * 200;
                this.hp = this.maxHp;
                this.color = '#ff6600';
                this.dead = false;
                this.orbHitCooldown = 0;
                this.attackCooldown = 0;
                this.isBoss = true;
                this.bossType = 'mini';
            }
            
            update(dt) {
                if (this.dead) return;
                
                // Chase player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                
                // Clamp to world
                this.x = Math.max(this.radius, Math.min(WORLD.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD.height - this.radius, this.y));
                
                // Collision damage
                if (dist < this.radius + player.radius) {
                    player.takeDamage(25);
                }
                
                // Spawn minions periodically
                if (this.attackCooldown <= 0) {
                    this.spawnMinions();
                    this.attackCooldown = 5000; // Every 5 seconds
                }
                
                if (this.attackCooldown > 0) this.attackCooldown -= dt;
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }
            
            spawnMinions() {
                // Spawn 3-5 swarm enemies around boss
                const count = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const spawnX = this.x + Math.cos(angle) * 60;
                    const spawnY = this.y + Math.sin(angle) * 60;
                    enemies.push(new Enemy('swarm', spawnX, spawnY));
                }
                spawnParticles(this.x, this.y, this.color, 15);
            }
            
            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }
            
            die() {
                if (this.dead) return;
                this.dead = true;
                kills += 10;
                DOM.killCount.textContent = kills;
                
                // Big explosion
                spawnParticles(this.x, this.y, this.color, 40);
                spawnParticles(this.x, this.y, '#ffffff', 25);
                spawnParticles(this.x, this.y, COLORS.gold, 20);
                
                // Drop lots of gold and XP
                playerGold += 100;
                updateGoldDisplay();
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const gemX = this.x + Math.cos(angle) * 30;
                    const gemY = this.y + Math.sin(angle) * 30;
                    xpGems.push(new XPGem(gemX, gemY, 15));
                }
                
                showBossDefeatMessage('MINI BOSS');
            }
            
            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                
                // Pulsing glow
                const pulse = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                ctx.shadowBlur = 30 * pulse;
                ctx.shadowColor = this.color;
                
                // Main body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner ring
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.7, 0, Math.PI * 2);
                ctx.stroke();
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(sx - r * 0.3, sy - r * 0.1, r * 0.15, 0, Math.PI * 2);
                ctx.arc(sx + r * 0.3, sy - r * 0.1, r * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                // Red pupils
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(sx - r * 0.3, sy - r * 0.1, r * 0.08, 0, Math.PI * 2);
                ctx.arc(sx + r * 0.3, sy - r * 0.1, r * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                // HP bar
                ctx.shadowBlur = 0;
                const barWidth = r * 2;
                ctx.fillStyle = '#333';
                ctx.fillRect(sx - barWidth/2, sy - r - 20, barWidth, 8);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(sx - barWidth/2, sy - r - 20, barWidth * (this.hp / this.maxHp), 8);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(sx - barWidth/2, sy - r - 20, barWidth, 8);
                
                // "MINI BOSS" label
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${camera.scale(10)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('MINI BOSS', sx, sy - r - 25);
                
                ctx.restore();
            }
        }
        
        // ===== MAJOR BOSS CLASS =====
        class MajorBoss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 55;
                this.speed = 0.8;
                this.maxHp = 2500 + bossCount * 500;
                this.hp = this.maxHp;
                this.color = '#ff00ff';
                this.dead = false;
                this.orbHitCooldown = 0;
                this.attackCooldown = 0;
                this.chargeTimer = 0;
                this.isCharging = false;
                this.chargeTarget = { x: 0, y: 0 };
                this.isBoss = true;
                this.bossType = 'major';
                this.phase = 1; // Phases at 66% and 33% HP
            }
            
            update(dt) {
                if (this.dead) return;
                
                // Phase transitions
                const hpPercent = this.hp / this.maxHp;
                if (hpPercent <= 0.33 && this.phase < 3) {
                    this.phase = 3;
                    this.speed = 1.4;
                    spawnParticles(this.x, this.y, '#ff0000', 30);
                    showBossPhaseWarning('ENRAGED!');
                } else if (hpPercent <= 0.66 && this.phase < 2) {
                    this.phase = 2;
                    this.speed = 1.1;
                    spawnParticles(this.x, this.y, '#ffaa00', 20);
                    showBossPhaseWarning('PHASE 2');
                }
                
                // Charge attack
                if (this.isCharging) {
                    const dx = this.chargeTarget.x - this.x;
                    const dy = this.chargeTarget.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 20) {
                        this.x += (dx / dist) * 8;
                        this.y += (dy / dist) * 8;
                    } else {
                        this.isCharging = false;
                        // Shockwave on landing
                        spawnParticles(this.x, this.y, this.color, 25);
                        // Damage player if close
                        const playerDist = Math.hypot(player.x - this.x, player.y - this.y);
                        if (playerDist < 100) {
                            player.takeDamage(40);
                            // Knockback
                            const kbDx = player.x - this.x;
                            const kbDy = player.y - this.y;
                            const kbDist = Math.hypot(kbDx, kbDy);
                            if (kbDist > 0) {
                                player.x += (kbDx / kbDist) * 80;
                                player.y += (kbDy / kbDist) * 80;
                            }
                        }
                    }
                } else {
                    // Normal chase
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 0) {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                }
                
                // Clamp to world
                this.x = Math.max(this.radius, Math.min(WORLD.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD.height - this.radius, this.y));
                
                // Collision damage
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < this.radius + player.radius) {
                    player.takeDamage(35);
                }
                
                // Attack patterns
                if (this.attackCooldown <= 0 && !this.isCharging) {
                    const attack = Math.random();
                    if (attack < 0.3) {
                        // Charge attack
                        this.isCharging = true;
                        this.chargeTarget = { x: player.x, y: player.y };
                        spawnParticles(this.x, this.y, '#ff0000', 15);
                    } else if (attack < 0.6) {
                        // Spawn minions
                        this.spawnMinions();
                    } else {
                        // Ring of projectiles
                        this.fireRing();
                    }
                    this.attackCooldown = this.phase === 3 ? 2500 : (this.phase === 2 ? 3500 : 4500);
                }
                
                if (this.attackCooldown > 0) this.attackCooldown -= dt;
                if (this.orbHitCooldown > 0) this.orbHitCooldown -= dt;
            }
            
            spawnMinions() {
                const count = 4 + this.phase * 2;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const spawnX = this.x + Math.cos(angle) * 80;
                    const spawnY = this.y + Math.sin(angle) * 80;
                    const type = Math.random() < 0.3 ? 'fast' : 'swarm';
                    enemies.push(new Enemy(type, spawnX, spawnY));
                }
                spawnParticles(this.x, this.y, COLORS.green, 20);
            }
            
            fireRing() {
                // Fire projectiles in a ring (visual effect - damages on contact)
                const count = 8 + this.phase * 4;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    // Create enemy projectile (use basic enemy that dies fast)
                    const projX = this.x + Math.cos(angle) * 40;
                    const projY = this.y + Math.sin(angle) * 40;
                    const proj = new Enemy('swarm', projX, projY);
                    proj.hp = 1;
                    proj.speed = 4;
                    // Override movement to go in straight line
                    proj.fixedAngle = angle;
                    enemies.push(proj);
                }
                spawnParticles(this.x, this.y, this.color, 20);
            }
            
            takeDamage(amount, isCrit = false) {
                this.hp -= amount;
                spawnDamageNumber(this.x, this.y, Math.round(amount), isCrit);
                
                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }
            
            die() {
                if (this.dead) return;
                this.dead = true;
                kills += 25;
                DOM.killCount.textContent = kills;
                
                // Massive explosion
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const ox = (Math.random() - 0.5) * 60;
                        const oy = (Math.random() - 0.5) * 60;
                        spawnParticles(this.x + ox, this.y + oy, this.color, 30);
                        spawnParticles(this.x + ox, this.y + oy, '#ffffff', 20);
                    }, i * 100);
                }
                spawnParticles(this.x, this.y, COLORS.gold, 40);
                
                // Drop lots of gold and XP
                playerGold += 250;
                updateGoldDisplay();
                
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const dist = 30 + Math.random() * 40;
                    const gemX = this.x + Math.cos(angle) * dist;
                    const gemY = this.y + Math.sin(angle) * dist;
                    xpGems.push(new XPGem(gemX, gemY, 20));
                }
                
                showBossDefeatMessage('BOSS');
            }
            
            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                
                // Intense pulsing glow (faster in higher phases)
                const pulseSpeed = 0.003 + this.phase * 0.002;
                const pulse = 0.7 + Math.sin(Date.now() * pulseSpeed) * 0.3;
                ctx.shadowBlur = 40 * pulse;
                ctx.shadowColor = this.phase === 3 ? '#ff0000' : this.color;
                
                // Main body
                const bodyColor = this.phase === 3 ? '#ff0044' : (this.phase === 2 ? '#ff44aa' : this.color);
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner rings
                ctx.strokeStyle = '#ffaaff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.75, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Core
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffffff';
                ctx.beginPath();
                ctx.arc(sx, sy, r * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes (menacing)
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(sx - r * 0.35, sy - r * 0.15, r * 0.12, 0, Math.PI * 2);
                ctx.arc(sx + r * 0.35, sy - r * 0.15, r * 0.12, 0, Math.PI * 2);
                ctx.fill();
                
                // Glowing pupils
                ctx.fillStyle = this.phase === 3 ? '#ff0000' : '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                ctx.arc(sx - r * 0.35, sy - r * 0.15, r * 0.06, 0, Math.PI * 2);
                ctx.arc(sx + r * 0.35, sy - r * 0.15, r * 0.06, 0, Math.PI * 2);
                ctx.fill();
                
                // HP bar
                ctx.shadowBlur = 0;
                const barWidth = r * 2.5;
                ctx.fillStyle = '#333';
                ctx.fillRect(sx - barWidth/2, sy - r - 25, barWidth, 10);
                
                // HP bar color based on phase
                const hpColor = this.phase === 3 ? '#ff0000' : (this.phase === 2 ? '#ffaa00' : '#00ff00');
                ctx.fillStyle = hpColor;
                ctx.fillRect(sx - barWidth/2, sy - r - 25, barWidth * (this.hp / this.maxHp), 10);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx - barWidth/2, sy - r - 25, barWidth, 10);
                
                // "BOSS" label
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${camera.scale(14)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillText('‚òÖ BOSS ‚òÖ', sx, sy - r - 32);
                
                ctx.restore();
            }
        }
        
        // Boss defeat message
        function showBossDefeatMessage(type) {
            const msg = document.createElement('div');
            msg.innerHTML = `<div style="font-size: 32px;">üíÄ ${type} DEFEATED! üíÄ</div>`;
            msg.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${COLORS.gold};
                text-shadow: 0 0 30px ${COLORS.gold}, 0 0 60px #ff00ff;
                z-index: 9999;
                pointer-events: none;
                animation: bossDefeat 2s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossDefeat {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    80% { opacity: 1; }
                    100% { opacity: 0; transform: translate(-50%, -80%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 2000);
        }
        
        // Boss phase warning
        function showBossPhaseWarning(text) {
            const msg = document.createElement('div');
            msg.innerHTML = `<div style="font-size: 26px;">‚ö†Ô∏è ${text} ‚ö†Ô∏è</div>`;
            msg.style.cssText = `
                position: fixed;
                top: 40%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #ff4444;
                text-shadow: 0 0 20px #ff0000;
                z-index: 9999;
                pointer-events: none;
                animation: phaseWarn 1.5s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes phaseWarn {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    70% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 1500);
        }

        // ===== TREASURE CHEST CLASS =====
        class TreasureChest {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 18;
                this.opened = false;
                this.dead = false;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.glowPulse = Math.random() * Math.PI * 2;
                
                // 10% chance to be free (gold), 90% costs gold (silver)
                this.isFree = Math.random() < 0.10;
                this.cost = this.isFree ? 0 : nextChestCost;
                
                // Pre-roll contents
                this.contents = this.rollContents();
            }
            
            update(dt) {
                if (this.opened || this.dead) return;
                
                // Check if player is touching
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < this.radius + player.radius) {
                    this.showOffer();
                }
            }
            
            showOffer() {
                if (this.opened) return;
                this.opened = true;
                gamePaused = true;
                pendingChest = this;
                
                const color = this.isFree ? COLORS.gold : '#c0c0c0';
                spawnParticles(this.x, this.y, color, 15);
                
                // Set up overlay
                DOM.chestTitle.textContent = this.isFree ? 'üì¶ FREE TREASURE! üì¶' : 'üì¶ TREASURE FOUND! üì¶';
                DOM.chestTitle.className = 'chest-title' + (this.isFree ? '' : ' silver');
                
                if (this.isFree) {
                    DOM.chestCost.textContent = 'FREE!';
                    DOM.chestCost.style.color = '#00ff00';
                } else {
                    DOM.chestCost.innerHTML = `Cost: ü™ô ${this.cost} <span style="color: #888;">(You have: ${playerGold})</span>`;
                    DOM.chestCost.style.color = '#ffd700';
                }
                
                DOM.chestCard.className = 'chest-card' + (this.isFree ? '' : ' silver');
                DOM.chestCard.style.borderColor = this.contents.color || color;
                
                DOM.chestIcon.textContent = this.contents.icon;
                DOM.chestName.textContent = this.contents.name;
                DOM.chestName.style.color = this.contents.color || color;
                DOM.chestValue.textContent = this.contents.desc;
                
                // Update accept button
                const canAfford = this.isFree || playerGold >= this.cost;
                DOM.chestAccept.disabled = !canAfford;
                DOM.chestAccept.textContent = this.isFree ? 'TAKE' : (canAfford ? `BUY (${this.cost})` : 'NOT ENOUGH GOLD');
                
                // Ensure skip/leave button is visible for regular chests
                DOM.chestSkip.style.display = '';
                
                DOM.chestOverlay.classList.add('active');
            }
            
            rollContents() {
                // Calculate legendary chance
                let legendaryChance = 0.02 + (gameTime / 60) * 0.005;
                legendaryChance = Math.min(legendaryChance, 0.15);
                
                // Bad luck protection
                if (guaranteedLegendaryNext && legendaryCount < MAX_LEGENDARIES) {
                    legendaryChance = 1.0;
                }
                
                // Good luck protection
                if (legendaryCount >= MAX_LEGENDARIES) {
                    legendaryChance = 0;
                }
                
                if (Math.random() < legendaryChance) {
                    // Pick a random legendary for preview
                    const legendaryKeys = Object.keys(LEGENDARY_UPGRADES);
                    const randomKey = legendaryKeys[Math.floor(Math.random() * legendaryKeys.length)];
                    const legendary = LEGENDARY_UPGRADES[randomKey];
                    return { 
                        type: 'legendary', 
                        id: randomKey,
                        icon: legendary.icon, 
                        name: '‚≠ê ' + legendary.name + ' ‚≠ê', 
                        desc: legendary.desc,
                        color: legendary.color 
                    };
                } else {
                    // Random shrine powerup
                    const powerupIds = Object.keys(SHRINE_POWERUPS);
                    const randomId = powerupIds[Math.floor(Math.random() * powerupIds.length)];
                    const powerup = SHRINE_POWERUPS[randomId];
                    return { 
                        type: 'shrine', 
                        id: randomId,
                        icon: powerup.icon,
                        name: powerup.name,
                        desc: powerup.desc,
                        color: powerup.color
                    };
                }
            }
            
            draw() {
                if (this.opened || !camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const bob = Math.sin(Date.now() * 0.003 + this.bobOffset) * camera.scale(2);
                const glow = 0.6 + Math.sin(Date.now() * 0.004 + this.glowPulse) * 0.3;
                
                // Color based on free/paid
                const trimColor = this.isFree ? COLORS.gold : '#c0c0c0';
                const glowColor = this.isFree ? COLORS.gold : '#a0a0a0';
                
                ctx.save();
                
                // Glow effect
                ctx.shadowBlur = 20 * glow;
                ctx.shadowColor = glowColor;
                
                // Chest base (brown rectangle)
                const w = camera.scale(24);
                const h = camera.scale(16);
                ctx.fillStyle = this.isFree ? '#8B4513' : '#4a4a4a';
                ctx.fillRect(sx - w/2, sy - h/2 + bob, w, h);
                
                // Chest lid
                ctx.fillStyle = this.isFree ? '#A0522D' : '#606060';
                ctx.fillRect(sx - w/2, sy - h/2 + bob - camera.scale(4), w, camera.scale(6));
                
                // Trim
                ctx.strokeStyle = trimColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(sx - w/2, sy - h/2 + bob - camera.scale(4), w, h + camera.scale(4));
                
                // Lock/clasp
                ctx.fillStyle = trimColor;
                ctx.beginPath();
                ctx.arc(sx, sy + bob, camera.scale(4), 0, Math.PI * 2);
                ctx.fill();
                
                // Cost indicator above silver chests
                if (!this.isFree) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `${camera.scale(10)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`ü™ô${this.cost}`, sx, sy - h/2 + bob - camera.scale(12));
                }
                
                // Sparkle particles
                if (Math.random() < 0.05) {
                    const sparkleX = this.x + (Math.random() - 0.5) * 30;
                    const sparkleY = this.y + (Math.random() - 0.5) * 20;
                    spawnParticles(sparkleX, sparkleY, trimColor, 1);
                }
                
                ctx.restore();
            }
        }
        
        // Accept chest offer
        function acceptChestOffer() {
            if (!pendingChest) return;
            
            // Handle pot of gold rewards differently
            if (pendingChest.isPotReward) {
                acceptPotReward();
                return;
            }
            
            const chest = pendingChest;
            
            // Deduct gold if not free
            if (!chest.isFree) {
                if (playerGold < chest.cost) return;
                playerGold -= chest.cost;
                updateGoldDisplay();
                nextChestCost *= 2; // Double cost for next paid chest
            }
            
            // Apply contents
            if (chest.contents.type === 'legendary') {
                legendaryCount++;
                lastLegendaryTime = gameTime;
                guaranteedLegendaryNext = false;
                DOM.chestOverlay.classList.remove('active');
                showLegendaryUpgrade();
            } else {
                const powerup = SHRINE_POWERUPS[chest.contents.id];
                player.addShrineBonus(powerup.stat, powerup.value);
                updateBuffsBar();
                closeChestOverlay();
            }
            
            // Remove chest
            chest.dead = true;
            pendingChest = null;
        }
        
        // Skip chest offer
        function skipChestOffer() {
            if (!pendingChest) return;
            
            // Can't skip pot rewards
            if (pendingChest.isPotReward) return;
            
            // Don't destroy chest - let player come back later
            pendingChest.opened = false; // Reset so player can interact again
            pendingChest = null;
            closeChestOverlay();
        }
        
        function closeChestOverlay() {
            DOM.chestOverlay.classList.remove('active');
            DOM.chestSkip.style.display = ''; // Restore skip button
            gamePaused = false;
        }

        // Show chest reward notification
        function showChestReward(powerup) {
            const notification = document.createElement('div');
            notification.innerHTML = `<div style="font-size: 22px;">${powerup.icon} ${powerup.name}!</div><div style="font-size: 14px; opacity: 0.8;">${powerup.desc}</div>`;
            notification.style.cssText = `
                position: fixed;
                top: 40%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${powerup.color};
                text-shadow: 0 0 20px ${powerup.color};
                text-align: center;
                z-index: 9999;
                pointer-events: none;
                animation: chestReward 1.5s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes chestReward {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    80% { opacity: 1; }
                    100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), 1500);
        }

        // Show legendary from chest
        function showChestLegendary() {
            legendaryCount++;
            lastLegendaryTime = gameTime;
            guaranteedLegendaryNext = false;
            showLegendaryUpgrade();
        }

        // Spawn chests around the map
        function spawnInitialChests() {
            const chestCount = 15 + Math.floor(Math.random() * 6); // 15-20 chests
            
            for (let i = 0; i < chestCount; i++) {
                const pos = getValidSpawnPosition(100, WORLD.width - 100, 100, WORLD.height - 100, 50, 300);
                chests.push(new TreasureChest(pos.x, pos.y));
            }
        }

        // Respawn chests over time
        let chestRespawnTimer = 0;
        const CHEST_RESPAWN_INTERVAL = 45000; // New chest every 45 seconds

        function updateChestSpawning(dt) {
            chestRespawnTimer += dt;
            
            if (chestRespawnTimer >= CHEST_RESPAWN_INTERVAL) {
                chestRespawnTimer = 0;
                
                // Spawn new chest away from player, avoiding terrain
                const pos = getValidSpawnPosition(100, WORLD.width - 100, 100, WORLD.height - 100, 50, 0);
                
                // Make sure it's not too close to player
                if (Math.hypot(pos.x - player.x, pos.y - player.y) > 300) {
                    chests.push(new TreasureChest(pos.x, pos.y));
                }
            }
            
            // Bad luck protection check
            if (gameTime >= 600 && legendaryCount === 0 && !guaranteedLegendaryNext) {
                guaranteedLegendaryNext = true;
            }
        }

        // ===== TERRAIN OBSTACLES (Lakes & Mountains) =====
        let terrainObstacles = [];
        let decorations = []; // Trees only
        
        // Map area: 4320 x 4320 = 18,662,400 sq units
        // Large lake: 2-3% = 373,248 - 559,872 sq units each (radius ~345-422)
        // Mountain range: 3-4% = 559,872 - 746,496 sq units each (radius ~422-487)
        
        const TERRAIN_TYPES = {
            lake: {
                draw: function(ctx, sx, sy, scale, time, obstacle) {
                    const pulse = 0.4 + Math.sin(time * 0.001 + obstacle.variant) * 0.15;
                    const colors = ['#00ffff', '#0088ff'];
                    const color = colors[obstacle.variant % colors.length];
                    const radiusX = scale(obstacle.radiusX);
                    const radiusY = scale(obstacle.radiusY);
                    
                    ctx.save();
                    ctx.globalAlpha = pulse * 0.4;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = color;
                    ctx.fillStyle = color;
                    
                    // Lake body (ellipse)
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX, radiusY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner glow rings
                    ctx.globalAlpha = pulse * 0.5;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX * 0.7, radiusY * 0.7, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.globalAlpha = pulse * 0.3;
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX * 0.4, radiusY * 0.4, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Ripple effect
                    const ripple = ((time * 0.0006 + obstacle.variant) % 2) / 2;
                    ctx.globalAlpha = (1 - ripple) * 0.3;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, radiusX * ripple, radiusY * ripple, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            },
            tree: {
                draw: function(ctx, sx, sy, scale, time, obstacle) {
                    const colors = ['#00ffaa', '#00ff66', '#88ff00'];
                    const color = colors[obstacle.variant % colors.length];
                    const sway = Math.sin(time * 0.001 + obstacle.variant) * scale(2);
                    const height = scale(60 + (obstacle.variant % 3) * 20);
                    const radius = scale(obstacle.radius);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.45;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = color;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    
                    // Trunk
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + sway * 0.3, sy - height * 0.6);
                    ctx.stroke();
                    
                    // Main branches (triangular canopy made of lines)
                    const levels = 3;
                    for (let i = 0; i < levels; i++) {
                        const levelY = sy - height * 0.3 - i * height * 0.25;
                        const spread = scale(25 - i * 5);
                        const levelSway = sway * (1 + i * 0.3);
                        
                        ctx.beginPath();
                        ctx.moveTo(sx + levelSway - spread, levelY + scale(15));
                        ctx.lineTo(sx + levelSway, levelY - scale(10));
                        ctx.lineTo(sx + levelSway + spread, levelY + scale(15));
                        ctx.stroke();
                        
                        // Horizontal line at base
                        ctx.beginPath();
                        ctx.moveTo(sx + levelSway - spread, levelY + scale(15));
                        ctx.lineTo(sx + levelSway + spread, levelY + scale(15));
                        ctx.stroke();
                    }
                    
                    // Glowing points (data nodes)
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.7 + Math.sin(time * 0.005 + obstacle.variant) * 0.3;
                    for (let i = 0; i < 4; i++) {
                        const nodeY = sy - height * 0.4 - i * height * 0.15;
                        const nodeX = sx + sway + (Math.sin(i * 2 + obstacle.variant) * scale(15));
                        ctx.beginPath();
                        ctx.arc(nodeX, nodeY, scale(3), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }
        };
        
        // Check if a point is inside any terrain obstacle (including trees)
        function isInTerrain(x, y, padding = 0) {
            for (const obs of terrainObstacles) {
                if (obs.type === 'tree') {
                    // Trees use circular collision
                    const dist = Math.hypot(x - obs.x, y - obs.y);
                    if (dist < obs.radius + padding) {
                        return obs;
                    }
                } else {
                    // Lakes and mountains use ellipse collision
                    const dx = (x - obs.x) / (obs.radiusX + padding);
                    const dy = (y - obs.y) / (obs.radiusY + padding);
                    if (dx * dx + dy * dy < 1) {
                        return obs;
                    }
                }
            }
            return null;
        }
        
        // Get valid spawn position avoiding terrain
        function getValidSpawnPosition(minX, maxX, minY, maxY, padding = 50, avoidCenter = 0) {
            let attempts = 0;
            while (attempts < 50) {
                const x = minX + Math.random() * (maxX - minX);
                const y = minY + Math.random() * (maxY - minY);
                
                // Check center avoidance
                if (avoidCenter > 0 && Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < avoidCenter) {
                    attempts++;
                    continue;
                }
                
                // Check terrain
                if (!isInTerrain(x, y, padding)) {
                    return { x, y };
                }
                attempts++;
            }
            // Fallback - return position anyway
            return { x: minX + Math.random() * (maxX - minX), y: minY + Math.random() * (maxY - minY) };
        }
        
        function spawnTerrain() {
            terrainObstacles = [];
            
            // Minimum corridor width for player to pass (player radius is 12)
            const MIN_CORRIDOR = 120;
            
            // Helper to check if position overlaps existing terrain
            function overlapsExisting(x, y, radiusX, radiusY, padding = 50) {
                for (const obs of terrainObstacles) {
                    if (obs.type === 'tree') {
                        const dist = Math.hypot(x - obs.x, y - obs.y);
                        if (dist < Math.max(radiusX, radiusY) + obs.radius + padding) return true;
                    } else {
                        // Ellipse overlap check with padding
                        const combinedRadiusX = obs.radiusX + radiusX + padding;
                        const combinedRadiusY = obs.radiusY + radiusY + padding;
                        const dx = (x - obs.x) / combinedRadiusX;
                        const dy = (y - obs.y) / combinedRadiusY;
                        if (dx * dx + dy * dy < 1) return true;
                    }
                }
                return false;
            }
            
            // Check if obstacle blocks edge access (player must walk around perimeter)
            function blocksEdge(x, y, radiusX, radiusY) {
                const edgeBuffer = MIN_CORRIDOR + 50;
                // Check all four edges
                if (x - radiusX < edgeBuffer) return true;  // Too close to left
                if (x + radiusX > WORLD.width - edgeBuffer) return true;  // Too close to right
                if (y - radiusY < edgeBuffer) return true;  // Too close to top
                if (y + radiusY > WORLD.height - edgeBuffer) return true;  // Too close to bottom
                return false;
            }
            
            // Check if two obstacles create a blocking corridor
            function createsBlockage(x, y, radiusX, radiusY) {
                for (const obs of terrainObstacles) {
                    if (obs.type !== 'lake') continue;
                    
                    // Check horizontal gap (for vertical corridors)
                    const horizontalGap = Math.abs(x - obs.x) - radiusX - obs.radiusX;
                    const verticalOverlap = Math.abs(y - obs.y) < radiusY + obs.radiusY;
                    
                    // Check vertical gap (for horizontal corridors)
                    const verticalGap = Math.abs(y - obs.y) - radiusY - obs.radiusY;
                    const horizontalOverlap = Math.abs(x - obs.x) < radiusX + obs.radiusX;
                    
                    // If obstacles overlap in one axis and gap is too small in other
                    if (verticalOverlap && horizontalGap > 0 && horizontalGap < MIN_CORRIDOR) return true;
                    if (horizontalOverlap && verticalGap > 0 && verticalGap < MIN_CORRIDOR) return true;
                    
                    // Check if this creates a corner trap with map edge
                    // Left edge trap
                    if (x < WORLD.width * 0.3 && obs.x < WORLD.width * 0.3) {
                        if (x - radiusX < MIN_CORRIDOR * 2 || obs.x - obs.radiusX < MIN_CORRIDOR * 2) {
                            if (Math.abs(y - obs.y) < radiusY + obs.radiusY + MIN_CORRIDOR) return true;
                        }
                    }
                    // Right edge trap
                    if (x > WORLD.width * 0.7 && obs.x > WORLD.width * 0.7) {
                        if (x + radiusX > WORLD.width - MIN_CORRIDOR * 2 || obs.x + obs.radiusX > WORLD.width - MIN_CORRIDOR * 2) {
                            if (Math.abs(y - obs.y) < radiusY + obs.radiusY + MIN_CORRIDOR) return true;
                        }
                    }
                }
                return false;
            }
            
            // ===== STEP 1: Spawn 3 Lakes (spread across map, ensuring accessibility) =====
            // Smaller lakes to ensure room for corridors
            const lakeZones = [
                { minX: 0.15, maxX: 0.35, minY: 0.15, maxY: 0.35 },  // Top-left
                { minX: 0.65, maxX: 0.85, minY: 0.65, maxY: 0.85 },  // Bottom-right
                { minX: 0.65, maxX: 0.85, minY: 0.15, maxY: 0.35 }   // Top-right
            ];
            
            for (let i = 0; i < 3; i++) {
                // Slightly smaller lakes to ensure corridors
                const baseRadius = 700 + Math.random() * 200;
                const radiusX = baseRadius * (0.9 + Math.random() * 0.2);
                const radiusY = baseRadius * (0.7 + Math.random() * 0.2);
                
                let x, y, attempts = 0;
                let placed = false;
                
                const zone = lakeZones[i];
                
                do {
                    // Random position within assigned zone
                    x = WORLD.width * (zone.minX + Math.random() * (zone.maxX - zone.minX));
                    y = WORLD.height * (zone.minY + Math.random() * (zone.maxY - zone.minY));
                    
                    attempts++;
                    
                    // Check edge access is maintained
                    if (blocksEdge(x, y, radiusX, radiusY)) continue;
                    
                    // Keep away from center spawn area
                    const centerDist = Math.hypot(x - WORLD.width/2, y - WORLD.height/2);
                    if (centerDist < 500 + Math.max(radiusX, radiusY)) continue;
                    
                    // Check no overlap with existing lakes
                    if (overlapsExisting(x, y, radiusX, radiusY, MIN_CORRIDOR)) continue;
                    
                    // Check this doesn't create blocking corridors
                    if (createsBlockage(x, y, radiusX, radiusY)) continue;
                    
                    placed = true;
                    break;
                } while (attempts < 40);
                
                if (placed) {
                    terrainObstacles.push({
                        type: 'lake',
                        x: x,
                        y: y,
                        radiusX: radiusX,
                        radiusY: radiusY,
                        variant: i
                    });
                }
            }
            
            // ===== STEP 2: Spawn Trees (avoiding lakes, edges, and blocking paths) =====
            const treeCount = 25 + Math.floor(Math.random() * 10);
            const minTreeSpacing = 100; // Increased spacing to prevent walls
            const edgeBuffer = 200; // Keep trees away from edges
            
            for (let i = 0; i < treeCount; i++) {
                let x, y, attempts = 0;
                const treeRadius = 20 + Math.random() * 10;
                
                do {
                    x = edgeBuffer + Math.random() * (WORLD.width - edgeBuffer * 2);
                    y = edgeBuffer + Math.random() * (WORLD.height - edgeBuffer * 2);
                    attempts++;
                    
                    // Check not in center spawn area
                    if (Math.hypot(x - WORLD.width/2, y - WORLD.height/2) < 400) continue;
                    
                    // Check not overlapping lakes (with padding)
                    let overlaps = false;
                    for (const obs of terrainObstacles) {
                        if (obs.type === 'lake') {
                            const dx = (x - obs.x) / (obs.radiusX + treeRadius + 80);
                            const dy = (y - obs.y) / (obs.radiusY + treeRadius + 80);
                            if (dx * dx + dy * dy < 1) {
                                overlaps = true;
                                break;
                            }
                        } else if (obs.type === 'tree') {
                            // Check spacing between trees
                            const dist = Math.hypot(x - obs.x, y - obs.y);
                            if (dist < minTreeSpacing) {
                                overlaps = true;
                                break;
                            }
                        }
                    }
                    if (!overlaps) break;
                } while (attempts < 50);
                
                if (attempts < 50) {
                    terrainObstacles.push({
                        type: 'tree',
                        x: x,
                        y: y,
                        radius: treeRadius,
                        variant: i
                    });
                }
            }
        }
        
        function spawnDecorations() {
            // Trees are now part of terrain, this is kept for compatibility
            decorations = [];
        }
        
        function drawTerrain() {
            // Draw only lakes (background layer - player walks over these)
            const time = Date.now();
            
            for (const obs of terrainObstacles) {
                if (obs.type !== 'lake') continue; // Only lakes in background
                
                const visMargin = Math.max(obs.radiusX || 0, obs.radiusY || 0) + 150;
                if (!camera.isVisible(obs.x, obs.y, visMargin)) continue;
                
                const sx = camera.screenX(obs.x);
                const sy = camera.screenY(obs.y);
                const scaleFn = (val) => camera.scale(val);
                
                const terrainType = TERRAIN_TYPES[obs.type];
                if (terrainType && terrainType.draw) {
                    terrainType.draw(ctx, sx, sy, scaleFn, time, obs);
                }
            }
        }
        
        function drawTrees() {
            // Draw trees (foreground layer - on top of player)
            const time = Date.now();
            
            for (const obs of terrainObstacles) {
                if (obs.type !== 'tree') continue; // Only trees in foreground
                
                if (!camera.isVisible(obs.x, obs.y, 100)) continue;
                
                const sx = camera.screenX(obs.x);
                const sy = camera.screenY(obs.y);
                const scaleFn = (val) => camera.scale(val);
                
                const terrainType = TERRAIN_TYPES[obs.type];
                if (terrainType && terrainType.draw) {
                    terrainType.draw(ctx, sx, sy, scaleFn, time, obs);
                }
            }
        }
        
        function drawDecorations() {
            // Trees are now drawn as terrain, keeping for compatibility
        }

        // ===== LEGENDARY UPGRADE SYSTEM =====
        const LEGENDARY_UPGRADES = {
            burn: {
                name: 'Inferno Touch',
                icon: 'üî•',
                color: COLORS.burn,
                desc: 'Attacks have 15% chance to burn enemies',
                effect: 'Burn: Initial damage + 3 ticks over 2s'
            },
            freeze: {
                name: 'Frostbite',
                icon: '‚ùÑÔ∏è',
                color: COLORS.freeze,
                desc: 'Attacks have 12% chance to freeze enemies',
                effect: 'Freeze: Slows enemy 50% for 6 seconds'
            },
            shock: {
                name: 'Overcharged',
                icon: '‚ö°',
                color: COLORS.shock,
                desc: 'Attacks have 10% chance to shock enemies',
                effect: 'Shock: Stuns for 3s, moderate damage'
            },
            timeSlow: {
                name: 'Temporal Shield',
                icon: '‚è≥',
                color: '#9966ff',
                desc: 'Below 30% HP: Slows time 60% for 8s',
                effect: '+150% HP Regen during effect. 1 min cooldown'
            },
            holyBook: {
                name: 'Sacred Tome',
                icon: 'üìñ',
                color: '#ffffaa',
                desc: '+25 Max HP, +2 HP/s Regen',
                effect: 'Healing radiates damage to nearby enemies'
            },
            stillness: {
                name: 'Inner Peace',
                icon: 'üßò',
                color: '#88ffaa',
                desc: 'Heal 5 HP/s while standing still',
                effect: '+20% Lifesteal on all attacks'
            },
            xpMagnet: {
                name: 'Soul Harvest',
                icon: 'üíé',
                color: '#ffd700',
                desc: 'Absorb ALL XP on map every 30s',
                effect: 'Automatic collection pulse'
            },
            ghostStrike: {
                name: 'Vengeful Spirits',
                icon: 'üëª',
                color: '#aaccff',
                desc: 'Killing enemies spawns a ghost',
                effect: 'Ghost kamikazes nearest enemy'
            }
        };

        function showLegendaryUpgrade() {
            gamePaused = true;
            
            // Create overlay
            let overlay = document.getElementById('legendaryOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'legendaryOverlay';
                overlay.className = 'legendary-overlay';
                document.body.appendChild(overlay);
            }
            
            // Randomly select 3 upgrade options
            const allOptions = Object.keys(LEGENDARY_UPGRADES);
            const shuffled = allOptions.sort(() => Math.random() - 0.5);
            const options = shuffled.slice(0, 3);
            
            // Check if player already has an upgrade
            function hasUpgrade(id) {
                const eff = legendaryEffects[id];
                if (!eff) return false;
                if (eff.chance !== undefined) return eff.chance > 0;
                if (eff.active !== undefined) return eff.active;
                return false;
            }
            
            overlay.innerHTML = `
                <div class="legendary-title">üçÄ LEGENDARY LOOT! üçÄ</div>
                <div class="legendary-subtitle">The leprechaun's treasure is yours!</div>
                <div class="legendary-options">
                    ${options.map(id => {
                        const upg = LEGENDARY_UPGRADES[id];
                        const hasIt = hasUpgrade(id);
                        return `
                            <div class="legendary-card" data-upgrade="${id}" style="border-color: ${upg.color}; box-shadow: 0 0 20px ${upg.color}40;">
                                <div class="legendary-icon">${upg.icon}</div>
                                <div class="legendary-name" style="color: ${upg.color}">${upg.name}${hasIt ? ' +' : ''}</div>
                                <div class="legendary-desc">${upg.desc}</div>
                                <div class="legendary-effect">${upg.effect}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            
            overlay.classList.add('active');
            
            // Add click handlers
            overlay.querySelectorAll('.legendary-card').forEach(card => {
                const handler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    selectLegendaryUpgrade(card.dataset.upgrade);
                };
                card.addEventListener('click', handler);
                card.addEventListener('touchend', handler, { passive: false });
            });
        }

        function selectLegendaryUpgrade(upgradeId) {
            const overlay = document.getElementById('legendaryOverlay');
            if (overlay) overlay.classList.remove('active');
            
            // Apply the upgrade
            switch(upgradeId) {
                case 'burn':
                    legendaryEffects.burn.chance += 0.15;
                    legendaryEffects.burn.damage = 8 + player.level * 2;
                    break;
                case 'freeze':
                    legendaryEffects.freeze.chance += 0.12;
                    legendaryEffects.freeze.slowAmount = 0.5;
                    break;
                case 'shock':
                    legendaryEffects.shock.chance += 0.10;
                    legendaryEffects.shock.damage = 15 + player.level * 3;
                    break;
                case 'timeSlow':
                    legendaryEffects.timeSlow.active = true;
                    break;
                case 'holyBook':
                    legendaryEffects.holyBook.active = true;
                    legendaryEffects.holyBook.maxHpBonus += 25;
                    legendaryEffects.holyBook.regenBonus += 2;
                    // Apply immediately
                    player.maxHp += 25;
                    player.hp = Math.min(player.hp + 25, player.maxHp);
                    player.regenRate += 2;
                    break;
                case 'stillness':
                    legendaryEffects.stillness.active = true;
                    legendaryEffects.stillness.lifestealBonus = 0.20;
                    break;
                case 'xpMagnet':
                    legendaryEffects.xpMagnet.active = true;
                    legendaryEffects.xpMagnet.lastPulse = 0;
                    break;
                case 'ghostStrike':
                    legendaryEffects.ghostStrike.active = true;
                    break;
            }
            
            gamePaused = false;
        }

        // Apply status effect to enemy when hit
        function applyStatusEffects(enemy, damage) {
            // Try burn
            if (legendaryEffects.burn.chance > 0 && Math.random() < legendaryEffects.burn.chance) {
                enemy.applyBurn(legendaryEffects.burn.damage);
            }
            // Try freeze
            if (legendaryEffects.freeze.chance > 0 && Math.random() < legendaryEffects.freeze.chance) {
                enemy.applyFreeze(legendaryEffects.freeze.slowAmount);
            }
            // Try shock
            if (legendaryEffects.shock.chance > 0 && Math.random() < legendaryEffects.shock.chance) {
                enemy.applyShock(legendaryEffects.shock.damage);
            }
        }

        // ===== PROJECTILE CLASS =====
        class Projectile {
            constructor(x, y, angle, speed, damage, color, type, pierce = 1) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.angle = angle;
                this.speed = speed;
                this.damage = damage;
                this.color = color;
                this.type = type;
                this.pierce = pierce;
                this.radius = type === 'laser' ? 6 : type === 'dagger' ? 7 : type === 'boomerang' ? 10 : type === 'bolt' ? 5 : 8;
                this.trail = [];
                this.hitEnemies = new Set();
                this.spinAngle = 0;
            }

            update() {
                // Store trail (shorter for daggers)
                this.trail.push({ x: this.x, y: this.y });
                const maxTrail = this.type === 'dagger' ? 5 : this.type === 'boomerang' ? 10 : 8;
                if (this.trail.length > maxTrail) this.trail.shift();
                
                // Boomerang special behavior
                if (this.type === 'boomerang') {
                    this.spinAngle += 0.3;
                    const distFromStart = Math.hypot(this.x - this.startX, this.y - this.startY);
                    
                    if (!this.returning && distFromStart >= this.maxDist) {
                        this.returning = true;
                        this.hitEnemies.clear(); // Can hit again on return
                    }
                    
                    if (this.returning) {
                        // Return to player
                        const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                        this.vx = Math.cos(toPlayer) * this.speed * 1.3;
                        this.vy = Math.sin(toPlayer) * this.speed * 1.3;
                        
                        // Despawn when reaching player
                        if (Math.hypot(player.x - this.x, player.y - this.y) < 30) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Check collision with enemies
                for (const enemy of enemies) {
                    if (enemy.dead || this.hitEnemies.has(enemy)) continue;
                    
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < enemy.radius + this.radius) {
                        this.hitEnemies.add(enemy);
                        
                        const { damage, isCrit } = player.calcDamage(this.damage);
                        enemy.takeDamage(damage, isCrit);
                        player.onDealDamage(damage);
                        applyStatusEffects(enemy, damage);
                        this.pierce--;
                        spawnParticles(this.x, this.y, this.color, 5);
                        if (this.pierce <= 0) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                // Check collision with leprechauns
                for (const leprechaun of leprechauns) {
                    if (leprechaun.dead || this.hitEnemies.has(leprechaun)) continue;
                    
                    const dist = Math.hypot(leprechaun.x - this.x, leprechaun.y - this.y);
                    if (dist < leprechaun.radius + this.radius) {
                        this.hitEnemies.add(leprechaun);
                        
                        const { damage, isCrit } = player.calcDamage(this.damage);
                        leprechaun.takeDamage(damage, isCrit);
                        player.onDealDamage(damage);
                        this.pierce--;
                        spawnParticles(this.x, this.y, COLORS.gold, 5);
                        if (this.pierce <= 0) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                // Check collision with bosses
                for (const boss of bosses) {
                    if (boss.dead || this.hitEnemies.has(boss)) continue;
                    
                    const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
                    if (dist < boss.radius + this.radius) {
                        this.hitEnemies.add(boss);
                        
                        const { damage, isCrit } = player.calcDamage(this.damage);
                        boss.takeDamage(damage, isCrit);
                        player.onDealDamage(damage);
                        this.pierce--;
                        spawnParticles(this.x, this.y, boss.color, 5);
                        if (this.pierce <= 0) {
                            this.dead = true;
                            return;
                        }
                    }
                }
                
                // Out of bounds (world) - except boomerangs which return
                if (this.type !== 'boomerang') {
                    if (this.x < -20 || this.x > WORLD.width + 20 ||
                        this.y < -20 || this.y > WORLD.height + 20) {
                        this.dead = true;
                    }
                }
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                
                // Trail (skip for bolt type)
                if (this.type !== 'bolt') {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.type === 'laser' ? 3 : this.type === 'boomerang' ? 2.5 : 2;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    for (let i = 0; i < this.trail.length; i++) {
                        const t = this.trail[i];
                        const tsx = camera.screenX(t.x);
                        const tsy = camera.screenY(t.y);
                        if (i === 0) ctx.moveTo(tsx, tsy);
                        else ctx.lineTo(tsx, tsy);
                    }
                    ctx.lineTo(sx, sy);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                ctx.fillStyle = this.color;
                
                // Different shapes for different projectile types
                if (this.type === 'dagger') {
                    // Diamond/dagger shape
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.translate(sx, sy);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(r * 1.5, 0);
                    ctx.lineTo(0, r * 0.5);
                    ctx.lineTo(-r * 0.5, 0);
                    ctx.lineTo(0, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'boomerang') {
                    // Spinning tri-blade
                    ctx.translate(sx, sy);
                    ctx.rotate(this.spinAngle);
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const a = (Math.PI * 2 / 3) * i;
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * r * 1.8, Math.sin(a) * r * 1.8);
                        ctx.lineTo(Math.cos(a + 0.3) * r * 0.8, Math.sin(a + 0.3) * r * 0.8);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Default circle
                    ctx.beginPath();
                    ctx.arc(sx, sy, r, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // ===== XP GEM CLASS =====
        class XPGem {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.radius = 3 + value * 0.5;
                this.color = COLORS.cyan;  // Cyan color matching player
                this.pulse = 0;
            }

            update() {
                this.pulse += 0.1;
                
                // Magnet toward player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                // During magnet pulse, pull ALL gems rapidly
                if (magnetPulseActive && dist > 1) {
                    const speed = 12; // Fast pull speed
                    this.x += (dx / dist) * speed;
                    this.y += (dy / dist) * speed;
                }
                // Normal magnet behavior within pickup range
                else if (dist > 1 && dist < player.pickupRange) {
                    const speed = 5 * (1 - dist / player.pickupRange) + 1;
                    this.x += (dx / dist) * speed;
                    this.y += (dy / dist) * speed;
                }
                
                // Collect
                if (dist < player.radius + this.radius) {
                    player.gainXP(this.value);
                    this.dead = true;
                }
            }

            draw() {
                if (!camera.isVisible(this.x, this.y)) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                
                ctx.save();
                const glow = 10 + Math.sin(this.pulse) * 4;
                ctx.shadowBlur = glow;
                ctx.shadowColor = COLORS.cyan;
                
                // Cyan gem circle
                ctx.fillStyle = COLORS.cyan;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner shine (white core)
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(sx - r * 0.25, sy - r * 0.25, r * 0.35, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // ===== SHRINE CLASS =====
        class Shrine {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 195;      // Outer ring (15% smaller)
                this.innerRadius = 187; // Inner ring - almost same size
                this.chargeTime = 0;
                this.chargeRequired = 5000;
                this.activated = false;
                this.pulse = Math.random() * Math.PI * 2;
                this.color = COLORS.shrine; // Neon purple
            }

            update(dt) {
                if (this.activated) return;
                
                this.pulse += dt * 0.002;
                
                // Check if player is inside
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                
                if (dist < this.innerRadius) {
                    this.chargeTime += dt;
                    
                    // Update charge bar (using DOM cache)
                    DOM.shrineChargeBar.classList.add('active');
                    DOM.shrineChargeFill.style.width = `${(this.chargeTime / this.chargeRequired) * 100}%`;
                    
                    // Spawn particles while charging
                    if (Math.random() < 0.1) {
                        const angle = Math.random() * Math.PI * 2;
                        const pr = this.radius + 10;
                        spawnParticles(
                            this.x + Math.cos(angle) * pr,
                            this.y + Math.sin(angle) * pr,
                            this.color, 1
                        );
                    }
                    
                    if (this.chargeTime >= this.chargeRequired) {
                        this.activate();
                    }
                } else {
                    // Decay charge when player leaves
                    this.chargeTime = Math.max(0, this.chargeTime - dt * 0.5);
                    
                    if (this.chargeTime === 0) {
                        DOM.shrineChargeBar.classList.remove('active');
                    }
                }
            }

            activate() {
                this.activated = true;
                DOM.shrineChargeBar.classList.remove('active');
                
                // Burst particles
                spawnParticles(this.x, this.y, this.color, 30);
                spawnParticles(this.x, this.y, COLORS.cyan, 20);
                
                // Show shrine power-up selection
                showShrinePowerups();
            }

            draw() {
                if (!camera.isVisible(this.x, this.y, this.radius + 20)) return;
                if (this.activated) return;
                
                const sx = camera.screenX(this.x);
                const sy = camera.screenY(this.y);
                const r = camera.scale(this.radius);
                const ir = camera.scale(this.innerRadius);
                
                ctx.save();
                
                // Outer glow ring
                const glowIntensity = 0.3 + Math.sin(this.pulse) * 0.15;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = glowIntensity;
                
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner ring
                ctx.lineWidth = 2;
                ctx.globalAlpha = glowIntensity * 0.7;
                ctx.beginPath();
                ctx.arc(sx, sy, ir, 0, Math.PI * 2);
                ctx.stroke();
                
                // Charge progress arc
                if (this.chargeTime > 0) {
                    const progress = this.chargeTime / this.chargeRequired;
                    ctx.strokeStyle = COLORS.cyan;
                    ctx.lineWidth = 6;
                    ctx.shadowColor = COLORS.cyan;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(sx, sy, r - camera.scale(5), -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                    ctx.stroke();
                }
                
                // Center symbol
                ctx.globalAlpha = glowIntensity;
                ctx.fillStyle = this.color;
                ctx.font = `${camera.scale(20)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ú®', sx, sy);
                
                ctx.restore();
            }
        }

        // ===== SHRINE POWER-UP SYSTEM =====
        let shrineSlotResults = [];
        
        function showShrinePowerups() {
            gamePaused = true;
            
            DOM.shrineOverlay.classList.add('active');
            DOM.slotMachine.innerHTML = '';
            DOM.slotMachine.style.display = 'none';
            DOM.shrineOptions.innerHTML = '';
            
            // Pick 3 random powerups
            const powerupKeys = Object.keys(SHRINE_POWERUPS);
            const shuffled = powerupKeys.sort(() => Math.random() - 0.5).slice(0, 3);
            shrineSlotResults = shuffled.map(key => ({ key, ...SHRINE_POWERUPS[key] }));
            
            // Skip slot animation, show cards directly
            showShrineCards();
        }
        
        function showShrineCards() {
            // Hide slot machine completely
            DOM.slotMachine.style.display = 'none';
            DOM.slotMachine.style.visibility = 'hidden';
            DOM.slotMachine.innerHTML = '';
            
            DOM.shrineOptions.innerHTML = '';
            
            shrineSlotResults.forEach((powerup, i) => {
                const card = document.createElement('div');
                card.className = 'shrine-card revealed';
                card.style.borderColor = powerup.color;
                card.style.cursor = 'pointer';
                
                card.innerHTML = `
                    <div class="icon">${powerup.icon}</div>
                    <div class="name" style="color: ${powerup.color}; text-shadow: 0 0 8px ${powerup.color};">${powerup.name}</div>
                    <div class="value">${powerup.desc}</div>
                `;
                
                // Use onclick directly
                card.onclick = function(e) {
                    selectShrinePowerup(powerup);
                };
                
                card.ontouchend = function(e) {
                    e.preventDefault();
                    selectShrinePowerup(powerup);
                };
                
                DOM.shrineOptions.appendChild(card);
            });
        }
        
        function selectShrinePowerup(powerup) {
            player.addShrineBonus(powerup.stat, powerup.value);
            
            DOM.shrineOverlay.classList.remove('active');
            gamePaused = false;
            
            // Update buffs bar display
            updateBuffsBar();
            
            // Visual feedback
            spawnParticles(player.x, player.y, powerup.color, 20);
        }
        
        // ===== SHRINE SPAWNING =====
        const SHRINE_CONFIG = {
            maxActive: 5,           // Max shrines active at once
            spawnInterval: 15000,   // Spawn new shrine every 15 seconds
            initialDelay: 5000,     // Wait 5 seconds before first shrine
            minDist: 600,           // Minimum distance between shrines
            idealDist: 1200,        // Ideal distance between shrines
            edgeBuffer: 400,        // Distance from world edges
            exceptionChance: 0.12   // 12% chance to allow closer placement
        };
        
        let shrineSpawnTimer = 0;
        let shrineInitialDelay = true;
        
        function getActiveShrineCount() {
            return shrines.filter(s => !s.activated).length;
        }
        
        function spawnSingleShrine() {
            const candidateCount = 8; // Increased to account for terrain
            let bestCandidate = null;
            let bestScore = -Infinity;
            
            // Get only active (non-activated) shrines for distance checks
            const activeShrines = shrines.filter(s => !s.activated);
            
            // Generate multiple candidate positions and pick the best one
            for (let c = 0; c < candidateCount; c++) {
                const x = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.width - SHRINE_CONFIG.edgeBuffer * 2);
                const y = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.height - SHRINE_CONFIG.edgeBuffer * 2);
                
                // Skip if in terrain (shrines need large clear area)
                if (isInTerrain(x, y, 250)) continue;
                
                // Calculate score based on distances to existing active shrines
                let minDistToShrine = Infinity;
                let totalDistScore = 0;
                
                for (const shrine of activeShrines) {
                    const dist = Math.hypot(shrine.x - x, shrine.y - y);
                    minDistToShrine = Math.min(minDistToShrine, dist);
                    
                    if (dist < SHRINE_CONFIG.idealDist) {
                        totalDistScore += dist / SHRINE_CONFIG.idealDist;
                    } else {
                        totalDistScore += 1 - (dist - SHRINE_CONFIG.idealDist) / (WORLD.width * 0.5) * 0.3;
                    }
                }
                
                // Check distance from player (spawn far from player)
                const playerDist = Math.hypot(player.x - x, player.y - y);
                if (playerDist < 800) continue; // Don't spawn too close to player
                
                // Determine if this candidate is valid
                let isValid = true;
                
                if (activeShrines.length > 0) {
                    const allowException = Math.random() < SHRINE_CONFIG.exceptionChance;
                    const effectiveMinDist = allowException ? SHRINE_CONFIG.minDist * 0.5 : SHRINE_CONFIG.minDist;
                    
                    if (minDistToShrine < effectiveMinDist) {
                        isValid = false;
                    }
                }
                
                if (!isValid) continue;
                
                // Calculate final score - prefer spawning farther from player
                const nearestScore = activeShrines.length > 0 
                    ? Math.min(minDistToShrine / SHRINE_CONFIG.idealDist, 1.5) 
                    : 1;
                const avgScore = activeShrines.length > 0 
                    ? totalDistScore / activeShrines.length 
                    : 1;
                const playerDistBonus = Math.min(playerDist / 1200, 1);
                
                const randomFactor = 0.9 + Math.random() * 0.2;
                const score = (nearestScore * 0.5 + avgScore * 0.2 + playerDistBonus * 0.3) * randomFactor;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestCandidate = { x, y };
                }
            }
            
            // Fallback if no valid candidate found
            if (!bestCandidate) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const x = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.width - SHRINE_CONFIG.edgeBuffer * 2);
                    const y = SHRINE_CONFIG.edgeBuffer + Math.random() * (WORLD.height - SHRINE_CONFIG.edgeBuffer * 2);
                    
                    let tooClose = false;
                    for (const shrine of activeShrines) {
                        if (Math.hypot(shrine.x - x, shrine.y - y) < SHRINE_CONFIG.minDist * 0.4) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    const playerDist = Math.hypot(player.x - x, player.y - y);
                    if (!tooClose && playerDist >= 300) {
                        bestCandidate = { x, y };
                        break;
                    }
                }
            }
            
            if (bestCandidate) {
                shrines.push(new Shrine(bestCandidate.x, bestCandidate.y));
                return true;
            }
            return false;
        }
        
        function updateShrineSpawning(dt) {
            // Handle initial delay
            if (shrineInitialDelay) {
                shrineSpawnTimer += dt;
                if (shrineSpawnTimer >= SHRINE_CONFIG.initialDelay) {
                    shrineInitialDelay = false;
                    shrineSpawnTimer = 0;
                    spawnSingleShrine(); // Spawn first shrine
                }
                return;
            }
            
            // Check if we need more shrines
            const activeCount = getActiveShrineCount();
            if (activeCount >= SHRINE_CONFIG.maxActive) {
                shrineSpawnTimer = 0; // Reset timer when at max
                return;
            }
            
            // Spawn timer
            shrineSpawnTimer += dt;
            if (shrineSpawnTimer >= SHRINE_CONFIG.spawnInterval) {
                shrineSpawnTimer = 0;
                spawnSingleShrine();
            }
        }
        
        // Legacy function for compatibility - now just resets state
        function spawnShrines() {
            shrines = [];
            shrineSpawnTimer = 0;
            shrineInitialDelay = true;
        }

        // ===== PARTICLES & EFFECTS =====
        function spawnParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color,
                    life: 1,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function spawnDamageNumber(x, y, damage, isCrit = false) {
            damageNumbers.push({
                x: x + (Math.random() - 0.5) * 20,
                y,
                damage,
                isCrit,
                life: 1,
                vy: isCrit ? -3 : -2,
                scale: isCrit ? 1.5 : 1
            });
        }

        // ===== HELPERS =====
        function findNearestEnemy(x, y) {
            let nearest = null;
            let minDist = Infinity;
            for (const enemy of enemies) {
                if (enemy.dead) continue; // Skip dead enemies
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }
            return nearest;
        }
        
        // Efficient in-place array cleanup (swap-and-pop)
        function cleanupArray(arr, shouldRemove) {
            for (let i = arr.length - 1; i >= 0; i--) {
                if (shouldRemove(arr[i])) {
                    arr[i] = arr[arr.length - 1];
                    arr.pop();
                }
            }
        }
        
        // Random sample without full shuffle (O(k) instead of O(n))
        function randomSample(arr, count) {
            const result = [];
            const indices = new Set();
            const max = Math.min(count, arr.length);
            while (result.length < max) {
                const idx = Math.floor(Math.random() * arr.length);
                if (!indices.has(idx)) {
                    indices.add(idx);
                    result.push(arr[idx]);
                }
            }
            return result;
        }
        
        // Generate lightning bolt segments (for lightning strike visual)
        function generateLightning(x1, y1, x2, y2) {
            const segments = [];
            const steps = 6;
            let px = x1, py = y1;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const nx = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 40 * (1 - t);
                const ny = y1 + (y2 - y1) * t;
                segments.push({ x1: px, y1: py, x2: nx, y2: ny });
                px = nx; py = ny;
            }
            return segments;
        }

        // ===== SPAWNING =====
        let spawnTimer = 0;
        const spawnInterval = 3000; // Doubled (was 1500) - half as many enemies

        function spawnEnemies(dt) {
            spawnTimer += dt;
            
            // Balanced spawn rate over time
            // Floor raised to 800ms (was 400), slower scaling
            let currentInterval = Math.max(800, spawnInterval - gameTime * 1.5);
            
            // SWARM EVENT: 2x spawn rate for 30 seconds before boss
            if (swarmActive) {
                currentInterval = currentInterval / 2;
            }
            
            // FINAL HORDE: 30 minutes (1800s) - spawn rate doubles every minute gradually
            const finalSwarmTime = 1800; // 30 minutes
            if (gameTime >= finalSwarmTime) {
                const secondsOver30Min = gameTime - finalSwarmTime;
                // Gradual doubling: every 60 seconds, spawn rate doubles
                // Using exponential decay: interval = base * 0.5^(minutes)
                const minutesOver = secondsOver30Min / 60;
                const multiplier = Math.pow(0.5, minutesOver);
                currentInterval = Math.max(150, currentInterval * multiplier);
                
                // Show warning once
                if (!finalSwarmWarningShown) {
                    showFinalSwarmWarning();
                }
            }
            
            if (spawnTimer >= currentInterval) {
                spawnTimer = 0;
                
                // Determine enemy type based on time
                const types = ['basic'];
                if (gameTime > 30) types.push('fast');
                if (gameTime > 60) types.push('tank');
                if (gameTime > 90) types.push('swarm', 'swarm');
                
                // SWARM EVENT: More swarm-type enemies
                if (swarmActive) {
                    types.push('swarm', 'swarm', 'fast');
                }
                
                // FINAL HORDE: 30 minutes+ heavily favors swarm enemies
                if (gameTime >= finalSwarmTime) {
                    types.push('swarm', 'swarm', 'swarm', 'fast');
                }
                
                // Spawn count increases slower: every 90s instead of 45s
                let count = 1 + Math.floor(gameTime / 90);
                
                // SWARM EVENT: +50% enemies per wave
                if (swarmActive) {
                    count = Math.ceil(count * 1.5);
                }
                
                // FINAL HORDE: 30 minutes+ spawns more enemies per wave
                if (gameTime >= finalSwarmTime) {
                    const secondsOver30Min = gameTime - finalSwarmTime;
                    count += Math.floor(secondsOver30Min / 20); // +1 enemy per 20 seconds over 30 min
                }
                
                for (let i = 0; i < count; i++) {
                    // Enforce enemy limit (raised for final horde)
                    const maxEnemies = (gameTime >= finalSwarmTime) ? LIMITS.enemies + 50 : LIMITS.enemies;
                    if (enemies.length >= maxEnemies) break;
                    
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    // Spawn well outside visible area (accounting for zoom)
                    let x, y, spawnAttempts = 0;
                    const visibleWidth = canvas.width / camera.zoom;
                    const visibleHeight = canvas.height / camera.zoom;
                    const spawnDist = Math.max(visibleWidth, visibleHeight) / 2 + 150;
                    
                    do {
                        const angle = Math.random() * Math.PI * 2;
                        x = player.x + Math.cos(angle) * spawnDist;
                        y = player.y + Math.sin(angle) * spawnDist;
                        
                        // Clamp to world bounds
                        x = Math.max(20, Math.min(WORLD.width - 20, x));
                        y = Math.max(20, Math.min(WORLD.height - 20, y));
                        spawnAttempts++;
                    } while (isInTerrain(x, y, 30) && spawnAttempts < 10);
                    
                    enemies.push(new Enemy(type, x, y));
                }
            }
        }

        // ===== LEPRECHAUN SPAWNING =====
        function spawnLeprechaun() {
            // Spawn at a distance from player, avoiding terrain
            let potX, potY, attempts = 0;
            
            do {
                const angle = Math.random() * Math.PI * 2;
                const spawnDist = 400 + Math.random() * 200;
                
                potX = player.x + Math.cos(angle) * spawnDist;
                potY = player.y + Math.sin(angle) * spawnDist;
                
                // Clamp to world bounds
                potX = Math.max(150, Math.min(WORLD.width - 150, potX));
                potY = Math.max(150, Math.min(WORLD.height - 150, potY));
                attempts++;
            } while (isInTerrain(potX, potY, 100) && attempts < 20);
            
            // Create rainbow/pot at spawn location
            const rainbow = new Rainbow(potX, potY);
            rainbows.push(rainbow);
            
            // Spawn leprechaun near the pot, guarding it
            const lepX = potX + 40;
            const lepY = potY;
            const lep = new Leprechaun(lepX, lepY, potX, potY);
            lep.linkedRainbow = rainbow;
            rainbow.linkedLeprechaun = lep;
            leprechauns.push(lep);
            
            // Flash notification
            showLeprechaunWarning();
        }

        function showLeprechaunWarning() {
            showStackedWarning({
                html: `<div style="font-size: 28px;">üçÄ A LEPRECHAUN APPEARS! üçÄ</div>`,
                color: COLORS.gold,
                textShadow: `0 0 20px ${COLORS.gold}, 0 0 40px ${COLORS.green}`,
                duration: 2000
            });
        }

        function updateLeprechaunSpawning(dt) {
            leprechaunSpawnTimer += dt;
            
            if (leprechaunSpawnTimer >= nextLeprechaunSpawn) {
                leprechaunSpawnTimer = 0;
                nextLeprechaunSpawn = 120000; // 2 minutes between spawns after first
                spawnLeprechaun();
            }
        }
        
        // ===== STACKING WARNING SYSTEM =====
        let activeWarnings = [];
        
        function showStackedWarning(options) {
            const warning = document.createElement('div');
            warning.className = 'stacked-warning';
            warning.innerHTML = options.html;
            warning.style.cssText = `
                position: fixed;
                left: 50%;
                transform: translateX(-50%);
                color: ${options.color};
                text-shadow: ${options.textShadow};
                text-align: center;
                z-index: 9999;
                pointer-events: none;
                opacity: 0;
                transition: top 0.3s ease-out;
            `;
            
            document.body.appendChild(warning);
            
            // Add to active warnings at the beginning (newest first)
            activeWarnings.unshift(warning);
            repositionWarnings();
            
            // Animate in
            requestAnimationFrame(() => {
                warning.style.opacity = '1';
                warning.style.animation = 'warningPulse 0.5s ease-out';
            });
            
            // Remove after duration
            setTimeout(() => {
                warning.style.opacity = '0';
                warning.style.transform = 'translateX(-50%) translateY(-20px)';
                setTimeout(() => {
                    const idx = activeWarnings.indexOf(warning);
                    if (idx > -1) activeWarnings.splice(idx, 1);
                    warning.remove();
                    repositionWarnings();
                }, 300);
            }, options.duration - 300);
        }
        
        function repositionWarnings() {
            const startY = 25; // Start from 25% down
            const spacing = 60; // Pixels between warnings
            
            activeWarnings.forEach((warning, index) => {
                warning.style.top = `calc(${startY}% + ${index * spacing}px)`;
            });
        }
        
        // Add warning animation styles once
        (function() {
            const style = document.createElement('style');
            style.textContent = `
                @keyframes warningPulse {
                    0% { transform: translateX(-50%) scale(0.5); }
                    50% { transform: translateX(-50%) scale(1.15); }
                    100% { transform: translateX(-50%) scale(1); }
                }
                .stacked-warning {
                    transition: top 0.3s ease-out, opacity 0.3s ease-out, transform 0.3s ease-out;
                }
            `;
            document.head.appendChild(style);
        })();
        
        // ===== BOSS SPAWNING SYSTEM =====
        function updateBossSpawning(dt) {
            // Boss schedule: 2.5 mins, 5 mins, 7.5 mins, 10 mins, etc.
            // Mini boss at odd intervals (2.5, 7.5, 12.5...)
            // Major boss at even intervals (5, 10, 15...)
            
            // Check for swarm trigger (1 minute before next boss)
            const nextBossNumber = bossCount + 1;
            const nextBossTimeCalc = nextBossNumber * 150; // 150s = 2.5 mins
            const swarmTriggerTime = nextBossTimeCalc - 60; // 1 minute before
            
            // Start swarm if we haven't triggered it for this boss yet
            if (gameTime >= swarmTriggerTime && swarmTriggeredForBoss < nextBossNumber) {
                swarmTriggeredForBoss = nextBossNumber;
                swarmActive = true;
                swarmEndTime = gameTime + 30; // 30 seconds duration
                showSwarmWarning();
            }
            
            // End swarm after 30 seconds
            if (swarmActive && gameTime >= swarmEndTime) {
                swarmActive = false;
            }
            
            // Spawn boss at the right time
            if (gameTime >= nextBossTime) {
                bossCount++;
                nextBossTime = (bossCount + 1) * 150; // Schedule next boss
                
                // Determine boss type: odd count = mini, even count = major
                if (bossCount % 2 === 1) {
                    spawnMiniBoss();
                } else {
                    spawnMajorBoss();
                }
            }
        }
        
        function spawnMiniBoss() {
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 350;
            
            let x = player.x + Math.cos(angle) * spawnDist;
            let y = player.y + Math.sin(angle) * spawnDist;
            
            // Clamp to world bounds
            x = Math.max(100, Math.min(WORLD.width - 100, x));
            y = Math.max(100, Math.min(WORLD.height - 100, y));
            
            bosses.push(new MiniBoss(x, y));
            showBossWarning('MINI BOSS', '#ff6600');
        }
        
        function spawnMajorBoss() {
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 400;
            
            let x = player.x + Math.cos(angle) * spawnDist;
            let y = player.y + Math.sin(angle) * spawnDist;
            
            // Clamp to world bounds
            x = Math.max(150, Math.min(WORLD.width - 150, x));
            y = Math.max(150, Math.min(WORLD.height - 150, y));
            
            bosses.push(new MajorBoss(x, y));
            showBossWarning('‚òÖ BOSS ‚òÖ', '#ff00ff');
        }
        
        function showBossWarning(text, color) {
            showStackedWarning({
                html: `<div style="font-size: 36px;">‚ö†Ô∏è ${text} INCOMING! ‚ö†Ô∏è</div>`,
                color: color,
                textShadow: `0 0 30px ${color}, 0 0 60px #ffffff`,
                duration: 2500
            });
        }
        
        function showSwarmWarning() {
            showStackedWarning({
                html: `<div style="font-size: 28px;">üåä ENEMY SWARM! üåä</div><div style="font-size: 16px; margin-top: 10px;">Enemies spawning 2x faster for 30 seconds!</div>`,
                color: '#ff4444',
                textShadow: '0 0 20px #ff0000',
                duration: 2000
            });
        }

        // ===== FINAL HORDE WARNING =====
        let finalSwarmWarningShown = false;
        
        function showFinalSwarmWarning() {
            if (finalSwarmWarningShown) return;
            finalSwarmWarningShown = true;
            
            // Create warning overlay
            const warning = document.createElement('div');
            warning.id = 'finalSwarmWarning';
            warning.innerHTML = `
                <div class="warning-text">‚ö†Ô∏è FINAL HORDE ‚ö†Ô∏è</div>
                <div class="warning-subtext">THE FINAL SWARM APPROACHES</div>
                <div class="warning-desc">Enemy spawns will now double every minute!</div>
            `;
            warning.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(255, 0, 0, 0.15);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: warningPulse 0.5s ease-in-out 3;
                pointer-events: none;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes warningPulse {
                    0%, 100% { background: rgba(255, 0, 0, 0.1); }
                    50% { background: rgba(255, 0, 0, 0.3); }
                }
                #finalSwarmWarning .warning-text {
                    font-size: 48px;
                    font-weight: bold;
                    color: #ff3333;
                    text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000;
                    animation: warningTextPulse 0.3s ease-in-out infinite;
                    letter-spacing: 8px;
                }
                #finalSwarmWarning .warning-subtext {
                    font-size: 28px;
                    color: #ff6600;
                    text-shadow: 0 0 20px #ff6600;
                    margin-top: 15px;
                    letter-spacing: 4px;
                }
                #finalSwarmWarning .warning-desc {
                    font-size: 16px;
                    color: #fff;
                    margin-top: 20px;
                    opacity: 0.8;
                }
                @keyframes warningTextPulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.05); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(warning);
            
            // Remove warning after 2.5 seconds
            setTimeout(() => {
                warning.style.transition = 'opacity 0.5s';
                warning.style.opacity = '0';
                setTimeout(() => warning.remove(), 500);
            }, 2500);
        }

        // ===== UPGRADE SELECTION =====
        let upgradeSlotResults = [];
        
        function showUpgradeSelection() {
            gamePaused = true;
            DOM.upgradeOverlay.classList.add('active');
            DOM.upgradeSlotMachine.innerHTML = '';
            DOM.upgradeSlotMachine.style.display = 'flex';
            DOM.upgradeSlotMachine.style.visibility = 'visible';
            DOM.upgradeOptions.innerHTML = '';
            
            // Generate 3 random upgrades
            const available = [];
            
            // Add weapon upgrades
            for (const [id, def] of Object.entries(WEAPONS)) {
                const level = player.weapons[id]?.level || 0;
                if (level < 5) {
                    available.push({
                        ...def,
                        type: 'weapon',
                        id,
                        currentLevel: level
                    });
                }
            }
            
            // Add passive upgrades
            for (const [id, def] of Object.entries(PASSIVES)) {
                const level = player.passives[id] || 0;
                if (level < 5) {
                    available.push({
                        ...def,
                        type: 'passive',
                        id,
                        currentLevel: level
                    });
                }
            }
            
            // Pick 3 random (or fewer if not available)
            upgradeSlotResults = available.sort(() => Math.random() - 0.5).slice(0, 3);
            
            // Handle edge case of no upgrades available
            if (upgradeSlotResults.length === 0) {
                DOM.upgradeOverlay.classList.remove('active');
                gamePaused = false;
                return;
            }
            
            // Create slot reels
            const reelCount = upgradeSlotResults.length;
            for (let i = 0; i < reelCount; i++) {
                const reel = document.createElement('div');
                reel.className = 'slot-reel spinning';
                reel.id = `upgradeReel${i}`;
                
                const content = document.createElement('div');
                content.className = 'slot-content';
                content.innerHTML = `
                    <div class="slot-icon">‚ùì</div>
                    <div class="slot-name">???</div>
                    <div class="slot-value">???</div>
                `;
                
                reel.appendChild(content);
                DOM.upgradeSlotMachine.appendChild(reel);
            }
            
            // Animate slot machine reveal
            upgradeSlotResults.forEach((upgrade, i) => {
                setTimeout(() => {
                    const reel = document.getElementById(`upgradeReel${i}`);
                    if (!reel) return;
                    reel.classList.remove('spinning');
                    reel.classList.add('stopped');
                    
                    const levelText = upgrade.currentLevel > 0 
                        ? `Lv ${upgrade.currentLevel} ‚Üí ${upgrade.currentLevel + 1}` 
                        : 'NEW!';
                    
                    const content = reel.querySelector('.slot-content');
                    content.innerHTML = `
                        <div class="slot-icon">${upgrade.icon}</div>
                        <div class="slot-name">${upgrade.name}</div>
                        <div class="slot-value">${levelText}</div>
                    `;
                    content.style.color = upgrade.color;
                    reel.style.borderColor = upgrade.color;
                    reel.style.boxShadow = `0 0 25px ${upgrade.color}50`;
                    
                    // Show clickable cards after last reel
                    if (i === upgradeSlotResults.length - 1) {
                        setTimeout(() => showUpgradeCards(), 300);
                    }
                }, 400 + i * 500);
            });
        }
        
        function showUpgradeCards() {
            console.log('showUpgradeCards called, results:', upgradeSlotResults);
            // Hide slot machine completely
            DOM.upgradeSlotMachine.style.display = 'none';
            DOM.upgradeSlotMachine.style.visibility = 'hidden';
            DOM.upgradeSlotMachine.innerHTML = '';
            DOM.upgradeOptions.innerHTML = '';
            
            upgradeSlotResults.forEach((upgrade, i) => {
                console.log('Creating card for:', upgrade.name);
                const card = document.createElement('div');
                card.className = 'upgrade-card revealed';
                card.style.borderColor = upgrade.color;
                card.style.boxShadow = `0 0 20px ${upgrade.color}40`;
                card.style.cursor = 'pointer';
                
                const levelText = upgrade.currentLevel > 0 
                    ? ` (Lv ${upgrade.currentLevel} ‚Üí ${upgrade.currentLevel + 1})` 
                    : ' (NEW)';
                
                card.innerHTML = `
                    <div class="icon">${upgrade.icon}</div>
                    <div class="name">${upgrade.name}${levelText}</div>
                    <div class="desc">${upgrade.desc}</div>
                `;
                
                // Use onclick directly for simplicity
                card.onclick = function(e) {
                    console.log('Card clicked:', upgrade.name);
                    selectUpgrade(upgrade);
                };
                
                // Also handle touch
                card.ontouchend = function(e) {
                    console.log('Card touched:', upgrade.name);
                    e.preventDefault();
                    selectUpgrade(upgrade);
                };
                
                DOM.upgradeOptions.appendChild(card);
                console.log('Card appended to DOM');
            });
        }

        function selectUpgrade(upgrade) {
            console.log('selectUpgrade called with:', upgrade);
            if (upgrade.type === 'weapon') {
                console.log('Adding weapon:', upgrade.id);
                player.addWeapon(upgrade.id);
            } else {
                console.log('Adding passive:', upgrade.id);
                player.addPassive(upgrade.id);
            }
            
            DOM.upgradeOverlay.classList.remove('active');
            gamePaused = false;
            updateWeaponsDisplay();
            console.log('Upgrade complete, weapons:', player.weapons);
        }

        function updateWeaponsDisplay() {
            DOM.weaponsDisplay.innerHTML = '';
            
            for (const [id, state] of Object.entries(player.weapons)) {
                const def = WEAPONS[id];
                const div = document.createElement('div');
                div.className = 'weapon-icon';
                div.style.borderColor = def.color;
                div.style.boxShadow = `0 0 10px ${def.color}`;
                div.innerHTML = `
                    ${def.icon}
                    <span class="weapon-level">${state.level}</span>
                `;
                DOM.weaponsDisplay.appendChild(div);
            }
        }

        // ===== INPUT HANDLING =====
        const input = {
            left: false, right: false, up: false, down: false,
            joystickX: 0, joystickY: 0
        };

        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w') input.up = true;
            if (e.key === 'ArrowDown' || e.key === 's') input.down = true;
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w') input.up = false;
            if (e.key === 'ArrowDown' || e.key === 's') input.down = false;
        });

        // Mobile dynamic joystick controls
        const trackpadZone = document.getElementById('trackpadZone');
        const joystickOverlay = document.getElementById('joystickOverlay');
        const joystickKnob = document.getElementById('joystickKnob');
        
        let touchActive = false;
        let joystickCenter = { x: 0, y: 0 };
        const joystickRadius = 60; // Half of overlay size
        const knobMaxDist = 40;    // Max distance knob can move
        
        function updateJoystick(touchX, touchY) {
            const dx = touchX - joystickCenter.x;
            const dy = touchY - joystickCenter.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);
            
            // Clamp distance to max
            const clampedDist = Math.min(dist, knobMaxDist);
            
            // Calculate input values (-1 to 1)
            if (dist > 5) { // Small deadzone
                input.joystickX = (clampedDist / knobMaxDist) * Math.cos(angle);
                input.joystickY = (clampedDist / knobMaxDist) * Math.sin(angle);
            } else {
                input.joystickX = 0;
                input.joystickY = 0;
            }
            
            // Move knob visually
            const knobX = Math.cos(angle) * clampedDist;
            const knobY = Math.sin(angle) * clampedDist;
            joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
        }
        
        // Simple touch handling without complex ID tracking
        trackpadZone.addEventListener('touchstart', e => {
            if (gamePaused) return;
            e.preventDefault();
            
            // Tell parent page to lock scrolling
            try { parent.postMessage({ type: 'gameTouch', action: 'start' }, '*'); } catch(err) {}
            
            const touch = e.touches[0];
            touchActive = true;
            
            const rect = trackpadZone.getBoundingClientRect();
            
            // Position joystick at touch point
            joystickCenter = { 
                x: touch.clientX, 
                y: touch.clientY 
            };
            
            // Show joystick overlay at touch position
            joystickOverlay.style.left = (touch.clientX - rect.left - joystickRadius) + 'px';
            joystickOverlay.style.top = (touch.clientY - rect.top - joystickRadius) + 'px';
            joystickOverlay.classList.add('active');
            
            // Reset knob and input
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            input.joystickX = 0;
            input.joystickY = 0;
        }, { passive: false });

        // Handle touchmove on trackpad
        trackpadZone.addEventListener('touchmove', e => {
            if (!touchActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            if (touch) {
                updateJoystick(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        // Handle touchmove on entire document (for when finger leaves trackpad)
        document.addEventListener('touchmove', e => {
            if (!touchActive) return;
            
            const touch = e.touches[0];
            if (touch) {
                updateJoystick(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        // Handle touch end
        function endJoystick() {
            touchActive = false;
            input.joystickX = 0;
            input.joystickY = 0;
            joystickOverlay.classList.remove('active');
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            
            // Tell parent page to unlock scrolling
            try { parent.postMessage({ type: 'gameTouch', action: 'end' }, '*'); } catch(err) {}
        }
        
        document.addEventListener('touchend', endJoystick);
        document.addEventListener('touchcancel', endJoystick);

        // ===== GAME LOOP =====
        let lastTime = performance.now(); // Fix: Initialize properly to avoid first-frame spike

        // Cache DOM elements for performance
        const DOM = {
            trackpadHpFill: document.getElementById('trackpadHpFill'),
            trackpadXpFill: document.getElementById('trackpadXpFill'),
            levelDisplay: document.getElementById('levelDisplay'),
            timer: document.getElementById('timer'),
            killCount: document.getElementById('killCount'),
            goldCount: document.getElementById('goldCount'),
            shrineChargeBar: document.getElementById('shrineChargeBar'),
            shrineChargeFill: document.getElementById('shrineChargeFill'),
            upgradeOverlay: document.getElementById('upgradeOverlay'),
            upgradeSlotMachine: document.getElementById('upgradeSlotMachine'),
            upgradeOptions: document.getElementById('upgradeOptions'),
            shrineOverlay: document.getElementById('shrineOverlay'),
            slotMachine: document.getElementById('slotMachine'),
            shrineOptions: document.getElementById('shrineOptions'),
            chestOverlay: document.getElementById('chestOverlay'),
            chestTitle: document.getElementById('chestTitle'),
            chestCost: document.getElementById('chestCost'),
            chestCard: document.getElementById('chestCard'),
            chestIcon: document.getElementById('chestIcon'),
            chestName: document.getElementById('chestName'),
            chestValue: document.getElementById('chestValue'),
            chestAccept: document.getElementById('chestAccept'),
            chestSkip: document.getElementById('chestSkip'),
            menuOverlay: document.getElementById('menuOverlay'),
            finalStats: document.getElementById('finalStats'),
            startBtn: document.getElementById('startBtn'),
            weaponsDisplay: document.getElementById('weaponsDisplay'),
            activeBuffsBar: document.getElementById('activeBuffsBar'),
            statsDisplay: document.getElementById('statsDisplay')
        };
        
        // Gold display update
        function updateGoldDisplay() {
            DOM.goldCount.textContent = playerGold;
        }
        
        // ===== BUFFS BAR UPDATE =====
        function updateBuffsBar() {
            if (!player) return;
            
            DOM.activeBuffsBar.innerHTML = '';
            DOM.statsDisplay.innerHTML = '';
            
            const bonuses = player.shrineBonuses;
            const buffItems = [];
            
            // Map bonus stats to display info
            const buffInfo = {
                damageBonus: { icon: '‚öîÔ∏è', name: 'DMG', color: COLORS.orange },
                speedBonus: { icon: 'üí®', name: 'SPD', color: COLORS.teal },
                attackSpeedBonus: { icon: '‚ö°', name: 'ASPD', color: COLORS.yellow },
                regenBonus: { icon: 'üíö', name: 'REGEN', color: COLORS.teal },
                lifesteal: { icon: 'ü©∏', name: 'VAMP', color: COLORS.pink },
                critChance: { icon: 'üéØ', name: 'CRIT', color: COLORS.cyan },
                critMultiplier: { icon: 'üíÄ', name: 'CDMG', color: COLORS.purple },
                armor: { icon: 'üõ°Ô∏è', name: 'ARMOR', color: COLORS.blue }
            };
            
            // Create buff icons for active bonuses
            for (const [stat, value] of Object.entries(bonuses)) {
                if (value > 0 && buffInfo[stat]) {
                    const info = buffInfo[stat];
                    const stacks = Math.round(value * 100); // Convert to percentage display
                    
                    const buffDiv = document.createElement('div');
                    buffDiv.className = 'buff-item';
                    buffDiv.style.color = info.color;
                    buffDiv.innerHTML = `
                        <span class="buff-icon">${info.icon}</span>
                        <span class="buff-stack">+${stacks}%</span>
                    `;
                    DOM.activeBuffsBar.appendChild(buffDiv);
                    
                    buffItems.push({ name: info.name, value: stacks, color: info.color });
                }
            }
            
            // Show stats summary in stats display (up to 4 lines)
            const statsToShow = buffItems.slice(0, 4);
            for (const stat of statsToShow) {
                const span = document.createElement('span');
                span.style.color = stat.color;
                span.textContent = `${stat.name}: +${stat.value}%`;
                DOM.statsDisplay.appendChild(span);
            }
        }

        function gameLoop(timestamp) {
            const dt = Math.min(timestamp - lastTime, 50); // Cap dt to prevent spiral of death
            lastTime = timestamp;
            
            if (gameRunning && !gamePaused) {
                // Apply time slow effect (Temporal Shield)
                let effectiveDt = dt;
                if (legendaryEffects.timeSlow.active) {
                    const hpPercent = player.hp / player.maxHp;
                    const now = Date.now();
                    
                    // Trigger when below 30% HP and off cooldown
                    if (hpPercent < 0.3 && !legendaryEffects.timeSlow.isSlowed && now > legendaryEffects.timeSlow.cooldownEnd) {
                        legendaryEffects.timeSlow.isSlowed = true;
                        legendaryEffects.timeSlow.effectEnd = now + 8000; // 8 seconds
                        legendaryEffects.timeSlow.regenBoostEnd = now + 8000;
                        timeSlowMultiplier = 0.4; // 60% slower
                        spawnParticles(player.x, player.y, '#9966ff', 25);
                    }
                    
                    // Check if effect should end
                    if (legendaryEffects.timeSlow.isSlowed && now >= legendaryEffects.timeSlow.effectEnd) {
                        legendaryEffects.timeSlow.isSlowed = false;
                        legendaryEffects.timeSlow.cooldownEnd = now + 60000; // 1 minute cooldown
                        timeSlowMultiplier = 1;
                    }
                    
                    // Apply time slow to enemy updates
                    if (legendaryEffects.timeSlow.isSlowed) {
                        effectiveDt = dt * timeSlowMultiplier;
                    }
                }
                
                gameTime += dt / 1000;
                
                // Legendary XP Magnet - 30 second pulse
                if (legendaryEffects.xpMagnet.active) {
                    const timeSinceLastPulse = gameTime - legendaryEffects.xpMagnet.lastPulse;
                    if (timeSinceLastPulse >= 30 && xpGems.length > 0) {
                        legendaryEffects.xpMagnet.lastPulse = gameTime;
                        magnetPulseActive = true;
                        spawnParticles(player.x, player.y, '#ffd700', 25);
                        
                        setTimeout(() => {
                            magnetPulseActive = false;
                        }, 2000);
                    }
                }
                
                // Stillness healing - heal when not moving
                if (legendaryEffects.stillness.active && player) {
                    const isMoving = input.left || input.right || input.up || input.down || 
                                     Math.abs(input.joystickX) > 0.1 || Math.abs(input.joystickY) > 0.1;
                    if (!isMoving) {
                        // Standing still - heal 5 HP/s
                        const healAmount = 5 * (dt / 1000);
                        player.heal(healAmount);
                        // Occasional visual
                        if (Math.random() < 0.05) {
                            spawnParticles(player.x, player.y, '#88ffaa', 3);
                        }
                    }
                }
                
                // Update
                player.update(dt, input);
                camera.update();
                updateFogOfWar();
                spawnEnemies(effectiveDt);
                updateShrineSpawning(dt);
                updateLeprechaunSpawning(dt);
                updateBossSpawning(dt);
                
                for (const enemy of enemies) {
                    if (!enemy.dead) enemy.update(effectiveDt);
                }
                for (const proj of projectiles) proj.update();
                for (const gem of xpGems) gem.update();
                for (const shrine of shrines) shrine.update(dt);
                for (const lep of leprechauns) {
                    if (!lep.dead) lep.update(effectiveDt);
                }
                for (const rainbow of rainbows) rainbow.update();
                for (const ghost of ghosts) {
                    if (!ghost.dead) ghost.update(dt);
                }
                for (const chest of chests) {
                    if (!chest.dead) chest.update(dt);
                }
                for (const boss of bosses) {
                    if (!boss.dead) boss.update(effectiveDt);
                }
                updateChestSpawning(dt);
                
                // Clean up dead entities (in-place for performance)
                cleanupArray(enemies, e => e.dead);
                cleanupArray(projectiles, p => p.dead);
                cleanupArray(xpGems, g => g.dead);
                cleanupArray(leprechauns, l => l.dead);
                cleanupArray(rainbows, r => r.dead);
                cleanupArray(ghosts, g => g.dead);
                cleanupArray(chests, c => c.dead);
                cleanupArray(bosses, b => b.dead);
                
                // Fade out rainbows when their leprechaun dies
                for (const rainbow of rainbows) {
                    if (!rainbow.fading) {
                        const hasLeprechaun = leprechauns.some(l => !l.dead);
                        if (!hasLeprechaun) {
                            rainbow.startFadeOut();
                        }
                    }
                }
                
                // Update particles with limit
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.03;
                    if (p.life <= 0) {
                        particles[i] = particles[particles.length - 1];
                        particles.pop();
                    }
                }
                // Enforce particle limit
                if (particles.length > LIMITS.particles) {
                    particles.length = LIMITS.particles;
                }
                
                // Update damage numbers with limit
                for (let i = damageNumbers.length - 1; i >= 0; i--) {
                    const d = damageNumbers[i];
                    d.y += d.vy;
                    d.life -= 0.02;
                    if (d.life <= 0) {
                        damageNumbers[i] = damageNumbers[damageNumbers.length - 1];
                        damageNumbers.pop();
                    }
                }
                if (damageNumbers.length > LIMITS.damageNumbers) {
                    damageNumbers.length = LIMITS.damageNumbers;
                }
                
                // Update HUD (using cached DOM elements)
                DOM.trackpadHpFill.style.width = `${(player.hp / player.maxHp) * 100}%`;
                DOM.trackpadXpFill.style.width = `${(player.xp / player.xpToNext) * 100}%`;
                DOM.levelDisplay.textContent = player.level;
                
                // Timer
                const minutes = Math.floor(gameTime / 60);
                const seconds = Math.floor(gameTime % 60);
                DOM.timer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Render
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid background (scrolls with camera, scales with zoom)
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const worldGridSize = 60; // World units per grid cell
            const screenGridSize = worldGridSize * camera.zoom;
            
            // Calculate grid offset based on camera position in world space
            const gridOffsetX = (camera.x % worldGridSize) * camera.zoom;
            const gridOffsetY = (camera.y % worldGridSize) * camera.zoom;
            
            for (let x = -gridOffsetX; x < canvas.width + screenGridSize; x += screenGridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = -gridOffsetY; y < canvas.height + screenGridSize; y += screenGridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // World boundary indicator (dotted purple)
            ctx.strokeStyle = '#9b30ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.strokeRect(
                camera.screenX(0), 
                camera.screenY(0), 
                WORLD.width * camera.zoom, 
                WORLD.height * camera.zoom
            );
            ctx.setLineDash([]);
            
            if (!gameRunning) return;
            
            // Draw terrain obstacles (lakes/mountains - background)
            drawTerrain();
            
            // Draw environment decorations (trees)
            drawDecorations();
            
            // Draw shrines first (under everything)
            for (const shrine of shrines) shrine.draw();
            
            // Draw treasure chests
            for (const chest of chests) {
                if (!chest.dead && !chest.opened) chest.draw();
            }
            
            // Draw rainbows (behind everything else)
            for (const rainbow of rainbows) rainbow.draw();
            
            // Draw entities
            for (const gem of xpGems) gem.draw();
            for (const enemy of enemies) {
                if (!enemy.dead) enemy.draw();
            }
            for (const lep of leprechauns) {
                if (!lep.dead) lep.draw();
            }
            for (const ghost of ghosts) {
                if (!ghost.dead) ghost.draw();
            }
            for (const boss of bosses) {
                if (!boss.dead) boss.draw();
            }
            for (const proj of projectiles) proj.draw();
            player.draw();
            
            // Draw trees on top of player (foreground layer)
            drawTrees();
            
            // Particles (batched rendering)
            ctx.save();
            for (const p of particles) {
                if (!camera.isVisible(p.x, p.y, 20)) continue;
                const sx = camera.screenX(p.x);
                const sy = camera.screenY(p.y);
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(sx, sy, camera.scale(p.size) * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Damage numbers (batched rendering)
            ctx.save();
            for (const d of damageNumbers) {
                if (!camera.isVisible(d.x, d.y, 30)) continue;
                const sx = camera.screenX(d.x);
                const sy = camera.screenY(d.y);
                ctx.globalAlpha = d.life;
                
                if (d.isCrit) {
                    ctx.font = `bold ${camera.scale(18)}px sans-serif`;
                    ctx.fillStyle = COLORS.yellow;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = COLORS.orange;
                    ctx.fillText(d.damage + '!', sx, sy);
                } else {
                    ctx.font = `bold ${camera.scale(14)}px sans-serif`;
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = COLORS.orange;
                    ctx.fillText(d.damage, sx, sy);
                }
            }
            ctx.restore();
            
            // Low health warning flash
            if (player && player.hp / player.maxHp < 0.3) {
                const pulse = 0.15 + Math.sin(Date.now() * 0.008) * 0.1;
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Red vignette edges
                const gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
                    canvas.width / 2, canvas.height / 2, canvas.height * 0.7
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(255, 0, 0, ${pulse + 0.15})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Minimap
            drawMinimap();
        }

        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const mapSize = 156; // Fixed size - CSS handles display scaling
        
        function drawMinimap() {
            const scale = mapSize / WORLD.width;
            const fogCellScale = FOG_CELL_SIZE * scale;
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, mapSize, mapSize);
            
            // Draw fog of war (unexplored = dark, explored = slightly visible)
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            minimapCtx.fillRect(0, 0, mapSize, mapSize);
            
            // Draw explored areas
            minimapCtx.fillStyle = 'rgba(20, 20, 40, 0.9)';
            for (let cy = 0; cy < FOG_GRID_SIZE; cy++) {
                for (let cx = 0; cx < FOG_GRID_SIZE; cx++) {
                    if (fogGrid[cy] && fogGrid[cy][cx]) {
                        minimapCtx.fillRect(
                            cx * fogCellScale,
                            cy * fogCellScale,
                            fogCellScale + 0.5,
                            fogCellScale + 0.5
                        );
                    }
                }
            }
            
            // Viewport indicator (always visible)
            const viewWidth = canvas.width / camera.zoom;
            const viewHeight = canvas.height / camera.zoom;
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scale,
                camera.y * scale,
                viewWidth * scale,
                viewHeight * scale
            );
            
            // Only show entities in explored areas
            
            // Enemies (as small dots) - only in explored areas
            minimapCtx.fillStyle = COLORS.magenta;
            for (const enemy of enemies) {
                if (enemy.dead) continue;
                if (!isExplored(enemy.x, enemy.y)) continue;
                const ex = enemy.x * scale;
                const ey = enemy.y * scale;
                minimapCtx.fillRect(ex - 1, ey - 1, 2, 2);
            }
            
            // XP gems - only in explored areas
            minimapCtx.fillStyle = COLORS.cyan;
            for (const gem of xpGems) {
                if (!isExplored(gem.x, gem.y)) continue;
                const gx = gem.x * scale;
                const gy = gem.y * scale;
                minimapCtx.fillRect(gx, gy, 1, 1);
            }
            
            // Shrines - only in explored areas
            minimapCtx.fillStyle = COLORS.shrine;
            for (const shrine of shrines) {
                if (shrine.activated) continue;
                if (!isExplored(shrine.x, shrine.y)) continue;
                const shx = shrine.x * scale;
                const shy = shrine.y * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(shx, shy, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }
            
            // Treasure chests - only in explored areas
            for (const chest of chests) {
                if (chest.dead || chest.opened) continue;
                if (!isExplored(chest.x, chest.y)) continue;
                minimapCtx.fillStyle = chest.isFree ? COLORS.gold : '#c0c0c0';
                const cx = chest.x * scale;
                const cy = chest.y * scale;
                minimapCtx.fillRect(cx - 2, cy - 2, 4, 4);
            }
            
            // Leprechauns - only in explored areas
            for (const lep of leprechauns) {
                if (lep.dead) continue;
                if (!isExplored(lep.x, lep.y)) continue;
                const lx = lep.x * scale;
                const ly = lep.y * scale;
                minimapCtx.fillStyle = COLORS.green;
                minimapCtx.strokeStyle = COLORS.gold;
                minimapCtx.lineWidth = 1;
                minimapCtx.beginPath();
                minimapCtx.arc(lx, ly, 4, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Bosses - only in explored areas
            for (const boss of bosses) {
                if (boss.dead) continue;
                if (!isExplored(boss.x, boss.y)) continue;
                const bx = boss.x * scale;
                const by = boss.y * scale;
                minimapCtx.fillStyle = boss.color;
                minimapCtx.strokeStyle = '#ffffff';
                minimapCtx.lineWidth = 2;
                minimapCtx.beginPath();
                minimapCtx.arc(bx, by, boss.bossType === 'major' ? 7 : 5, 0, Math.PI * 2);
                minimapCtx.fill();
                minimapCtx.stroke();
            }
            
            // Player (always visible)
            minimapCtx.fillStyle = COLORS.cyan;
            minimapCtx.shadowBlur = 5;
            minimapCtx.shadowColor = COLORS.cyan;
            const px = player.x * scale;
            const py = player.y * scale;
            minimapCtx.beginPath();
            minimapCtx.arc(px, py, 4, 0, Math.PI * 2);
            minimapCtx.fill();
            minimapCtx.shadowBlur = 0;
        }

        // ===== GAME START/END =====
        function startGame() {
            gameRunning = true;
            gamePaused = false;
            gameTime = 0;
            kills = 0;
            enemies = [];
            projectiles = [];
            xpGems = [];
            particles = [];
            damageNumbers = [];
            shrines = [];
            leprechauns = [];
            rainbows = [];
            ghosts = [];
            chests = [];
            leprechaunSpawnTimer = 0;
            nextLeprechaunSpawn = 90000; // First spawn at 90s
            finalSwarmWarningShown = false; // Reset for new game
            magnetPulseActive = false;
            timeSlowMultiplier = 1;
            
            // Reset boss system
            bosses = [];
            bossCount = 0;
            nextBossTime = 150; // First boss at 2.5 mins
            swarmActive = false;
            swarmEndTime = 0;
            swarmTriggeredForBoss = 0;
            
            // Clear any active warnings
            activeWarnings.forEach(w => w.remove());
            activeWarnings = [];
            
            // Reset chest/legendary tracking
            legendaryCount = 0;
            lastLegendaryTime = 0;
            guaranteedLegendaryNext = false;
            chestRespawnTimer = 0;
            
            // Reset gold currency
            playerGold = 0;
            nextChestCost = 5;
            pendingChest = null;
            updateGoldDisplay();
            
            // Reset all legendary effects
            legendaryEffects = {
                burn: { chance: 0, damage: 0 },
                freeze: { chance: 0, slowAmount: 0 },
                shock: { chance: 0, damage: 0 },
                timeSlow: { active: false, cooldownEnd: 0, isSlowed: false, effectEnd: 0, regenBoostEnd: 0 },
                holyBook: { active: false, maxHpBonus: 0, regenBonus: 0 },
                stillness: { active: false, lifestealBonus: 0 },
                xpMagnet: { active: false, lastPulse: 0, interval: 30000 },
                ghostStrike: { active: false }
            };
            
            player = new Player();
            initFogGrid();
            spawnTerrain();
            spawnShrines();
            spawnDecorations();
            spawnInitialChests();
            
            DOM.menuOverlay.classList.add('hidden');
            DOM.killCount.textContent = '0';
            DOM.finalStats.style.display = 'none';
            DOM.shrineChargeBar.classList.remove('active');
            updateWeaponsDisplay();
            updateBuffsBar();
        }

        function gameOver() {
            gameRunning = false;
            
            // Store stats for later display
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            const shrinesActivated = shrines.filter(s => s.activated).length;
            
            window.gameOverStats = {
                time: timeString,
                level: player.level,
                kills: kills,
                shrines: shrinesActivated
            };
            
            // Show score modal for leaderboard submission (pass time instead of level)
            showScoreModal(kills, timeString);
        }
        
        function showGameOverMenu() {
            DOM.menuOverlay.classList.remove('hidden');
            DOM.menuOverlay.querySelector('.game-title').textContent = 'GAME OVER';
            DOM.menuOverlay.querySelector('.game-subtitle').textContent = 'You have fallen...';
            DOM.startBtn.textContent = 'TRY AGAIN';
            
            const stats = window.gameOverStats;
            DOM.finalStats.innerHTML = `
                Survived: <span>${stats.time}</span><br>
                Level: <span>${stats.level}</span><br>
                Kills: <span>${stats.kills}</span><br>
                Shrines: <span>${stats.shrines}</span>
            `;
            DOM.finalStats.style.display = 'block';
        }

        // ===== INIT =====
        DOM.startBtn.addEventListener('click', startGame);
        DOM.startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            startGame();
        });
        
        // Chest overlay buttons
        DOM.chestAccept.addEventListener('click', acceptChestOffer);
        DOM.chestAccept.addEventListener('touchend', (e) => {
            e.preventDefault();
            acceptChestOffer();
        });
        DOM.chestSkip.addEventListener('click', skipChestOffer);
        DOM.chestSkip.addEventListener('touchend', (e) => {
            e.preventDefault();
            skipChestOffer();
        });
        
        requestAnimationFrame(gameLoop);
        
        // ========== FIREBASE LEADERBOARD SYSTEM ==========
        
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBPuBuo8DbG4dz_sYuLpmWYFGS9YbpwOg",
            authDomain: "boo-website-game-leaderboard.firebaseapp.com",
            projectId: "boo-website-game-leaderboard",
            storageBucket: "boo-website-game-leaderboard.firebasestorage.app",
            messagingSenderId: "520765430820",
            appId: "1:520765430820:web:a417b457bf7bb6f4390cb1"
        };
        
        // Collection name for THIS game
        const COLLECTION_NAME = 'survivors_scores';
        const LOCAL_STORAGE_KEY = 'survivors_scores';
        
        // Firebase state
        let db = null;
        let firebaseReady = false;
        
        // Initialize Firebase
        function initFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.log("Firebase not configured - leaderboard running in offline mode");
                return false;
            }
            try {
                if (typeof firebase !== 'undefined') {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseReady = true;
                    console.log("Firebase initialized successfully");
                    return true;
                }
            } catch (e) {
                console.warn("Firebase initialization failed:", e);
            }
            return false;
        }
        
        // Load Firebase SDK dynamically
        function loadFirebaseSDK() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") return;
            
            const script1 = document.createElement('script');
            script1.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js';
            script1.onload = () => {
                const script2 = document.createElement('script');
                script2.src = 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js';
                script2.onload = initFirebase;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script1);
        }
        loadFirebaseSDK();
        
        // ===== PROFANITY FILTER =====
        const blockedPatterns = [
            /\bf+u+c+k+/i, /\bs+h+i+t+/i, /\ba+s+s+h+o+l+e/i, /\bb+i+t+c+h/i, /\bc+u+n+t/i,
            /\bd+i+c+k/i, /\bp+u+s+s+y/i, /\bc+o+c+k/i, /\bw+h+o+r+e/i, /\bs+l+u+t/i,
            /\bf+a+g+/i, /\bn+i+g+g+/i, /\bn+i+g+a/i, /\br+e+t+a+r+d/i, /\bc+h+i+n+k/i,
            /\bs+p+i+c+/i, /\bk+i+k+e/i, /\bg+o+o+k/i, /\bw+e+t+b+a+c+k/i, /\btr+a+n+n+y/i,
            /\bd+y+k+e/i, /\bp+a+k+i/i, /\bt+w+a+t/i, /\bw+a+n+k/i, /\bp+r+i+c+k/i,
            /\bb+o+l+l+o+c+k/i, /\ba+r+s+e/i, /\bb+u+g+g+e+r/i, /\bc+r+a+p/i, /\bd+a+m+n/i,
            /\bp+u+t+a/i, /\bm+i+e+r+d+a/i, /\bc+a+b+r+[o√≥]+n/i, /\bp+e+n+d+e+j+o/i,
            /\bc+h+i+n+g+a/i, /\bj+o+d+e+r/i, /\bm+a+r+i+c+[o√≥]+n/i,
            /\bm+e+r+d+e/i, /\bp+u+t+a+i+n/i, /\bs+a+l+o+p/i,
            /\bs+c+h+e+i+[s√ü]+e/i, /\bf+i+c+k/i, /\bh+u+r+e/i, /\ba+r+s+c+h/i,
            /n.?i.?g.?g/i, /f.?u.?c.?k/i, /s.?h.?i.?t/i
        ];
        
        const blockedExact = new Set([
            'ass', 'cum', 'fag', 'gay', 'jew', 'nig', 'nip', 'poo', 'sex', 'tit',
            'kkk', 'nazi', 'rape', 'pedo', 'porn', 'anal', 'anus', 'homo'
        ]);
        
        function containsProfanity(text) {
            if (!text) return false;
            const normalized = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            const withSpaces = text.toLowerCase();
            if (blockedExact.has(normalized)) return true;
            for (const pattern of blockedPatterns) {
                if (pattern.test(normalized) || pattern.test(withSpaces)) return true;
            }
            return false;
        }
        
        function sanitizeUsername(name) {
            return name.trim().substring(0, 12).toUpperCase().replace(/[^A-Z0-9_\-]/g, '');
        }
        
        // ===== SCORE MODAL =====
        const scoreModal = document.getElementById('scoreModal');
        const scoreModalTitle = document.getElementById('scoreModalTitle');
        const usernameInput = document.getElementById('usernameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const skipScoreBtn = document.getElementById('skipScoreBtn');
        const scoreErrorMsg = document.getElementById('scoreErrorMsg');
        const finalKillsDisplay = document.getElementById('finalKillsDisplay');
        const finalTimeDisplay = document.getElementById('finalTimeDisplay');
        
        let pendingScore = 0;
        let pendingTime = '0:00';
        
        async function showScoreModal(finalKills, finalTime) {
            pendingScore = finalKills;
            pendingTime = finalTime;
            finalKillsDisplay.textContent = finalKills;
            finalTimeDisplay.textContent = finalTime;
            usernameInput.value = '';
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'Submit';
            
            // Check rank
            let rank = await getScoreRank(finalKills);
            
            if (rank === 1) {
                scoreModalTitle.textContent = "üèÜ #1 SLAYER üèÜ";
            } else if (rank <= 10) {
                scoreModalTitle.textContent = 'TOP 10!!';
            } else {
                scoreModalTitle.textContent = 'FALLEN WARRIOR';
            }
            
            scoreModal.classList.add('active');
            setTimeout(() => usernameInput.focus(), 100);
        }
        
        async function getScoreRank(playerScore) {
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data().score));
                } else {
                    scores = getLocalScores().map(s => s.score);
                }
                
                let rank = 1;
                for (const existingScore of scores) {
                    if (playerScore <= existingScore) rank++;
                    else break;
                }
                return rank;
            } catch (error) {
                console.error('Error checking rank:', error);
                return 999;
            }
        }
        
        scoreModal.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        
        function hideScoreModal() {
            scoreModal.classList.remove('active');
            usernameInput.blur();
            showGameOverMenu();
        }
        
        async function submitScore() {
            const rawName = usernameInput.value;
            const username = sanitizeUsername(rawName);
            
            if (username.length < 2) {
                scoreErrorMsg.textContent = 'Name must be at least 2 characters';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            if (containsProfanity(rawName) || containsProfanity(username)) {
                scoreErrorMsg.textContent = 'Please choose an appropriate name';
                usernameInput.classList.add('error');
                setTimeout(() => usernameInput.classList.remove('error'), 400);
                return;
            }
            
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'Saving...';
            
            try {
                if (firebaseReady && db) {
                    await db.collection(COLLECTION_NAME).add({
                        name: username,
                        score: pendingScore,
                        time: pendingTime,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } else {
                    saveLocalScore(username, pendingScore, pendingTime);
                }
                hideScoreModal();
            } catch (e) {
                console.warn('Score submission failed:', e);
                saveLocalScore(username, pendingScore, pendingTime);
                hideScoreModal();
            }
            
            submitScoreBtn.textContent = 'Submit';
            submitScoreBtn.disabled = false;
        }
        
        // Local storage fallback
        function saveLocalScore(name, score, time) {
            try {
                const scores = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
                scores.push({ name, score, time, timestamp: Date.now() });
                scores.sort((a, b) => b.score - a.score);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(scores.slice(0, 100)));
            } catch (e) {
                console.warn('Local storage save failed:', e);
            }
        }
        
        function getLocalScores() {
            try {
                return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }
        
        // Score modal event listeners
        submitScoreBtn.addEventListener('click', submitScore);
        submitScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            submitScore();
        }, { passive: false, capture: true });
        
        skipScoreBtn.addEventListener('click', hideScoreModal);
        skipScoreBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideScoreModal();
        }, { passive: false, capture: true });
        
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); submitScore(); }
            if (e.key === 'Escape') { hideScoreModal(); }
        });
        
        usernameInput.addEventListener('input', () => {
            scoreErrorMsg.textContent = '';
            usernameInput.classList.remove('error');
        });
        
        // ===== LEADERBOARD =====
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const leaderboardOverlay = document.getElementById('leaderboardOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardClose = document.getElementById('leaderboardClose');
        
        async function showLeaderboard() {
            leaderboardOverlay.classList.add('active');
            leaderboardList.innerHTML = '<div class="leaderboard-loading">Loading scores...</div>';
            
            try {
                let scores = [];
                if (firebaseReady && db) {
                    const snapshot = await db.collection(COLLECTION_NAME)
                        .orderBy('score', 'desc')
                        .limit(100)
                        .get();
                    snapshot.forEach(doc => scores.push(doc.data()));
                } else {
                    scores = getLocalScores();
                }
                renderLeaderboard(scores);
            } catch (e) {
                console.warn('Leaderboard fetch failed:', e);
                renderLeaderboard(getLocalScores());
            }
        }
        
        function renderLeaderboard(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            scores.forEach((entry, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3;
                const rankClass = isTop3 ? `top-3 leaderboard-rank-${rank}` : '';
                const time = entry.time || entry.level || '?'; // Fallback for old entries
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                        <div class="leaderboard-level">${time}</div>
                    </div>
                `;
            });
            leaderboardList.innerHTML = html;
        }
        
        const escapeDiv = document.createElement('div');
        function escapeHtml(text) {
            escapeDiv.textContent = text;
            return escapeDiv.innerHTML;
        }
        
        function hideLeaderboard() {
            leaderboardOverlay.classList.remove('active');
        }
        
        // Leaderboard button listeners
        leaderboardBtn.addEventListener('click', showLeaderboard);
        leaderboardBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardClose.addEventListener('click', hideLeaderboard);
        leaderboardClose.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            hideLeaderboard();
        }, { passive: false, capture: true });
        
        leaderboardOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardOverlay) hideLeaderboard();
        });
        
        leaderboardOverlay.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        leaderboardOverlay.addEventListener('touchend', (e) => {
            if (e.target === leaderboardOverlay) {
                e.preventDefault();
                hideLeaderboard();
            }
        }, { passive: false });
    </script>
</body>
</html>
